// Code generated by protoc-gen-go. DO NOT EDIT.
// source: upgrade.proto

/*
Package main is a generated protocol buffer package.

It is generated from these files:
	upgrade.proto

It has these top-level messages:
	UpgReq
	UpgResp
	UpgStateReq
	UpgAppResp
*/
package main

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import clientApi "github.com/pensando/sw/nic/delphi/gosdk/client_api"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UpgReqType int32

const (
	UpgReqType_InvalidCmd UpgReqType = 0
	UpgReqType_UpgStart   UpgReqType = 1
	UpgReqType_UpgAbort   UpgReqType = 2
)

var UpgReqType_name = map[int32]string{
	0: "InvalidCmd",
	1: "UpgStart",
	2: "UpgAbort",
}
var UpgReqType_value = map[string]int32{
	"InvalidCmd": 0,
	"UpgStart":   1,
	"UpgAbort":   2,
}

func (x UpgReqType) String() string {
	return proto.EnumName(UpgReqType_name, int32(x))
}
func (UpgReqType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UpgRespType int32

const (
	UpgRespType_UpgRespPass  UpgRespType = 0
	UpgRespType_UpgRespFail  UpgRespType = 1
	UpgRespType_UpgRespAbort UpgRespType = 2
)

var UpgRespType_name = map[int32]string{
	0: "UpgRespPass",
	1: "UpgRespFail",
	2: "UpgRespAbort",
}
var UpgRespType_value = map[string]int32{
	"UpgRespPass":  0,
	"UpgRespFail":  1,
	"UpgRespAbort": 2,
}

func (x UpgRespType) String() string {
	return proto.EnumName(UpgRespType_name, int32(x))
}
func (UpgRespType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Upgrade Request Status
type UpgReqStateType int32

const (
	UpgReqStateType_UpgReqRcvd                      UpgReqStateType = 0
	UpgReqStateType_PreUpgState                     UpgReqStateType = 1
	UpgReqStateType_ProcessesQuiesced               UpgReqStateType = 2
	UpgReqStateType_PostBinRestart                  UpgReqStateType = 3
	UpgReqStateType_DataplaneDowntimePhase1Start    UpgReqStateType = 4
	UpgReqStateType_DataplaneDowntimeAdminQHandling UpgReqStateType = 5
	UpgReqStateType_DataplaneDowntimePhase2Start    UpgReqStateType = 6
	UpgReqStateType_Cleanup                         UpgReqStateType = 7
	UpgReqStateType_UpgSuccess                      UpgReqStateType = 8
	UpgReqStateType_UpgFailed                       UpgReqStateType = 9
	UpgReqStateType_UpgAborted                      UpgReqStateType = 10
	// Always to be last
	UpgReqStateType_UpgStateTerminal UpgReqStateType = 11
)

var UpgReqStateType_name = map[int32]string{
	0:  "UpgReqRcvd",
	1:  "PreUpgState",
	2:  "ProcessesQuiesced",
	3:  "PostBinRestart",
	4:  "DataplaneDowntimePhase1Start",
	5:  "DataplaneDowntimeAdminQHandling",
	6:  "DataplaneDowntimePhase2Start",
	7:  "Cleanup",
	8:  "UpgSuccess",
	9:  "UpgFailed",
	10: "UpgAborted",
	11: "UpgStateTerminal",
}
var UpgReqStateType_value = map[string]int32{
	"UpgReqRcvd":                      0,
	"PreUpgState":                     1,
	"ProcessesQuiesced":               2,
	"PostBinRestart":                  3,
	"DataplaneDowntimePhase1Start":    4,
	"DataplaneDowntimeAdminQHandling": 5,
	"DataplaneDowntimePhase2Start":    6,
	"Cleanup":                         7,
	"UpgSuccess":                      8,
	"UpgFailed":                       9,
	"UpgAborted":                      10,
	"UpgStateTerminal":                11,
}

func (x UpgReqStateType) String() string {
	return proto.EnumName(UpgReqStateType_name, int32(x))
}
func (UpgReqStateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Upgrade Request Status
type UpgRespStateType int32

const (
	UpgRespStateType_UpgReqRcvdPass                      UpgRespStateType = 0
	UpgRespStateType_UpgReqRcvdFail                      UpgRespStateType = 1
	UpgRespStateType_PreUpgStatePass                     UpgRespStateType = 2
	UpgRespStateType_PreUpgStateFail                     UpgRespStateType = 3
	UpgRespStateType_ProcessesQuiescedPass               UpgRespStateType = 4
	UpgRespStateType_ProcessesQuiescedFail               UpgRespStateType = 5
	UpgRespStateType_PostBinRestartPass                  UpgRespStateType = 6
	UpgRespStateType_PostBinRestartFail                  UpgRespStateType = 7
	UpgRespStateType_DataplaneDowntimePhase1StartPass    UpgRespStateType = 8
	UpgRespStateType_DataplaneDowntimePhase1StartFail    UpgRespStateType = 9
	UpgRespStateType_DataplaneDowntimeAdminQHandlingPass UpgRespStateType = 10
	UpgRespStateType_DataplaneDowntimeAdminQHandlingFail UpgRespStateType = 11
	UpgRespStateType_DataplaneDowntimePhase2StartPass    UpgRespStateType = 12
	UpgRespStateType_DataplaneDowntimePhase2StartFail    UpgRespStateType = 13
	UpgRespStateType_CleanupPass                         UpgRespStateType = 14
	UpgRespStateType_CleanupFail                         UpgRespStateType = 15
	UpgRespStateType_UpgSuccessPass                      UpgRespStateType = 16
	UpgRespStateType_UpgSuccessFail                      UpgRespStateType = 17
	UpgRespStateType_UpgFailedPass                       UpgRespStateType = 18
	UpgRespStateType_UpgFailedFail                       UpgRespStateType = 19
	UpgRespStateType_UpgAbortedPass                      UpgRespStateType = 20
	UpgRespStateType_UpgAbortedFail                      UpgRespStateType = 21
)

var UpgRespStateType_name = map[int32]string{
	0:  "UpgReqRcvdPass",
	1:  "UpgReqRcvdFail",
	2:  "PreUpgStatePass",
	3:  "PreUpgStateFail",
	4:  "ProcessesQuiescedPass",
	5:  "ProcessesQuiescedFail",
	6:  "PostBinRestartPass",
	7:  "PostBinRestartFail",
	8:  "DataplaneDowntimePhase1StartPass",
	9:  "DataplaneDowntimePhase1StartFail",
	10: "DataplaneDowntimeAdminQHandlingPass",
	11: "DataplaneDowntimeAdminQHandlingFail",
	12: "DataplaneDowntimePhase2StartPass",
	13: "DataplaneDowntimePhase2StartFail",
	14: "CleanupPass",
	15: "CleanupFail",
	16: "UpgSuccessPass",
	17: "UpgSuccessFail",
	18: "UpgFailedPass",
	19: "UpgFailedFail",
	20: "UpgAbortedPass",
	21: "UpgAbortedFail",
}
var UpgRespStateType_value = map[string]int32{
	"UpgReqRcvdPass":                      0,
	"UpgReqRcvdFail":                      1,
	"PreUpgStatePass":                     2,
	"PreUpgStateFail":                     3,
	"ProcessesQuiescedPass":               4,
	"ProcessesQuiescedFail":               5,
	"PostBinRestartPass":                  6,
	"PostBinRestartFail":                  7,
	"DataplaneDowntimePhase1StartPass":    8,
	"DataplaneDowntimePhase1StartFail":    9,
	"DataplaneDowntimeAdminQHandlingPass": 10,
	"DataplaneDowntimeAdminQHandlingFail": 11,
	"DataplaneDowntimePhase2StartPass":    12,
	"DataplaneDowntimePhase2StartFail":    13,
	"CleanupPass":                         14,
	"CleanupFail":                         15,
	"UpgSuccessPass":                      16,
	"UpgSuccessFail":                      17,
	"UpgFailedPass":                       18,
	"UpgFailedFail":                       19,
	"UpgAbortedPass":                      20,
	"UpgAbortedFail":                      21,
}

func (x UpgRespStateType) String() string {
	return proto.EnumName(UpgRespStateType_name, int32(x))
}
func (UpgRespStateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type UpgType int32

const (
	UpgType_UpgTypeDisruptive    UpgType = 0
	UpgType_UpgTypeNonDisruptive UpgType = 1
)

var UpgType_name = map[int32]string{
	0: "UpgTypeDisruptive",
	1: "UpgTypeNonDisruptive",
}
var UpgType_value = map[string]int32{
	"UpgTypeDisruptive":    0,
	"UpgTypeNonDisruptive": 1,
}

func (x UpgType) String() string {
	return proto.EnumName(UpgType_name, int32(x))
}
func (UpgType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// spec part of the object
type UpgReq struct {
	Meta      *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key       uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgReqCmd UpgReqType         `protobuf:"varint,3,opt,name=UpgReqCmd,enum=main.UpgReqType" json:"UpgReqCmd,omitempty"`
}

func (m *UpgReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgReq) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *UpgReq) GetDelphiKind() string {
	return "UpgReq"
}

func (m *UpgReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgReq)
	return obj
}

func UpgReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgReq", mode)
}

func UpgReqMountKey(client clientApi.Client, key uint32, mode delphi.MountMode) {
	client.MountKindKey("UpgReq", fmt.Sprintf("%v", key), mode)
}

func GetUpgReq(client clientApi.Client, key uint32) *UpgReq {
	o := client.GetObject("UpgReq", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgReqWatch(client clientApi.Client, reactor UpgReqReactor) {
	client.WatchKind("UpgReq", reactor)
}
func UpgReqList(client clientApi.Client) []*UpgReq {
	bobjs := client.List("UpgReq")
	objs := make([]*UpgReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgReqCreate(m)
			} else {
				oldObj, ok := old.(*UpgReq)
				if ok == false {
					panic("Not an UpgReq object")
				}
				rctr.OnUpgReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgReqDelete(m)
		}
	}
}

type UpgReqReactor interface {
	OnUpgReqCreate(obj *UpgReq)
	OnUpgReqUpdate(old *UpgReq, obj *UpgReq)
	OnUpgReqDelete(obj *UpgReq)
}

func (m *UpgReq) Reset()                    { *m = UpgReq{} }
func (m *UpgReq) String() string            { return proto.CompactTextString(m) }
func (*UpgReq) ProtoMessage()               {}
func (*UpgReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UpgReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgReq) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgReq) GetUpgReqCmd() UpgReqType {
	if m != nil {
		return m.UpgReqCmd
	}
	return UpgReqType_InvalidCmd
}

type UpgResp struct {
	Meta           *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key            uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgRespVal     UpgRespType        `protobuf:"varint,3,opt,name=UpgRespVal,enum=main.UpgRespType" json:"UpgRespVal,omitempty"`
	UpgRespFailStr []string           `protobuf:"bytes,4,rep,name=UpgRespFailStr" json:"UpgRespFailStr,omitempty"`
}

func (m *UpgResp) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgResp) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgResp) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgResp) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *UpgResp) GetDelphiKind() string {
	return "UpgResp"
}

func (m *UpgResp) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgResp) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgResp)
	return obj
}

func UpgRespMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgResp", mode)
}

func UpgRespMountKey(client clientApi.Client, key uint32, mode delphi.MountMode) {
	client.MountKindKey("UpgResp", fmt.Sprintf("%v", key), mode)
}

func GetUpgResp(client clientApi.Client, key uint32) *UpgResp {
	o := client.GetObject("UpgResp", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgResp)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgRespFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgResp
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgRespWatch(client clientApi.Client, reactor UpgRespReactor) {
	client.WatchKind("UpgResp", reactor)
}
func UpgRespList(client clientApi.Client) []*UpgResp {
	bobjs := client.List("UpgResp")
	objs := make([]*UpgResp, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgResp)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgResp) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgRespCreate(m)
			} else {
				oldObj, ok := old.(*UpgResp)
				if ok == false {
					panic("Not an UpgResp object")
				}
				rctr.OnUpgRespUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgRespDelete(m)
		}
	}
}

type UpgRespReactor interface {
	OnUpgRespCreate(obj *UpgResp)
	OnUpgRespUpdate(old *UpgResp, obj *UpgResp)
	OnUpgRespDelete(obj *UpgResp)
}

func (m *UpgResp) Reset()                    { *m = UpgResp{} }
func (m *UpgResp) String() string            { return proto.CompactTextString(m) }
func (*UpgResp) ProtoMessage()               {}
func (*UpgResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UpgResp) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgResp) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgResp) GetUpgRespVal() UpgRespType {
	if m != nil {
		return m.UpgRespVal
	}
	return UpgRespType_UpgRespPass
}

func (m *UpgResp) GetUpgRespFailStr() []string {
	if m != nil {
		return m.UpgRespFailStr
	}
	return nil
}

// status part of the object
type UpgStateReq struct {
	Meta        *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key         uint32             `protobuf:"varint,2,opt,name=Key" json:"Key,omitempty"`
	UpgReqState UpgReqStateType    `protobuf:"varint,3,opt,name=UpgReqState,enum=main.UpgReqStateType" json:"UpgReqState,omitempty"`
	UpgReqType  UpgType            `protobuf:"varint,4,opt,name=UpgReqType,enum=main.UpgType" json:"UpgReqType,omitempty"`
}

func (m *UpgStateReq) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgStateReq) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgStateReq) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgStateReq) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *UpgStateReq) GetDelphiKind() string {
	return "UpgStateReq"
}

func (m *UpgStateReq) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgStateReq) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgStateReq)
	return obj
}

func UpgStateReqMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgStateReq", mode)
}

func UpgStateReqMountKey(client clientApi.Client, key uint32, mode delphi.MountMode) {
	client.MountKindKey("UpgStateReq", fmt.Sprintf("%v", key), mode)
}

func GetUpgStateReq(client clientApi.Client, key uint32) *UpgStateReq {
	o := client.GetObject("UpgStateReq", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgStateReq)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgStateReqFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgStateReq
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgStateReqWatch(client clientApi.Client, reactor UpgStateReqReactor) {
	client.WatchKind("UpgStateReq", reactor)
}
func UpgStateReqList(client clientApi.Client) []*UpgStateReq {
	bobjs := client.List("UpgStateReq")
	objs := make([]*UpgStateReq, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgStateReq)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgStateReq) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgStateReqReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgStateReqCreate(m)
			} else {
				oldObj, ok := old.(*UpgStateReq)
				if ok == false {
					panic("Not an UpgStateReq object")
				}
				rctr.OnUpgStateReqUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgStateReqDelete(m)
		}
	}
}

type UpgStateReqReactor interface {
	OnUpgStateReqCreate(obj *UpgStateReq)
	OnUpgStateReqUpdate(old *UpgStateReq, obj *UpgStateReq)
	OnUpgStateReqDelete(obj *UpgStateReq)
}

func (m *UpgStateReq) Reset()                    { *m = UpgStateReq{} }
func (m *UpgStateReq) String() string            { return proto.CompactTextString(m) }
func (*UpgStateReq) ProtoMessage()               {}
func (*UpgStateReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpgStateReq) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgStateReq) GetKey() uint32 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *UpgStateReq) GetUpgReqState() UpgReqStateType {
	if m != nil {
		return m.UpgReqState
	}
	return UpgReqStateType_UpgReqRcvd
}

func (m *UpgStateReq) GetUpgReqType() UpgType {
	if m != nil {
		return m.UpgReqType
	}
	return UpgType_UpgTypeDisruptive
}

type UpgAppResp struct {
	Meta          *delphi.ObjectMeta `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	Key           string             `protobuf:"bytes,2,opt,name=Key" json:"Key,omitempty"`
	UpgAppRespVal UpgRespStateType   `protobuf:"varint,3,opt,name=UpgAppRespVal,enum=main.UpgRespStateType" json:"UpgAppRespVal,omitempty"`
	UpgAppRespStr string             `protobuf:"bytes,4,opt,name=UpgAppRespStr" json:"UpgAppRespStr,omitempty"`
}

func (m *UpgAppResp) GetDelphiMessage() proto.Message {
	return m
}

func (m *UpgAppResp) GetDelphiMeta() *delphi.ObjectMeta {
	return m.Meta
}

func (m *UpgAppResp) SetDelphiMeta(meta *delphi.ObjectMeta) {
	m.Meta = meta
}

func (m *UpgAppResp) GetDelphiKey() string {
	return fmt.Sprintf("%v", m.Key)
}

func (m *UpgAppResp) GetDelphiKind() string {
	return "UpgAppResp"
}

func (m *UpgAppResp) GetDelphiPath() string {
	return fmt.Sprintf("%s|%s", m.GetDelphiKind(), m.GetDelphiKey())
}

func (m *UpgAppResp) DelphiClone() clientApi.BaseObject {
	obj, _ := proto.Clone(m).(*UpgAppResp)
	return obj
}

func UpgAppRespMount(client clientApi.Client, mode delphi.MountMode) {
	client.MountKind("UpgAppResp", mode)
}

func UpgAppRespMountKey(client clientApi.Client, key string, mode delphi.MountMode) {
	client.MountKindKey("UpgAppResp", fmt.Sprintf("%v", key), mode)
}

func GetUpgAppResp(client clientApi.Client, key string) *UpgAppResp {
	o := client.GetObject("UpgAppResp", fmt.Sprintf("%v", key))
	if o == nil {
		return nil
	}
	obj, ok := o.(*UpgAppResp)
	if ok != true {
		panic("Cast failed")
	}
	return obj
}

func UpgAppRespFactory(sdkClient clientApi.Client, data []byte) (clientApi.BaseObject, error) {
	var msg UpgAppResp
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, err
	}
	return &msg, nil
}

func UpgAppRespWatch(client clientApi.Client, reactor UpgAppRespReactor) {
	client.WatchKind("UpgAppResp", reactor)
}
func UpgAppRespList(client clientApi.Client) []*UpgAppResp {
	bobjs := client.List("UpgAppResp")
	objs := make([]*UpgAppResp, 0)
	for _, bobj := range bobjs {
		obj, _ := bobj.(*UpgAppResp)
		objs = append(objs, obj)
	}
	return objs
}
func (m *UpgAppResp) TriggerEvent(sdkClient clientApi.Client, old clientApi.BaseObject, op delphi.ObjectOperation, rl []clientApi.BaseReactor) {
	for _, r := range rl {
		rctr, ok := r.(UpgAppRespReactor)
		if ok == false {
			panic("Not a Reactor")
		}
		if op == delphi.ObjectOperation_SetOp {
			if old == nil {
				rctr.OnUpgAppRespCreate(m)
			} else {
				oldObj, ok := old.(*UpgAppResp)
				if ok == false {
					panic("Not an UpgAppResp object")
				}
				rctr.OnUpgAppRespUpdate(oldObj, m)
			}
		} else {
			rctr.OnUpgAppRespDelete(m)
		}
	}
}

type UpgAppRespReactor interface {
	OnUpgAppRespCreate(obj *UpgAppResp)
	OnUpgAppRespUpdate(old *UpgAppResp, obj *UpgAppResp)
	OnUpgAppRespDelete(obj *UpgAppResp)
}

func (m *UpgAppResp) Reset()                    { *m = UpgAppResp{} }
func (m *UpgAppResp) String() string            { return proto.CompactTextString(m) }
func (*UpgAppResp) ProtoMessage()               {}
func (*UpgAppResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UpgAppResp) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UpgAppResp) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *UpgAppResp) GetUpgAppRespVal() UpgRespStateType {
	if m != nil {
		return m.UpgAppRespVal
	}
	return UpgRespStateType_UpgReqRcvdPass
}

func (m *UpgAppResp) GetUpgAppRespStr() string {
	if m != nil {
		return m.UpgAppRespStr
	}
	return ""
}

func init() {
	clientApi.RegisterFactory("UpgReq", UpgReqFactory)
	proto.RegisterType((*UpgReq)(nil), "main.UpgReq")
	clientApi.RegisterFactory("UpgResp", UpgRespFactory)
	proto.RegisterType((*UpgResp)(nil), "main.UpgResp")
	clientApi.RegisterFactory("UpgStateReq", UpgStateReqFactory)
	proto.RegisterType((*UpgStateReq)(nil), "main.UpgStateReq")
	clientApi.RegisterFactory("UpgAppResp", UpgAppRespFactory)
	proto.RegisterType((*UpgAppResp)(nil), "main.UpgAppResp")
	proto.RegisterEnum("main.UpgReqType", UpgReqType_name, UpgReqType_value)
	proto.RegisterEnum("main.UpgRespType", UpgRespType_name, UpgRespType_value)
	proto.RegisterEnum("main.UpgReqStateType", UpgReqStateType_name, UpgReqStateType_value)
	proto.RegisterEnum("main.UpgRespStateType", UpgRespStateType_name, UpgRespStateType_value)
	proto.RegisterEnum("main.UpgType", UpgType_name, UpgType_value)
}

func init() { proto.RegisterFile("upgrade.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 696 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x51, 0x4f, 0x13, 0x4d,
	0x14, 0x65, 0xdb, 0xa5, 0xa5, 0xb7, 0xb4, 0x9d, 0x5e, 0x28, 0xe9, 0xf7, 0xc5, 0xc4, 0x06, 0x08,
	0x36, 0x7d, 0x28, 0xb1, 0x98, 0x68, 0x48, 0x7c, 0x28, 0x10, 0xa3, 0x31, 0x6a, 0x59, 0xc0, 0xf7,
	0xa1, 0x3b, 0x29, 0x63, 0xb6, 0xbb, 0xc3, 0xee, 0x16, 0xc3, 0x8b, 0xf1, 0x5f, 0xe8, 0x6f, 0xf0,
	0x07, 0xf8, 0xee, 0xbb, 0x3f, 0xca, 0xec, 0x9d, 0x29, 0xdd, 0x6d, 0x45, 0x8c, 0x3c, 0x75, 0xe7,
	0xcc, 0xb9, 0xa7, 0xe7, 0x9e, 0x7b, 0x37, 0x0b, 0x95, 0x89, 0x1a, 0x85, 0xdc, 0x15, 0x5d, 0x15,
	0x06, 0x71, 0x80, 0xf6, 0x98, 0x4b, 0xff, 0xff, 0x6d, 0x5f, 0x0e, 0x77, 0x5d, 0xe1, 0xa9, 0x0b,
	0xb9, 0x4b, 0xf8, 0xf4, 0xa0, 0x7f, 0x34, 0x77, 0xf3, 0x13, 0x14, 0xce, 0xd4, 0xc8, 0x11, 0x97,
	0xb8, 0x03, 0xf6, 0x1b, 0x11, 0xf3, 0xa6, 0xd5, 0xb2, 0xda, 0xe5, 0x1e, 0x76, 0x0d, 0xed, 0xdd,
	0xf9, 0x07, 0x31, 0x8c, 0x93, 0x1b, 0x87, 0xee, 0x91, 0x41, 0xfe, 0xb5, 0xb8, 0x6e, 0xe6, 0x5a,
	0x56, 0xbb, 0xe2, 0x24, 0x8f, 0xf8, 0x04, 0x4a, 0x5a, 0xe3, 0x70, 0xec, 0x36, 0xf3, 0x2d, 0xab,
	0x5d, 0xed, 0xb1, 0x6e, 0xe2, 0xa1, 0xab, 0xe1, 0xd3, 0x6b, 0x25, 0x0e, 0xec, 0xcf, 0x5f, 0x36,
	0x2d, 0x67, 0x46, 0xdc, 0x27, 0x60, 0xf3, 0x9b, 0x05, 0x45, 0xc2, 0x22, 0x75, 0x0f, 0x07, 0x4f,
	0x01, 0x8c, 0xc8, 0x7b, 0xee, 0x19, 0x0b, 0xf5, 0x94, 0x85, 0x48, 0xa5, 0x3c, 0xa4, 0xa8, 0xb8,
	0x03, 0x55, 0x73, 0x7a, 0xc1, 0xa5, 0x77, 0x12, 0x87, 0x4d, 0xbb, 0x95, 0x6f, 0x97, 0x9c, 0x39,
	0xd4, 0x98, 0xfd, 0x61, 0x41, 0xf9, 0x4c, 0x8d, 0x4e, 0x62, 0x1e, 0x8b, 0xfb, 0x45, 0xf6, 0x9c,
	0x84, 0x1c, 0x71, 0x49, 0x5a, 0xc6, 0x71, 0x23, 0x1d, 0x1a, 0x5d, 0xa4, 0x5c, 0xa7, 0xf9, 0xb8,
	0x67, 0xfa, 0xa5, 0x68, 0x9b, 0x36, 0x55, 0x57, 0x6e, 0xaa, 0x17, 0x7a, 0x25, 0x9a, 0xe9, 0xe1,
	0xbb, 0x45, 0xb5, 0x7d, 0xa5, 0xfe, 0x35, 0xf3, 0x92, 0x6e, 0xe1, 0x00, 0x2a, 0x33, 0x9d, 0x59,
	0xec, 0x1b, 0x99, 0xd8, 0xe7, 0xbb, 0xc8, 0x96, 0xe0, 0x76, 0x5a, 0x43, 0xa7, 0x9f, 0xe8, 0x67,
	0x41, 0x6d, 0xbc, 0xf3, 0x2c, 0xdd, 0x33, 0x56, 0x01, 0x5e, 0xf9, 0x57, 0xdc, 0x93, 0xee, 0xe1,
	0xd8, 0x65, 0x4b, 0xb8, 0x0a, 0x2b, 0x7a, 0x32, 0x61, 0xcc, 0x2c, 0x73, 0xea, 0x9f, 0x07, 0x61,
	0xcc, 0x72, 0x9d, 0xbe, 0x09, 0x5b, 0x6f, 0x01, 0xd6, 0x6e, 0x8e, 0x03, 0x1e, 0x45, 0x6c, 0x29,
	0x05, 0x24, 0xe3, 0x66, 0x16, 0x32, 0x58, 0x35, 0xc0, 0x54, 0xe2, 0x6b, 0x0e, 0x6a, 0x73, 0x73,
	0x49, 0x2c, 0x68, 0xc8, 0x19, 0x5e, 0xb9, 0x5a, 0x66, 0x10, 0x8a, 0xe9, 0x7e, 0x30, 0x0b, 0x1b,
	0x50, 0x1f, 0x84, 0xc1, 0x50, 0x44, 0x91, 0x88, 0x8e, 0x27, 0x52, 0x44, 0x43, 0xe1, 0xb2, 0x1c,
	0x22, 0x54, 0x07, 0x41, 0x14, 0x1f, 0x48, 0xdf, 0x11, 0x11, 0x19, 0xce, 0x63, 0x0b, 0x1e, 0x1c,
	0xf1, 0x98, 0x2b, 0x8f, 0xfb, 0xe2, 0x28, 0xf8, 0xe8, 0xc7, 0x72, 0x2c, 0x06, 0x17, 0x3c, 0x12,
	0x8f, 0x75, 0x4b, 0x36, 0x6e, 0xc1, 0xc3, 0x05, 0x46, 0xdf, 0x1d, 0x4b, 0xff, 0xf8, 0x25, 0xf7,
	0x5d, 0x4f, 0xfa, 0x23, 0xb6, 0x7c, 0xbb, 0x4c, 0x4f, 0xcb, 0x14, 0xb0, 0x0c, 0xc5, 0x43, 0x4f,
	0x70, 0x7f, 0xa2, 0x58, 0xd1, 0x74, 0x70, 0x32, 0x19, 0x26, 0x1e, 0xd9, 0x0a, 0x56, 0xe8, 0x45,
	0x4e, 0x42, 0x10, 0x2e, 0x2b, 0x99, 0x6b, 0x8a, 0x40, 0xb8, 0x0c, 0x70, 0x1d, 0xd8, 0xb4, 0xbb,
	0x53, 0x11, 0x8e, 0xa5, 0xcf, 0x3d, 0x56, 0xee, 0xfc, 0xb4, 0x09, 0xce, 0x4c, 0x3b, 0xe9, 0x71,
	0x96, 0x8d, 0x89, 0x39, 0x83, 0x99, 0xa4, 0xd7, 0xa0, 0x96, 0xca, 0x8c, 0x88, 0xb9, 0x39, 0x90,
	0x98, 0x79, 0xfc, 0x0f, 0x1a, 0x0b, 0x61, 0x12, 0xdf, 0xfe, 0xed, 0x15, 0x55, 0x2d, 0xe3, 0x06,
	0x60, 0x36, 0x6b, 0x2a, 0x29, 0x2c, 0xe2, 0xc4, 0x2f, 0xe2, 0x36, 0xb4, 0xfe, 0x34, 0x07, 0xaa,
	0x5e, 0xb9, 0x8b, 0x45, 0x5a, 0x25, 0x7c, 0x04, 0x5b, 0x77, 0x4c, 0x8c, 0xe4, 0xe0, 0x2f, 0x88,
	0xa4, 0x58, 0xbe, 0xfd, 0x7f, 0x7b, 0x33, 0x77, 0xab, 0x77, 0xb1, 0x48, 0xab, 0x92, 0x6c, 0xab,
	0x59, 0x04, 0x2a, 0xab, 0xa6, 0x00, 0x62, 0xd4, 0xcc, 0xbc, 0xcc, 0x76, 0x10, 0x89, 0x65, 0x31,
	0xe2, 0xd5, 0xb1, 0x4e, 0x2f, 0xb1, 0xde, 0x1a, 0xa2, 0x61, 0x06, 0x22, 0xd6, 0x9a, 0xa9, 0x34,
	0xcb, 0x44, 0xb4, 0xf5, 0x2c, 0x46, 0xbc, 0x46, 0x67, 0x9f, 0xbe, 0x07, 0xb4, 0x44, 0x0d, 0xa8,
	0x9b, 0xc7, 0x23, 0x19, 0x85, 0x13, 0x15, 0xcb, 0x2b, 0xc1, 0x96, 0xb0, 0x09, 0xeb, 0x06, 0x7e,
	0x1b, 0xf8, 0xa9, 0x1b, 0xeb, 0xbc, 0x40, 0xdf, 0xb4, 0xbd, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x36, 0x11, 0xdd, 0x7e, 0x10, 0x07, 0x00, 0x00,
}
