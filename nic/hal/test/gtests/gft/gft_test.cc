#include <stdio.h>
#include <iostream>
#include <gtest/gtest.h>

#include <boost/crc.hpp>
#include "boost/property_tree/json_parser.hpp"
#include "nic/sdk/model_sim/include/lib_model_client.h"
#include "nic/sdk/lib/pal/pal.hpp"
#include "nic/sdk/lib/utils/utils.hpp"
#include "nic/sdk/include/sdk/types.hpp"
#include "nic/sdk/asic/cmn/asic_hbm.hpp"
#include "nic/sdk/lib/p4/p4_api.hpp"
#include "gen/p4gen/gft/include/p4pd.h"
#include "nic/p4/gft/include/defines.h"
#include "nic/sdk/asic/pd/pd.hpp"
#include "nic/hal/pd/asicpd/asic_pd_common.hpp"
#include "nic/hal/pd/asic_pd.hpp"
#include "nic/sdk/lib/device/device.hpp"

// packets generated by tools/gft_test.py
uint8_t g_snd_pkt1[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x8C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x59, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB5, 0x00, 0x78,
    0x52, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x00, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0x08, 0x00,
    0x45, 0x00, 0x00, 0x5A, 0x00, 0x01, 0x00, 0x00,
    0x40, 0x11, 0x5D, 0x8B, 0x0D, 0x01, 0x02, 0x03,
    0x0C, 0x01, 0x02, 0x03, 0x00, 0x35, 0x12, 0xB5,
    0x00, 0x46, 0x11, 0xDF, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x00, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x28, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x06, 0x59, 0xC8, 0x0F, 0x01,
    0x02, 0x03, 0x0E, 0x01, 0x02, 0x03, 0xAB, 0xBA,
    0xBE, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x02, 0x20, 0x00, 0x04, 0x31,
    0x00, 0x00};

uint8_t g_rcv_pkt1[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x8C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x59, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB5, 0x00, 0x78,
    0x52, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x00, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0x08, 0x00,
    0x45, 0x00, 0x00, 0x5A, 0x00, 0x01, 0x00, 0x00,
    0x40, 0x11, 0x5D, 0x8B, 0x0D, 0x01, 0x02, 0x03,
    0x0C, 0x01, 0x02, 0x03, 0x00, 0x35, 0x12, 0xB5,
    0x00, 0x46, 0x11, 0xDF, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x00, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x28, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x06, 0x59, 0xC8, 0x0F, 0x01,
    0x02, 0x03, 0x0E, 0x01, 0x02, 0x03, 0xAB, 0xBA,
    0xBE, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x02, 0x20, 0x00, 0x04, 0x31,
    0x00, 0x00};

uint8_t g_snd_pkt2[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x8C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x59, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB5, 0x00, 0x78,
    0x52, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x00, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0x08, 0x00,
    0x45, 0x00, 0x00, 0x5A, 0x00, 0x01, 0x00, 0x00,
    0x40, 0x11, 0x5D, 0x8B, 0x0D, 0x01, 0x02, 0x03,
    0x0C, 0x01, 0x02, 0x03, 0x00, 0x35, 0x12, 0xB5,
    0x00, 0x46, 0x11, 0xDF, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x00, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x28, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x06, 0x59, 0xC8, 0x0F, 0x01,
    0x02, 0x03, 0x0E, 0x01, 0x02, 0x03, 0x12, 0x34,
    0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x02, 0x20, 0x00, 0x06, 0x2F,
    0x00, 0x00};

uint8_t g_rcv_pkt2[] = {
    0x00, 0xFE, 0xED, 0xFE, 0xED, 0xFE, 0x00, 0xDE,
    0xAE, 0xAE, 0xAE, 0xAF, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x28, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06,
//  0x47, 0xA4, 0x0F, 0x0A, 0x0B, 0x0C, 0x0E, 0x0A,
    0x59, 0xC8, 0x0F, 0x0A, 0x0B, 0x0C, 0x0E, 0x0A,
    0x0B, 0x0C, 0x12, 0x34, 0x56, 0x78, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02,
//  0x20, 0x00, 0xF4, 0x0A, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x06, 0x2F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00};

uint8_t g_snd_pkt3[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x4C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x99, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB7, 0x00, 0x38,
    0x1D, 0x35, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x79, 0x27,
    0x48, 0x2D};

uint8_t g_rcv_pkt3[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x22, 0x00, 0x20, 0x0c, 0x00, 0x00, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
    0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
    0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
    0x1E, 0x1F};

uint8_t g_snd_pkt4[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x7E, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x67, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB5, 0x00, 0x6A,
    0x52, 0x26, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x00, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0x08, 0x00,
    0x45, 0x00, 0x00, 0x4C, 0x00, 0x01, 0x00, 0x00,
    0x40, 0x11, 0x5D, 0x99, 0x0D, 0x01, 0x02, 0x03,
    0x0C, 0x01, 0x02, 0x03, 0x00, 0x35, 0x12, 0xB7,
    0x00, 0x38, 0x23, 0x74, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    0x6A, 0x62, 0x4C, 0xB3};

uint8_t g_rcv_pkt4[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x22, 0x00, 0x20, 0x0c, 0x00, 0x00, 0x00, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
    0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
    0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
    0x1E, 0x1F};

uint8_t g_snd_pkt5[] = {
    0x00, 0x21, 0x22, 0x23, 0x24, 0x25, 0x00, 0xC1,
    0xC2, 0xC3, 0xC4, 0xC5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x5C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06,
    0x59, 0x94, 0x0F, 0x01, 0x02, 0x03, 0x0E, 0x01,
    0x02, 0x03, 0x12, 0x34, 0x56, 0x78, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x02,
    0x20, 0x00, 0xE8, 0xC3, 0x00, 0x00, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x7A, 0x78, 0x79,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E, 0x6F, 0x70,
    0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x7A,
    0x78, 0x79};

uint8_t g_rcv_pkt5[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x26, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB5, 0x00, 0xAC,
    0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x00, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0x08, 0x00,
    0x45, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x11, 0x5D, 0x58, 0x0D, 0x01, 0x02, 0x03,
    0x0C, 0x01, 0x02, 0x03, 0x00, 0x35, 0x12, 0xB5,
    0x00, 0x7A, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x22, 0x23,
    0x24, 0x25, 0x00, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5,
    0x08, 0x00, 0x45, 0x00, 0x00, 0x5C, 0x00, 0x01,
    0x00, 0x00, 0x40, 0x06, 0x59, 0x94, 0x0F, 0x01,
    0x02, 0x03, 0x0E, 0x01, 0x02, 0x03, 0x12, 0x34,
    0x56, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x50, 0x02, 0x20, 0x00, 0xE8, 0xC3,
    0x00, 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x7A, 0x78, 0x79, 0x61, 0x62, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6C, 0x6B,
    0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
    0x75, 0x76, 0x77, 0x7A, 0x78, 0x79};

uint8_t g_snd_pkt6[] = {
    0x00, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x4C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x99, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB7, 0x00, 0x38,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x00, 0x00,
    0x00, 0x00};

uint8_t g_rcv_pkt6[] = {
    0x00, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x4C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x99, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB7, 0x00, 0x38,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x79, 0x27,
    0x48, 0x2D};

uint8_t g_snd_pkt7[] = {
    0x00, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x4C, 0x00, 0x01, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x99, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB7, 0x00, 0x38,
    0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x00, 0x00,
    0x00, 0x00};

uint8_t g_rcv_pkt7[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00, 0xA1,
    0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00, 0x45, 0x00,
    0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x40, 0x11,
    0x61, 0x68, 0x0B, 0x01, 0x02, 0x03, 0x0A, 0x01,
    0x02, 0x03, 0x00, 0x35, 0x12, 0xB5, 0x00, 0x6A,
    0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5,
    0x00, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0x08, 0x00,
    0x45, 0x00, 0x00, 0x4C, 0x00, 0x01, 0x00, 0x00,
    0x40, 0x11, 0x61, 0x99, 0x0B, 0x01, 0x02, 0x03,
    0x0A, 0x01, 0x02, 0x03, 0x00, 0x35, 0x12, 0xB7,
    0x00, 0x38, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    0x79, 0x27, 0x48, 0x2D};

uint64_t g_layer1_dmac   = 0x000102030405ULL;
uint64_t g_layer1_smac   = 0x00A1A2A3A4A5ULL;
uint32_t g_layer1_dip    = 0x0A010203;
uint32_t g_layer1_sip    = 0x0B010203;
uint8_t  g_layer1_proto  = IP_PROTO_UDP;
uint64_t g_layer2_dmac   = 0x001112131415ULL;
uint64_t g_layer2_smac   = 0x00B1B2B3B4B5ULL;
uint32_t g_layer2_dip    = 0x0C010203;
uint32_t g_layer2_sip    = 0x0D010203;
uint8_t  g_layer2_proto  = IP_PROTO_UDP;
uint64_t g_layer3_dmac   = 0x002122232425ULL;
uint64_t g_layer3_smac   = 0x00C1C2C3C4C5ULL;
uint32_t g_layer3_dip    = 0x0E010203;
uint32_t g_layer3_sip    = 0x0F010203;
uint8_t  g_layer3_proto  = IP_PROTO_TCP;
uint16_t g_layer31_sport = 0xABBA;
uint16_t g_layer31_dport = 0xBEEF;
uint16_t g_layer32_sport = 0x1234;
uint16_t g_layer32_dport = 0x5678;
uint32_t g_ohash_idx     = 0xDEAF;
uint32_t g_hash_msb      = 0x7F;
uint32_t g_flow_idx1     = 0xA32;
uint32_t g_flow_idx2     = 0xA34;
uint32_t g_flow_idx3     = 0xA36;
uint32_t g_flow_idx4     = 0xA38;

uint64_t g_rw_layer3_dmac = 0x00FEEDFEEDFEULL;
uint64_t g_rw_layer3_smac = 0x00DEAEAEAEAFULL;
uint32_t g_rw_layer3_dip  = 0x0E0A0B0C;
uint32_t g_rw_layer3_sip  = 0x0F0A0B0C;

uint64_t g_tx_layer1_dmac  = 0x002122232425ULL;
uint64_t g_tx_layer1_smac  = 0x00C1C2C3C4C5ULL;
uint32_t g_tx_layer1_dip   = 0x0E010203;
uint32_t g_tx_layer1_sip   = 0x0F010203;
uint8_t  g_tx_layer1_proto = IP_PROTO_TCP;
uint16_t g_tx_layer1_sport = 0x1234;
uint16_t g_tx_layer1_dport = 0x5678;

uint64_t g_tx_rdma1_dmac   = 0x00E1E2E3E4E5ULL;
uint64_t g_tx_rdma1_smac   = 0x00A1A2A3A4A5ULL;
uint32_t g_tx_rdma1_dip    = 0x0A010203;
uint32_t g_tx_rdma1_sip    = 0x0B010203;
uint64_t g_tx_rdma2_dmac   = 0x00F1F2F3F4F5ULL;

uint16_t g_rdma_sport      = 0x0035;
uint16_t g_rdma_dport      = 0x12B7;
uint8_t  g_rdma_proto      = IP_PROTO_UDP;

uint32_t g_tx_flow_idx1    = 0xB32;
uint32_t g_tx_flow_idx2    = 0xB34;
uint32_t g_tx_flow_idx3    = 0xB36;

static uint32_t
generate_hash_(void *key, uint32_t key_len, uint32_t crc_init_val) {
    boost::crc_basic<32> *crc_hash;
    uint32_t hash_val = 0x0;

    crc_hash = new boost::crc_basic<32>(0x04C11DB7, crc_init_val,
                                        0x00000000, false, false);
    crc_hash->process_bytes(key, key_len);
    hash_val = crc_hash->checksum();
    delete crc_hash;
    return hash_val;
}

static void
rx_roce_init() {
    rx_roce_actiondata_t data;

    memset(&data, 0, sizeof(data));
    data.action_id = RX_ROCE_RX_ROCE_ID;
    data.action_u.rx_roce_rx_roce.len = 12;
    data.action_u.rx_roce_rx_roce.qtype = 1;
    data.action_u.rx_roce_rx_roce.parsed_hdrs_len = 12  + 12;

    p4pd_entry_write(P4TBL_ID_RX_ROCE, 4, NULL, NULL, &data);
}

static void
rx_key1_init(int index) {
    rx_key1_swkey_t      key;
    rx_key1_swkey_mask_t mask;
    rx_key1_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_1 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_2_valid = 0xFF;
    key.ipv4_2_valid = 0xFF;
    key.udp_2_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_2 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_3_valid = 0xFF;
    key.ipv4_3_valid = 0xFF;
    key.tcp_3_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key1_rx_key1.match_fields =
        (MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
         MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY1, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY1, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY1, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
rx_key2_init(int index) {
    rx_key2_swkey_t      key;
    rx_key2_swkey_mask_t mask;
    rx_key2_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_1 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_2_valid = 0xFF;
    key.ipv4_2_valid = 0xFF;
    key.udp_2_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_2 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_3_valid = 0xFF;
    key.ipv4_3_valid = 0xFF;
    key.tcp_3_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key2_rx_key2.match_fields =
        (MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
         MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY2, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY2, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY2, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
rx_key3_init(int index) {
    rx_key3_swkey_t      key;
    rx_key3_swkey_mask_t mask;
    rx_key3_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_1 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_2_valid = 0xFF;
    key.ipv4_2_valid = 0xFF;
    key.udp_2_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_2 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_3_valid = 0xFF;
    key.ipv4_3_valid = 0xFF;
    key.tcp_3_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key3_rx_key3.match_fields =
        (MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
         MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY3, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY3, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY3, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
rx_key4_init(int index) {
    rx_key4_swkey_t      key;
    rx_key4_swkey_mask_t mask;
    rx_key4_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_1 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_2_valid = 0xFF;
    key.ipv4_2_valid = 0xFF;
    key.udp_2_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_2 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_3_valid = 0xFF;
    key.ipv4_3_valid = 0xFF;
    key.tcp_3_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key4_rx_key4.match_fields =
        (MATCH_TRANSPORT_SRC_PORT_3 | MATCH_TRANSPORT_DST_PORT_3);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY4, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY4, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY4, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
native_udp_rx_key1_init(int index) {
    rx_key1_swkey_t      key;
    rx_key1_swkey_mask_t mask;
    rx_key1_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key1_rx_key1.match_fields =
        (MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
         MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY1, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY1, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY1, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
native_udp_rx_key4_init(int index) {
    rx_key4_swkey_t      key;
    rx_key4_swkey_mask_t mask;
    rx_key4_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key4_rx_key4.match_fields =
        (MATCH_TRANSPORT_SRC_PORT_1 | MATCH_TRANSPORT_DST_PORT_1);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY4, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY4, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY4, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
tunneled_udp_rx_key1_init(int index) {
    rx_key1_swkey_t      key;
    rx_key1_swkey_mask_t mask;
    rx_key1_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_1 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_2_valid = 0xFF;
    key.ipv4_2_valid = 0xFF;
    key.udp_2_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key1_rx_key1.match_fields =
        (MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
         MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY1, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY1, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY1, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
tunneled_udp_rx_key2_init(int index) {
    rx_key2_swkey_t      key;
    rx_key2_swkey_mask_t mask;
    rx_key2_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_1 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_2_valid = 0xFF;
    key.ipv4_2_valid = 0xFF;
    key.udp_2_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key2_rx_key2.match_fields =
        (MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
         MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY2, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY2, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY2, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
tunneled_udp_rx_key4_init(int index) {
    rx_key4_swkey_t      key;
    rx_key4_swkey_mask_t mask;
    rx_key4_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    key.tunnel_metadata_tunnel_type_1 = INGRESS_TUNNEL_TYPE_VXLAN;
    key.ethernet_2_valid = 0xFF;
    key.ipv4_2_valid = 0xFF;
    key.udp_2_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.rx_key4_rx_key4.match_fields =
        (MATCH_TRANSPORT_SRC_PORT_2 | MATCH_TRANSPORT_DST_PORT_2);

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_KEY4, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_KEY4, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_KEY4, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
rx_key_init() {
    rx_key1_init(0);
    rx_key2_init(0);
    rx_key3_init(0);
    rx_key4_init(0);

    native_udp_rx_key1_init(1);
    native_udp_rx_key4_init(1);

    tunneled_udp_rx_key1_init(2);
    tunneled_udp_rx_key2_init(2);
    tunneled_udp_rx_key4_init(2);
}

static void
rx_create_vport_entry() {
    rx_vport_swkey_t      key;
    rx_vport_swkey_mask_t mask;
    rx_vport_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key
    key.ethernet_1_valid = 0xFF;
    memcpy(key.ethernet_1_dstAddr, &g_layer1_dmac, 6);

    // mask
    mask.ethernet_1_valid_mask = 0xFF;
    memset(mask.ethernet_1_dstAddr_mask, 0xFF, 6);

    // data
    data.action_u.rx_vport_rx_vport.vport = 0x55;
    data.action_u.rx_vport_rx_vport.tm_oport = TM_PORT_UPLINK_0;
    data.action_u.rx_vport_rx_vport.rdma_enabled = 1;

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_RX_VPORT, &hwkey_len, &hwmask_len,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_VPORT, &key, &mask,
                                hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_RX_VPORT, 0, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
rx_create_transposition() {
    rx_hdr_transpositions0_actiondata_t data0;
    rx_hdr_transpositions1_actiondata_t data1;
    rx_hdr_transpositions2_actiondata_t data2;
    rx_hdr_transpositions3_actiondata_t data3;

    memset(&data0, 0, sizeof(data0));
    memset(&data1, 0, sizeof(data1));
    memset(&data2, 0, sizeof(data2));
    memset(&data3, 0, sizeof(data3));

#define DATA0 data0.action_u.rx_hdr_transpositions0_rx_hdr_transpositions
#define DATA1 data1.action_u.rx_hdr_transpositions1_rx_hdr_transpositions
#define DATA2 data2.action_u.rx_hdr_transpositions2_rx_hdr_transpositions
#define DATA3 data3.action_u.rx_hdr_transpositions3_rx_l4_hdr_transpositions

    DATA0.hdr1_bits =
        TRANSPOSITIONS_POP_ETHERNET |
        TRANSPOSITIONS_POP_IPV4;
    DATA0.hdr2_bits =
        TRANSPOSITIONS_POP_ETHERNET |
        TRANSPOSITIONS_POP_IPV4;
    p4pd_entry_write(P4TBL_ID_RX_HDR_TRANSPOSITIONS0, g_flow_idx2,
                         NULL, NULL, &data0);

    DATA1.hdr3_bits =
        TRANSPOSITIONS_MODIFY_ETHERNET_SRC |
        TRANSPOSITIONS_MODIFY_ETHERNET_DST;
    memcpy(DATA1.ethernet_dst, &g_rw_layer3_dmac, 6);
    memcpy(DATA1.ethernet_src, &g_rw_layer3_smac, 6);
    p4pd_entry_write(P4TBL_ID_RX_HDR_TRANSPOSITIONS1, g_flow_idx2,
                         NULL, NULL, &data1);

    DATA2.hdr3_bits =
        TRANSPOSITIONS_MODIFY_IP_SRC | TRANSPOSITIONS_MODIFY_IP_DST;
    memcpy(DATA2.ip_dst, &g_rw_layer3_dip, 4);
    memcpy(DATA2.ip_src, &g_rw_layer3_sip, 4);
    p4pd_entry_write(P4TBL_ID_RX_HDR_TRANSPOSITIONS2, g_flow_idx2,
                         NULL, NULL, &data2);

    DATA3.hdr_bits =
        TRANSPOSITIONS_POP_VXLAN_1 |
        TRANSPOSITIONS_POP_UDP_1 |
        TRANSPOSITIONS_POP_VXLAN_2 |
        TRANSPOSITIONS_POP_UDP_2;
    p4pd_entry_write(P4TBL_ID_RX_HDR_TRANSPOSITIONS3, g_flow_idx2,
                         NULL, NULL, &data3);

#undef DATA0
#undef DATA1
#undef DATA2
#undef DATA3
}

static void
rx_gft_entry_write(rx_gft_hash_swkey_t *key, rx_gft_hash_actiondata_t *data,
                   bool has_overflow_entry) {
    uint32_t hwkey_len = 0;
    uint32_t hwdata_len = 0;
    uint32_t hash = 0;
    uint32_t hash_len = 0;
    uint32_t gft_idx = 0;
    uint8_t  *hwkey = NULL;

    // build hardware entry
    p4pd_hwentry_query(P4TBL_ID_RX_GFT_HASH, &hwkey_len, NULL,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hash_len = hwkey_len;
    if (hash_len % 64) {
        hash_len +=  (64 - (hwkey_len % 64));
    }
    hwkey = new uint8_t[hash_len];
    memset(hwkey, 0, hash_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_GFT_HASH, key, NULL, hwkey, NULL);

    // generate hash
    uint32_t crc_init_val = 0;
    for (uint32_t i = 0; i < hash_len; i += 64) {
        hash = generate_hash_(hwkey + i, 64, crc_init_val);
        //printf("HASH(%d) : 0x%0x\n", i, hash);
        crc_init_val = hash;
    }
    hash = generate_hash_(hwkey, hash_len, 0);
    gft_idx = hash & 0x7FFFFF;
    //printf("Final hash : 0x%0x, index : 0x%0x\n", hash, gft_idx);

    if (has_overflow_entry) {
        // reset the key to 0
        memset(hwkey, 0, hash_len);
    }
    p4pd_entry_write(P4TBL_ID_RX_GFT_HASH, gft_idx, hwkey, NULL, data);
    delete [] hwkey;
}

static void
rx_create_gft_entry1() {
    rx_gft_hash_swkey_t     key;
    rx_gft_hash_actiondata_t  data;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_layer1_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_layer1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_layer1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_layer1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_layer1_proto;
    memcpy(key.flow_lkp_metadata_ethernet_dst_2, &g_layer2_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_2, &g_layer2_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_2, &g_layer2_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_2, &g_layer2_sip, 4);
    key.flow_lkp_metadata_ip_proto_2 = g_layer2_proto;
    memcpy(key.flow_lkp_metadata_ethernet_dst_3, &g_layer3_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_3, &g_layer3_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_3, &g_layer3_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_3, &g_layer3_sip, 4);
    key.flow_lkp_metadata_ip_proto_3 = g_layer3_proto;
    key.flow_lkp_metadata_l4_sport_3 = g_layer31_sport;
    key.flow_lkp_metadata_l4_dport_3 = g_layer31_dport;

    // data
    data.action_u.rx_gft_hash_rx_gft_hash_info.entry_valid = 1;
    data.action_u.rx_gft_hash_rx_gft_hash_info.flow_index = g_flow_idx1;

    rx_gft_entry_write(&key, &data, false);
}

static void
rx_create_gft_entry2() {
    rx_gft_hash_swkey_t     key;
    rx_gft_hash_actiondata_t  data;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_layer1_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_layer1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_layer1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_layer1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_layer1_proto;
    memcpy(key.flow_lkp_metadata_ethernet_dst_2, &g_layer2_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_2, &g_layer2_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_2, &g_layer2_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_2, &g_layer2_sip, 4);
    key.flow_lkp_metadata_ip_proto_2 = g_layer2_proto;
    memcpy(key.flow_lkp_metadata_ethernet_dst_3, &g_layer3_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_3, &g_layer3_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_3, &g_layer3_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_3, &g_layer3_sip, 4);
    key.flow_lkp_metadata_ip_proto_3 = g_layer3_proto;
    key.flow_lkp_metadata_l4_sport_3 = g_layer32_sport;
    key.flow_lkp_metadata_l4_dport_3 = g_layer32_dport;

    // data
    data.action_u.rx_gft_hash_rx_gft_hash_info.entry_valid = 1;
    data.action_u.rx_gft_hash_rx_gft_hash_info.flow_index = 0;
    data.action_u.rx_gft_hash_rx_gft_hash_info.hint1 = g_ohash_idx;
    data.action_u.rx_gft_hash_rx_gft_hash_info.hash1 = g_hash_msb;

    rx_gft_entry_write(&key, &data, true);
}

static void
rx_create_gft_entry3() {
    rx_gft_hash_swkey_t     key;
    rx_gft_hash_actiondata_t  data;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_layer1_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_layer1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_layer1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_layer1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_layer1_proto;
    key.flow_lkp_metadata_l4_sport_1 = g_rdma_sport;
    key.flow_lkp_metadata_l4_dport_1 = g_rdma_dport;

    // data
    data.action_u.rx_gft_hash_rx_gft_hash_info.entry_valid = 1;
    data.action_u.rx_gft_hash_rx_gft_hash_info.flow_index = g_flow_idx3;

    rx_gft_entry_write(&key, &data, false);
}

static void
rx_create_gft_entry4() {
    rx_gft_hash_swkey_t     key;
    rx_gft_hash_actiondata_t  data;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_layer1_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_layer1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_layer1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_layer1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_layer1_proto;
    memcpy(key.flow_lkp_metadata_ethernet_dst_2, &g_layer2_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_2, &g_layer2_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_2, &g_layer2_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_2, &g_layer2_sip, 4);
    key.flow_lkp_metadata_ip_proto_2 = g_layer2_proto;
    key.flow_lkp_metadata_l4_sport_2 = g_rdma_sport;
    key.flow_lkp_metadata_l4_dport_2 = g_rdma_dport;

    // data
    data.action_u.rx_gft_hash_rx_gft_hash_info.entry_valid = 1;
    data.action_u.rx_gft_hash_rx_gft_hash_info.flow_index = g_flow_idx4;

    rx_gft_entry_write(&key, &data, false);
}

static void
rx_create_gft_overflow_entry() {
    rx_gft_hash_swkey_t     key;
    rx_gft_hash_actiondata_t  data;
    uint32_t                hwkey_len = 0;
    uint32_t                hwdata_len = 0;
    uint8_t                 *hwkey = NULL;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_layer1_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_layer1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_layer1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_layer1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_layer1_proto;
    memcpy(key.flow_lkp_metadata_ethernet_dst_2, &g_layer2_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_2, &g_layer2_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_2, &g_layer2_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_2, &g_layer2_sip, 4);
    key.flow_lkp_metadata_ip_proto_2 = g_layer2_proto;
    memcpy(key.flow_lkp_metadata_ethernet_dst_3, &g_layer3_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_3, &g_layer3_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_3, &g_layer3_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_3, &g_layer3_sip, 4);
    key.flow_lkp_metadata_ip_proto_3 = g_layer3_proto;
    key.flow_lkp_metadata_l4_sport_3 = g_layer32_sport;
    key.flow_lkp_metadata_l4_dport_3 = g_layer32_dport;

    // data
    data.action_u.rx_gft_hash_rx_gft_hash_info.entry_valid = 1;
    data.action_u.rx_gft_hash_rx_gft_hash_info.flow_index = g_flow_idx2;

    // build hardware entry
    p4pd_hwentry_query(P4TBL_ID_RX_GFT_HASH_OVERFLOW, &hwkey_len, NULL,
                           &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    memset(hwkey, 0, hwkey_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_RX_GFT_HASH_OVERFLOW, &key, NULL,
                                hwkey, NULL);

    p4pd_entry_write(P4TBL_ID_RX_GFT_HASH_OVERFLOW, g_ohash_idx, hwkey,
                         NULL, &data);
    delete [] hwkey;
}

static void
tx_tcp_key_init(int index) {
    tx_key_swkey_t      key;
    tx_key_swkey_mask_t mask;
    tx_key_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.tcp_1_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.tx_key_tx_key.match_fields =
        ((MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
          MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO) |
         ((MATCH_TRANSPORT_SRC_PORT_1 | MATCH_TRANSPORT_DST_PORT_1) << 16));

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_TX_KEY, &hwkey_len, &hwmask_len, &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_TX_KEY, &key, &mask, hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_TX_KEY, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
tx_udp_key_init(int index) {
    tx_key_swkey_t      key;
    tx_key_swkey_mask_t mask;
    tx_key_actiondata_t   data;

    memset(&key, 0, sizeof(key));
    memset(&mask, 0, sizeof(mask));
    memset(&data, 0, sizeof(data));

    // key and mask
    key.ethernet_1_valid = 0xFF;
    key.ipv4_1_valid = 0xFF;
    key.udp_1_valid = 0xFF;
    memset(&mask, 0xFF, sizeof(mask));

    // data
    data.action_u.tx_key_tx_key.match_fields =
        ((MATCH_ETHERNET_SRC | MATCH_ETHERNET_DST |
          MATCH_IP_SRC | MATCH_IP_DST | MATCH_IP_PROTO) |
         ((MATCH_TRANSPORT_SRC_PORT_1 | MATCH_TRANSPORT_DST_PORT_1) << 16));

    // prepare entry and write hardware
    uint32_t hwkey_len = 0;
    uint32_t hwmask_len = 0;
    uint32_t hwdata_len = 0;
    uint8_t  *hwkey = NULL;
    uint8_t  *hwmask = NULL;
    p4pd_hwentry_query(P4TBL_ID_TX_KEY, &hwkey_len, &hwmask_len, &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwmask_len = (hwmask_len >> 3) + ((hwmask_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hwkey = new uint8_t[hwkey_len];
    hwmask = new uint8_t[hwmask_len];
    memset(hwkey, 0, hwkey_len);
    memset(hwmask, 0, hwmask_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_TX_KEY, &key, &mask, hwkey, hwmask);
    p4pd_entry_write(P4TBL_ID_TX_KEY, index, hwkey, hwmask, &data);
    delete [] hwkey;
    delete [] hwmask;
}

static void
tx_key_init() {
    tx_tcp_key_init(0);
    tx_udp_key_init(1);
}

static void
tx_create_transposition2() {
    tx_hdr_transpositions0_actiondata_t data0;
    tx_hdr_transpositions1_actiondata_t data1;
    tx_hdr_transpositions2_actiondata_t data2;
    tx_hdr_transpositions3_actiondata_t data3;

    memset(&data0, 0, sizeof(data0));
    memset(&data1, 0, sizeof(data1));
    memset(&data2, 0, sizeof(data2));
    memset(&data3, 0, sizeof(data3));

#define DATA0 data0.action_u.tx_hdr_transpositions0_tx_hdr_transpositions
#define DATA1 data1.action_u.tx_hdr_transpositions1_tx_hdr_transpositions
#define DATA2 data2.action_u.tx_hdr_transpositions2_tx_hdr_transpositions
#define DATA3 data3.action_u.tx_hdr_transpositions3_tx_l4_hdr_transpositions

    // encap len = 36B
    DATA0.hdr0_bits =
        (TRANSPOSITIONS_PUSH_ETHERNET_00 | TRANSPOSITIONS_PUSH_IPV4_00) |
        (36 << 16);
    memcpy(DATA0.ethernet_dst, &g_layer1_dmac, 6);
    memcpy(DATA0.ethernet_src, &g_layer1_smac, 6);
    memcpy(DATA0.ip_src, &g_layer1_sip, 4);
    memcpy(DATA0.ip_dst, &g_layer1_dip, 4);
    DATA0.ethernet_type = 0x0800;
    DATA0.ip_ttl = 64;
    DATA0.ip_proto = g_layer1_proto;
    p4pd_entry_write(P4TBL_ID_TX_HDR_TRANSPOSITIONS0, g_tx_flow_idx3,
                     NULL, NULL, &data0);

    DATA3.hdr0_bits =
        TRANSPOSITIONS_PUSH_VXLAN_00 | TRANSPOSITIONS_PUSH_UDP_00;
    DATA3.l4_sport_00  = 0x0035;
    DATA3.l4_dport_00  = 0x12b5;
    DATA3.encap_len_00 = 16;
    p4pd_entry_write(P4TBL_ID_TX_HDR_TRANSPOSITIONS3, g_tx_flow_idx3,
                     NULL, NULL, &data3);

#undef DATA0
#undef DATA1
#undef DATA2
#undef DATA3
}

static void
tx_create_transposition3() {
    tx_hdr_transpositions0_actiondata_t data0;
    tx_hdr_transpositions1_actiondata_t data1;
    tx_hdr_transpositions2_actiondata_t data2;
    tx_hdr_transpositions3_actiondata_t data3;

    memset(&data0, 0, sizeof(data0));
    memset(&data1, 0, sizeof(data1));
    memset(&data2, 0, sizeof(data2));
    memset(&data3, 0, sizeof(data3));

#define DATA0 data0.action_u.tx_hdr_transpositions0_tx_hdr_transpositions
#define DATA1 data1.action_u.tx_hdr_transpositions1_tx_hdr_transpositions
#define DATA2 data2.action_u.tx_hdr_transpositions2_tx_hdr_transpositions
#define DATA3 data3.action_u.tx_hdr_transpositions3_tx_l4_hdr_transpositions

    // encap len = 86B
    DATA0.hdr0_bits =
        (TRANSPOSITIONS_PUSH_ETHERNET_00 | TRANSPOSITIONS_PUSH_IPV4_00) |
        (86 << 16);
    memcpy(DATA0.ethernet_dst, &g_layer1_dmac, 6);
    memcpy(DATA0.ethernet_src, &g_layer1_smac, 6);
    memcpy(DATA0.ip_src, &g_layer1_sip, 4);
    memcpy(DATA0.ip_dst, &g_layer1_dip, 4);
    DATA0.ethernet_type = 0x0800;
    DATA0.ip_ttl = 64;
    DATA0.ip_proto = g_layer1_proto;
    p4pd_entry_write(P4TBL_ID_TX_HDR_TRANSPOSITIONS0, g_tx_flow_idx1,
                     NULL, NULL, &data0);

    // encap len = 36B
    DATA1.hdr0_bits =
        (TRANSPOSITIONS_PUSH_ETHERNET_01 | TRANSPOSITIONS_PUSH_IPV4_01) |
        (36 << 8);
    memcpy(DATA1.ethernet_dst, &g_layer2_dmac, 6);
    memcpy(DATA1.ethernet_src, &g_layer2_smac, 6);
    memcpy(DATA1.ip_src, &g_layer2_sip, 4);
    memcpy(DATA1.ip_dst, &g_layer2_dip, 4);
    DATA1.ethernet_type = 0x0800;
    DATA1.ip_ttl = 64;
    DATA1.ip_proto = g_layer1_proto;
    p4pd_entry_write(P4TBL_ID_TX_HDR_TRANSPOSITIONS1, g_tx_flow_idx1,
                     NULL, NULL, &data1);

    DATA3.hdr0_bits =
        TRANSPOSITIONS_PUSH_VXLAN_00 |
        TRANSPOSITIONS_PUSH_UDP_00 |
        TRANSPOSITIONS_PUSH_VXLAN_01 |
        TRANSPOSITIONS_PUSH_UDP_01;
    DATA3.l4_sport_00  = 0x0035;
    DATA3.l4_dport_00  = 0x12b5;
    DATA3.encap_len_00 = 66;
    DATA3.l4_sport_01  = 0x0035;
    DATA3.l4_dport_01  = 0x12b5;
    DATA3.encap_len_01 = 16;
    p4pd_entry_write(P4TBL_ID_TX_HDR_TRANSPOSITIONS3, g_tx_flow_idx1,
                     NULL, NULL, &data3);

#undef DATA0
#undef DATA1
#undef DATA2
#undef DATA3
}

static void
tx_gft_entry_write(tx_gft_hash_swkey_t *key, tx_gft_hash_actiondata_t *data) {
    uint32_t hwkey_len = 0;
    uint32_t hwdata_len = 0;
    uint32_t hash = 0;
    uint32_t hash_len = 0;
    uint32_t gft_idx = 0;
    uint8_t  *hwkey = NULL;

    // build hardware entry
    p4pd_hwentry_query(P4TBL_ID_TX_GFT_HASH, &hwkey_len, NULL, &hwdata_len);
    hwkey_len = (hwkey_len >> 3) + ((hwkey_len & 0x7) ? 1 : 0);
    hwdata_len = (hwdata_len >> 3) + ((hwdata_len & 0x7) ? 1 : 0);
    hash_len = hwkey_len;
    if (hash_len % 64) {
        hash_len +=  (64 - (hwkey_len % 64));
    }
    hwkey = new uint8_t[hash_len];
    memset(hwkey, 0, hash_len);
    p4pd_hwkey_hwmask_build(P4TBL_ID_TX_GFT_HASH, key, NULL, hwkey, NULL);

    // generate hash
    uint32_t crc_init_val = 0;
    for (uint32_t i = 0; i < hash_len; i += 64) {
        hash = generate_hash_(hwkey + i, 64, crc_init_val);
        //printf("HASH(%d) : 0x%0x\n", i, hash);
        crc_init_val = hash;
    }
    hash = generate_hash_(hwkey, hash_len, 0);
    gft_idx = hash & 0xFFFFF;
    //printf("Final hash : 0x%0x, index : 0x%0x\n", hash, gft_idx);

    p4pd_entry_write(P4TBL_ID_TX_GFT_HASH, gft_idx, hwkey, NULL, data);
    delete [] hwkey;
}

static void
tx_create_gft_entry1() {
    tx_gft_hash_swkey_t     key;
    tx_gft_hash_actiondata_t  data;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_tx_layer1_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_tx_layer1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_tx_layer1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_tx_layer1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_tx_layer1_proto;
    key.flow_lkp_metadata_l4_sport_1 = g_tx_layer1_sport;
    key.flow_lkp_metadata_l4_dport_1 = g_tx_layer1_dport;

    // data
    data.action_u.tx_gft_hash_tx_gft_hash_info.entry_valid = 1;
    data.action_u.tx_gft_hash_tx_gft_hash_info.flow_index = g_tx_flow_idx1;

    tx_gft_entry_write(&key, &data);
}

static void
tx_create_gft_entry2() {
    tx_gft_hash_swkey_t     key;
    tx_gft_hash_actiondata_t  data;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_tx_rdma1_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_tx_rdma1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_tx_rdma1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_tx_rdma1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_rdma_proto;
    key.flow_lkp_metadata_l4_sport_1 = g_rdma_sport;
    key.flow_lkp_metadata_l4_dport_1 = g_rdma_dport;

    // data
    data.action_u.tx_gft_hash_tx_gft_hash_info.entry_valid = 1;
    data.action_u.tx_gft_hash_tx_gft_hash_info.flow_index = g_tx_flow_idx2;

    tx_gft_entry_write(&key, &data);
}

class gft_test : public ::testing::Test {
  protected:
    gft_test() {}
    virtual ~gft_test() {}
    virtual void SetUp() {}
    virtual void TearDown() {}
};

static void
tx_create_gft_entry3() {
    tx_gft_hash_swkey_t     key;
    tx_gft_hash_actiondata_t  data;

    memset(&key, 0, sizeof(key));
    memset(&data, 0, sizeof(data));

    // key
    memcpy(key.flow_lkp_metadata_ethernet_dst_1, &g_tx_rdma2_dmac, 6);
    memcpy(key.flow_lkp_metadata_ethernet_src_1, &g_tx_rdma1_smac, 6);
    memcpy(key.flow_lkp_metadata_ip_dst_1, &g_tx_rdma1_dip, 4);
    memcpy(key.flow_lkp_metadata_ip_src_1, &g_tx_rdma1_sip, 4);
    key.flow_lkp_metadata_ip_proto_1 = g_rdma_proto;
    key.flow_lkp_metadata_l4_sport_1 = g_rdma_sport;
    key.flow_lkp_metadata_l4_dport_1 = g_rdma_dport;

    // data
    data.action_u.tx_gft_hash_tx_gft_hash_info.entry_valid = 1;
    data.action_u.tx_gft_hash_tx_gft_hash_info.flow_index = g_tx_flow_idx3;

    tx_gft_entry_write(&key, &data);
}

static int
hal_sdk_logger (uint32_t mod_id, sdk_trace_level_e tracel_level,
                const char *format, ...)
{
    char       logbuf[1024];
    va_list    args;

    if ((int)hal_trace_level() >= (int)tracel_level)  {
        va_start(args, format);
        vsnprintf(logbuf, sizeof(logbuf), format, args);
        switch (tracel_level) {
        case sdk::lib::SDK_TRACE_LEVEL_ERR:
            HAL_TRACE_ERR_NO_META("{}", logbuf);
            break;
        case sdk::lib::SDK_TRACE_LEVEL_WARN:
            HAL_TRACE_WARN_NO_META("{}", logbuf);
            break;
        case sdk::lib::SDK_TRACE_LEVEL_INFO:
            HAL_TRACE_INFO_NO_META("{}", logbuf);
            break;
        case sdk::lib::SDK_TRACE_LEVEL_DEBUG:
            HAL_TRACE_DEBUG_NO_META("{}", logbuf);
            break;
        case sdk::lib::SDK_TRACE_LEVEL_VERBOSE:
            HAL_TRACE_VERBOSE_NO_META("{}", logbuf);
            break;
        default:
            break;
        }
        va_end(args);
    }

    return 0;
}

TEST_F(gft_test, test1) {
    int ret = 0;
    char *default_config_dir = NULL;
    asic_cfg_t cfg;
    sdk::lib::catalog *catalog;

    p4pd_cfg_t    p4pd_cfg = {
        .table_map_cfg_file  = "gft/capri_p4_table_map.json",
        .p4pd_pgm_name       = "gft",
        .p4pd_rxdma_pgm_name = "p4plus",
        .p4pd_txdma_pgm_name = "p4plus",
        .cfg_path = std::getenv("HAL_CONFIG_PATH")
    };

    cfg.cfg_path = std::string(std::getenv("HAL_CONFIG_PATH"));
    std::string mpart_json = cfg.cfg_path + "/gft/hbm_mem.json";
    platform_type_t platform = platform_type_t::PLATFORM_TYPE_SIM;
    catalog = sdk::lib::catalog::factory(cfg.cfg_path, "/catalog.json");
    if (getenv("HAL_PLATFORM_RTL")) {
        platform = platform_type_t::PLATFORM_TYPE_RTL;
    } else if (getenv("HAL_PLATFORM_HW")) {
        platform = platform_type_t::PLATFORM_TYPE_HW;
        catalog = sdk::lib::catalog::factory(cfg.cfg_path, "");
    }
    ASSERT_TRUE(catalog != NULL);
    cfg.catalog = catalog;
    cfg.mempartition = sdk::platform::utils::mpartition::factory(mpart_json.c_str());

    default_config_dir = std::getenv("HAL_PBC_INIT_CONFIG");
    if (default_config_dir) {
        cfg.default_config_dir = std::string(default_config_dir);
    } else {
        cfg.default_config_dir = "8x25_hbm";
    }

    cfg.platform = platform;
    cfg.admin_cos = 1;
    cfg.pgm_name = std::string("gft");

    printf("Connecting to ASIC SIM\n");
    // hal::hal_sdk_init();
    sdk::lib::logger::init(hal_sdk_logger);

    hal::utils::trace_init("hal", 0, true, "hal.log", NULL,
                           TRACE_FILE_SIZE_DEFAULT, TRACE_NUM_FILES_DEFAULT,
                           ::utils::trace_debug, ::utils::trace_none);
    ret = sdk::lib::pal_init(platform);
    ASSERT_TRUE(ret == 0);

    cfg.num_pgm_cfgs = 1;
    memset(cfg.pgm_cfg, 0, sizeof(cfg.pgm_cfg));
    cfg.pgm_cfg[0].path = std::string("pgm_bin");
    cfg.num_rings = 0;
    cfg.ring_meta = NULL;

    cfg.num_asm_cfgs = 1;
    memset(cfg.asm_cfg, 0, sizeof(cfg.asm_cfg));
    cfg.asm_cfg[0].name = std::string("gft");
    cfg.asm_cfg[0].path = std::string("asm_bin");
    cfg.asm_cfg[0].base_addr = std::string(JP4_PRGM);

    cfg.completion_func = NULL;
    sdk::lib::device_profile_t device_profile = {0};
    device_profile.qos_profile = {9216, 8, 25, 27, 16, 2, {0, 24}, 2, {0, 5}};
    cfg.device_profile = &device_profile;

    ret = sdk::asic::pd::asicpd_init(&cfg);
    ASSERT_EQ(ret, SDK_RET_OK);
    ret = p4pd_init(&p4pd_cfg);
    ASSERT_EQ(ret, HAL_RET_OK);
    ASSERT_EQ(ret, HAL_RET_OK);
    ret = sdk::asic::pd::asicpd_table_mpu_base_init(&p4pd_cfg);
    ASSERT_EQ(ret, SDK_RET_OK);
    ret = sdk::asic::pd::asicpd_program_table_mpu_pc();
    ASSERT_EQ(ret, SDK_RET_OK);
    ret = sdk::asic::pd::asicpd_deparser_init();
    ASSERT_EQ(ret, SDK_RET_OK);
    ret = sdk::asic::pd::asicpd_program_hbm_table_base_addr();
    ASSERT_EQ(ret, SDK_RET_OK);

#ifdef SIM
    config_done();
#endif

    rx_roce_init();
    rx_key_init();
    rx_create_vport_entry();
    rx_create_transposition();
    rx_create_gft_entry1();
    rx_create_gft_entry2();
    rx_create_gft_entry3();
    rx_create_gft_entry4();
    rx_create_gft_overflow_entry();

    tx_key_init();
    tx_create_transposition2();
    tx_create_transposition3();
    tx_create_gft_entry1();
    tx_create_gft_entry2();
    tx_create_gft_entry3();

#ifdef SIM
    uint32_t i = 0;
    uint32_t port = 0;
    uint32_t cos = 0;
    std::vector<uint8_t> ipkt;
    std::vector<uint8_t> opkt;
    std::vector<uint8_t> epkt;
    uint32_t tcscale = 1;
    int tcid = 0;
    int tcid_filter = 0;
    uint32_t tx_enable = 0;
    uint32_t rx_enable = 0;

    if (getenv("TCSCALE")) {
        tcscale = atoi(getenv("TCSCALE"));
    }

    if (getenv("GFT_TEST_TX_ONLY")) {
        tx_enable = atoi(getenv("GFT_TEST_TX_ONLY"));
    }

    if (getenv("GFT_TEST_RX_ONLY")) {
        rx_enable = atoi(getenv("GFT_TEST_RX_ONLY"));
    }

    // Run all tests, if none of these are set.
    if (!getenv("GFT_TEST_TX_ONLY") && !getenv("GFT_TEST_RX_ONLY")) {
        rx_enable = 1;
        tx_enable = 1;
    }

    if (getenv("GFT_TCID")) {
        tcid_filter = atoi(getenv("GFT_TCID"));
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt1));
        memcpy(ipkt.data(), g_snd_pkt1, sizeof(g_snd_pkt1));
        epkt.resize(sizeof(g_rcv_pkt1));
        memcpy(epkt.data(), g_rcv_pkt1, sizeof(g_rcv_pkt1));
        std::cout << "Rx: Testing wide key without overflow" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt2));
        memcpy(ipkt.data(), g_snd_pkt2, sizeof(g_snd_pkt2));
        epkt.resize(sizeof(g_rcv_pkt2));
        memcpy(epkt.data(), g_rcv_pkt2, sizeof(g_rcv_pkt2));
        std::cout << "Rx: Testing wide key with overflow" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt3));
        memcpy(ipkt.data(), g_snd_pkt3, sizeof(g_snd_pkt3));
        epkt.resize(sizeof(g_rcv_pkt3));
        memcpy(epkt.data(), g_rcv_pkt3, sizeof(g_rcv_pkt3));
        std::cout << "Rx: Testing native RDMA flow" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (rx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        ipkt.resize(sizeof(g_snd_pkt4));
        memcpy(ipkt.data(), g_snd_pkt4, sizeof(g_snd_pkt4));
        epkt.resize(sizeof(g_rcv_pkt4));
        memcpy(epkt.data(), g_rcv_pkt4, sizeof(g_rcv_pkt4));
        std::cout << "Rx: Testing tunneled RDMA flow" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (tx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        port = 1;
        ipkt.resize(sizeof(g_snd_pkt5));
        memcpy(ipkt.data(), g_snd_pkt5, sizeof(g_snd_pkt5));
        epkt.resize(sizeof(g_rcv_pkt5));
        memcpy(epkt.data(), g_rcv_pkt5, sizeof(g_rcv_pkt5));
        std::cout << "Tx: Testing wide key without overflow" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (tx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        port = 1;
        ipkt.resize(sizeof(g_snd_pkt6));
        memcpy(ipkt.data(), g_snd_pkt6, sizeof(g_snd_pkt6));
        epkt.resize(sizeof(g_rcv_pkt6));
        memcpy(epkt.data(), g_rcv_pkt6, sizeof(g_rcv_pkt6));
        std::cout << "Tx: Testing native RDMA flow" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    tcid++;
    if (tx_enable && (tcid_filter == 0 || tcid == tcid_filter)) {
        port = 1;
        ipkt.resize(sizeof(g_snd_pkt7));
        memcpy(ipkt.data(), g_snd_pkt7, sizeof(g_snd_pkt7));
        epkt.resize(sizeof(g_rcv_pkt7));
        memcpy(epkt.data(), g_rcv_pkt7, sizeof(g_rcv_pkt7));
        std::cout << "Tx: Testing tunneled RDMA flow" << std::endl;
        for (i = 0; i < tcscale; i++) {
            printf("Starting Testcase TC%06d-%04d\n", tcid, i+1);
            testcase_begin(tcid, i+1);
            step_network_pkt(ipkt, port);
            if (!getenv("SKIP_VERIFY")) {
                get_next_pkt(opkt, port, cos);
                EXPECT_TRUE(opkt == epkt);
            }
            testcase_end(tcid, i+1);
        }
    }

    exit_simulation();
#endif
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
