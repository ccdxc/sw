// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.
 /*
 * Package restapi is a auto generated package.
 * Input file: {{.Name}}
 */
 {{$pkgName := .Package}}
package restapi
import (
	"github.com/gorilla/mux"
	"github.com/fatih/structs"
	"github.com/pensando/sw/nic/delphi/proto/goproto"
	"github.com/pensando/sw/api"
	"github.com/pensando/sw/venice/utils/ntranslate"
        "github.com/pensando/sw/venice/utils/tsdb"
	_ "github.com/pensando/sw/nic/utils/ntranslate/{{$pkgName}}"
{{if (strEq .GetName "metrics.proto")}}
        "github.com/pensando/sw/venice/utils/tsdb/metrics"
{{end}}
)

 {{$msgs := .Messages}}
 {{range $msgs}}

    {{if (HasSuffix .GetName "Metrics")}}
	// Add{{.GetName}}APIRoutes adds routes for {{.GetName}}
	func (s *RestServer) Add{{.GetName}}APIRoutes(r *mux.Router){
		r.Methods("GET").Subrouter().HandleFunc("/{Meta.Tenant}/{Meta.Name}/", httputils.MakeHTTPHandler(s.get{{.GetName}}Handler))
		r.Methods("GET").Subrouter().HandleFunc("/", httputils.MakeHTTPHandler(s.list{{.GetName}}Handler))
	}

	// list{{.GetName}}Handler is the List Handler for {{.GetName}}
	func (s *RestServer) list{{.GetName}}Handler(r *http.Request) (interface{}, error){
		iter, err := goproto.New{{.GetName}}Iterator()
		if err != nil {
			return nil, fmt.Errorf("failed to get metrics, error: %s", err)
		}

		// for OSX tests
		if iter == nil {
			return nil, nil
		}

		var mtr []goproto.{{.GetName}}

		for iter.HasNext() {
			temp := iter.Next()
			if temp == nil {
				continue
			}

			objMeta := s.GetObjectMeta("{{.GetName}}Key", temp.GetKey())
			if objMeta == nil {
				log.Errorf("failed to get objMeta for {{.GetName}} key %+v", temp.GetKey())
				continue
			}

			temp.ObjectMeta = *objMeta
			mtr = append(mtr, *temp)
		}
		iter.Free()
		return mtr, nil
	}

	// get{{.GetName}}Points returns tags and fields to save in Venice TSDB
	func (s *RestServer) get{{.GetName}}Points() ([]*tsdb.Point, error){
	 {{if (hasExtension "venice.metricInfo" .) }}
        {{$param := (getMsgMetricOptionsHdlr .)}}
        {{$scope := $param.Scope}}
        {{if (or (strEq $scope "UnknownScope") (strEq $scope "PerRingPerSubRing") (strEq $scope "PerLIFPerQ") (strEq $scope "PerPciePort"  ) ) }}
     return nil, nil
        {{else}}
		iter, err := goproto.New{{.GetName}}Iterator()
		if err != nil {
			return nil, fmt.Errorf("failed to get metrics, error: %s", err)
		}

		// for OSX tests
		if iter == nil {
			return nil, nil
		}

		points := []*tsdb.Point{}

		for iter.HasNext() {
			m := iter.Next()
			if m == nil {
			     continue
			}

                    {{if strEq $scope "PerFTE"}}
                    // Venice has no concept of FTE. Aggregate all per-fte stats to per-asic
                    // since Iris pipeline has only one FTE, ignoring other FTE has same effect
                    if m.GetKey() != 0 {
                        continue
                    }
                    {{end}}


			// translate key to meta
			objMeta := s.GetObjectMeta("{{.GetName}}Key", m.GetKey())
			if objMeta == nil {
				log.Errorf("failed to get objMeta for {{.GetName}} key %+v", m.GetKey())
				continue
			}
			tags := s.getTagsFromMeta(objMeta)
			fields := structs.Map(m)
			{{if (strEq .GetName "LifMetrics")}}
			newFields := map[string][]string{
			   "RxTotalBytes": []string{"RxUnicastBytes", "RxMulticastBytes", "RxBroadcastBytes"},
			   "TxTotalBytes": []string{"TxUnicastBytes", "TxMulticastBytes", "TxBroadcastBytes"},
			}
			for nf, agg := range newFields {
			     var s metrics.Counter
			     for _, e := range agg {
			        if v, ok := fields[e].(metrics.Counter); ok {
			           s = s + v
			        } else {
			            log.Errorf("invalid type for %v, %T", e, fields[e])
			        }

			     }
			     fields[nf] = s
			}
			{{end}}

			if len(fields) > 0 {
			    delete(fields, "ObjectMeta")
			    points = append(points, &tsdb.Point{Tags:tags, Fields: fields})
			}
		}

		iter.Free()
		return points, nil

        {{end}}
     {{else}}
         return nil, nil
     {{end}}
	}

	// get{{.GetName}}Handler is the Get Handler for {{.GetName}}
	func (s *RestServer) get{{.GetName}}Handler(r *http.Request) (interface{}, error){
		log.Infof("Got GET request {{.GetName}}/%s", mux.Vars(r)["Meta.Name"])
		return nil, nil
	}
    {{end}}
{{end}}
