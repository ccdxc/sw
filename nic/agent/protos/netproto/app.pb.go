// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app.proto

/*
	Package netproto is a generated protocol buffer package.

	It is generated from these files:
		app.proto
		agg_watch.proto
		endpoint.proto
		interface.proto
		ipam.proto
		match.proto
		namespace.proto
		network.proto
		port.proto
		sgpolicy.proto
		secprofile.proto
		tenant.proto
		tunnel.proto
		vrf.proto

	It has these top-level messages:
		App
		AppSpec
		ALG
		DNS
		SIP
		RPC
		FTP
		TFTP
		RTSP
		ICMP
		AppStatus
		AppList
		AppEvent
		AppEventList
		AggKinds
		AggObject
		AggObjectList
		AggObjectEvent
		AggObjectEventList
		Endpoint
		EndpointSpec
		EndpointStatus
		EndpointList
		EndpointEvent
		EndpointEventList
		EndpointMigrationStatus
		Interface
		PauseSpec
		InterfaceSpec
		InterfaceHostStatus
		InterfaceUplinkStatus
		TransceiverStatus
		InterfaceStatus
		InterfaceList
		InterfaceEvent
		InterfaceEventList
		DHCPServer
		DHCPRelayPolicy
		IPAMPolicySpec
		IPAMPolicyStatus
		IPAMPolicyEvent
		IPAMPolicyEventList
		IPAMPolicyList
		IPAMPolicy
		MatchSelector
		ProtoPort
		Namespace
		NamespaceSpec
		NamespaceStatus
		NamespaceList
		NamespaceEvent
		NamespaceEventList
		ApiResponse
		Network
		NetworkSpec
		NetworkStatus
		NetworkList
		NetworkEvent
		NetworkEventList
		Port
		PortSpec
		PortStatus
		PortList
		PortEvent
		NetworkSecurityPolicy
		NetworkSecurityPolicySpec
		PolicyRule
		NetworkSecurityPolicyStatus
		NetworkSecurityPolicyList
		NetworkSecurityPolicyEvent
		NetworkSecurityPolicyEventList
		SecurityProfile
		SecurityProfileSpec
		Timeouts
		SecurityProfileStatus
		SecurityProfileList
		SecurityProfileEvent
		SecurityProfileEventList
		TenantStatus
		TenantSpec
		Tenant
		TenantList
		TenantEvent
		TenantEventList
		Tunnel
		TunnelSpec
		TunnelStatus
		TunnelList
		TunnelEvent
		TunnelEventList
		Vrf
		VrfSpec
		VrfStatus
		VrfList
		VrfEvent
		VrfEventList
*/
package netproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// app object
type App struct {
	api.TypeMeta   `protobuf:"bytes,1,opt,name=TypeMeta,embedded=TypeMeta" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=ObjectMeta,embedded=ObjectMeta" json:"meta,omitempty"`
	Spec           AppSpec   `protobuf:"bytes,3,opt,name=Spec" json:"spec,omitempty"`
	Status         AppStatus `protobuf:"bytes,4,opt,name=Status" json:"status,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{0} }

func (m *App) GetSpec() AppSpec {
	if m != nil {
		return m.Spec
	}
	return AppSpec{}
}

func (m *App) GetStatus() AppStatus {
	if m != nil {
		return m.Status
	}
	return AppStatus{}
}

// app spec
type AppSpec struct {
	ProtoPorts []*ProtoPort `protobuf:"bytes,1,rep,name=ProtoPorts" json:"proto-ports,omitempty"`
	// ALG specific configuration
	ALG *ALG `protobuf:"bytes,2,opt,name=ALG" json:"alg,omitempty"`
	// AppIdleTimeout is the app specific idle timeout. Specfied in parseable time, Eg: 10s, 1m30s or 1h45m15s and so on
	AppIdleTimeout string `protobuf:"bytes,3,opt,name=AppIdleTimeout,proto3" json:"app-idle-timeout,omitempty"`
}

func (m *AppSpec) Reset()                    { *m = AppSpec{} }
func (m *AppSpec) String() string            { return proto.CompactTextString(m) }
func (*AppSpec) ProtoMessage()               {}
func (*AppSpec) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{1} }

func (m *AppSpec) GetProtoPorts() []*ProtoPort {
	if m != nil {
		return m.ProtoPorts
	}
	return nil
}

func (m *AppSpec) GetALG() *ALG {
	if m != nil {
		return m.ALG
	}
	return nil
}

func (m *AppSpec) GetAppIdleTimeout() string {
	if m != nil {
		return m.AppIdleTimeout
	}
	return ""
}

type ALG struct {
	DNS    *DNS   `protobuf:"bytes,1,opt,name=DNS" json:"dns,omitempty"`
	SIP    *SIP   `protobuf:"bytes,2,opt,name=SIP" json:"sip,omitempty"`
	SUNRPC []*RPC `protobuf:"bytes,3,rep,name=SUNRPC" json:"sunrpc,omitempty"`
	FTP    *FTP   `protobuf:"bytes,4,opt,name=FTP" json:"ftp,omitempty"`
	MSRPC  []*RPC `protobuf:"bytes,5,rep,name=MSRPC" json:"msrpc,omitempty"`
	TFTP   *TFTP  `protobuf:"bytes,6,opt,name=TFTP" json:"tftp,omitempty"`
	RTSP   *RTSP  `protobuf:"bytes,7,opt,name=RTSP" json:"rtsp,omitempty"`
	ICMP   *ICMP  `protobuf:"bytes,8,opt,name=ICMP" json:"icmp,omitempty"`
}

func (m *ALG) Reset()                    { *m = ALG{} }
func (m *ALG) String() string            { return proto.CompactTextString(m) }
func (*ALG) ProtoMessage()               {}
func (*ALG) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{2} }

func (m *ALG) GetDNS() *DNS {
	if m != nil {
		return m.DNS
	}
	return nil
}

func (m *ALG) GetSIP() *SIP {
	if m != nil {
		return m.SIP
	}
	return nil
}

func (m *ALG) GetSUNRPC() []*RPC {
	if m != nil {
		return m.SUNRPC
	}
	return nil
}

func (m *ALG) GetFTP() *FTP {
	if m != nil {
		return m.FTP
	}
	return nil
}

func (m *ALG) GetMSRPC() []*RPC {
	if m != nil {
		return m.MSRPC
	}
	return nil
}

func (m *ALG) GetTFTP() *TFTP {
	if m != nil {
		return m.TFTP
	}
	return nil
}

func (m *ALG) GetRTSP() *RTSP {
	if m != nil {
		return m.RTSP
	}
	return nil
}

func (m *ALG) GetICMP() *ICMP {
	if m != nil {
		return m.ICMP
	}
	return nil
}

// DNS ALG configuration
type DNS struct {
	// Drop DNS Packets for multiple questions
	DropMultiQuestionPackets bool `protobuf:"varint,1,opt,name=DropMultiQuestionPackets,proto3" json:"drop-multi-question-packets,omitempty"`
	// Drop packets whose domain name > 255
	DropLargeDomainPackets bool `protobuf:"varint,2,opt,name=DropLargeDomainPackets,proto3" json:"drop-large-domain-packets,omitempty"`
	// Drop packets whose labels length > 63
	DropLongLabelPackets bool `protobuf:"varint,3,opt,name=DropLongLabelPackets,proto3" json:"drop-long-label-packets,omitempty"`
	// Drop packets for num zones > 1
	DropMultiZonePackets bool `protobuf:"varint,4,opt,name=DropMultiZonePackets,proto3" json:"drop-multi-zone-packets,omitempty"`
	// Maximum allowed message length
	MaxMessageLength uint32 `protobuf:"varint,5,opt,name=MaxMessageLength,proto3" json:"max-msg-length,omitempty"`
	// Timeout for query response in seconds, minutes, eg 1m, 45s
	QueryResponseTimeout string `protobuf:"bytes,6,opt,name=QueryResponseTimeout,proto3" json:"query-response-timeout,omitempty"`
}

func (m *DNS) Reset()                    { *m = DNS{} }
func (m *DNS) String() string            { return proto.CompactTextString(m) }
func (*DNS) ProtoMessage()               {}
func (*DNS) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{3} }

func (m *DNS) GetDropMultiQuestionPackets() bool {
	if m != nil {
		return m.DropMultiQuestionPackets
	}
	return false
}

func (m *DNS) GetDropLargeDomainPackets() bool {
	if m != nil {
		return m.DropLargeDomainPackets
	}
	return false
}

func (m *DNS) GetDropLongLabelPackets() bool {
	if m != nil {
		return m.DropLongLabelPackets
	}
	return false
}

func (m *DNS) GetDropMultiZonePackets() bool {
	if m != nil {
		return m.DropMultiZonePackets
	}
	return false
}

func (m *DNS) GetMaxMessageLength() uint32 {
	if m != nil {
		return m.MaxMessageLength
	}
	return 0
}

func (m *DNS) GetQueryResponseTimeout() string {
	if m != nil {
		return m.QueryResponseTimeout
	}
	return ""
}

// SIP ALG configuration
type SIP struct {
	// Maximum timeout for a call to remain active without any media
	MediaInactivityTimeout string `protobuf:"bytes,1,opt,name=MediaInactivityTimeout,proto3" json:"media-inactivity-timeout,omitempty"`
	// Maximum length of call in hours, minutes, seconds, eg 1h, 15m, 45s
	MaxCallDuration string `protobuf:"bytes,2,opt,name=MaxCallDuration,proto3" json:"max-call-duration,omitempty"`
	// Timeout for INVITE transaction in minutes, seconds, eg 1m, 45s
	CTimeout string `protobuf:"bytes,3,opt,name=CTimeout,proto3" json:"c-timeout,omitempty"`
	// Timeout for T1 Interval in minutes, seconds, eg 1m, 45s
	T1Timeout string `protobuf:"bytes,4,opt,name=T1Timeout,proto3" json:"t1-timeout,omitempty"`
	// Timeout for T4 interval in minutes, seconds, eg 1m, 45s
	T4Timeout string `protobuf:"bytes,5,opt,name=T4Timeout,proto3" json:"t4-timeout,omitempty"`
	// DSCP traffic classification. 0 - 63
	DSCPCodePoint uint32 `protobuf:"varint,6,opt,name=DSCPCodePoint,proto3" json:"dscp-code-point,omitempty"`
}

func (m *SIP) Reset()                    { *m = SIP{} }
func (m *SIP) String() string            { return proto.CompactTextString(m) }
func (*SIP) ProtoMessage()               {}
func (*SIP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{4} }

func (m *SIP) GetMediaInactivityTimeout() string {
	if m != nil {
		return m.MediaInactivityTimeout
	}
	return ""
}

func (m *SIP) GetMaxCallDuration() string {
	if m != nil {
		return m.MaxCallDuration
	}
	return ""
}

func (m *SIP) GetCTimeout() string {
	if m != nil {
		return m.CTimeout
	}
	return ""
}

func (m *SIP) GetT1Timeout() string {
	if m != nil {
		return m.T1Timeout
	}
	return ""
}

func (m *SIP) GetT4Timeout() string {
	if m != nil {
		return m.T4Timeout
	}
	return ""
}

func (m *SIP) GetDSCPCodePoint() uint32 {
	if m != nil {
		return m.DSCPCodePoint
	}
	return 0
}

// RPC ALG configuration for MSRPC and SunRPC
type RPC struct {
	// RPC Program identifier
	ProgramID string `protobuf:"bytes,1,opt,name=ProgramID,proto3" json:"program-id,omitempty"`
	// Timeout is the timeout for the specific program-id
	ProgramIDTimeout string `protobuf:"bytes,2,opt,name=ProgramIDTimeout,proto3" json:"program-id-timeout,omitempty"`
}

func (m *RPC) Reset()                    { *m = RPC{} }
func (m *RPC) String() string            { return proto.CompactTextString(m) }
func (*RPC) ProtoMessage()               {}
func (*RPC) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{5} }

func (m *RPC) GetProgramID() string {
	if m != nil {
		return m.ProgramID
	}
	return ""
}

func (m *RPC) GetProgramIDTimeout() string {
	if m != nil {
		return m.ProgramIDTimeout
	}
	return ""
}

// FTP ALG configuration
type FTP struct {
	// Allow FTP packets with mismatched IP header address and payload
	AllowMismatchIPAddresses bool `protobuf:"varint,1,opt,name=AllowMismatchIPAddresses,proto3" json:"allow-mismatch-ip-addresses,omitempty"`
}

func (m *FTP) Reset()                    { *m = FTP{} }
func (m *FTP) String() string            { return proto.CompactTextString(m) }
func (*FTP) ProtoMessage()               {}
func (*FTP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{6} }

func (m *FTP) GetAllowMismatchIPAddresses() bool {
	if m != nil {
		return m.AllowMismatchIPAddresses
	}
	return false
}

// TFTP ALG configuration
type TFTP struct {
}

func (m *TFTP) Reset()                    { *m = TFTP{} }
func (m *TFTP) String() string            { return proto.CompactTextString(m) }
func (*TFTP) ProtoMessage()               {}
func (*TFTP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{7} }

// RTSP ALG configuration
type RTSP struct {
}

func (m *RTSP) Reset()                    { *m = RTSP{} }
func (m *RTSP) String() string            { return proto.CompactTextString(m) }
func (*RTSP) ProtoMessage()               {}
func (*RTSP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{8} }

// ICMP ALG configuration
type ICMP struct {
	// ICMP Type
	Type uint32 `protobuf:"varint,1,opt,name=Type,proto3" json:"type,omitempty"`
	// ICMP Code is sub-command for a given ICMP Type
	Code uint32 `protobuf:"varint,2,opt,name=Code,proto3" json:"code,omitempty"`
}

func (m *ICMP) Reset()                    { *m = ICMP{} }
func (m *ICMP) String() string            { return proto.CompactTextString(m) }
func (*ICMP) ProtoMessage()               {}
func (*ICMP) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{9} }

func (m *ICMP) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ICMP) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// app status
type AppStatus struct {
	AppID uint64 `protobuf:"varint,3,opt,name=AppID,proto3" json:"app-id,omitempty"`
}

func (m *AppStatus) Reset()                    { *m = AppStatus{} }
func (m *AppStatus) String() string            { return proto.CompactTextString(m) }
func (*AppStatus) ProtoMessage()               {}
func (*AppStatus) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{10} }

func (m *AppStatus) GetAppID() uint64 {
	if m != nil {
		return m.AppID
	}
	return 0
}

// list of apps
type AppList struct {
	Apps []*App `protobuf:"bytes,1,rep,name=apps" json:"apps,omitempty"`
}

func (m *AppList) Reset()                    { *m = AppList{} }
func (m *AppList) String() string            { return proto.CompactTextString(m) }
func (*AppList) ProtoMessage()               {}
func (*AppList) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{11} }

func (m *AppList) GetApps() []*App {
	if m != nil {
		return m.Apps
	}
	return nil
}

// app watch event
type AppEvent struct {
	EventType api.EventType `protobuf:"varint,1,opt,name=EventType,proto3,enum=api.EventType" json:"event-type,omitempty"`
	App       App           `protobuf:"bytes,2,opt,name=App" json:"app,omitempty"`
}

func (m *AppEvent) Reset()                    { *m = AppEvent{} }
func (m *AppEvent) String() string            { return proto.CompactTextString(m) }
func (*AppEvent) ProtoMessage()               {}
func (*AppEvent) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{12} }

func (m *AppEvent) GetEventType() api.EventType {
	if m != nil {
		return m.EventType
	}
	return api.EventType_CreateEvent
}

func (m *AppEvent) GetApp() App {
	if m != nil {
		return m.App
	}
	return App{}
}

// app watch events batched
type AppEventList struct {
	AppEvents []*AppEvent `protobuf:"bytes,1,rep,name=AppEvents" json:"AppEvents,omitempty"`
}

func (m *AppEventList) Reset()                    { *m = AppEventList{} }
func (m *AppEventList) String() string            { return proto.CompactTextString(m) }
func (*AppEventList) ProtoMessage()               {}
func (*AppEventList) Descriptor() ([]byte, []int) { return fileDescriptorApp, []int{13} }

func (m *AppEventList) GetAppEvents() []*AppEvent {
	if m != nil {
		return m.AppEvents
	}
	return nil
}

func init() {
	proto.RegisterType((*App)(nil), "netproto.App")
	proto.RegisterType((*AppSpec)(nil), "netproto.AppSpec")
	proto.RegisterType((*ALG)(nil), "netproto.ALG")
	proto.RegisterType((*DNS)(nil), "netproto.DNS")
	proto.RegisterType((*SIP)(nil), "netproto.SIP")
	proto.RegisterType((*RPC)(nil), "netproto.RPC")
	proto.RegisterType((*FTP)(nil), "netproto.FTP")
	proto.RegisterType((*TFTP)(nil), "netproto.TFTP")
	proto.RegisterType((*RTSP)(nil), "netproto.RTSP")
	proto.RegisterType((*ICMP)(nil), "netproto.ICMP")
	proto.RegisterType((*AppStatus)(nil), "netproto.AppStatus")
	proto.RegisterType((*AppList)(nil), "netproto.AppList")
	proto.RegisterType((*AppEvent)(nil), "netproto.AppEvent")
	proto.RegisterType((*AppEventList)(nil), "netproto.AppEventList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AppApiV1 service

type AppApiV1Client interface {
	ListApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*AppList, error)
	WatchApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (AppApiV1_WatchAppsClient, error)
	AppOperUpdate(ctx context.Context, opts ...grpc.CallOption) (AppApiV1_AppOperUpdateClient, error)
}

type appApiV1Client struct {
	cc *grpc.ClientConn
}

func NewAppApiV1Client(cc *grpc.ClientConn) AppApiV1Client {
	return &appApiV1Client{cc}
}

func (c *appApiV1Client) ListApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (*AppList, error) {
	out := new(AppList)
	err := grpc.Invoke(ctx, "/netproto.AppApiV1/ListApps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appApiV1Client) WatchApps(ctx context.Context, in *api.ObjectMeta, opts ...grpc.CallOption) (AppApiV1_WatchAppsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppApiV1_serviceDesc.Streams[0], c.cc, "/netproto.AppApiV1/WatchApps", opts...)
	if err != nil {
		return nil, err
	}
	x := &appApiV1WatchAppsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AppApiV1_WatchAppsClient interface {
	Recv() (*AppEventList, error)
	grpc.ClientStream
}

type appApiV1WatchAppsClient struct {
	grpc.ClientStream
}

func (x *appApiV1WatchAppsClient) Recv() (*AppEventList, error) {
	m := new(AppEventList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *appApiV1Client) AppOperUpdate(ctx context.Context, opts ...grpc.CallOption) (AppApiV1_AppOperUpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AppApiV1_serviceDesc.Streams[1], c.cc, "/netproto.AppApiV1/AppOperUpdate", opts...)
	if err != nil {
		return nil, err
	}
	x := &appApiV1AppOperUpdateClient{stream}
	return x, nil
}

type AppApiV1_AppOperUpdateClient interface {
	Send(*AppEvent) error
	CloseAndRecv() (*api.TypeMeta, error)
	grpc.ClientStream
}

type appApiV1AppOperUpdateClient struct {
	grpc.ClientStream
}

func (x *appApiV1AppOperUpdateClient) Send(m *AppEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *appApiV1AppOperUpdateClient) CloseAndRecv() (*api.TypeMeta, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(api.TypeMeta)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AppApiV1 service

type AppApiV1Server interface {
	ListApps(context.Context, *api.ObjectMeta) (*AppList, error)
	WatchApps(*api.ObjectMeta, AppApiV1_WatchAppsServer) error
	AppOperUpdate(AppApiV1_AppOperUpdateServer) error
}

func RegisterAppApiV1Server(s *grpc.Server, srv AppApiV1Server) {
	s.RegisterService(&_AppApiV1_serviceDesc, srv)
}

func _AppApiV1_ListApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ObjectMeta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppApiV1Server).ListApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/netproto.AppApiV1/ListApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppApiV1Server).ListApps(ctx, req.(*api.ObjectMeta))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppApiV1_WatchApps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ObjectMeta)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AppApiV1Server).WatchApps(m, &appApiV1WatchAppsServer{stream})
}

type AppApiV1_WatchAppsServer interface {
	Send(*AppEventList) error
	grpc.ServerStream
}

type appApiV1WatchAppsServer struct {
	grpc.ServerStream
}

func (x *appApiV1WatchAppsServer) Send(m *AppEventList) error {
	return x.ServerStream.SendMsg(m)
}

func _AppApiV1_AppOperUpdate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AppApiV1Server).AppOperUpdate(&appApiV1AppOperUpdateServer{stream})
}

type AppApiV1_AppOperUpdateServer interface {
	SendAndClose(*api.TypeMeta) error
	Recv() (*AppEvent, error)
	grpc.ServerStream
}

type appApiV1AppOperUpdateServer struct {
	grpc.ServerStream
}

func (x *appApiV1AppOperUpdateServer) SendAndClose(m *api.TypeMeta) error {
	return x.ServerStream.SendMsg(m)
}

func (x *appApiV1AppOperUpdateServer) Recv() (*AppEvent, error) {
	m := new(AppEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AppApiV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "netproto.AppApiV1",
	HandlerType: (*AppApiV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListApps",
			Handler:    _AppApiV1_ListApps_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchApps",
			Handler:       _AppApiV1_WatchApps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AppOperUpdate",
			Handler:       _AppApiV1_AppOperUpdate_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "app.proto",
}

func (m *App) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *App) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AppSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProtoPorts) > 0 {
		for _, msg := range m.ProtoPorts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ALG != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.ALG.Size()))
		n5, err := m.ALG.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.AppIdleTimeout) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.AppIdleTimeout)))
		i += copy(dAtA[i:], m.AppIdleTimeout)
	}
	return i, nil
}

func (m *ALG) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ALG) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DNS != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.DNS.Size()))
		n6, err := m.DNS.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.SIP != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.SIP.Size()))
		n7, err := m.SIP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.SUNRPC) > 0 {
		for _, msg := range m.SUNRPC {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FTP != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.FTP.Size()))
		n8, err := m.FTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.MSRPC) > 0 {
		for _, msg := range m.MSRPC {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TFTP != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.TFTP.Size()))
		n9, err := m.TFTP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.RTSP != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.RTSP.Size()))
		n10, err := m.RTSP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ICMP != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.ICMP.Size()))
		n11, err := m.ICMP.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *DNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNS) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		dAtA[i] = 0x8
		i++
		if m.DropMultiQuestionPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLargeDomainPackets {
		dAtA[i] = 0x10
		i++
		if m.DropLargeDomainPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropLongLabelPackets {
		dAtA[i] = 0x18
		i++
		if m.DropLongLabelPackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DropMultiZonePackets {
		dAtA[i] = 0x20
		i++
		if m.DropMultiZonePackets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxMessageLength != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.MaxMessageLength))
	}
	if len(m.QueryResponseTimeout) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.QueryResponseTimeout)))
		i += copy(dAtA[i:], m.QueryResponseTimeout)
	}
	return i, nil
}

func (m *SIP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SIP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MediaInactivityTimeout) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.MediaInactivityTimeout)))
		i += copy(dAtA[i:], m.MediaInactivityTimeout)
	}
	if len(m.MaxCallDuration) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.MaxCallDuration)))
		i += copy(dAtA[i:], m.MaxCallDuration)
	}
	if len(m.CTimeout) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.CTimeout)))
		i += copy(dAtA[i:], m.CTimeout)
	}
	if len(m.T1Timeout) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.T1Timeout)))
		i += copy(dAtA[i:], m.T1Timeout)
	}
	if len(m.T4Timeout) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.T4Timeout)))
		i += copy(dAtA[i:], m.T4Timeout)
	}
	if m.DSCPCodePoint != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.DSCPCodePoint))
	}
	return i, nil
}

func (m *RPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProgramID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.ProgramID)))
		i += copy(dAtA[i:], m.ProgramID)
	}
	if len(m.ProgramIDTimeout) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApp(dAtA, i, uint64(len(m.ProgramIDTimeout)))
		i += copy(dAtA[i:], m.ProgramIDTimeout)
	}
	return i, nil
}

func (m *FTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AllowMismatchIPAddresses {
		dAtA[i] = 0x8
		i++
		if m.AllowMismatchIPAddresses {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *TFTP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TFTP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RTSP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RTSP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ICMP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *AppStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AppID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.AppID))
	}
	return i, nil
}

func (m *AppList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, msg := range m.Apps {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EventType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApp(dAtA, i, uint64(m.EventType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintApp(dAtA, i, uint64(m.App.Size()))
	n12, err := m.App.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	return i, nil
}

func (m *AppEventList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppEventList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppEvents) > 0 {
		for _, msg := range m.AppEvents {
			dAtA[i] = 0xa
			i++
			i = encodeVarintApp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintApp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *App) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovApp(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovApp(uint64(l))
	return n
}

func (m *AppSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.ProtoPorts) > 0 {
		for _, e := range m.ProtoPorts {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	if m.ALG != nil {
		l = m.ALG.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.AppIdleTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *ALG) Size() (n int) {
	var l int
	_ = l
	if m.DNS != nil {
		l = m.DNS.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.SIP != nil {
		l = m.SIP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if len(m.SUNRPC) > 0 {
		for _, e := range m.SUNRPC {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	if m.FTP != nil {
		l = m.FTP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if len(m.MSRPC) > 0 {
		for _, e := range m.MSRPC {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	if m.TFTP != nil {
		l = m.TFTP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.RTSP != nil {
		l = m.RTSP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	if m.ICMP != nil {
		l = m.ICMP.Size()
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *DNS) Size() (n int) {
	var l int
	_ = l
	if m.DropMultiQuestionPackets {
		n += 2
	}
	if m.DropLargeDomainPackets {
		n += 2
	}
	if m.DropLongLabelPackets {
		n += 2
	}
	if m.DropMultiZonePackets {
		n += 2
	}
	if m.MaxMessageLength != 0 {
		n += 1 + sovApp(uint64(m.MaxMessageLength))
	}
	l = len(m.QueryResponseTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *SIP) Size() (n int) {
	var l int
	_ = l
	l = len(m.MediaInactivityTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.MaxCallDuration)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.CTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.T1Timeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.T4Timeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	if m.DSCPCodePoint != 0 {
		n += 1 + sovApp(uint64(m.DSCPCodePoint))
	}
	return n
}

func (m *RPC) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProgramID)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	l = len(m.ProgramIDTimeout)
	if l > 0 {
		n += 1 + l + sovApp(uint64(l))
	}
	return n
}

func (m *FTP) Size() (n int) {
	var l int
	_ = l
	if m.AllowMismatchIPAddresses {
		n += 2
	}
	return n
}

func (m *TFTP) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RTSP) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ICMP) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovApp(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovApp(uint64(m.Code))
	}
	return n
}

func (m *AppStatus) Size() (n int) {
	var l int
	_ = l
	if m.AppID != 0 {
		n += 1 + sovApp(uint64(m.AppID))
	}
	return n
}

func (m *AppList) Size() (n int) {
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	return n
}

func (m *AppEvent) Size() (n int) {
	var l int
	_ = l
	if m.EventType != 0 {
		n += 1 + sovApp(uint64(m.EventType))
	}
	l = m.App.Size()
	n += 1 + l + sovApp(uint64(l))
	return n
}

func (m *AppEventList) Size() (n int) {
	var l int
	_ = l
	if len(m.AppEvents) > 0 {
		for _, e := range m.AppEvents {
			l = e.Size()
			n += 1 + l + sovApp(uint64(l))
		}
	}
	return n
}

func sovApp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApp(x uint64) (n int) {
	return sovApp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *App) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtoPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtoPorts = append(m.ProtoPorts, &ProtoPort{})
			if err := m.ProtoPorts[len(m.ProtoPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ALG", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ALG == nil {
				m.ALG = &ALG{}
			}
			if err := m.ALG.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppIdleTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppIdleTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ALG) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ALG: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ALG: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNS == nil {
				m.DNS = &DNS{}
			}
			if err := m.DNS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SIP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SIP == nil {
				m.SIP = &SIP{}
			}
			if err := m.SIP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SUNRPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SUNRPC = append(m.SUNRPC, &RPC{})
			if err := m.SUNRPC[len(m.SUNRPC)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FTP == nil {
				m.FTP = &FTP{}
			}
			if err := m.FTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MSRPC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MSRPC = append(m.MSRPC, &RPC{})
			if err := m.MSRPC[len(m.MSRPC)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TFTP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TFTP == nil {
				m.TFTP = &TFTP{}
			}
			if err := m.TFTP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RTSP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RTSP == nil {
				m.RTSP = &RTSP{}
			}
			if err := m.RTSP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ICMP", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ICMP == nil {
				m.ICMP = &ICMP{}
			}
			if err := m.ICMP.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiQuestionPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiQuestionPackets = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLargeDomainPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLargeDomainPackets = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropLongLabelPackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropLongLabelPackets = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropMultiZonePackets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DropMultiZonePackets = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMessageLength", wireType)
			}
			m.MaxMessageLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMessageLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryResponseTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryResponseTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SIP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SIP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SIP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaInactivityTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaInactivityTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCallDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxCallDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T1Timeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.T1Timeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field T4Timeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.T4Timeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DSCPCodePoint", wireType)
			}
			m.DSCPCodePoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DSCPCodePoint |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramIDTimeout", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramIDTimeout = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMismatchIPAddresses", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowMismatchIPAddresses = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TFTP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TFTP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TFTP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RTSP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RTSP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RTSP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ICMP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			m.AppID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, &App{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventType |= (api.EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.App.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppEventList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppEventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppEventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppEvents = append(m.AppEvents, &AppEvent{})
			if err := m.AppEvents[len(m.AppEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("app.proto", fileDescriptorApp) }

var fileDescriptorApp = []byte{
	// 1352 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x57, 0xcd, 0x92, 0xd3, 0xc6,
	0x13, 0x5f, 0xad, 0xbd, 0xc6, 0x1e, 0xf0, 0xc2, 0x7f, 0x58, 0xf6, 0x6f, 0x0c, 0x81, 0x45, 0x84,
	0xd4, 0x86, 0x20, 0x1b, 0x08, 0x05, 0x29, 0x2a, 0x24, 0xb1, 0x6c, 0x96, 0x72, 0x62, 0x2f, 0xc2,
	0x36, 0xa4, 0x2a, 0x95, 0x1c, 0x66, 0xa5, 0x41, 0x28, 0xe8, 0xa3, 0x91, 0xc6, 0xc0, 0x26, 0xc5,
	0x29, 0xb7, 0x5c, 0x73, 0x49, 0x55, 0xde, 0x82, 0x17, 0xc8, 0x95, 0x23, 0x4f, 0x40, 0x11, 0x8e,
	0x79, 0x8a, 0xd4, 0xb4, 0x3e, 0x2c, 0x79, 0xb5, 0x27, 0x3c, 0xd3, 0xbf, 0x8f, 0xee, 0x19, 0xd1,
	0xd3, 0x4b, 0x1a, 0x0c, 0xa0, 0x03, 0x61, 0x20, 0x02, 0x5a, 0xf7, 0xb9, 0xc0, 0x5f, 0xed, 0xb3,
	0x76, 0x10, 0xd8, 0x2e, 0xef, 0x32, 0x70, 0xba, 0xcc, 0xf7, 0x03, 0xc1, 0x84, 0x13, 0xf8, 0x51,
	0x8c, 0x6b, 0xdf, 0xb5, 0x1d, 0xf1, 0x64, 0xbe, 0xd7, 0x31, 0x03, 0xaf, 0x0b, 0xdc, 0x8f, 0x98,
	0x6f, 0x05, 0xdd, 0xe8, 0x45, 0xf7, 0x39, 0xf7, 0x1d, 0x93, 0x77, 0xe7, 0xc2, 0x71, 0x23, 0x49,
	0xb5, 0xb9, 0x9f, 0x67, 0x77, 0x1d, 0xdf, 0x74, 0xe7, 0x16, 0x4f, 0x65, 0xb4, 0x9c, 0x8c, 0x1d,
	0xd8, 0x41, 0x17, 0xb7, 0xf7, 0xe6, 0x8f, 0x71, 0x85, 0x0b, 0xfc, 0x95, 0xc0, 0x2f, 0x1d, 0xe2,
	0x2a, 0x73, 0xf4, 0xb8, 0x60, 0x09, 0xec, 0xa8, 0xc7, 0x84, 0xf9, 0x24, 0x5e, 0xa8, 0x7f, 0xae,
	0x92, 0x4a, 0x0f, 0x80, 0x7e, 0x45, 0xea, 0xb3, 0x7d, 0xe0, 0x63, 0x2e, 0x58, 0x4b, 0xd9, 0x52,
	0xb6, 0x8f, 0x5e, 0x6f, 0x76, 0x18, 0x38, 0x9d, 0x74, 0x53, 0x3f, 0xf9, 0xe6, 0xdd, 0xf9, 0x95,
	0xb7, 0xef, 0xce, 0x2b, 0xff, 0xbe, 0x3b, 0x7f, 0xe4, 0x8a, 0xe3, 0xbb, 0x8e, 0xcf, 0x27, 0x19,
	0x87, 0x7e, 0x47, 0xc8, 0xfd, 0xbd, 0x9f, 0xb9, 0x29, 0x50, 0x61, 0x15, 0x15, 0x8e, 0xa3, 0xc2,
	0x62, 0x5b, 0x6f, 0xe7, 0x34, 0xd6, 0x65, 0x46, 0x57, 0x02, 0xcf, 0x11, 0xdc, 0x03, 0xb1, 0x3f,
	0xc9, 0xd1, 0xe9, 0x1d, 0x52, 0x9d, 0x02, 0x37, 0x5b, 0x15, 0x94, 0xf9, 0x5f, 0x27, 0x3d, 0xf5,
	0x4e, 0x0f, 0x40, 0x06, 0xf4, 0x4d, 0x29, 0x24, 0x45, 0x22, 0xe0, 0x66, 0x4e, 0x04, 0x69, 0xf4,
	0x2e, 0xa9, 0x4d, 0x05, 0x13, 0xf3, 0xa8, 0x55, 0x45, 0x81, 0x93, 0x45, 0x01, 0x0c, 0xe9, 0xad,
	0x44, 0xe2, 0x44, 0x84, 0xeb, 0x9c, 0x48, 0x42, 0x56, 0xff, 0x51, 0xc8, 0x91, 0xc4, 0x90, 0x4e,
	0x08, 0x31, 0xa4, 0x80, 0x11, 0x84, 0x22, 0x6a, 0x29, 0x5b, 0x95, 0xa2, 0x6c, 0x16, 0xd3, 0x3f,
	0x7a, 0x13, 0x97, 0x77, 0x0a, 0x03, 0x1a, 0x48, 0x7c, 0xbe, 0xca, 0x85, 0x0a, 0xbd, 0x49, 0x2a,
	0xbd, 0xd1, 0xbd, 0xe4, 0xac, 0x9a, 0xb9, 0x1c, 0x47, 0xf7, 0xf4, 0x53, 0x89, 0x4c, 0x93, 0xb9,
	0x76, 0x8e, 0x2e, 0x09, 0xf4, 0x5b, 0xb2, 0xde, 0x03, 0x18, 0x5a, 0x2e, 0x9f, 0x39, 0x1e, 0x0f,
	0xe6, 0x02, 0xcf, 0xa9, 0xa1, 0xab, 0x09, 0xa7, 0xcd, 0x00, 0x34, 0xc7, 0x72, 0xb9, 0x26, 0xe2,
	0x78, 0x4e, 0x60, 0x89, 0xa9, 0xbe, 0xaf, 0x60, 0x12, 0x32, 0x97, 0xc1, 0xee, 0x34, 0xbb, 0xf9,
	0x2c, 0x97, 0xc1, 0xee, 0x74, 0x91, 0x8b, 0xe5, 0xe7, 0x4b, 0x91, 0x04, 0xc9, 0x9b, 0x0e, 0x8d,
	0x83, 0x35, 0x4c, 0x87, 0xc6, 0x82, 0x17, 0x39, 0x90, 0xe7, 0x4d, 0x87, 0x06, 0xfd, 0x9a, 0xd4,
	0xa6, 0x0f, 0x77, 0x27, 0x46, 0xbf, 0x55, 0xc1, 0xb3, 0xcc, 0x51, 0x27, 0x46, 0x1f, 0x2f, 0x47,
	0xc1, 0xcb, 0x99, 0xfb, 0x21, 0x98, 0x85, 0xcb, 0x41, 0x9a, 0x34, 0xde, 0x99, 0x19, 0xc9, 0x05,
	0xe7, 0xd8, 0x3b, 0xb3, 0x9c, 0xf1, 0x63, 0x51, 0x30, 0xde, 0x99, 0x19, 0xf4, 0x4b, 0xb2, 0x36,
	0x9e, 0x4a, 0xdf, 0xb5, 0x32, 0xdf, 0xff, 0x27, 0xcc, 0xe3, 0x5e, 0x54, 0xb4, 0x8d, 0x49, 0xf4,
	0x36, 0xa9, 0xce, 0xa4, 0x6d, 0x0d, 0x6d, 0xd7, 0x17, 0x64, 0xb9, 0x8b, 0x5f, 0x25, 0x7e, 0xda,
	0xa2, 0x68, 0x8c, 0x1c, 0xc9, 0x9d, 0xcc, 0xa6, 0x46, 0xeb, 0xc8, 0x32, 0x57, 0xee, 0x2e, 0xb8,
	0xa1, 0x88, 0x0a, 0x5c, 0x19, 0x95, 0xdc, 0x61, 0x7f, 0x6c, 0xb4, 0xea, 0xcb, 0x5c, 0xb9, 0xbb,
	0xe0, 0x3a, 0xa6, 0x57, 0xe0, 0xca, 0xa8, 0xfa, 0x77, 0x15, 0xef, 0x96, 0x3a, 0xa4, 0x35, 0x08,
	0x03, 0x18, 0xcf, 0x5d, 0xe1, 0x3c, 0x98, 0xf3, 0x48, 0x76, 0x1c, 0x83, 0x99, 0x4f, 0x39, 0x7e,
	0xd0, 0xca, 0x76, 0x5d, 0xd7, 0x12, 0x9d, 0x4b, 0x56, 0x18, 0x80, 0xe6, 0x49, 0xa0, 0xf6, 0x2c,
	0x41, 0x6a, 0x10, 0x43, 0x73, 0xf2, 0x87, 0xca, 0x51, 0x93, 0x6c, 0xca, 0xd8, 0x88, 0x85, 0x36,
	0x1f, 0x04, 0x1e, 0x73, 0x32, 0xa3, 0x55, 0x34, 0xfa, 0x2c, 0x31, 0xba, 0x88, 0x46, 0xae, 0x84,
	0x69, 0x16, 0xe2, 0x4a, 0x6c, 0x0e, 0x91, 0xa2, 0x3f, 0x91, 0x0d, 0x8c, 0x04, 0xbe, 0x3d, 0x62,
	0x7b, 0xdc, 0x4d, 0x2d, 0x2a, 0x68, 0xf1, 0x69, 0x62, 0x71, 0x21, 0xb6, 0x08, 0x7c, 0x5b, 0x73,
	0x25, 0xaa, 0xc4, 0xa0, 0x54, 0x26, 0x95, 0xc7, 0xfa, 0x7e, 0x08, 0x7c, 0x9e, 0xca, 0x57, 0x4b,
	0xe4, 0xe3, 0xa3, 0xfa, 0x25, 0xf0, 0xf9, 0x61, 0xf2, 0xcb, 0x32, 0x74, 0x44, 0x4e, 0x8c, 0xd9,
	0xcb, 0x31, 0x8f, 0x22, 0x66, 0xf3, 0x11, 0xf7, 0x6d, 0xf1, 0xa4, 0xb5, 0xb6, 0xa5, 0x6c, 0x37,
	0xf5, 0xad, 0x44, 0xba, 0xe5, 0xb1, 0x97, 0x9a, 0x17, 0xd9, 0x9a, 0x8b, 0xd1, 0x9c, 0xe2, 0x01,
	0x26, 0xfd, 0x91, 0x6c, 0x3c, 0x98, 0xf3, 0x70, 0x7f, 0xc2, 0x23, 0x08, 0xfc, 0x28, 0x6b, 0x0c,
	0x35, 0x6c, 0x0c, 0xdb, 0x89, 0xe2, 0xd6, 0x33, 0x89, 0xd1, 0xc2, 0x04, 0x54, 0xd2, 0x1e, 0x4a,
	0x55, 0xd4, 0xd7, 0x15, 0xfc, 0x5f, 0x4e, 0xf7, 0xc8, 0xe6, 0x98, 0x5b, 0x0e, 0x1b, 0xfa, 0xcc,
	0x14, 0xce, 0x73, 0x47, 0xec, 0xa7, 0x3e, 0x0a, 0xfa, 0x5c, 0x4e, 0x7c, 0x54, 0x4f, 0xa2, 0x34,
	0x27, 0x83, 0x95, 0x38, 0x1d, 0xa2, 0x44, 0xc7, 0xe4, 0xf8, 0x98, 0xbd, 0xec, 0x33, 0xd7, 0x1d,
	0xcc, 0x43, 0x7c, 0x15, 0xf1, 0x9b, 0x69, 0xe8, 0x17, 0x13, 0xf1, 0x33, 0xf2, 0x58, 0x4c, 0xe6,
	0xba, 0x9a, 0x95, 0x00, 0x72, 0xaa, 0xcb, 0x5c, 0x7a, 0x8b, 0xd4, 0xfb, 0xc5, 0x2e, 0x79, 0x26,
	0xd1, 0x39, 0x69, 0x96, 0x64, 0x95, 0x81, 0xe9, 0x6d, 0xd2, 0x98, 0x5d, 0x4b, 0x99, 0x55, 0x64,
	0x9e, 0x4d, 0x98, 0x1b, 0xe2, 0x5a, 0x09, 0x75, 0x01, 0x47, 0xee, 0x8d, 0x94, 0xbb, 0xb6, 0xc4,
	0xbd, 0x51, 0xca, 0x4d, 0xe1, 0xf4, 0x1e, 0x69, 0x0e, 0xa6, 0x7d, 0xa3, 0x1f, 0x58, 0xdc, 0x08,
	0x1c, 0x3f, 0xbe, 0xc2, 0xa6, 0x7e, 0x21, 0xe1, 0x9f, 0xb6, 0x22, 0x13, 0x34, 0x33, 0xb0, 0xb8,
	0x06, 0x32, 0x9c, 0x13, 0x29, 0xf2, 0xd4, 0x3f, 0x14, 0x52, 0x89, 0x5b, 0x56, 0xc3, 0x08, 0x03,
	0x3b, 0x64, 0xde, 0x70, 0x90, 0xdc, 0x53, 0x96, 0x0c, 0xc4, 0x01, 0xcd, 0xb1, 0xf2, 0xc9, 0x64,
	0x70, 0x6a, 0x90, 0x13, 0xd9, 0x22, 0xad, 0x27, 0xbe, 0x8d, 0x8f, 0x13, 0x89, 0xb3, 0x0b, 0x89,
	0x92, 0xba, 0x0e, 0xb0, 0x55, 0xc0, 0xb6, 0x2d, 0x7b, 0x51, 0xcf, 0x75, 0x83, 0x17, 0x63, 0x27,
	0xc2, 0x61, 0x64, 0x68, 0xf4, 0x2c, 0x2b, 0xe4, 0x51, 0xc4, 0x0f, 0xf4, 0x22, 0x26, 0x71, 0x9a,
	0x97, 0x00, 0x35, 0x07, 0x34, 0x96, 0x42, 0xf3, 0xbd, 0xe8, 0x30, 0x39, 0xb5, 0x16, 0xb7, 0x6c,
	0xf9, 0xaf, 0x6c, 0xa5, 0xea, 0xa3, 0xb8, 0x95, 0xd2, 0x4f, 0x48, 0x55, 0x0e, 0x2f, 0x68, 0xd7,
	0xd4, 0x29, 0xb6, 0xed, 0x7d, 0xe0, 0x85, 0xb6, 0xbd, 0x0f, 0x5c, 0xe2, 0xe4, 0xa1, 0x62, 0xdd,
	0x09, 0x4e, 0x1e, 0x7f, 0x1e, 0x27, 0xe3, 0xea, 0x2d, 0xd2, 0xc8, 0x86, 0x0b, 0x7a, 0x99, 0xac,
	0xc9, 0x87, 0x76, 0x80, 0xdf, 0x5c, 0x55, 0xdf, 0x90, 0x4f, 0x59, 0xfc, 0x2a, 0xe7, 0xdf, 0x14,
	0x84, 0xa8, 0x57, 0x70, 0xca, 0x18, 0x39, 0x91, 0xa0, 0x17, 0x48, 0x95, 0x01, 0xa4, 0xf3, 0x45,
	0xb3, 0x30, 0xb6, 0x4c, 0x30, 0xa4, 0xfe, 0xae, 0x90, 0x7a, 0x0f, 0xe0, 0xee, 0x73, 0xee, 0x0b,
	0xba, 0x43, 0x1a, 0xf8, 0x23, 0x2b, 0x64, 0xfd, 0xfa, 0x3a, 0xce, 0x5c, 0xd9, 0xae, 0xde, 0x92,
	0xf7, 0xcc, 0xe5, 0x52, 0x5b, 0x2a, 0x6f, 0x41, 0xc5, 0x49, 0x04, 0xa0, 0x64, 0x12, 0x01, 0xc0,
	0xc7, 0x74, 0x05, 0x27, 0x11, 0x28, 0x3c, 0xa6, 0x3d, 0x00, 0xf5, 0x1b, 0x72, 0x2c, 0xcd, 0x05,
	0xf3, 0xbf, 0x8a, 0x67, 0x80, 0xeb, 0xb4, 0x08, 0x5a, 0x50, 0xc3, 0xd0, 0x64, 0x01, 0xba, 0xfe,
	0xd7, 0x2a, 0x96, 0xd3, 0x03, 0xe7, 0xd1, 0x35, 0x7a, 0x95, 0xd4, 0xa5, 0x4c, 0x0f, 0x20, 0xa2,
	0xcb, 0xb3, 0x63, 0xbb, 0x38, 0x05, 0x4a, 0x9c, 0xba, 0x42, 0xbf, 0x20, 0x8d, 0xef, 0xe5, 0x85,
	0x97, 0x53, 0x36, 0x0f, 0x7a, 0xc7, 0xbc, 0xab, 0x0a, 0xbd, 0x49, 0x9a, 0x3d, 0x80, 0xfb, 0xc0,
	0xc3, 0x87, 0x60, 0x31, 0xc1, 0x69, 0x49, 0xa2, 0xed, 0xe2, 0x08, 0xac, 0xae, 0x6c, 0x2b, 0xed,
	0xa7, 0xaf, 0x7f, 0x3b, 0x6d, 0xc7, 0x23, 0x73, 0xd5, 0x95, 0x35, 0x57, 0x21, 0x88, 0x04, 0xad,
	0xc0, 0x5c, 0xd0, 0x9a, 0xc5, 0x5d, 0x2e, 0x78, 0xfb, 0x4e, 0xf7, 0xd7, 0x45, 0x16, 0x9d, 0x19,
	0xf7, 0x99, 0x2f, 0x5e, 0x15, 0xf6, 0x76, 0x99, 0xc7, 0x23, 0x60, 0x26, 0x3f, 0xb8, 0xfd, 0x4a,
	0xad, 0xe3, 0xdf, 0x14, 0x00, 0x91, 0x7e, 0xec, 0xcd, 0x87, 0x73, 0xca, 0xdb, 0x0f, 0xe7, 0x94,
	0xf7, 0x1f, 0xce, 0x29, 0x86, 0xb2, 0x57, 0xc3, 0xfc, 0x3e, 0xff, 0x2f, 0x00, 0x00, 0xff, 0xff,
	0x76, 0x50, 0xfe, 0x44, 0x92, 0x0c, 0x00, 0x00,
}
