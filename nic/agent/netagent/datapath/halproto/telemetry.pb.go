// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: telemetry.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ExportFormat is a enumeration of export formats supported
type ExportFormat int32

const (
	ExportFormat_IPFIX     ExportFormat = 0
	ExportFormat_NETFLOWV9 ExportFormat = 1
)

var ExportFormat_name = map[int32]string{
	0: "IPFIX",
	1: "NETFLOWV9",
}
var ExportFormat_value = map[string]int32{
	"IPFIX":     0,
	"NETFLOWV9": 1,
}

func (x ExportFormat) String() string {
	return proto.EnumName(ExportFormat_name, int32(x))
}
func (ExportFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{0} }

// RuleAction is an enumeration of support telemetry actions
type RuleAction int32

const (
	RuleAction_COLLECT_FLOW_STATS RuleAction = 0
	RuleAction_MIRROR             RuleAction = 1
	RuleAction_MIRROR_TO_CPU      RuleAction = 2
)

var RuleAction_name = map[int32]string{
	0: "COLLECT_FLOW_STATS",
	1: "MIRROR",
	2: "MIRROR_TO_CPU",
}
var RuleAction_value = map[string]int32{
	"COLLECT_FLOW_STATS": 0,
	"MIRROR":             1,
	"MIRROR_TO_CPU":      2,
}

func (x RuleAction) String() string {
	return proto.EnumName(RuleAction_name, int32(x))
}
func (RuleAction) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{1} }

// AggregationScheme is an enumeration of aggregation schemes supported
type AggregationScheme int32

const (
	AggregationScheme_NONE             AggregationScheme = 0
	AggregationScheme_IPSOURCE         AggregationScheme = 1
	AggregationScheme_IPDESTINATION    AggregationScheme = 2
	AggregationScheme_IPPAIR           AggregationScheme = 3
	AggregationScheme_SOURCE_PORT      AggregationScheme = 4
	AggregationScheme_DESTINATION_PORT AggregationScheme = 5
	AggregationScheme_SERVICE          AggregationScheme = 6
	AggregationScheme_IPPAIR_SERVICE   AggregationScheme = 7
	AggregationScheme_SOURCE_SEC_GROUP AggregationScheme = 8
	AggregationScheme_DEST_SEC_GROUP   AggregationScheme = 9
	AggregationScheme_SEC_GROUP_PAIR   AggregationScheme = 10
)

var AggregationScheme_name = map[int32]string{
	0:  "NONE",
	1:  "IPSOURCE",
	2:  "IPDESTINATION",
	3:  "IPPAIR",
	4:  "SOURCE_PORT",
	5:  "DESTINATION_PORT",
	6:  "SERVICE",
	7:  "IPPAIR_SERVICE",
	8:  "SOURCE_SEC_GROUP",
	9:  "DEST_SEC_GROUP",
	10: "SEC_GROUP_PAIR",
}
var AggregationScheme_value = map[string]int32{
	"NONE":             0,
	"IPSOURCE":         1,
	"IPDESTINATION":    2,
	"IPPAIR":           3,
	"SOURCE_PORT":      4,
	"DESTINATION_PORT": 5,
	"SERVICE":          6,
	"IPPAIR_SERVICE":   7,
	"SOURCE_SEC_GROUP": 8,
	"DEST_SEC_GROUP":   9,
	"SEC_GROUP_PAIR":   10,
}

func (x AggregationScheme) String() string {
	return proto.EnumName(AggregationScheme_name, int32(x))
}
func (AggregationScheme) EnumDescriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{2} }

// CollectorSpec is the configuration specification for a telemetry collector
type CollectorSpec struct {
	Meta           *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle    *CollectorKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	Encap          *EncapInfo          `protobuf:"bytes,3,opt,name=encap" json:"encap,omitempty"`
	L2SegKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,4,opt,name=l2seg_key_handle,json=l2segKeyHandle" json:"l2seg_key_handle,omitempty" venice:ref`
	DestIp         *IPAddress          `protobuf:"bytes,5,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty" venice:mandatory`
	SrcIp          *IPAddress          `protobuf:"bytes,6,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty" venice:mandatory`
	Protocol       IPProtocol          `protobuf:"varint,7,opt,name=protocol,proto3,enum=types.IPProtocol" json:"protocol,omitempty" venice:mandatory`
	DestPort       uint32              `protobuf:"varint,8,opt,name=dest_port,json=destPort,proto3" json:"dest_port,omitempty" venice:mandatory`
	Format         ExportFormat        `protobuf:"varint,9,opt,name=format,proto3,enum=telemetry.ExportFormat" json:"format,omitempty" venice:mandatory`
	TemplateId     uint32              `protobuf:"varint,10,opt,name=template_id,json=templateId,proto3" json:"template_id,omitempty" venice:mandatory`
}

func (m *CollectorSpec) Reset()                    { *m = CollectorSpec{} }
func (m *CollectorSpec) String() string            { return proto.CompactTextString(m) }
func (*CollectorSpec) ProtoMessage()               {}
func (*CollectorSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{0} }

func (m *CollectorSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CollectorSpec) GetKeyOrHandle() *CollectorKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *CollectorSpec) GetEncap() *EncapInfo {
	if m != nil {
		return m.Encap
	}
	return nil
}

func (m *CollectorSpec) GetL2SegKeyHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.L2SegKeyHandle
	}
	return nil
}

func (m *CollectorSpec) GetDestIp() *IPAddress {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *CollectorSpec) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *CollectorSpec) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *CollectorSpec) GetDestPort() uint32 {
	if m != nil {
		return m.DestPort
	}
	return 0
}

func (m *CollectorSpec) GetFormat() ExportFormat {
	if m != nil {
		return m.Format
	}
	return ExportFormat_IPFIX
}

func (m *CollectorSpec) GetTemplateId() uint32 {
	if m != nil {
		return m.TemplateId
	}
	return 0
}

// CollectorSpec is the operational status of the collector
type CollectorStatus struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *CollectorStatus) Reset()                    { *m = CollectorStatus{} }
func (m *CollectorStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorStatus) ProtoMessage()               {}
func (*CollectorStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{1} }

func (m *CollectorStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// Collector is a container that holds both the configuration and the operational
//  state of the collector
type CollectorResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *CollectorStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *CollectorResponse) Reset()                    { *m = CollectorResponse{} }
func (m *CollectorResponse) String() string            { return proto.CompactTextString(m) }
func (*CollectorResponse) ProtoMessage()               {}
func (*CollectorResponse) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{2} }

func (m *CollectorResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CollectorResponse) GetStatus() *CollectorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// CollectorConfigsMsg is used in requests and is a batchable request message
type CollectorRequestMsg struct {
	Request []*CollectorSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CollectorRequestMsg) Reset()                    { *m = CollectorRequestMsg{} }
func (m *CollectorRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CollectorRequestMsg) ProtoMessage()               {}
func (*CollectorRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{3} }

func (m *CollectorRequestMsg) GetRequest() []*CollectorSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// CollectorConfigsMsg message is used as response for API requests.
type CollectorResponseMsg struct {
	Response []*CollectorResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CollectorResponseMsg) Reset()                    { *m = CollectorResponseMsg{} }
func (m *CollectorResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*CollectorResponseMsg) ProtoMessage()               {}
func (*CollectorResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{4} }

func (m *CollectorResponseMsg) GetResponse() []*CollectorResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CollectorDeleteRequest is used to delete a collector
type CollectorDeleteRequest struct {
	Meta        *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *CollectorKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *CollectorDeleteRequest) Reset()                    { *m = CollectorDeleteRequest{} }
func (m *CollectorDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*CollectorDeleteRequest) ProtoMessage()               {}
func (*CollectorDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{5} }

func (m *CollectorDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CollectorDeleteRequest) GetKeyOrHandle() *CollectorKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// CollectorDeleteResponse is response to CollectorDeleteRequest
type CollectorDeleteResponse struct {
	ApiStatus   ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	KeyOrHandle *CollectorKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *CollectorDeleteResponse) Reset()                    { *m = CollectorDeleteResponse{} }
func (m *CollectorDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*CollectorDeleteResponse) ProtoMessage()               {}
func (*CollectorDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{6} }

func (m *CollectorDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CollectorDeleteResponse) GetKeyOrHandle() *CollectorKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// CollectorDeleteRequestMsg is used to delete a batch of collectors
type CollectorDeleteRequestMsg struct {
	Request []*CollectorDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CollectorDeleteRequestMsg) Reset()         { *m = CollectorDeleteRequestMsg{} }
func (m *CollectorDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*CollectorDeleteRequestMsg) ProtoMessage()    {}
func (*CollectorDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{7}
}

func (m *CollectorDeleteRequestMsg) GetRequest() []*CollectorDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// CollectorDeleteResponseMsg is batched response to CollectorDeleteRequestMsg
type CollectorDeleteResponseMsg struct {
	Response []*CollectorDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CollectorDeleteResponseMsg) Reset()         { *m = CollectorDeleteResponseMsg{} }
func (m *CollectorDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*CollectorDeleteResponseMsg) ProtoMessage()    {}
func (*CollectorDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{8}
}

func (m *CollectorDeleteResponseMsg) GetResponse() []*CollectorDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// CollectorGetRequest is used to get information about a collector
type CollectorGetRequest struct {
	Meta        *ObjectMeta         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *CollectorKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *CollectorGetRequest) Reset()                    { *m = CollectorGetRequest{} }
func (m *CollectorGetRequest) String() string            { return proto.CompactTextString(m) }
func (*CollectorGetRequest) ProtoMessage()               {}
func (*CollectorGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{9} }

func (m *CollectorGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CollectorGetRequest) GetKeyOrHandle() *CollectorKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// CollectorGetRequestMsg is batched GET requests for collectors
type CollectorGetRequestMsg struct {
	Request []*CollectorGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *CollectorGetRequestMsg) Reset()                    { *m = CollectorGetRequestMsg{} }
func (m *CollectorGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*CollectorGetRequestMsg) ProtoMessage()               {}
func (*CollectorGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{10} }

func (m *CollectorGetRequestMsg) GetRequest() []*CollectorGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type CollectorStats struct {
}

func (m *CollectorStats) Reset()                    { *m = CollectorStats{} }
func (m *CollectorStats) String() string            { return proto.CompactTextString(m) }
func (*CollectorStats) ProtoMessage()               {}
func (*CollectorStats) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{11} }

type CollectorGetResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *CollectorSpec  `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Stats     *CollectorStats `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *CollectorGetResponse) Reset()                    { *m = CollectorGetResponse{} }
func (m *CollectorGetResponse) String() string            { return proto.CompactTextString(m) }
func (*CollectorGetResponse) ProtoMessage()               {}
func (*CollectorGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{12} }

func (m *CollectorGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *CollectorGetResponse) GetSpec() *CollectorSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CollectorGetResponse) GetStats() *CollectorStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// CollectorGetResponseMsg is batched response to CollectorGetRequestMsg
type CollectorGetResponseMsg struct {
	Response []*CollectorGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *CollectorGetResponseMsg) Reset()         { *m = CollectorGetResponseMsg{} }
func (m *CollectorGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*CollectorGetResponseMsg) ProtoMessage()    {}
func (*CollectorGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{13}
}

func (m *CollectorGetResponseMsg) GetResponse() []*CollectorGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// ExportControlSpec is the configuration specification for Export Control
type ExportControlSpec struct {
	Meta               *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle        *ExportControlKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	CollectorKeyHandle []*CollectorKeyHandle   `protobuf:"bytes,3,rep,name=collector_key_handle,json=collectorKeyHandle" json:"collector_key_handle,omitempty"`
	ActiveTimeout      uint32                  `protobuf:"varint,4,opt,name=active_timeout,json=activeTimeout,proto3" json:"active_timeout,omitempty"`
	InactiveTimeout    uint32                  `protobuf:"varint,5,opt,name=inactive_timeout,json=inactiveTimeout,proto3" json:"inactive_timeout,omitempty"`
}

func (m *ExportControlSpec) Reset()                    { *m = ExportControlSpec{} }
func (m *ExportControlSpec) String() string            { return proto.CompactTextString(m) }
func (*ExportControlSpec) ProtoMessage()               {}
func (*ExportControlSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{14} }

func (m *ExportControlSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ExportControlSpec) GetKeyOrHandle() *ExportControlKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *ExportControlSpec) GetCollectorKeyHandle() []*CollectorKeyHandle {
	if m != nil {
		return m.CollectorKeyHandle
	}
	return nil
}

func (m *ExportControlSpec) GetActiveTimeout() uint32 {
	if m != nil {
		return m.ActiveTimeout
	}
	return 0
}

func (m *ExportControlSpec) GetInactiveTimeout() uint32 {
	if m != nil {
		return m.InactiveTimeout
	}
	return 0
}

// ExportControlSpec is the operational status of the Export Control object
type ExportControlStatus struct {
	Handle uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
}

func (m *ExportControlStatus) Reset()                    { *m = ExportControlStatus{} }
func (m *ExportControlStatus) String() string            { return proto.CompactTextString(m) }
func (*ExportControlStatus) ProtoMessage()               {}
func (*ExportControlStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{15} }

func (m *ExportControlStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

// ExportControl is a container that holds both the configuration and the operational
// state
type ExportControlResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *ExportControlStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *ExportControlResponse) Reset()                    { *m = ExportControlResponse{} }
func (m *ExportControlResponse) String() string            { return proto.CompactTextString(m) }
func (*ExportControlResponse) ProtoMessage()               {}
func (*ExportControlResponse) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{16} }

func (m *ExportControlResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ExportControlResponse) GetStatus() *ExportControlStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// ExportControlConfigsMsg is used in requests and is a batchable request message
type ExportControlRequestMsg struct {
	Request []*ExportControlSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *ExportControlRequestMsg) Reset()         { *m = ExportControlRequestMsg{} }
func (m *ExportControlRequestMsg) String() string { return proto.CompactTextString(m) }
func (*ExportControlRequestMsg) ProtoMessage()    {}
func (*ExportControlRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{17}
}

func (m *ExportControlRequestMsg) GetRequest() []*ExportControlSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// ExportControlConfigsMsg message is used as response for API requests.
type ExportControlResponseMsg struct {
	Response []*ExportControlResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *ExportControlResponseMsg) Reset()         { *m = ExportControlResponseMsg{} }
func (m *ExportControlResponseMsg) String() string { return proto.CompactTextString(m) }
func (*ExportControlResponseMsg) ProtoMessage()    {}
func (*ExportControlResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{18}
}

func (m *ExportControlResponseMsg) GetResponse() []*ExportControlResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// ExportControlDeleteRequest is used to delete an export control object
type ExportControlDeleteRequest struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *ExportControlKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *ExportControlDeleteRequest) Reset()         { *m = ExportControlDeleteRequest{} }
func (m *ExportControlDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*ExportControlDeleteRequest) ProtoMessage()    {}
func (*ExportControlDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{19}
}

func (m *ExportControlDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ExportControlDeleteRequest) GetKeyOrHandle() *ExportControlKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// ExportControlDeleteResponse is response to ExportControlDeleteRequest
type ExportControlDeleteResponse struct {
	ApiStatus   ApiStatus               `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	KeyOrHandle *ExportControlKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *ExportControlDeleteResponse) Reset()         { *m = ExportControlDeleteResponse{} }
func (m *ExportControlDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*ExportControlDeleteResponse) ProtoMessage()    {}
func (*ExportControlDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{20}
}

func (m *ExportControlDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ExportControlDeleteResponse) GetKeyOrHandle() *ExportControlKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// ExportControlDeleteRequestMsg is used to delete a batch of exportcontrol objects
type ExportControlDeleteRequestMsg struct {
	Request []*ExportControlDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *ExportControlDeleteRequestMsg) Reset()         { *m = ExportControlDeleteRequestMsg{} }
func (m *ExportControlDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*ExportControlDeleteRequestMsg) ProtoMessage()    {}
func (*ExportControlDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{21}
}

func (m *ExportControlDeleteRequestMsg) GetRequest() []*ExportControlDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// ExportControlDeleteResponseMsg is batched response to ExportControlDeleteRequestMsg
type ExportControlDeleteResponseMsg struct {
	Response []*ExportControlDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *ExportControlDeleteResponseMsg) Reset()         { *m = ExportControlDeleteResponseMsg{} }
func (m *ExportControlDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*ExportControlDeleteResponseMsg) ProtoMessage()    {}
func (*ExportControlDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{22}
}

func (m *ExportControlDeleteResponseMsg) GetResponse() []*ExportControlDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// ExportControlGetRequest is used to get information about an exportcontrol object
type ExportControlGetRequest struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *ExportControlKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *ExportControlGetRequest) Reset()         { *m = ExportControlGetRequest{} }
func (m *ExportControlGetRequest) String() string { return proto.CompactTextString(m) }
func (*ExportControlGetRequest) ProtoMessage()    {}
func (*ExportControlGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{23}
}

func (m *ExportControlGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ExportControlGetRequest) GetKeyOrHandle() *ExportControlKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// ExportControlGetRequestMsg is batched GET requests for exportcontrol objects
type ExportControlGetRequestMsg struct {
	Request []*ExportControlGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *ExportControlGetRequestMsg) Reset()         { *m = ExportControlGetRequestMsg{} }
func (m *ExportControlGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*ExportControlGetRequestMsg) ProtoMessage()    {}
func (*ExportControlGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{24}
}

func (m *ExportControlGetRequestMsg) GetRequest() []*ExportControlGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type ExportControlStats struct {
}

func (m *ExportControlStats) Reset()                    { *m = ExportControlStats{} }
func (m *ExportControlStats) String() string            { return proto.CompactTextString(m) }
func (*ExportControlStats) ProtoMessage()               {}
func (*ExportControlStats) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{25} }

type ExportControlGetResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *ExportControlSpec  `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Stats     *ExportControlStats `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *ExportControlGetResponse) Reset()         { *m = ExportControlGetResponse{} }
func (m *ExportControlGetResponse) String() string { return proto.CompactTextString(m) }
func (*ExportControlGetResponse) ProtoMessage()    {}
func (*ExportControlGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{26}
}

func (m *ExportControlGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *ExportControlGetResponse) GetSpec() *ExportControlSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ExportControlGetResponse) GetStats() *ExportControlStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// ExportControlGetResponseMsg is batched response to ExportControlGetRequestMsg
type ExportControlGetResponseMsg struct {
	Response []*ExportControlGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *ExportControlGetResponseMsg) Reset()         { *m = ExportControlGetResponseMsg{} }
func (m *ExportControlGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*ExportControlGetResponseMsg) ProtoMessage()    {}
func (*ExportControlGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{27}
}

func (m *ExportControlGetResponseMsg) GetResponse() []*ExportControlGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// MonitorAction defines the action for a flow monitor rule
type MonitorAction struct {
	Action             []RuleAction        `protobuf:"varint,1,rep,packed,name=action,enum=telemetry.RuleAction" json:"action,omitempty"`
	AggScheme          []AggregationScheme `protobuf:"varint,2,rep,packed,name=agg_scheme,json=aggScheme,enum=telemetry.AggregationScheme" json:"agg_scheme,omitempty"`
	MirrorDestinations []uint32            `protobuf:"varint,3,rep,packed,name=mirror_destinations,json=mirrorDestinations" json:"mirror_destinations,omitempty"`
}

func (m *MonitorAction) Reset()                    { *m = MonitorAction{} }
func (m *MonitorAction) String() string            { return proto.CompactTextString(m) }
func (*MonitorAction) ProtoMessage()               {}
func (*MonitorAction) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{28} }

func (m *MonitorAction) GetAction() []RuleAction {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *MonitorAction) GetAggScheme() []AggregationScheme {
	if m != nil {
		return m.AggScheme
	}
	return nil
}

func (m *MonitorAction) GetMirrorDestinations() []uint32 {
	if m != nil {
		return m.MirrorDestinations
	}
	return nil
}

// FlowMonitorRuleSpec flow monitor rule specification
type FlowMonitorRuleSpec struct {
	Meta          *ObjectMeta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle   *FlowMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	EcKeyHandle   *ExportControlKeyHandle   `protobuf:"bytes,3,opt,name=ec_key_handle,json=ecKeyHandle" json:"ec_key_handle,omitempty"`
	SourceMac     uint64                    `protobuf:"varint,4,opt,name=source_mac,json=sourceMac,proto3" json:"source_mac,omitempty"`
	DestMac       uint64                    `protobuf:"varint,5,opt,name=dest_mac,json=destMac,proto3" json:"dest_mac,omitempty"`
	Ethertype     uint32                    `protobuf:"varint,6,opt,name=ethertype,proto3" json:"ethertype,omitempty"`
	Protocol      IPProtocol                `protobuf:"varint,7,opt,name=protocol,proto3,enum=types.IPProtocol" json:"protocol,omitempty"`
	SourceIp      *IPPrefix                 `protobuf:"bytes,8,opt,name=source_ip,json=sourceIp" json:"source_ip,omitempty"`
	DestIp        *IPPrefix                 `protobuf:"bytes,9,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	SourceL4Port  uint32                    `protobuf:"varint,10,opt,name=source_l4_port,json=sourceL4Port,proto3" json:"source_l4_port,omitempty"`
	DestL4Port    uint32                    `protobuf:"varint,11,opt,name=dest_l4_port,json=destL4Port,proto3" json:"dest_l4_port,omitempty"`
	SourceGroupid uint64                    `protobuf:"varint,12,opt,name=source_groupid,json=sourceGroupid,proto3" json:"source_groupid,omitempty"`
	DestGroupid   uint64                    `protobuf:"varint,13,opt,name=dest_groupid,json=destGroupid,proto3" json:"dest_groupid,omitempty"`
	Action        *MonitorAction            `protobuf:"bytes,14,opt,name=action" json:"action,omitempty"`
}

func (m *FlowMonitorRuleSpec) Reset()                    { *m = FlowMonitorRuleSpec{} }
func (m *FlowMonitorRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleSpec) ProtoMessage()               {}
func (*FlowMonitorRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{29} }

func (m *FlowMonitorRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetKeyOrHandle() *FlowMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetEcKeyHandle() *ExportControlKeyHandle {
	if m != nil {
		return m.EcKeyHandle
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceMac() uint64 {
	if m != nil {
		return m.SourceMac
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetDestMac() uint64 {
	if m != nil {
		return m.DestMac
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetEthertype() uint32 {
	if m != nil {
		return m.Ethertype
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetProtocol() IPProtocol {
	if m != nil {
		return m.Protocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *FlowMonitorRuleSpec) GetSourceIp() *IPPrefix {
	if m != nil {
		return m.SourceIp
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetDestIp() *IPPrefix {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *FlowMonitorRuleSpec) GetSourceL4Port() uint32 {
	if m != nil {
		return m.SourceL4Port
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetDestL4Port() uint32 {
	if m != nil {
		return m.DestL4Port
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetSourceGroupid() uint64 {
	if m != nil {
		return m.SourceGroupid
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetDestGroupid() uint64 {
	if m != nil {
		return m.DestGroupid
	}
	return 0
}

func (m *FlowMonitorRuleSpec) GetAction() *MonitorAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// FlowMonitorRuleStatus is the operational status of the rule
type FlowMonitorRuleStatus struct {
	Handle      uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
	ActiveFlows uint32 `protobuf:"varint,2,opt,name=active_flows,json=activeFlows,proto3" json:"active_flows,omitempty"`
}

func (m *FlowMonitorRuleStatus) Reset()                    { *m = FlowMonitorRuleStatus{} }
func (m *FlowMonitorRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleStatus) ProtoMessage()               {}
func (*FlowMonitorRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{30} }

func (m *FlowMonitorRuleStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *FlowMonitorRuleStatus) GetActiveFlows() uint32 {
	if m != nil {
		return m.ActiveFlows
	}
	return 0
}

// FlowMonitorRule is a container that holds both the configuration and the operational
// state of the flowmonitor
type FlowMonitorRuleResponse struct {
	ApiStatus ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *FlowMonitorRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *FlowMonitorRuleResponse) Reset()         { *m = FlowMonitorRuleResponse{} }
func (m *FlowMonitorRuleResponse) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleResponse) ProtoMessage()    {}
func (*FlowMonitorRuleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{31}
}

func (m *FlowMonitorRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FlowMonitorRuleResponse) GetStatus() *FlowMonitorRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// FlowMonitorRuleConfigsMsg is used in requests and is a batchable request message
type FlowMonitorRuleRequestMsg struct {
	Request []*FlowMonitorRuleSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FlowMonitorRuleRequestMsg) Reset()         { *m = FlowMonitorRuleRequestMsg{} }
func (m *FlowMonitorRuleRequestMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleRequestMsg) ProtoMessage()    {}
func (*FlowMonitorRuleRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{32}
}

func (m *FlowMonitorRuleRequestMsg) GetRequest() []*FlowMonitorRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowMonitorRuleConfigsMsg message is used as response for API requests.
type FlowMonitorRuleResponseMsg struct {
	Response []*FlowMonitorRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *FlowMonitorRuleResponseMsg) Reset()         { *m = FlowMonitorRuleResponseMsg{} }
func (m *FlowMonitorRuleResponseMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleResponseMsg) ProtoMessage()    {}
func (*FlowMonitorRuleResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{33}
}

func (m *FlowMonitorRuleResponseMsg) GetResponse() []*FlowMonitorRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// FlowMonitorRuleDeleteRequest is used to delete a flowmonitor
type FlowMonitorRuleDeleteRequest struct {
	Meta        *ObjectMeta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *FlowMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *FlowMonitorRuleDeleteRequest) Reset()         { *m = FlowMonitorRuleDeleteRequest{} }
func (m *FlowMonitorRuleDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleDeleteRequest) ProtoMessage()    {}
func (*FlowMonitorRuleDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{34}
}

func (m *FlowMonitorRuleDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *FlowMonitorRuleDeleteRequest) GetKeyOrHandle() *FlowMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// FlowMonitorRuleDeleteResponse is response to FlowMonitorRuleDeleteRequest
type FlowMonitorRuleDeleteResponse struct {
	ApiStatus   ApiStatus                 `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	KeyOrHandle *FlowMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *FlowMonitorRuleDeleteResponse) Reset()         { *m = FlowMonitorRuleDeleteResponse{} }
func (m *FlowMonitorRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleDeleteResponse) ProtoMessage()    {}
func (*FlowMonitorRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{35}
}

func (m *FlowMonitorRuleDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FlowMonitorRuleDeleteResponse) GetKeyOrHandle() *FlowMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// FlowMonitorRuleDeleteRequestMsg is used to delete a batch of flowmonitors
type FlowMonitorRuleDeleteRequestMsg struct {
	Request []*FlowMonitorRuleDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FlowMonitorRuleDeleteRequestMsg) Reset()         { *m = FlowMonitorRuleDeleteRequestMsg{} }
func (m *FlowMonitorRuleDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleDeleteRequestMsg) ProtoMessage()    {}
func (*FlowMonitorRuleDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{36}
}

func (m *FlowMonitorRuleDeleteRequestMsg) GetRequest() []*FlowMonitorRuleDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// FlowMonitorRuleDeleteResponseMsg is batched response to FlowMonitorRuleDeleteRequestMsg
type FlowMonitorRuleDeleteResponseMsg struct {
	Response []*FlowMonitorRuleDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *FlowMonitorRuleDeleteResponseMsg) Reset()         { *m = FlowMonitorRuleDeleteResponseMsg{} }
func (m *FlowMonitorRuleDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleDeleteResponseMsg) ProtoMessage()    {}
func (*FlowMonitorRuleDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{37}
}

func (m *FlowMonitorRuleDeleteResponseMsg) GetResponse() []*FlowMonitorRuleDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// FlowMonitorRuleGetRequest is used to get information about a flowmonitor
type FlowMonitorRuleGetRequest struct {
	Meta        *ObjectMeta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *FlowMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *FlowMonitorRuleGetRequest) Reset()         { *m = FlowMonitorRuleGetRequest{} }
func (m *FlowMonitorRuleGetRequest) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleGetRequest) ProtoMessage()    {}
func (*FlowMonitorRuleGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{38}
}

func (m *FlowMonitorRuleGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *FlowMonitorRuleGetRequest) GetKeyOrHandle() *FlowMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// FlowMonitorRuleGetRequestMsg is batched GET requests for flowmonitors
type FlowMonitorRuleGetRequestMsg struct {
	Request []*FlowMonitorRuleGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FlowMonitorRuleGetRequestMsg) Reset()         { *m = FlowMonitorRuleGetRequestMsg{} }
func (m *FlowMonitorRuleGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleGetRequestMsg) ProtoMessage()    {}
func (*FlowMonitorRuleGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{39}
}

func (m *FlowMonitorRuleGetRequestMsg) GetRequest() []*FlowMonitorRuleGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type FlowMonitorRuleStats struct {
}

func (m *FlowMonitorRuleStats) Reset()                    { *m = FlowMonitorRuleStats{} }
func (m *FlowMonitorRuleStats) String() string            { return proto.CompactTextString(m) }
func (*FlowMonitorRuleStats) ProtoMessage()               {}
func (*FlowMonitorRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{40} }

type FlowMonitorRuleGetResponse struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *FlowMonitorRuleSpec  `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Stats     *FlowMonitorRuleStats `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *FlowMonitorRuleGetResponse) Reset()         { *m = FlowMonitorRuleGetResponse{} }
func (m *FlowMonitorRuleGetResponse) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleGetResponse) ProtoMessage()    {}
func (*FlowMonitorRuleGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{41}
}

func (m *FlowMonitorRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FlowMonitorRuleGetResponse) GetSpec() *FlowMonitorRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *FlowMonitorRuleGetResponse) GetStats() *FlowMonitorRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// FlowMonitorGetResponseMsg is batched response to FlowMonitorGetRequestMsg
type FlowMonitorRuleGetResponseMsg struct {
	Response []*FlowMonitorRuleGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *FlowMonitorRuleGetResponseMsg) Reset()         { *m = FlowMonitorRuleGetResponseMsg{} }
func (m *FlowMonitorRuleGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*FlowMonitorRuleGetResponseMsg) ProtoMessage()    {}
func (*FlowMonitorRuleGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{42}
}

func (m *FlowMonitorRuleGetResponseMsg) GetResponse() []*FlowMonitorRuleGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Drop Monitor Rule specification
type DropMonitorRuleSpec struct {
	Meta        *ObjectMeta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *DropMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
	MsKeyHandle []*MirrorSessionKeyHandle `protobuf:"bytes,3,rep,name=ms_key_handle,json=msKeyHandle" json:"ms_key_handle,omitempty" venice:constraints={range:0-7}`
	Reasons     *DropReasons              `protobuf:"bytes,4,opt,name=reasons" json:"reasons,omitempty"`
}

func (m *DropMonitorRuleSpec) Reset()                    { *m = DropMonitorRuleSpec{} }
func (m *DropMonitorRuleSpec) String() string            { return proto.CompactTextString(m) }
func (*DropMonitorRuleSpec) ProtoMessage()               {}
func (*DropMonitorRuleSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{43} }

func (m *DropMonitorRuleSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DropMonitorRuleSpec) GetKeyOrHandle() *DropMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *DropMonitorRuleSpec) GetMsKeyHandle() []*MirrorSessionKeyHandle {
	if m != nil {
		return m.MsKeyHandle
	}
	return nil
}

func (m *DropMonitorRuleSpec) GetReasons() *DropReasons {
	if m != nil {
		return m.Reasons
	}
	return nil
}

// DropMonitorRuleStatus is the operational status of the rule
type DropMonitorRuleStatus struct {
	Handle      uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
	ActiveFlows uint32 `protobuf:"varint,3,opt,name=active_flows,json=activeFlows,proto3" json:"active_flows,omitempty"`
}

func (m *DropMonitorRuleStatus) Reset()                    { *m = DropMonitorRuleStatus{} }
func (m *DropMonitorRuleStatus) String() string            { return proto.CompactTextString(m) }
func (*DropMonitorRuleStatus) ProtoMessage()               {}
func (*DropMonitorRuleStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{44} }

func (m *DropMonitorRuleStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *DropMonitorRuleStatus) GetActiveFlows() uint32 {
	if m != nil {
		return m.ActiveFlows
	}
	return 0
}

// DropMonitorRule is a container that holds both the configuration and the operational
// state of the dropmonitor
type DropMonitorRuleResponse struct {
	ApiStatus ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *DropMonitorRuleStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *DropMonitorRuleResponse) Reset()         { *m = DropMonitorRuleResponse{} }
func (m *DropMonitorRuleResponse) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleResponse) ProtoMessage()    {}
func (*DropMonitorRuleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{45}
}

func (m *DropMonitorRuleResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DropMonitorRuleResponse) GetStatus() *DropMonitorRuleStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// DropMonitorRuleConfigsMsg is used in requests and is a batchable request message
type DropMonitorRuleRequestMsg struct {
	Request []*DropMonitorRuleSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DropMonitorRuleRequestMsg) Reset()         { *m = DropMonitorRuleRequestMsg{} }
func (m *DropMonitorRuleRequestMsg) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleRequestMsg) ProtoMessage()    {}
func (*DropMonitorRuleRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{46}
}

func (m *DropMonitorRuleRequestMsg) GetRequest() []*DropMonitorRuleSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// DropMonitorRuleConfigsMsg message is used as response for API requests.
type DropMonitorRuleResponseMsg struct {
	Response []*DropMonitorRuleResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DropMonitorRuleResponseMsg) Reset()         { *m = DropMonitorRuleResponseMsg{} }
func (m *DropMonitorRuleResponseMsg) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleResponseMsg) ProtoMessage()    {}
func (*DropMonitorRuleResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{47}
}

func (m *DropMonitorRuleResponseMsg) GetResponse() []*DropMonitorRuleResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// DropMonitorRuleDeleteRequest is used to delete a dropmonitor
type DropMonitorRuleDeleteRequest struct {
	Meta        *ObjectMeta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *DropMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *DropMonitorRuleDeleteRequest) Reset()         { *m = DropMonitorRuleDeleteRequest{} }
func (m *DropMonitorRuleDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleDeleteRequest) ProtoMessage()    {}
func (*DropMonitorRuleDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{48}
}

func (m *DropMonitorRuleDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DropMonitorRuleDeleteRequest) GetKeyOrHandle() *DropMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// DropMonitorRuleDeleteResponse is response to DropMonitorRuleDeleteRequest
type DropMonitorRuleDeleteResponse struct {
	ApiStatus   ApiStatus                 `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	KeyOrHandle *DropMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *DropMonitorRuleDeleteResponse) Reset()         { *m = DropMonitorRuleDeleteResponse{} }
func (m *DropMonitorRuleDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleDeleteResponse) ProtoMessage()    {}
func (*DropMonitorRuleDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{49}
}

func (m *DropMonitorRuleDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DropMonitorRuleDeleteResponse) GetKeyOrHandle() *DropMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// DropMonitorRuleDeleteRequestMsg is used to delete a batch of dropmonitors
type DropMonitorRuleDeleteRequestMsg struct {
	Request []*DropMonitorRuleDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DropMonitorRuleDeleteRequestMsg) Reset()         { *m = DropMonitorRuleDeleteRequestMsg{} }
func (m *DropMonitorRuleDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleDeleteRequestMsg) ProtoMessage()    {}
func (*DropMonitorRuleDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{50}
}

func (m *DropMonitorRuleDeleteRequestMsg) GetRequest() []*DropMonitorRuleDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// DropMonitorRuleDeleteResponseMsg is batched response to DropMonitorRuleDeleteRequestMsg
type DropMonitorRuleDeleteResponseMsg struct {
	Response []*DropMonitorRuleDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DropMonitorRuleDeleteResponseMsg) Reset()         { *m = DropMonitorRuleDeleteResponseMsg{} }
func (m *DropMonitorRuleDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleDeleteResponseMsg) ProtoMessage()    {}
func (*DropMonitorRuleDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{51}
}

func (m *DropMonitorRuleDeleteResponseMsg) GetResponse() []*DropMonitorRuleDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// DropMonitorRuleGetRequest is used to get information about a dropmonitor
type DropMonitorRuleGetRequest struct {
	Meta        *ObjectMeta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *DropMonitorRuleKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *DropMonitorRuleGetRequest) Reset()         { *m = DropMonitorRuleGetRequest{} }
func (m *DropMonitorRuleGetRequest) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleGetRequest) ProtoMessage()    {}
func (*DropMonitorRuleGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{52}
}

func (m *DropMonitorRuleGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DropMonitorRuleGetRequest) GetKeyOrHandle() *DropMonitorRuleKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// DropMonitorRuleGetRequestMsg is batched GET requests for dropmonitors
type DropMonitorRuleGetRequestMsg struct {
	Request []*DropMonitorRuleGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DropMonitorRuleGetRequestMsg) Reset()         { *m = DropMonitorRuleGetRequestMsg{} }
func (m *DropMonitorRuleGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleGetRequestMsg) ProtoMessage()    {}
func (*DropMonitorRuleGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{53}
}

func (m *DropMonitorRuleGetRequestMsg) GetRequest() []*DropMonitorRuleGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type DropMonitorRuleStats struct {
}

func (m *DropMonitorRuleStats) Reset()                    { *m = DropMonitorRuleStats{} }
func (m *DropMonitorRuleStats) String() string            { return proto.CompactTextString(m) }
func (*DropMonitorRuleStats) ProtoMessage()               {}
func (*DropMonitorRuleStats) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{54} }

type DropMonitorRuleGetResponse struct {
	ApiStatus ApiStatus             `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *DropMonitorRuleSpec  `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Stats     *DropMonitorRuleStats `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *DropMonitorRuleGetResponse) Reset()         { *m = DropMonitorRuleGetResponse{} }
func (m *DropMonitorRuleGetResponse) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleGetResponse) ProtoMessage()    {}
func (*DropMonitorRuleGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{55}
}

func (m *DropMonitorRuleGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DropMonitorRuleGetResponse) GetSpec() *DropMonitorRuleSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *DropMonitorRuleGetResponse) GetStats() *DropMonitorRuleStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// DropMonitorRuleGetResponseMsg is batched response to DropMonitorRuleGetRequestMsg
type DropMonitorRuleGetResponseMsg struct {
	Response []*DropMonitorRuleGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DropMonitorRuleGetResponseMsg) Reset()         { *m = DropMonitorRuleGetResponseMsg{} }
func (m *DropMonitorRuleGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*DropMonitorRuleGetResponseMsg) ProtoMessage()    {}
func (*DropMonitorRuleGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{56}
}

func (m *DropMonitorRuleGetResponseMsg) GetResponse() []*DropMonitorRuleGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// RspanSpec is the configuration specification for RSPAN.
type RSpanSpec struct {
	Intf       *InterfaceKeyHandle `protobuf:"bytes,1,opt,name=intf" json:"intf,omitempty"`
	RspanEncap *EncapInfo          `protobuf:"bytes,2,opt,name=rspan_encap,json=rspanEncap" json:"rspan_encap,omitempty"`
}

func (m *RSpanSpec) Reset()                    { *m = RSpanSpec{} }
func (m *RSpanSpec) String() string            { return proto.CompactTextString(m) }
func (*RSpanSpec) ProtoMessage()               {}
func (*RSpanSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{57} }

func (m *RSpanSpec) GetIntf() *InterfaceKeyHandle {
	if m != nil {
		return m.Intf
	}
	return nil
}

func (m *RSpanSpec) GetRspanEncap() *EncapInfo {
	if m != nil {
		return m.RspanEncap
	}
	return nil
}

// ERSpanSpec is the configuration specification for ERSPAN
type ERSpanSpec struct {
	DestIp *IPAddress `protobuf:"bytes,1,opt,name=dest_ip,json=destIp" json:"dest_ip,omitempty"`
	SrcIp  *IPAddress `protobuf:"bytes,2,opt,name=src_ip,json=srcIp" json:"src_ip,omitempty"`
	Dscp   string     `protobuf:"bytes,3,opt,name=dscp,proto3" json:"dscp,omitempty"`
	SpanId uint32     `protobuf:"varint,4,opt,name=span_id,json=spanId,proto3" json:"span_id,omitempty"`
}

func (m *ERSpanSpec) Reset()                    { *m = ERSpanSpec{} }
func (m *ERSpanSpec) String() string            { return proto.CompactTextString(m) }
func (*ERSpanSpec) ProtoMessage()               {}
func (*ERSpanSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{58} }

func (m *ERSpanSpec) GetDestIp() *IPAddress {
	if m != nil {
		return m.DestIp
	}
	return nil
}

func (m *ERSpanSpec) GetSrcIp() *IPAddress {
	if m != nil {
		return m.SrcIp
	}
	return nil
}

func (m *ERSpanSpec) GetDscp() string {
	if m != nil {
		return m.Dscp
	}
	return ""
}

func (m *ERSpanSpec) GetSpanId() uint32 {
	if m != nil {
		return m.SpanId
	}
	return 0
}

// MirrorSessionSpec is the configuration specification for mirror config
type MirrorSessionSpec struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *MirrorSessionKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key",venice:constraints={range:0-7}`
	Snaplen     uint32                  `protobuf:"varint,3,opt,name=snaplen,proto3" json:"snaplen,omitempty"`
	// Types that are valid to be assigned to Destination:
	//	*MirrorSessionSpec_LocalSpanIf
	//	*MirrorSessionSpec_RspanSpec
	//	*MirrorSessionSpec_ErspanSpec
	Destination isMirrorSessionSpec_Destination `protobuf_oneof:"destination"`
}

func (m *MirrorSessionSpec) Reset()                    { *m = MirrorSessionSpec{} }
func (m *MirrorSessionSpec) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionSpec) ProtoMessage()               {}
func (*MirrorSessionSpec) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{59} }

type isMirrorSessionSpec_Destination interface {
	isMirrorSessionSpec_Destination()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MirrorSessionSpec_LocalSpanIf struct {
	LocalSpanIf *InterfaceKeyHandle `protobuf:"bytes,4,opt,name=local_span_if,json=localSpanIf,oneof"`
}
type MirrorSessionSpec_RspanSpec struct {
	RspanSpec *RSpanSpec `protobuf:"bytes,5,opt,name=rspan_spec,json=rspanSpec,oneof"`
}
type MirrorSessionSpec_ErspanSpec struct {
	ErspanSpec *ERSpanSpec `protobuf:"bytes,6,opt,name=erspan_spec,json=erspanSpec,oneof"`
}

func (*MirrorSessionSpec_LocalSpanIf) isMirrorSessionSpec_Destination() {}
func (*MirrorSessionSpec_RspanSpec) isMirrorSessionSpec_Destination()   {}
func (*MirrorSessionSpec_ErspanSpec) isMirrorSessionSpec_Destination()  {}

func (m *MirrorSessionSpec) GetDestination() isMirrorSessionSpec_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *MirrorSessionSpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MirrorSessionSpec) GetKeyOrHandle() *MirrorSessionKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *MirrorSessionSpec) GetSnaplen() uint32 {
	if m != nil {
		return m.Snaplen
	}
	return 0
}

func (m *MirrorSessionSpec) GetLocalSpanIf() *InterfaceKeyHandle {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_LocalSpanIf); ok {
		return x.LocalSpanIf
	}
	return nil
}

func (m *MirrorSessionSpec) GetRspanSpec() *RSpanSpec {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_RspanSpec); ok {
		return x.RspanSpec
	}
	return nil
}

func (m *MirrorSessionSpec) GetErspanSpec() *ERSpanSpec {
	if x, ok := m.GetDestination().(*MirrorSessionSpec_ErspanSpec); ok {
		return x.ErspanSpec
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MirrorSessionSpec) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MirrorSessionSpec_OneofMarshaler, _MirrorSessionSpec_OneofUnmarshaler, _MirrorSessionSpec_OneofSizer, []interface{}{
		(*MirrorSessionSpec_LocalSpanIf)(nil),
		(*MirrorSessionSpec_RspanSpec)(nil),
		(*MirrorSessionSpec_ErspanSpec)(nil),
	}
}

func _MirrorSessionSpec_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MirrorSessionSpec)
	// destination
	switch x := m.Destination.(type) {
	case *MirrorSessionSpec_LocalSpanIf:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LocalSpanIf); err != nil {
			return err
		}
	case *MirrorSessionSpec_RspanSpec:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RspanSpec); err != nil {
			return err
		}
	case *MirrorSessionSpec_ErspanSpec:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ErspanSpec); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MirrorSessionSpec.Destination has unexpected type %T", x)
	}
	return nil
}

func _MirrorSessionSpec_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MirrorSessionSpec)
	switch tag {
	case 4: // destination.local_span_if
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InterfaceKeyHandle)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_LocalSpanIf{msg}
		return true, err
	case 5: // destination.rspan_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RSpanSpec)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_RspanSpec{msg}
		return true, err
	case 6: // destination.erspan_spec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ERSpanSpec)
		err := b.DecodeMessage(msg)
		m.Destination = &MirrorSessionSpec_ErspanSpec{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MirrorSessionSpec_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MirrorSessionSpec)
	// destination
	switch x := m.Destination.(type) {
	case *MirrorSessionSpec_LocalSpanIf:
		s := proto.Size(x.LocalSpanIf)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MirrorSessionSpec_RspanSpec:
		s := proto.Size(x.RspanSpec)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MirrorSessionSpec_ErspanSpec:
		s := proto.Size(x.ErspanSpec)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// MirrorSessionStatus is the operational status of the rule
type MirrorSessionStatus struct {
	Handle      uint64 `protobuf:"fixed64,1,opt,name=handle,proto3" json:"handle,omitempty"`
	ActiveFlows uint32 `protobuf:"varint,2,opt,name=active_flows,json=activeFlows,proto3" json:"active_flows,omitempty"`
}

func (m *MirrorSessionStatus) Reset()                    { *m = MirrorSessionStatus{} }
func (m *MirrorSessionStatus) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionStatus) ProtoMessage()               {}
func (*MirrorSessionStatus) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{60} }

func (m *MirrorSessionStatus) GetHandle() uint64 {
	if m != nil {
		return m.Handle
	}
	return 0
}

func (m *MirrorSessionStatus) GetActiveFlows() uint32 {
	if m != nil {
		return m.ActiveFlows
	}
	return 0
}

// MirrorSession is a container that holds both the configuration and the operational
// state of the mirrorsession
type MirrorSessionResponse struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *MirrorSessionStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *MirrorSessionResponse) Reset()                    { *m = MirrorSessionResponse{} }
func (m *MirrorSessionResponse) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionResponse) ProtoMessage()               {}
func (*MirrorSessionResponse) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{61} }

func (m *MirrorSessionResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSessionResponse) GetStatus() *MirrorSessionStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// MirrorSessionConfigsMsg is used in requests and is a batchable request message
type MirrorSessionRequestMsg struct {
	Request []*MirrorSessionSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *MirrorSessionRequestMsg) Reset()         { *m = MirrorSessionRequestMsg{} }
func (m *MirrorSessionRequestMsg) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionRequestMsg) ProtoMessage()    {}
func (*MirrorSessionRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{62}
}

func (m *MirrorSessionRequestMsg) GetRequest() []*MirrorSessionSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// MirrorSessionConfigsMsg message is used as response for API requests.
type MirrorSessionResponseMsg struct {
	Response []*MirrorSessionResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *MirrorSessionResponseMsg) Reset()         { *m = MirrorSessionResponseMsg{} }
func (m *MirrorSessionResponseMsg) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionResponseMsg) ProtoMessage()    {}
func (*MirrorSessionResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{63}
}

func (m *MirrorSessionResponseMsg) GetResponse() []*MirrorSessionResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// MirrorSessionDeleteRequest is used to delete a mirrorsession
type MirrorSessionDeleteRequest struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *MirrorSessionKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *MirrorSessionDeleteRequest) Reset()         { *m = MirrorSessionDeleteRequest{} }
func (m *MirrorSessionDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteRequest) ProtoMessage()    {}
func (*MirrorSessionDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{64}
}

func (m *MirrorSessionDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MirrorSessionDeleteRequest) GetKeyOrHandle() *MirrorSessionKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// MirrorSessionDeleteResponse is response to MirrorSessionDeleteRequest
type MirrorSessionDeleteResponse struct {
	ApiStatus   ApiStatus               `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	KeyOrHandle *MirrorSessionKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *MirrorSessionDeleteResponse) Reset()         { *m = MirrorSessionDeleteResponse{} }
func (m *MirrorSessionDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteResponse) ProtoMessage()    {}
func (*MirrorSessionDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{65}
}

func (m *MirrorSessionDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSessionDeleteResponse) GetKeyOrHandle() *MirrorSessionKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// MirrorSessionDeleteRequestMsg is used to delete a batch of mirrorsessions
type MirrorSessionDeleteRequestMsg struct {
	Request []*MirrorSessionDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *MirrorSessionDeleteRequestMsg) Reset()         { *m = MirrorSessionDeleteRequestMsg{} }
func (m *MirrorSessionDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteRequestMsg) ProtoMessage()    {}
func (*MirrorSessionDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{66}
}

func (m *MirrorSessionDeleteRequestMsg) GetRequest() []*MirrorSessionDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// MirrorSessionDeleteResponseMsg is batched response to MirrorSessionDeleteRequestMsg
type MirrorSessionDeleteResponseMsg struct {
	Response []*MirrorSessionDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *MirrorSessionDeleteResponseMsg) Reset()         { *m = MirrorSessionDeleteResponseMsg{} }
func (m *MirrorSessionDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionDeleteResponseMsg) ProtoMessage()    {}
func (*MirrorSessionDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{67}
}

func (m *MirrorSessionDeleteResponseMsg) GetResponse() []*MirrorSessionDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// MirrorSessionGetRequest is used to get information about a mirrorsession
type MirrorSessionGetRequest struct {
	Meta        *ObjectMeta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	KeyOrHandle *MirrorSessionKeyHandle `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:"key"`
}

func (m *MirrorSessionGetRequest) Reset()         { *m = MirrorSessionGetRequest{} }
func (m *MirrorSessionGetRequest) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionGetRequest) ProtoMessage()    {}
func (*MirrorSessionGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{68}
}

func (m *MirrorSessionGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *MirrorSessionGetRequest) GetKeyOrHandle() *MirrorSessionKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// MirrorSessionGetRequestMsg is batched GET requests for mirrorsessions
type MirrorSessionGetRequestMsg struct {
	Request []*MirrorSessionGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *MirrorSessionGetRequestMsg) Reset()         { *m = MirrorSessionGetRequestMsg{} }
func (m *MirrorSessionGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionGetRequestMsg) ProtoMessage()    {}
func (*MirrorSessionGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{69}
}

func (m *MirrorSessionGetRequestMsg) GetRequest() []*MirrorSessionGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type MirrorSessionStats struct {
}

func (m *MirrorSessionStats) Reset()                    { *m = MirrorSessionStats{} }
func (m *MirrorSessionStats) String() string            { return proto.CompactTextString(m) }
func (*MirrorSessionStats) ProtoMessage()               {}
func (*MirrorSessionStats) Descriptor() ([]byte, []int) { return fileDescriptorTelemetry, []int{70} }

type MirrorSessionGetResponse struct {
	ApiStatus ApiStatus           `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *MirrorSessionSpec  `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Stats     *MirrorSessionStats `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
}

func (m *MirrorSessionGetResponse) Reset()         { *m = MirrorSessionGetResponse{} }
func (m *MirrorSessionGetResponse) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionGetResponse) ProtoMessage()    {}
func (*MirrorSessionGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{71}
}

func (m *MirrorSessionGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *MirrorSessionGetResponse) GetSpec() *MirrorSessionSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *MirrorSessionGetResponse) GetStats() *MirrorSessionStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// MirrorSessionGetResponseMsg is batched response to MirrorSessionGetRequestMsg
type MirrorSessionGetResponseMsg struct {
	Response []*MirrorSessionGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *MirrorSessionGetResponseMsg) Reset()         { *m = MirrorSessionGetResponseMsg{} }
func (m *MirrorSessionGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*MirrorSessionGetResponseMsg) ProtoMessage()    {}
func (*MirrorSessionGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorTelemetry, []int{72}
}

func (m *MirrorSessionGetResponseMsg) GetResponse() []*MirrorSessionGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectorSpec)(nil), "telemetry.CollectorSpec")
	proto.RegisterType((*CollectorStatus)(nil), "telemetry.CollectorStatus")
	proto.RegisterType((*CollectorResponse)(nil), "telemetry.CollectorResponse")
	proto.RegisterType((*CollectorRequestMsg)(nil), "telemetry.CollectorRequestMsg")
	proto.RegisterType((*CollectorResponseMsg)(nil), "telemetry.CollectorResponseMsg")
	proto.RegisterType((*CollectorDeleteRequest)(nil), "telemetry.CollectorDeleteRequest")
	proto.RegisterType((*CollectorDeleteResponse)(nil), "telemetry.CollectorDeleteResponse")
	proto.RegisterType((*CollectorDeleteRequestMsg)(nil), "telemetry.CollectorDeleteRequestMsg")
	proto.RegisterType((*CollectorDeleteResponseMsg)(nil), "telemetry.CollectorDeleteResponseMsg")
	proto.RegisterType((*CollectorGetRequest)(nil), "telemetry.CollectorGetRequest")
	proto.RegisterType((*CollectorGetRequestMsg)(nil), "telemetry.CollectorGetRequestMsg")
	proto.RegisterType((*CollectorStats)(nil), "telemetry.CollectorStats")
	proto.RegisterType((*CollectorGetResponse)(nil), "telemetry.CollectorGetResponse")
	proto.RegisterType((*CollectorGetResponseMsg)(nil), "telemetry.CollectorGetResponseMsg")
	proto.RegisterType((*ExportControlSpec)(nil), "telemetry.ExportControlSpec")
	proto.RegisterType((*ExportControlStatus)(nil), "telemetry.ExportControlStatus")
	proto.RegisterType((*ExportControlResponse)(nil), "telemetry.ExportControlResponse")
	proto.RegisterType((*ExportControlRequestMsg)(nil), "telemetry.ExportControlRequestMsg")
	proto.RegisterType((*ExportControlResponseMsg)(nil), "telemetry.ExportControlResponseMsg")
	proto.RegisterType((*ExportControlDeleteRequest)(nil), "telemetry.ExportControlDeleteRequest")
	proto.RegisterType((*ExportControlDeleteResponse)(nil), "telemetry.ExportControlDeleteResponse")
	proto.RegisterType((*ExportControlDeleteRequestMsg)(nil), "telemetry.ExportControlDeleteRequestMsg")
	proto.RegisterType((*ExportControlDeleteResponseMsg)(nil), "telemetry.ExportControlDeleteResponseMsg")
	proto.RegisterType((*ExportControlGetRequest)(nil), "telemetry.ExportControlGetRequest")
	proto.RegisterType((*ExportControlGetRequestMsg)(nil), "telemetry.ExportControlGetRequestMsg")
	proto.RegisterType((*ExportControlStats)(nil), "telemetry.ExportControlStats")
	proto.RegisterType((*ExportControlGetResponse)(nil), "telemetry.ExportControlGetResponse")
	proto.RegisterType((*ExportControlGetResponseMsg)(nil), "telemetry.ExportControlGetResponseMsg")
	proto.RegisterType((*MonitorAction)(nil), "telemetry.MonitorAction")
	proto.RegisterType((*FlowMonitorRuleSpec)(nil), "telemetry.FlowMonitorRuleSpec")
	proto.RegisterType((*FlowMonitorRuleStatus)(nil), "telemetry.FlowMonitorRuleStatus")
	proto.RegisterType((*FlowMonitorRuleResponse)(nil), "telemetry.FlowMonitorRuleResponse")
	proto.RegisterType((*FlowMonitorRuleRequestMsg)(nil), "telemetry.FlowMonitorRuleRequestMsg")
	proto.RegisterType((*FlowMonitorRuleResponseMsg)(nil), "telemetry.FlowMonitorRuleResponseMsg")
	proto.RegisterType((*FlowMonitorRuleDeleteRequest)(nil), "telemetry.FlowMonitorRuleDeleteRequest")
	proto.RegisterType((*FlowMonitorRuleDeleteResponse)(nil), "telemetry.FlowMonitorRuleDeleteResponse")
	proto.RegisterType((*FlowMonitorRuleDeleteRequestMsg)(nil), "telemetry.FlowMonitorRuleDeleteRequestMsg")
	proto.RegisterType((*FlowMonitorRuleDeleteResponseMsg)(nil), "telemetry.FlowMonitorRuleDeleteResponseMsg")
	proto.RegisterType((*FlowMonitorRuleGetRequest)(nil), "telemetry.FlowMonitorRuleGetRequest")
	proto.RegisterType((*FlowMonitorRuleGetRequestMsg)(nil), "telemetry.FlowMonitorRuleGetRequestMsg")
	proto.RegisterType((*FlowMonitorRuleStats)(nil), "telemetry.FlowMonitorRuleStats")
	proto.RegisterType((*FlowMonitorRuleGetResponse)(nil), "telemetry.FlowMonitorRuleGetResponse")
	proto.RegisterType((*FlowMonitorRuleGetResponseMsg)(nil), "telemetry.FlowMonitorRuleGetResponseMsg")
	proto.RegisterType((*DropMonitorRuleSpec)(nil), "telemetry.DropMonitorRuleSpec")
	proto.RegisterType((*DropMonitorRuleStatus)(nil), "telemetry.DropMonitorRuleStatus")
	proto.RegisterType((*DropMonitorRuleResponse)(nil), "telemetry.DropMonitorRuleResponse")
	proto.RegisterType((*DropMonitorRuleRequestMsg)(nil), "telemetry.DropMonitorRuleRequestMsg")
	proto.RegisterType((*DropMonitorRuleResponseMsg)(nil), "telemetry.DropMonitorRuleResponseMsg")
	proto.RegisterType((*DropMonitorRuleDeleteRequest)(nil), "telemetry.DropMonitorRuleDeleteRequest")
	proto.RegisterType((*DropMonitorRuleDeleteResponse)(nil), "telemetry.DropMonitorRuleDeleteResponse")
	proto.RegisterType((*DropMonitorRuleDeleteRequestMsg)(nil), "telemetry.DropMonitorRuleDeleteRequestMsg")
	proto.RegisterType((*DropMonitorRuleDeleteResponseMsg)(nil), "telemetry.DropMonitorRuleDeleteResponseMsg")
	proto.RegisterType((*DropMonitorRuleGetRequest)(nil), "telemetry.DropMonitorRuleGetRequest")
	proto.RegisterType((*DropMonitorRuleGetRequestMsg)(nil), "telemetry.DropMonitorRuleGetRequestMsg")
	proto.RegisterType((*DropMonitorRuleStats)(nil), "telemetry.DropMonitorRuleStats")
	proto.RegisterType((*DropMonitorRuleGetResponse)(nil), "telemetry.DropMonitorRuleGetResponse")
	proto.RegisterType((*DropMonitorRuleGetResponseMsg)(nil), "telemetry.DropMonitorRuleGetResponseMsg")
	proto.RegisterType((*RSpanSpec)(nil), "telemetry.RSpanSpec")
	proto.RegisterType((*ERSpanSpec)(nil), "telemetry.ERSpanSpec")
	proto.RegisterType((*MirrorSessionSpec)(nil), "telemetry.MirrorSessionSpec")
	proto.RegisterType((*MirrorSessionStatus)(nil), "telemetry.MirrorSessionStatus")
	proto.RegisterType((*MirrorSessionResponse)(nil), "telemetry.MirrorSessionResponse")
	proto.RegisterType((*MirrorSessionRequestMsg)(nil), "telemetry.MirrorSessionRequestMsg")
	proto.RegisterType((*MirrorSessionResponseMsg)(nil), "telemetry.MirrorSessionResponseMsg")
	proto.RegisterType((*MirrorSessionDeleteRequest)(nil), "telemetry.MirrorSessionDeleteRequest")
	proto.RegisterType((*MirrorSessionDeleteResponse)(nil), "telemetry.MirrorSessionDeleteResponse")
	proto.RegisterType((*MirrorSessionDeleteRequestMsg)(nil), "telemetry.MirrorSessionDeleteRequestMsg")
	proto.RegisterType((*MirrorSessionDeleteResponseMsg)(nil), "telemetry.MirrorSessionDeleteResponseMsg")
	proto.RegisterType((*MirrorSessionGetRequest)(nil), "telemetry.MirrorSessionGetRequest")
	proto.RegisterType((*MirrorSessionGetRequestMsg)(nil), "telemetry.MirrorSessionGetRequestMsg")
	proto.RegisterType((*MirrorSessionStats)(nil), "telemetry.MirrorSessionStats")
	proto.RegisterType((*MirrorSessionGetResponse)(nil), "telemetry.MirrorSessionGetResponse")
	proto.RegisterType((*MirrorSessionGetResponseMsg)(nil), "telemetry.MirrorSessionGetResponseMsg")
	proto.RegisterEnum("telemetry.ExportFormat", ExportFormat_name, ExportFormat_value)
	proto.RegisterEnum("telemetry.RuleAction", RuleAction_name, RuleAction_value)
	proto.RegisterEnum("telemetry.AggregationScheme", AggregationScheme_name, AggregationScheme_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Telemetry service

type TelemetryClient interface {
	// Collector operations CRUD operations
	CollectorCreate(ctx context.Context, in *CollectorRequestMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorUpdate(ctx context.Context, in *CollectorRequestMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error)
	CollectorDelete(ctx context.Context, in *CollectorDeleteRequestMsg, opts ...grpc.CallOption) (*CollectorDeleteResponseMsg, error)
	CollectorGet(ctx context.Context, in *CollectorGetRequestMsg, opts ...grpc.CallOption) (*CollectorGetResponseMsg, error)
	// ExportConfig CRUD operations
	ExportControlCreate(ctx context.Context, in *ExportControlRequestMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlUpdate(ctx context.Context, in *ExportControlRequestMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error)
	ExportControlDelete(ctx context.Context, in *ExportControlDeleteRequestMsg, opts ...grpc.CallOption) (*ExportControlDeleteResponseMsg, error)
	ExportControlGet(ctx context.Context, in *ExportControlGetRequestMsg, opts ...grpc.CallOption) (*ExportControlGetResponseMsg, error)
	// FlowMonitorRules CRUD Operations
	FlowMonitorRuleCreate(ctx context.Context, in *FlowMonitorRuleRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleUpdate(ctx context.Context, in *FlowMonitorRuleRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleDelete(ctx context.Context, in *FlowMonitorRuleDeleteRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleDeleteResponseMsg, error)
	FlowMonitorRuleGet(ctx context.Context, in *FlowMonitorRuleGetRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleGetResponseMsg, error)
	// DropMonitorRules CRUD Operations
	DropMonitorRuleCreate(ctx context.Context, in *DropMonitorRuleRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleResponseMsg, error)
	DropMonitorRuleUpdate(ctx context.Context, in *DropMonitorRuleRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleResponseMsg, error)
	DropMonitorRuleDelete(ctx context.Context, in *DropMonitorRuleDeleteRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleDeleteResponseMsg, error)
	DropMonitorRuleGet(ctx context.Context, in *DropMonitorRuleGetRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleGetResponseMsg, error)
	// MirrorSession CRUD Operations
	MirrorSessionCreate(ctx context.Context, in *MirrorSessionRequestMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionUpdate(ctx context.Context, in *MirrorSessionRequestMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error)
	MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteRequestMsg, opts ...grpc.CallOption) (*MirrorSessionDeleteResponseMsg, error)
	MirrorSessionGet(ctx context.Context, in *MirrorSessionGetRequestMsg, opts ...grpc.CallOption) (*MirrorSessionGetResponseMsg, error)
}

type telemetryClient struct {
	cc *grpc.ClientConn
}

func NewTelemetryClient(cc *grpc.ClientConn) TelemetryClient {
	return &telemetryClient{cc}
}

func (c *telemetryClient) CollectorCreate(ctx context.Context, in *CollectorRequestMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorUpdate(ctx context.Context, in *CollectorRequestMsg, opts ...grpc.CallOption) (*CollectorResponseMsg, error) {
	out := new(CollectorResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorDelete(ctx context.Context, in *CollectorDeleteRequestMsg, opts ...grpc.CallOption) (*CollectorDeleteResponseMsg, error) {
	out := new(CollectorDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) CollectorGet(ctx context.Context, in *CollectorGetRequestMsg, opts ...grpc.CallOption) (*CollectorGetResponseMsg, error) {
	out := new(CollectorGetResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/CollectorGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlCreate(ctx context.Context, in *ExportControlRequestMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlUpdate(ctx context.Context, in *ExportControlRequestMsg, opts ...grpc.CallOption) (*ExportControlResponseMsg, error) {
	out := new(ExportControlResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlDelete(ctx context.Context, in *ExportControlDeleteRequestMsg, opts ...grpc.CallOption) (*ExportControlDeleteResponseMsg, error) {
	out := new(ExportControlDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) ExportControlGet(ctx context.Context, in *ExportControlGetRequestMsg, opts ...grpc.CallOption) (*ExportControlGetResponseMsg, error) {
	out := new(ExportControlGetResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/ExportControlGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleCreate(ctx context.Context, in *FlowMonitorRuleRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleUpdate(ctx context.Context, in *FlowMonitorRuleRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleResponseMsg, error) {
	out := new(FlowMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleDelete(ctx context.Context, in *FlowMonitorRuleDeleteRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleDeleteResponseMsg, error) {
	out := new(FlowMonitorRuleDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) FlowMonitorRuleGet(ctx context.Context, in *FlowMonitorRuleGetRequestMsg, opts ...grpc.CallOption) (*FlowMonitorRuleGetResponseMsg, error) {
	out := new(FlowMonitorRuleGetResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/FlowMonitorRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) DropMonitorRuleCreate(ctx context.Context, in *DropMonitorRuleRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleResponseMsg, error) {
	out := new(DropMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/DropMonitorRuleCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) DropMonitorRuleUpdate(ctx context.Context, in *DropMonitorRuleRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleResponseMsg, error) {
	out := new(DropMonitorRuleResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/DropMonitorRuleUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) DropMonitorRuleDelete(ctx context.Context, in *DropMonitorRuleDeleteRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleDeleteResponseMsg, error) {
	out := new(DropMonitorRuleDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/DropMonitorRuleDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) DropMonitorRuleGet(ctx context.Context, in *DropMonitorRuleGetRequestMsg, opts ...grpc.CallOption) (*DropMonitorRuleGetResponseMsg, error) {
	out := new(DropMonitorRuleGetResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/DropMonitorRuleGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionCreate(ctx context.Context, in *MirrorSessionRequestMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionUpdate(ctx context.Context, in *MirrorSessionRequestMsg, opts ...grpc.CallOption) (*MirrorSessionResponseMsg, error) {
	out := new(MirrorSessionResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionDelete(ctx context.Context, in *MirrorSessionDeleteRequestMsg, opts ...grpc.CallOption) (*MirrorSessionDeleteResponseMsg, error) {
	out := new(MirrorSessionDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemetryClient) MirrorSessionGet(ctx context.Context, in *MirrorSessionGetRequestMsg, opts ...grpc.CallOption) (*MirrorSessionGetResponseMsg, error) {
	out := new(MirrorSessionGetResponseMsg)
	err := grpc.Invoke(ctx, "/telemetry.Telemetry/MirrorSessionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Telemetry service

type TelemetryServer interface {
	// Collector operations CRUD operations
	CollectorCreate(context.Context, *CollectorRequestMsg) (*CollectorResponseMsg, error)
	CollectorUpdate(context.Context, *CollectorRequestMsg) (*CollectorResponseMsg, error)
	CollectorDelete(context.Context, *CollectorDeleteRequestMsg) (*CollectorDeleteResponseMsg, error)
	CollectorGet(context.Context, *CollectorGetRequestMsg) (*CollectorGetResponseMsg, error)
	// ExportConfig CRUD operations
	ExportControlCreate(context.Context, *ExportControlRequestMsg) (*ExportControlResponseMsg, error)
	ExportControlUpdate(context.Context, *ExportControlRequestMsg) (*ExportControlResponseMsg, error)
	ExportControlDelete(context.Context, *ExportControlDeleteRequestMsg) (*ExportControlDeleteResponseMsg, error)
	ExportControlGet(context.Context, *ExportControlGetRequestMsg) (*ExportControlGetResponseMsg, error)
	// FlowMonitorRules CRUD Operations
	FlowMonitorRuleCreate(context.Context, *FlowMonitorRuleRequestMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleUpdate(context.Context, *FlowMonitorRuleRequestMsg) (*FlowMonitorRuleResponseMsg, error)
	FlowMonitorRuleDelete(context.Context, *FlowMonitorRuleDeleteRequestMsg) (*FlowMonitorRuleDeleteResponseMsg, error)
	FlowMonitorRuleGet(context.Context, *FlowMonitorRuleGetRequestMsg) (*FlowMonitorRuleGetResponseMsg, error)
	// DropMonitorRules CRUD Operations
	DropMonitorRuleCreate(context.Context, *DropMonitorRuleRequestMsg) (*DropMonitorRuleResponseMsg, error)
	DropMonitorRuleUpdate(context.Context, *DropMonitorRuleRequestMsg) (*DropMonitorRuleResponseMsg, error)
	DropMonitorRuleDelete(context.Context, *DropMonitorRuleDeleteRequestMsg) (*DropMonitorRuleDeleteResponseMsg, error)
	DropMonitorRuleGet(context.Context, *DropMonitorRuleGetRequestMsg) (*DropMonitorRuleGetResponseMsg, error)
	// MirrorSession CRUD Operations
	MirrorSessionCreate(context.Context, *MirrorSessionRequestMsg) (*MirrorSessionResponseMsg, error)
	MirrorSessionUpdate(context.Context, *MirrorSessionRequestMsg) (*MirrorSessionResponseMsg, error)
	MirrorSessionDelete(context.Context, *MirrorSessionDeleteRequestMsg) (*MirrorSessionDeleteResponseMsg, error)
	MirrorSessionGet(context.Context, *MirrorSessionGetRequestMsg) (*MirrorSessionGetResponseMsg, error)
}

func RegisterTelemetryServer(s *grpc.Server, srv TelemetryServer) {
	s.RegisterService(&_Telemetry_serviceDesc, srv)
}

func _Telemetry_CollectorCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorCreate(ctx, req.(*CollectorRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorUpdate(ctx, req.(*CollectorRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorDelete(ctx, req.(*CollectorDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_CollectorGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectorGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).CollectorGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/CollectorGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).CollectorGet(ctx, req.(*CollectorGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlCreate(ctx, req.(*ExportControlRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlUpdate(ctx, req.(*ExportControlRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlDelete(ctx, req.(*ExportControlDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_ExportControlGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportControlGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).ExportControlGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/ExportControlGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).ExportControlGet(ctx, req.(*ExportControlGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleCreate(ctx, req.(*FlowMonitorRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleUpdate(ctx, req.(*FlowMonitorRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleDelete(ctx, req.(*FlowMonitorRuleDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_FlowMonitorRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlowMonitorRuleGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).FlowMonitorRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/FlowMonitorRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).FlowMonitorRuleGet(ctx, req.(*FlowMonitorRuleGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_DropMonitorRuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropMonitorRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).DropMonitorRuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/DropMonitorRuleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).DropMonitorRuleCreate(ctx, req.(*DropMonitorRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_DropMonitorRuleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropMonitorRuleRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).DropMonitorRuleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/DropMonitorRuleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).DropMonitorRuleUpdate(ctx, req.(*DropMonitorRuleRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_DropMonitorRuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropMonitorRuleDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).DropMonitorRuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/DropMonitorRuleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).DropMonitorRuleDelete(ctx, req.(*DropMonitorRuleDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_DropMonitorRuleGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropMonitorRuleGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).DropMonitorRuleGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/DropMonitorRuleGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).DropMonitorRuleGet(ctx, req.(*DropMonitorRuleGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionCreate(ctx, req.(*MirrorSessionRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionUpdate(ctx, req.(*MirrorSessionRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionDelete(ctx, req.(*MirrorSessionDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Telemetry_MirrorSessionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSessionGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemetryServer).MirrorSessionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/telemetry.Telemetry/MirrorSessionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemetryServer).MirrorSessionGet(ctx, req.(*MirrorSessionGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Telemetry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "telemetry.Telemetry",
	HandlerType: (*TelemetryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CollectorCreate",
			Handler:    _Telemetry_CollectorCreate_Handler,
		},
		{
			MethodName: "CollectorUpdate",
			Handler:    _Telemetry_CollectorUpdate_Handler,
		},
		{
			MethodName: "CollectorDelete",
			Handler:    _Telemetry_CollectorDelete_Handler,
		},
		{
			MethodName: "CollectorGet",
			Handler:    _Telemetry_CollectorGet_Handler,
		},
		{
			MethodName: "ExportControlCreate",
			Handler:    _Telemetry_ExportControlCreate_Handler,
		},
		{
			MethodName: "ExportControlUpdate",
			Handler:    _Telemetry_ExportControlUpdate_Handler,
		},
		{
			MethodName: "ExportControlDelete",
			Handler:    _Telemetry_ExportControlDelete_Handler,
		},
		{
			MethodName: "ExportControlGet",
			Handler:    _Telemetry_ExportControlGet_Handler,
		},
		{
			MethodName: "FlowMonitorRuleCreate",
			Handler:    _Telemetry_FlowMonitorRuleCreate_Handler,
		},
		{
			MethodName: "FlowMonitorRuleUpdate",
			Handler:    _Telemetry_FlowMonitorRuleUpdate_Handler,
		},
		{
			MethodName: "FlowMonitorRuleDelete",
			Handler:    _Telemetry_FlowMonitorRuleDelete_Handler,
		},
		{
			MethodName: "FlowMonitorRuleGet",
			Handler:    _Telemetry_FlowMonitorRuleGet_Handler,
		},
		{
			MethodName: "DropMonitorRuleCreate",
			Handler:    _Telemetry_DropMonitorRuleCreate_Handler,
		},
		{
			MethodName: "DropMonitorRuleUpdate",
			Handler:    _Telemetry_DropMonitorRuleUpdate_Handler,
		},
		{
			MethodName: "DropMonitorRuleDelete",
			Handler:    _Telemetry_DropMonitorRuleDelete_Handler,
		},
		{
			MethodName: "DropMonitorRuleGet",
			Handler:    _Telemetry_DropMonitorRuleGet_Handler,
		},
		{
			MethodName: "MirrorSessionCreate",
			Handler:    _Telemetry_MirrorSessionCreate_Handler,
		},
		{
			MethodName: "MirrorSessionUpdate",
			Handler:    _Telemetry_MirrorSessionUpdate_Handler,
		},
		{
			MethodName: "MirrorSessionDelete",
			Handler:    _Telemetry_MirrorSessionDelete_Handler,
		},
		{
			MethodName: "MirrorSessionGet",
			Handler:    _Telemetry_MirrorSessionGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "telemetry.proto",
}

func (m *CollectorSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n1, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n2, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Encap != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Encap.Size()))
		n3, err := m.Encap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.L2SegKeyHandle != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.L2SegKeyHandle.Size()))
		n4, err := m.L2SegKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.DestIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestIp.Size()))
		n5, err := m.DestIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.SrcIp != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SrcIp.Size()))
		n6, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Protocol))
	}
	if m.DestPort != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestPort))
	}
	if m.Format != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Format))
	}
	if m.TemplateId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.TemplateId))
	}
	return i, nil
}

func (m *CollectorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	return i, nil
}

func (m *CollectorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n7, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *CollectorRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CollectorResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CollectorDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n8, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n9, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *CollectorDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n10, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *CollectorDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CollectorDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CollectorGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n11, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n12, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *CollectorGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CollectorStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CollectorGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n13, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Stats.Size()))
		n14, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *CollectorGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CollectorGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n15, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n16, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.CollectorKeyHandle) > 0 {
		for _, msg := range m.CollectorKeyHandle {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ActiveTimeout != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ActiveTimeout))
	}
	if m.InactiveTimeout != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.InactiveTimeout))
	}
	return i, nil
}

func (m *ExportControlStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	return i, nil
}

func (m *ExportControlResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n17, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *ExportControlRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n18, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n19, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *ExportControlDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n20, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *ExportControlDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n21, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n22, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *ExportControlGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ExportControlStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ExportControlGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n23, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Stats.Size()))
		n24, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *ExportControlGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportControlGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MonitorAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitorAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Action) > 0 {
		dAtA26 := make([]byte, len(m.Action)*10)
		var j25 int
		for _, num := range m.Action {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if len(m.AggScheme) > 0 {
		dAtA28 := make([]byte, len(m.AggScheme)*10)
		var j27 int
		for _, num := range m.AggScheme {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	if len(m.MirrorDestinations) > 0 {
		dAtA30 := make([]byte, len(m.MirrorDestinations)*10)
		var j29 int
		for _, num := range m.MirrorDestinations {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(j29))
		i += copy(dAtA[i:], dAtA30[:j29])
	}
	return i, nil
}

func (m *FlowMonitorRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n31, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n32, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.EcKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.EcKeyHandle.Size()))
		n33, err := m.EcKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.SourceMac != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SourceMac))
	}
	if m.DestMac != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestMac))
	}
	if m.Ethertype != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Ethertype))
	}
	if m.Protocol != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Protocol))
	}
	if m.SourceIp != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SourceIp.Size()))
		n34, err := m.SourceIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.DestIp != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestIp.Size()))
		n35, err := m.DestIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.SourceL4Port != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SourceL4Port))
	}
	if m.DestL4Port != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestL4Port))
	}
	if m.SourceGroupid != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SourceGroupid))
	}
	if m.DestGroupid != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestGroupid))
	}
	if m.Action != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Action.Size()))
		n36, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *FlowMonitorRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	if m.ActiveFlows != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ActiveFlows))
	}
	return i, nil
}

func (m *FlowMonitorRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n37, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *FlowMonitorRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowMonitorRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowMonitorRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n38, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n39, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *FlowMonitorRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n40, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *FlowMonitorRuleDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowMonitorRuleDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowMonitorRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n41, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n42, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *FlowMonitorRuleGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FlowMonitorRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FlowMonitorRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n43, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Stats.Size()))
		n44, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *FlowMonitorRuleGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowMonitorRuleGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DropMonitorRuleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n45, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n46, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.MsKeyHandle) > 0 {
		for _, msg := range m.MsKeyHandle {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Reasons != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Reasons.Size()))
		n47, err := m.Reasons.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *DropMonitorRuleStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	if m.ActiveFlows != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ActiveFlows))
	}
	return i, nil
}

func (m *DropMonitorRuleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n48, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *DropMonitorRuleRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DropMonitorRuleResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DropMonitorRuleDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n49, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n50, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func (m *DropMonitorRuleDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n51, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *DropMonitorRuleDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DropMonitorRuleDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DropMonitorRuleGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n52, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n53, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}

func (m *DropMonitorRuleGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DropMonitorRuleStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DropMonitorRuleGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n54, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Stats.Size()))
		n55, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *DropMonitorRuleGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropMonitorRuleGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RSpanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RSpanSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Intf != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Intf.Size()))
		n56, err := m.Intf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.RspanEncap != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RspanEncap.Size()))
		n57, err := m.RspanEncap.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	return i, nil
}

func (m *ERSpanSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERSpanSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DestIp != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.DestIp.Size()))
		n58, err := m.DestIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.SrcIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SrcIp.Size()))
		n59, err := m.SrcIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.Dscp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Dscp)))
		i += copy(dAtA[i:], m.Dscp)
	}
	if m.SpanId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.SpanId))
	}
	return i, nil
}

func (m *MirrorSessionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n60, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n61, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.Snaplen != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Snaplen))
	}
	if m.Destination != nil {
		nn62, err := m.Destination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn62
	}
	return i, nil
}

func (m *MirrorSessionSpec_LocalSpanIf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LocalSpanIf != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.LocalSpanIf.Size()))
		n63, err := m.LocalSpanIf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}
func (m *MirrorSessionSpec_RspanSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RspanSpec != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.RspanSpec.Size()))
		n64, err := m.RspanSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}
func (m *MirrorSessionSpec_ErspanSpec) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ErspanSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ErspanSpec.Size()))
		n65, err := m.ErspanSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}
func (m *MirrorSessionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Handle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.Handle))
		i += 8
	}
	if m.ActiveFlows != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ActiveFlows))
	}
	return i, nil
}

func (m *MirrorSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Status.Size()))
		n66, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}

func (m *MirrorSessionRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n67, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n68, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *MirrorSessionDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n69, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}

func (m *MirrorSessionDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Meta.Size()))
		n70, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n71, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}

func (m *MirrorSessionGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MirrorSessionStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MirrorSessionGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Spec.Size()))
		n72, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Stats.Size()))
		n73, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *MirrorSessionGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MirrorSessionGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTelemetry(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CollectorSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Encap != nil {
		l = m.Encap.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.L2SegKeyHandle != nil {
		l = m.L2SegKeyHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DestIp != nil {
		l = m.DestIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Protocol != 0 {
		n += 1 + sovTelemetry(uint64(m.Protocol))
	}
	if m.DestPort != 0 {
		n += 1 + sovTelemetry(uint64(m.DestPort))
	}
	if m.Format != 0 {
		n += 1 + sovTelemetry(uint64(m.Format))
	}
	if m.TemplateId != 0 {
		n += 1 + sovTelemetry(uint64(m.TemplateId))
	}
	return n
}

func (m *CollectorStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *CollectorResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *CollectorRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *CollectorResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *CollectorDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *CollectorDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *CollectorDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *CollectorDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *CollectorGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *CollectorGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *CollectorStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CollectorGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *CollectorGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.CollectorKeyHandle) > 0 {
		for _, e := range m.CollectorKeyHandle {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.ActiveTimeout != 0 {
		n += 1 + sovTelemetry(uint64(m.ActiveTimeout))
	}
	if m.InactiveTimeout != 0 {
		n += 1 + sovTelemetry(uint64(m.InactiveTimeout))
	}
	return n
}

func (m *ExportControlStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	return n
}

func (m *ExportControlResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ExportControlRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ExportControlDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ExportControlDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ExportControlGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *ExportControlStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ExportControlGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ExportControlGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MonitorAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Action) > 0 {
		l = 0
		for _, e := range m.Action {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	if len(m.AggScheme) > 0 {
		l = 0
		for _, e := range m.AggScheme {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	if len(m.MirrorDestinations) > 0 {
		l = 0
		for _, e := range m.MirrorDestinations {
			l += sovTelemetry(uint64(e))
		}
		n += 1 + sovTelemetry(uint64(l)) + l
	}
	return n
}

func (m *FlowMonitorRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.EcKeyHandle != nil {
		l = m.EcKeyHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SourceMac != 0 {
		n += 1 + sovTelemetry(uint64(m.SourceMac))
	}
	if m.DestMac != 0 {
		n += 1 + sovTelemetry(uint64(m.DestMac))
	}
	if m.Ethertype != 0 {
		n += 1 + sovTelemetry(uint64(m.Ethertype))
	}
	if m.Protocol != 0 {
		n += 1 + sovTelemetry(uint64(m.Protocol))
	}
	if m.SourceIp != nil {
		l = m.SourceIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DestIp != nil {
		l = m.DestIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SourceL4Port != 0 {
		n += 1 + sovTelemetry(uint64(m.SourceL4Port))
	}
	if m.DestL4Port != 0 {
		n += 1 + sovTelemetry(uint64(m.DestL4Port))
	}
	if m.SourceGroupid != 0 {
		n += 1 + sovTelemetry(uint64(m.SourceGroupid))
	}
	if m.DestGroupid != 0 {
		n += 1 + sovTelemetry(uint64(m.DestGroupid))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	if m.ActiveFlows != 0 {
		n += 1 + sovTelemetry(uint64(m.ActiveFlows))
	}
	return n
}

func (m *FlowMonitorRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowMonitorRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowMonitorRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowMonitorRuleDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowMonitorRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *FlowMonitorRuleStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FlowMonitorRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *FlowMonitorRuleGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *DropMonitorRuleSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.MsKeyHandle) > 0 {
		for _, e := range m.MsKeyHandle {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.Reasons != nil {
		l = m.Reasons.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *DropMonitorRuleStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	if m.ActiveFlows != 0 {
		n += 1 + sovTelemetry(uint64(m.ActiveFlows))
	}
	return n
}

func (m *DropMonitorRuleResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *DropMonitorRuleRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *DropMonitorRuleResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *DropMonitorRuleDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *DropMonitorRuleDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *DropMonitorRuleDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *DropMonitorRuleDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *DropMonitorRuleGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *DropMonitorRuleGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *DropMonitorRuleStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DropMonitorRuleGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *DropMonitorRuleGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *RSpanSpec) Size() (n int) {
	var l int
	_ = l
	if m.Intf != nil {
		l = m.Intf.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.RspanEncap != nil {
		l = m.RspanEncap.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *ERSpanSpec) Size() (n int) {
	var l int
	_ = l
	if m.DestIp != nil {
		l = m.DestIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SrcIp != nil {
		l = m.SrcIp.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.Dscp)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.SpanId != 0 {
		n += 1 + sovTelemetry(uint64(m.SpanId))
	}
	return n
}

func (m *MirrorSessionSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Snaplen != 0 {
		n += 1 + sovTelemetry(uint64(m.Snaplen))
	}
	if m.Destination != nil {
		n += m.Destination.Size()
	}
	return n
}

func (m *MirrorSessionSpec_LocalSpanIf) Size() (n int) {
	var l int
	_ = l
	if m.LocalSpanIf != nil {
		l = m.LocalSpanIf.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *MirrorSessionSpec_RspanSpec) Size() (n int) {
	var l int
	_ = l
	if m.RspanSpec != nil {
		l = m.RspanSpec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *MirrorSessionSpec_ErspanSpec) Size() (n int) {
	var l int
	_ = l
	if m.ErspanSpec != nil {
		l = m.ErspanSpec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *MirrorSessionStatus) Size() (n int) {
	var l int
	_ = l
	if m.Handle != 0 {
		n += 9
	}
	if m.ActiveFlows != 0 {
		n += 1 + sovTelemetry(uint64(m.ActiveFlows))
	}
	return n
}

func (m *MirrorSessionResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *MirrorSessionRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *MirrorSessionDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *MirrorSessionDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *MirrorSessionGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func (m *MirrorSessionStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MirrorSessionGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovTelemetry(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}

func (m *MirrorSessionGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectorSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CollectorKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Encap == nil {
				m.Encap = &EncapInfo{}
			}
			if err := m.Encap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L2SegKeyHandle == nil {
				m.L2SegKeyHandle = &L2SegmentKeyHandle{}
			}
			if err := m.L2SegKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestIp == nil {
				m.DestIp = &IPAddress{}
			}
			if err := m.DestIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPort", wireType)
			}
			m.DestPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			m.Format = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Format |= (ExportFormat(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateId", wireType)
			}
			m.TemplateId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemplateId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CollectorStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CollectorSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CollectorResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CollectorKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CollectorKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CollectorDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CollectorDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &CollectorKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &CollectorGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CollectorSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &CollectorStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &CollectorGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &ExportControlKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CollectorKeyHandle = append(m.CollectorKeyHandle, &CollectorKeyHandle{})
			if err := m.CollectorKeyHandle[len(m.CollectorKeyHandle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTimeout", wireType)
			}
			m.ActiveTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InactiveTimeout", wireType)
			}
			m.InactiveTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InactiveTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ExportControlStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &ExportControlSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &ExportControlResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &ExportControlKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &ExportControlKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &ExportControlDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &ExportControlDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &ExportControlKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &ExportControlGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ExportControlSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ExportControlStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportControlGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportControlGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportControlGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &ExportControlGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitorAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitorAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitorAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v RuleAction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (RuleAction(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Action = append(m.Action, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v RuleAction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (RuleAction(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Action = append(m.Action, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
		case 2:
			if wireType == 0 {
				var v AggregationScheme
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (AggregationScheme(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AggScheme = append(m.AggScheme, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v AggregationScheme
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (AggregationScheme(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AggScheme = append(m.AggScheme, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AggScheme", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MirrorDestinations = append(m.MirrorDestinations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTelemetry
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MirrorDestinations = append(m.MirrorDestinations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MirrorDestinations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FlowMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcKeyHandle == nil {
				m.EcKeyHandle = &ExportControlKeyHandle{}
			}
			if err := m.EcKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceMac", wireType)
			}
			m.SourceMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestMac", wireType)
			}
			m.DestMac = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestMac |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethertype", wireType)
			}
			m.Ethertype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ethertype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceIp == nil {
				m.SourceIp = &IPPrefix{}
			}
			if err := m.SourceIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestIp == nil {
				m.DestIp = &IPPrefix{}
			}
			if err := m.DestIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceL4Port", wireType)
			}
			m.SourceL4Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceL4Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestL4Port", wireType)
			}
			m.DestL4Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestL4Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceGroupid", wireType)
			}
			m.SourceGroupid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceGroupid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestGroupid", wireType)
			}
			m.DestGroupid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestGroupid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &MonitorAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFlows", wireType)
			}
			m.ActiveFlows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFlows |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &FlowMonitorRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FlowMonitorRuleSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FlowMonitorRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FlowMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FlowMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FlowMonitorRuleDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FlowMonitorRuleDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FlowMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FlowMonitorRuleGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &FlowMonitorRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &FlowMonitorRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowMonitorRuleGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowMonitorRuleGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowMonitorRuleGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FlowMonitorRuleGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &DropMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsKeyHandle = append(m.MsKeyHandle, &MirrorSessionKeyHandle{})
			if err := m.MsKeyHandle[len(m.MsKeyHandle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reasons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reasons == nil {
				m.Reasons = &DropReasons{}
			}
			if err := m.Reasons.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFlows", wireType)
			}
			m.ActiveFlows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFlows |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DropMonitorRuleStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DropMonitorRuleSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DropMonitorRuleResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &DropMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &DropMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DropMonitorRuleDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DropMonitorRuleDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &DropMonitorRuleKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DropMonitorRuleGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DropMonitorRuleSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DropMonitorRuleStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropMonitorRuleGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropMonitorRuleGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropMonitorRuleGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DropMonitorRuleGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RSpanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RSpanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RSpanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Intf == nil {
				m.Intf = &InterfaceKeyHandle{}
			}
			if err := m.Intf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspanEncap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RspanEncap == nil {
				m.RspanEncap = &EncapInfo{}
			}
			if err := m.RspanEncap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERSpanSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERSpanSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERSpanSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestIp == nil {
				m.DestIp = &IPAddress{}
			}
			if err := m.DestIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcIp == nil {
				m.SrcIp = &IPAddress{}
			}
			if err := m.SrcIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dscp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dscp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanId", wireType)
			}
			m.SpanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpanId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &MirrorSessionKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snaplen", wireType)
			}
			m.Snaplen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Snaplen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSpanIf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InterfaceKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &MirrorSessionSpec_LocalSpanIf{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspanSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RSpanSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &MirrorSessionSpec_RspanSpec{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErspanSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ERSpanSpec{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Destination = &MirrorSessionSpec_ErspanSpec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handle", wireType)
			}
			m.Handle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.Handle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveFlows", wireType)
			}
			m.ActiveFlows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveFlows |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &MirrorSessionStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MirrorSessionSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorSessionResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &MirrorSessionKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &MirrorSessionKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MirrorSessionDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorSessionDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &MirrorSessionKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &MirrorSessionGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &MirrorSessionSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &MirrorSessionStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorSessionGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorSessionGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorSessionGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &MirrorSessionGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTelemetry(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTelemetry = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("telemetry.proto", fileDescriptorTelemetry) }

var fileDescriptorTelemetry = []byte{
	// 2569 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0xea, 0x83, 0x12, 0x1f, 0x45, 0x89, 0x1a, 0xc9, 0x36, 0xad, 0xda, 0xa2, 0xb2, 0xb6,
	0x6c, 0xd9, 0xf1, 0x57, 0x94, 0x38, 0x75, 0x13, 0xc7, 0x86, 0x44, 0xd3, 0xf6, 0xa2, 0x92, 0xc9,
	0x0e, 0x69, 0xc7, 0x30, 0x0a, 0xaf, 0xd7, 0xcb, 0x11, 0xc5, 0x98, 0xdc, 0xdd, 0xee, 0xae, 0x92,
	0x08, 0x45, 0x4f, 0xbd, 0x15, 0x08, 0x0a, 0x14, 0x68, 0xd3, 0xa2, 0xb7, 0x9e, 0x7a, 0x28, 0xd0,
	0x63, 0x0f, 0x45, 0xef, 0xed, 0xa9, 0xf9, 0x0b, 0x84, 0xc2, 0xfd, 0x0f, 0xd4, 0x9e, 0x8b, 0x62,
	0x66, 0x96, 0xcb, 0xfd, 0x5e, 0x4a, 0xa1, 0x94, 0x93, 0xc4, 0xd9, 0xf7, 0x35, 0xef, 0xbd, 0x99,
	0xdf, 0x9b, 0x79, 0x03, 0xb3, 0x36, 0xe9, 0x90, 0x2e, 0xb1, 0xcd, 0xbd, 0x1b, 0x86, 0xa9, 0xdb,
	0x3a, 0xca, 0xba, 0x03, 0x8b, 0x39, 0x7b, 0xcf, 0x20, 0x16, 0x1f, 0x5f, 0x9c, 0x7a, 0xb3, 0xc3,
	0xff, 0x13, 0xff, 0x3b, 0x0e, 0xf9, 0xb2, 0xde, 0xe9, 0x10, 0xd5, 0xd6, 0xcd, 0xba, 0x41, 0x54,
	0xb4, 0x02, 0xe3, 0x5d, 0x62, 0x2b, 0x45, 0x61, 0x59, 0x58, 0xcd, 0xad, 0xcd, 0xdd, 0xe0, 0x7c,
	0xd5, 0xd7, 0x9f, 0x11, 0xd5, 0xde, 0x22, 0xb6, 0x82, 0xd9, 0x67, 0xb4, 0x09, 0xf9, 0x37, 0x64,
	0x4f, 0xd6, 0x4d, 0x79, 0x47, 0xd1, 0x9a, 0x1d, 0x52, 0x1c, 0x65, 0xf4, 0xa7, 0x6f, 0xbc, 0xd9,
	0xb9, 0xe1, 0x0a, 0xfc, 0x21, 0xd9, 0x7b, 0xcc, 0xbe, 0x6e, 0x14, 0x0e, 0xf6, 0x4b, 0xd3, 0x9f,
	0x13, 0xad, 0xad, 0x92, 0x8f, 0xc4, 0x37, 0x64, 0x4f, 0xc4, 0xb9, 0x37, 0x64, 0xaf, 0x6a, 0xf2,
	0xcf, 0xe8, 0x12, 0x4c, 0x10, 0x4d, 0x55, 0x8c, 0xe2, 0x18, 0x93, 0x52, 0x70, 0xb4, 0x56, 0xe8,
	0x98, 0xa4, 0x6d, 0xeb, 0x98, 0x7f, 0x46, 0x35, 0x28, 0x74, 0xd6, 0x2c, 0xd2, 0x92, 0xa9, 0x6e,
	0x47, 0xf1, 0x78, 0x5f, 0xf1, 0xe6, 0x5a, 0x9d, 0xb4, 0xba, 0x44, 0xb3, 0xfb, 0x8a, 0x67, 0x0e,
	0xf6, 0x4b, 0xe0, 0x28, 0x36, 0xc9, 0x36, 0x9e, 0x61, 0xfc, 0xee, 0x77, 0x74, 0x1f, 0x26, 0x9b,
	0xc4, 0xb2, 0xe5, 0xb6, 0x51, 0x9c, 0xf0, 0xe9, 0x96, 0x6a, 0xeb, 0xcd, 0xa6, 0x49, 0x2c, 0x6b,
	0x63, 0xe1, 0x60, 0xbf, 0x54, 0x70, 0x44, 0x74, 0x15, 0xad, 0xa9, 0xd8, 0xba, 0xb9, 0x87, 0x33,
	0x94, 0x4d, 0x32, 0xd0, 0x27, 0x90, 0xb1, 0x4c, 0x95, 0xf2, 0x67, 0x0e, 0xc5, 0x3f, 0x61, 0x99,
	0xaa, 0x64, 0xa0, 0x32, 0x4c, 0xb1, 0x48, 0xa8, 0x7a, 0xa7, 0x38, 0xb9, 0x2c, 0xac, 0xce, 0xb8,
	0x2e, 0x97, 0x6a, 0x35, 0xe7, 0x43, 0x8c, 0x04, 0x97, 0x11, 0xbd, 0x07, 0x59, 0x36, 0x09, 0x43,
	0x37, 0xed, 0xe2, 0xd4, 0xb2, 0xb0, 0x9a, 0x8f, 0x63, 0xa1, 0x64, 0x35, 0xdd, 0xb4, 0x51, 0x05,
	0x32, 0xdb, 0xba, 0xd9, 0x55, 0xec, 0x62, 0x96, 0x69, 0x3d, 0x73, 0xa3, 0x9f, 0x3c, 0x95, 0x2f,
	0xa9, 0xa0, 0x87, 0xec, 0x73, 0xdc, 0xec, 0x39, 0x33, 0xba, 0x0d, 0x39, 0x9b, 0x74, 0x8d, 0x8e,
	0x62, 0x13, 0xb9, 0xdd, 0x2c, 0x42, 0x82, 0x6e, 0xe8, 0x11, 0x4a, 0x4d, 0xf1, 0x0a, 0xcc, 0xf6,
	0xb3, 0xce, 0x56, 0xec, 0x5d, 0x0b, 0x9d, 0x86, 0x8c, 0x13, 0x50, 0x9a, 0x79, 0x19, 0xec, 0xfc,
	0x12, 0x7f, 0x29, 0xc0, 0x9c, 0x4b, 0x8b, 0x89, 0x65, 0xe8, 0x9a, 0x45, 0xd0, 0x43, 0x00, 0xc5,
	0x68, 0xcb, 0x16, 0xe3, 0x65, 0x1c, 0x33, 0xae, 0xe7, 0xd7, 0x8d, 0x36, 0x97, 0xb9, 0x71, 0xea,
	0x60, 0xbf, 0x34, 0xe7, 0x18, 0xd2, 0x27, 0xc7, 0x59, 0xa5, 0x47, 0x81, 0xd6, 0x20, 0xe3, 0xc8,
	0xe0, 0xf9, 0xbb, 0xe8, 0x71, 0x43, 0xc0, 0x42, 0xec, 0x50, 0x8a, 0x12, 0xcc, 0x7b, 0x0c, 0xfa,
	0xc9, 0x2e, 0xb1, 0xec, 0x2d, 0xab, 0x85, 0xd6, 0x60, 0xd2, 0xe4, 0xbf, 0x8a, 0xc2, 0xf2, 0xd8,
	0x6a, 0x6e, 0xad, 0x18, 0x29, 0xcb, 0x20, 0x2a, 0xee, 0x11, 0x8a, 0x35, 0x58, 0x08, 0xcd, 0x8d,
	0xca, 0xba, 0x03, 0x53, 0xa6, 0xf3, 0xd3, 0x11, 0x76, 0x2e, 0x4a, 0x58, 0x8f, 0x05, 0xbb, 0xd4,
	0xe2, 0x57, 0x02, 0x9c, 0x76, 0xbf, 0x3f, 0x20, 0x1d, 0x62, 0x13, 0xc7, 0xc6, 0xef, 0x64, 0x65,
	0x8b, 0x7f, 0x16, 0xe0, 0x4c, 0xc8, 0x9e, 0x21, 0x07, 0x71, 0xb8, 0x16, 0x3f, 0x87, 0xb3, 0xd1,
	0x0e, 0xa4, 0x81, 0xf9, 0x38, 0x18, 0xe4, 0x77, 0xa2, 0xe2, 0xe2, 0x63, 0xeb, 0x47, 0xfb, 0xc7,
	0xb0, 0x18, 0xe3, 0x0a, 0x2a, 0xfa, 0x5e, 0x28, 0xe6, 0x62, 0x92, 0xec, 0x50, 0xe4, 0x7f, 0x21,
	0x78, 0xf2, 0xf2, 0x11, 0xb1, 0xbf, 0xd3, 0xb0, 0x63, 0x4f, 0x16, 0xf6, 0x6d, 0xe1, 0xa9, 0x1d,
	0xf0, 0xe0, 0x52, 0xd4, 0x2c, 0xfb, 0x3c, 0x7d, 0xf7, 0x15, 0x60, 0xc6, 0xb7, 0x24, 0x2d, 0xf1,
	0x6f, 0x82, 0x67, 0xfd, 0x30, 0x96, 0x21, 0x67, 0xd6, 0x35, 0x18, 0xb7, 0x0c, 0xa2, 0x3a, 0xbe,
	0x88, 0x5f, 0xd0, 0x8c, 0x0a, 0xdd, 0x84, 0x09, 0x2a, 0xc2, 0x72, 0x50, 0xec, 0x6c, 0xdc, 0x5e,
	0x62, 0x61, 0x4e, 0x27, 0x3e, 0xf3, 0xac, 0x0d, 0x8f, 0xf9, 0x3c, 0xd1, 0x82, 0xd9, 0x50, 0x8a,
	0xf5, 0x53, 0x28, 0x15, 0xfe, 0x38, 0x0a, 0x73, 0x7c, 0x13, 0x2f, 0xeb, 0x9a, 0x6d, 0xea, 0x9d,
	0xc3, 0x20, 0x7b, 0x2d, 0x3a, 0x11, 0x16, 0x69, 0x22, 0xf8, 0x84, 0x0e, 0x8c, 0xee, 0x8f, 0x61,
	0x41, 0xed, 0x19, 0xec, 0x45, 0xee, 0x31, 0x36, 0xaf, 0x98, 0x0c, 0xc3, 0x48, 0x0d, 0x8d, 0xa1,
	0x15, 0x98, 0x51, 0x54, 0xbb, 0xfd, 0x39, 0x91, 0xed, 0x76, 0x97, 0xe8, 0xbb, 0x36, 0x43, 0xff,
	0x3c, 0xce, 0xf3, 0xd1, 0x06, 0x1f, 0x44, 0x57, 0xa0, 0xd0, 0xd6, 0x02, 0x84, 0x13, 0x8c, 0x70,
	0xb6, 0x37, 0xee, 0x90, 0x8a, 0xd7, 0x61, 0xde, 0xef, 0xa9, 0x64, 0x34, 0xfa, 0x5a, 0x80, 0x53,
	0x3e, 0xfa, 0xa1, 0xa7, 0xdc, 0x87, 0x01, 0x44, 0x5a, 0x0a, 0x01, 0xb3, 0xcf, 0x52, 0x17, 0x95,
	0x7e, 0x04, 0x67, 0x02, 0x86, 0xb9, 0x4b, 0xee, 0xc3, 0xe0, 0x92, 0x3b, 0x17, 0x2b, 0xd3, 0x87,
	0x4e, 0xcf, 0xa1, 0x18, 0x39, 0x57, 0x2a, 0xf3, 0x6e, 0x28, 0x3f, 0x97, 0xe3, 0x84, 0x46, 0x24,
	0xe8, 0xaf, 0x05, 0x58, 0xf4, 0xd1, 0x1c, 0x09, 0xa9, 0x86, 0x9e, 0xa9, 0xe2, 0x5f, 0x04, 0xf8,
	0x5e, 0xa4, 0x5d, 0x43, 0x0e, 0xf2, 0xf0, 0x2d, 0x7f, 0x05, 0xe7, 0xe3, 0x1d, 0x4a, 0x03, 0x76,
	0x3f, 0x98, 0x04, 0x2b, 0x71, 0xf1, 0x8a, 0x41, 0xaf, 0x26, 0x2c, 0x25, 0xb8, 0x86, 0xaa, 0xd8,
	0x08, 0xe5, 0xc4, 0xa5, 0x34, 0x1d, 0xa1, 0xcc, 0xf8, 0x95, 0x10, 0xc8, 0xe3, 0xc3, 0x23, 0xd9,
	0xf0, 0x9d, 0xfb, 0x22, 0x90, 0xad, 0x7e, 0x44, 0xbb, 0x1b, 0xf4, 0xac, 0x18, 0x37, 0xeb, 0x28,
	0x54, 0x5b, 0x00, 0x14, 0x5a, 0xd6, 0x96, 0xf8, 0x0f, 0x21, 0xb0, 0xf6, 0x8e, 0x03, 0xdd, 0x6e,
	0xf9, 0xd0, 0x2d, 0x79, 0x53, 0xe0, 0x08, 0xf7, 0xbe, 0x1f, 0xe1, 0xce, 0x27, 0xed, 0x4d, 0x2e,
	0xca, 0xbd, 0x0c, 0xac, 0xa9, 0x00, 0xd2, 0xdd, 0x0f, 0x65, 0xcd, 0x85, 0x44, 0xff, 0x85, 0x52,
	0xe6, 0x4f, 0x02, 0xe4, 0xb7, 0x74, 0xad, 0x6d, 0xeb, 0xe6, 0xba, 0x6a, 0xb7, 0x75, 0x0d, 0x5d,
	0x87, 0x8c, 0xc2, 0xfe, 0x63, 0x02, 0x67, 0xd6, 0x4e, 0x79, 0x04, 0xe2, 0xdd, 0x0e, 0xe1, 0x64,
	0xd8, 0x21, 0x42, 0x1f, 0x03, 0x28, 0xad, 0x96, 0x6c, 0xa9, 0x3b, 0xa4, 0x4b, 0xb3, 0x85, 0xb2,
	0x78, 0xbd, 0xb1, 0xde, 0x6a, 0x99, 0xa4, 0xa5, 0x50, 0xda, 0x3a, 0xa3, 0xc1, 0x59, 0xa5, 0xd5,
	0xe2, 0xff, 0xa2, 0x9b, 0x30, 0xdf, 0x6d, 0x9b, 0xa6, 0x6e, 0xca, 0xf4, 0x6c, 0xd5, 0xd6, 0x18,
	0x99, 0xc5, 0xb0, 0x2d, 0x8f, 0x11, 0xff, 0xf4, 0xc0, 0xf3, 0x45, 0xfc, 0xcf, 0x38, 0xcc, 0x3f,
	0xec, 0xe8, 0x5f, 0x38, 0x26, 0x53, 0x7b, 0x0e, 0x03, 0xcf, 0x38, 0x3a, 0xbb, 0xcf, 0xd1, 0xec,
	0x0e, 0x88, 0x1d, 0x18, 0xa0, 0xef, 0x41, 0x9e, 0xa8, 0x7e, 0x64, 0x4e, 0x59, 0x31, 0x38, 0x47,
	0xd4, 0x3e, 0x2c, 0x9f, 0x07, 0xb0, 0xf4, 0x5d, 0x53, 0x25, 0x72, 0x57, 0x51, 0x19, 0x24, 0x8f,
	0xe3, 0x2c, 0x1f, 0xd9, 0x52, 0x54, 0x74, 0x16, 0xd8, 0xb9, 0x93, 0x7d, 0x9c, 0x60, 0x1f, 0xd9,
	0x99, 0x9b, 0x7e, 0x3a, 0x07, 0x59, 0x62, 0xef, 0x10, 0x93, 0x4e, 0x96, 0x1d, 0xa0, 0xf3, 0xb8,
	0x3f, 0x80, 0xae, 0x0f, 0x70, 0x38, 0xf6, 0x1c, 0x83, 0xaf, 0x81, 0xa3, 0x94, 0x9e, 0xc6, 0xa7,
	0xd8, 0x14, 0x66, 0x3d, 0xf4, 0x64, 0xbb, 0xfd, 0x25, 0x9e, 0xe2, 0x14, 0x92, 0x81, 0x56, 0xfb,
	0x27, 0xff, 0x6c, 0x34, 0x6d, 0xef, 0x88, 0x7f, 0x11, 0x66, 0x1c, 0xb9, 0x9d, 0x0f, 0xf8, 0x19,
	0x9b, 0x9d, 0x73, 0xf1, 0x34, 0x1f, 0xdd, 0xfc, 0x80, 0x9d, 0xa8, 0x97, 0x61, 0x9a, 0xc9, 0xeb,
	0xd1, 0xe4, 0x18, 0x0d, 0xd0, 0x31, 0x87, 0x62, 0xc5, 0x95, 0xd3, 0x32, 0xf5, 0x5d, 0xa3, 0xdd,
	0x2c, 0x4e, 0x33, 0x6f, 0xe4, 0xf9, 0xe8, 0x23, 0x3e, 0x88, 0xde, 0x71, 0x04, 0xf5, 0x88, 0xf2,
	0x8c, 0x28, 0x47, 0xc7, 0x7a, 0x24, 0xb7, 0xdc, 0x04, 0x9f, 0x09, 0x55, 0xa6, 0xbe, 0xa5, 0xd0,
	0xcb, 0x71, 0x11, 0xc3, 0xa9, 0x60, 0xd2, 0x25, 0x56, 0x3a, 0xd4, 0x0a, 0xa7, 0x82, 0xda, 0xee,
	0xe8, 0x5f, 0xf0, 0x6a, 0x24, 0x8f, 0x73, 0x7c, 0x8c, 0x8a, 0xb2, 0xc4, 0xdf, 0x0b, 0x70, 0x26,
	0x20, 0x74, 0xe8, 0x7b, 0xd4, 0x9d, 0x40, 0x39, 0xe4, 0xad, 0x32, 0x22, 0x27, 0xe4, 0x16, 0x44,
	0x4f, 0xe1, 0x6c, 0xc8, 0xb8, 0xc1, 0x4e, 0x21, 0x11, 0xab, 0xd3, 0x77, 0x88, 0x8b, 0x99, 0x73,
	0xfa, 0x21, 0x2e, 0x86, 0xd1, 0xb3, 0x97, 0xfd, 0x4e, 0x80, 0x73, 0x01, 0xaa, 0x23, 0x95, 0x46,
	0xc7, 0xb0, 0x4b, 0x88, 0x7f, 0x15, 0xe0, 0x7c, 0x8c, 0x6d, 0x43, 0x0e, 0xfa, 0x71, 0x58, 0xdf,
	0x84, 0x52, 0x92, 0x63, 0x69, 0xf0, 0xd6, 0x83, 0x49, 0x71, 0x39, 0x3e, 0x76, 0x31, 0x45, 0xd2,
	0x0e, 0x2c, 0x27, 0xba, 0x88, 0xaa, 0x79, 0x10, 0xca, 0x91, 0xd5, 0x74, 0x3d, 0xa1, 0x4c, 0xf9,
	0x8d, 0x10, 0xca, 0xef, 0xc3, 0x97, 0x4a, 0xc7, 0xe1, 0xe8, 0x97, 0xa1, 0x0c, 0xf6, 0x97, 0x4b,
	0xf7, 0x82, 0x5e, 0xbe, 0x18, 0x3f, 0xfb, 0xa8, 0x82, 0xe9, 0x34, 0x2c, 0x44, 0x2c, 0x7c, 0x4b,
	0xfc, 0xa7, 0x10, 0x5a, 0x99, 0xc7, 0x51, 0x34, 0xad, 0xf9, 0x8a, 0xa6, 0xb4, 0x6d, 0x83, 0x97,
	0x4d, 0xb7, 0xfd, 0x65, 0x53, 0x29, 0x79, 0x0f, 0x73, 0x0b, 0xa7, 0xd7, 0xa1, 0xf5, 0x16, 0x28,
	0x9d, 0xd6, 0x43, 0x99, 0xb4, 0x92, 0xe2, 0xcb, 0x50, 0x1a, 0xfd, 0x61, 0x14, 0xe6, 0x1f, 0x98,
	0xba, 0x71, 0x0c, 0xd5, 0x48, 0x40, 0xec, 0xc0, 0xd5, 0xc8, 0x6b, 0xc8, 0x77, 0xad, 0xf0, 0x3d,
	0x01, 0xab, 0x46, 0xb6, 0x58, 0x3d, 0x55, 0x27, 0x96, 0xd5, 0xd6, 0xb5, 0xbe, 0x44, 0xf1, 0x60,
	0xbf, 0xb4, 0xe4, 0x48, 0x54, 0x75, 0xcd, 0xb2, 0x4d, 0xa5, 0xad, 0xd9, 0xd6, 0x27, 0x3f, 0x35,
	0x15, 0xad, 0x45, 0x3e, 0xba, 0x75, 0xfd, 0xfb, 0x3f, 0xc3, 0xb9, 0xae, 0xd5, 0xaf, 0x58, 0xae,
	0xd1, 0x24, 0x54, 0x2c, 0x5a, 0xa9, 0xf1, 0xfe, 0x01, 0x72, 0x66, 0x48, 0x8d, 0xc6, 0xfc, 0x0b,
	0xee, 0x91, 0x50, 0xf0, 0x0c, 0xfa, 0xe8, 0x70, 0xe0, 0x39, 0x16, 0x0d, 0x9e, 0x01, 0xa1, 0x27,
	0x0a, 0x9e, 0x91, 0x13, 0xf2, 0x82, 0x67, 0xc8, 0xb8, 0xc1, 0xc0, 0x33, 0x22, 0x99, 0x7c, 0xe0,
	0x19, 0x33, 0xe7, 0x74, 0xf0, 0x8c, 0x61, 0x0c, 0x80, 0x67, 0x80, 0x6a, 0xe8, 0xe0, 0x79, 0xc4,
	0xa4, 0x66, 0xe0, 0x19, 0x63, 0xdb, 0x09, 0x82, 0xe7, 0x51, 0xad, 0x6f, 0x42, 0x29, 0xc9, 0xb1,
	0xa9, 0xe0, 0x99, 0xc4, 0xec, 0x03, 0xcf, 0x44, 0x17, 0xa5, 0x83, 0x67, 0x22, 0x7b, 0x00, 0x3c,
	0x03, 0xb4, 0xc3, 0x05, 0xcf, 0xa3, 0x3a, 0xfa, 0x65, 0x28, 0x83, 0x0f, 0x01, 0x9e, 0xb1, 0x9c,
	0x3e, 0xf0, 0x8c, 0x58, 0xf8, 0x1c, 0x3c, 0xa3, 0xd8, 0x4f, 0x0c, 0x3c, 0xa3, 0xb6, 0x8d, 0x54,
	0xf0, 0x8c, 0x9a, 0x8a, 0x07, 0x3c, 0xe3, 0x27, 0x94, 0x0e, 0x9e, 0xf1, 0xbc, 0x9e, 0x34, 0xfa,
	0x0c, 0xb2, 0xb8, 0x6e, 0x28, 0x1a, 0x43, 0xcc, 0xab, 0x30, 0xde, 0xd6, 0xec, 0x6d, 0x27, 0x6b,
	0xd8, 0xad, 0xb6, 0xa4, 0xd9, 0xc4, 0xdc, 0x56, 0xd4, 0x7e, 0xfc, 0x31, 0xa3, 0x41, 0xef, 0x41,
	0xce, 0xb4, 0x0c, 0x45, 0x93, 0x79, 0xd7, 0x7b, 0x34, 0xa6, 0xeb, 0x0d, 0x8c, 0x88, 0xfd, 0x16,
	0xbf, 0x12, 0x00, 0x2a, 0x7d, 0x6d, 0x57, 0xfa, 0xa7, 0x57, 0x21, 0xba, 0xef, 0xec, 0x1e, 0x5f,
	0x2f, 0xbb, 0x1d, 0xea, 0xd1, 0x18, 0x4a, 0xa7, 0x17, 0x8d, 0x60, 0xbc, 0x69, 0xa9, 0xbc, 0x09,
	0x9f, 0xc5, 0xec, 0x7f, 0x74, 0x06, 0x26, 0x99, 0xa1, 0xed, 0xa6, 0x73, 0xd5, 0x9e, 0xa1, 0x3f,
	0xa5, 0xa6, 0xf8, 0xf3, 0x31, 0x98, 0xf3, 0xa1, 0xf1, 0x61, 0xca, 0x06, 0x3d, 0xe1, 0x8a, 0x2e,
	0x06, 0xe2, 0x6f, 0x1e, 0xec, 0x97, 0xde, 0xf5, 0x2e, 0x9c, 0x6b, 0x69, 0x78, 0xef, 0xad, 0x29,
	0x8a, 0x30, 0x69, 0x69, 0x8a, 0xd1, 0x21, 0x9a, 0x83, 0xc5, 0xbd, 0x9f, 0xe8, 0x2e, 0xe4, 0x3b,
	0xba, 0xaa, 0x74, 0x64, 0x3e, 0xcd, 0x6d, 0xef, 0x7b, 0x82, 0x70, 0xfc, 0x1e, 0x8f, 0xe0, 0x1c,
	0x23, 0xa7, 0x81, 0x90, 0xb6, 0xd1, 0x6d, 0xe0, 0x31, 0x92, 0x59, 0x5a, 0xf3, 0x17, 0x04, 0x0b,
	0xde, 0xdb, 0xa6, 0x5e, 0xc0, 0x1e, 0x8f, 0xe0, 0x2c, 0xa3, 0x64, 0x6e, 0xba, 0x03, 0x39, 0xe2,
	0xe1, 0xe3, 0x2f, 0x07, 0xbc, 0xb7, 0x54, 0x15, 0x2f, 0x23, 0x10, 0x97, 0x73, 0x23, 0x0f, 0x39,
	0xcf, 0x3d, 0x93, 0x58, 0x83, 0x79, 0x7f, 0x10, 0xbe, 0xf5, 0xa1, 0xfe, 0x6b, 0x01, 0x4e, 0xf9,
	0x44, 0x9e, 0x68, 0x87, 0x23, 0x62, 0x32, 0xde, 0x0e, 0x47, 0xc0, 0xb0, 0xc1, 0x3a, 0x1c, 0xa1,
	0x2c, 0xf5, 0x75, 0x38, 0x22, 0xe7, 0x9a, 0xde, 0xe1, 0x88, 0x64, 0x0b, 0x74, 0x38, 0x7c, 0x34,
	0x43, 0xef, 0x70, 0xc4, 0xac, 0x93, 0x01, 0x3a, 0x1c, 0x91, 0x76, 0x9d, 0x60, 0x87, 0xe3, 0x68,
	0x96, 0xbf, 0x82, 0xf3, 0xf1, 0x0e, 0x4d, 0xed, 0x70, 0xc4, 0xb3, 0xfa, 0x3a, 0x1c, 0x09, 0xae,
	0x49, 0xef, 0x70, 0x24, 0x30, 0x07, 0x3a, 0x1c, 0x3e, 0xca, 0xe1, 0x76, 0x38, 0x8e, 0xe6, 0xdc,
	0x17, 0x81, 0x6c, 0x3d, 0x44, 0x87, 0x23, 0x86, 0xcf, 0xd7, 0xe1, 0x08, 0x2d, 0x6b, 0xde, 0xe1,
	0x08, 0xb3, 0x9e, 0x58, 0x87, 0x23, 0xbc, 0x29, 0xa4, 0x76, 0x38, 0xc2, 0x93, 0xf0, 0x74, 0x38,
	0xe2, 0xa6, 0x92, 0xde, 0xe1, 0x88, 0xe3, 0xec, 0xa7, 0xcc, 0xd5, 0x55, 0x98, 0xf6, 0xbe, 0xc9,
	0x42, 0x59, 0x98, 0x90, 0x6a, 0x0f, 0xa5, 0xe7, 0x85, 0x11, 0x94, 0x87, 0xec, 0x93, 0x4a, 0xe3,
	0xe1, 0x66, 0xf5, 0xd3, 0x67, 0x3f, 0x28, 0x08, 0x57, 0xcb, 0x00, 0xfd, 0x06, 0x07, 0x3a, 0x0d,
	0xa8, 0x5c, 0xdd, 0xdc, 0xac, 0x94, 0x1b, 0x32, 0xa5, 0x90, 0xeb, 0x8d, 0xf5, 0x46, 0xbd, 0x30,
	0x82, 0x00, 0x32, 0x5b, 0x12, 0xc6, 0x55, 0x5c, 0x10, 0xd0, 0x1c, 0xe4, 0xf9, 0xff, 0x72, 0xa3,
	0x2a, 0x97, 0x6b, 0x4f, 0x0b, 0xa3, 0x57, 0xbf, 0x11, 0x60, 0x2e, 0xd4, 0xf3, 0x40, 0x53, 0x30,
	0xfe, 0xa4, 0xfa, 0xa4, 0x52, 0x18, 0x41, 0xd3, 0x30, 0x25, 0xd5, 0xea, 0xd5, 0xa7, 0xb8, 0x5c,
	0xe1, 0x02, 0xa4, 0xda, 0x83, 0x4a, 0xbd, 0x21, 0x3d, 0x59, 0x6f, 0x48, 0xd5, 0x27, 0x85, 0x51,
	0x2a, 0x5f, 0xaa, 0xd5, 0xd6, 0x25, 0x5c, 0x18, 0x43, 0xb3, 0x90, 0xe3, 0xa4, 0x72, 0xad, 0x8a,
	0x1b, 0x85, 0x71, 0xb4, 0x00, 0x05, 0x0f, 0x35, 0x1f, 0x9d, 0x40, 0x39, 0x98, 0xac, 0x57, 0xf0,
	0x33, 0xa9, 0x5c, 0x29, 0x64, 0x10, 0x82, 0x19, 0xce, 0x2f, 0xf7, 0xc6, 0x26, 0x29, 0x9b, 0x23,
	0xa7, 0x5e, 0x29, 0xcb, 0x8f, 0x70, 0xf5, 0x69, 0xad, 0x30, 0x45, 0x29, 0xa9, 0x30, 0xcf, 0x58,
	0x96, 0x8e, 0xb9, 0x3f, 0x65, 0x66, 0x05, 0xac, 0xfd, 0x6f, 0x16, 0xb2, 0x8d, 0x9e, 0xcb, 0x51,
	0xc3, 0xf3, 0xfc, 0xac, 0x6c, 0x12, 0xc5, 0x26, 0x68, 0x29, 0xfa, 0x7d, 0x55, 0x6f, 0x09, 0x2c,
	0x96, 0x92, 0xde, 0x5f, 0x6d, 0x59, 0x2d, 0x71, 0xc4, 0x27, 0xf5, 0xa9, 0xd1, 0x1c, 0x92, 0xd4,
	0x57, 0x1e, 0xa9, 0x7c, 0x4f, 0x41, 0x17, 0x53, 0xdf, 0x1c, 0x51, 0xd9, 0x2b, 0xe9, 0xaf, 0x87,
	0xb8, 0x86, 0x4f, 0x61, 0xda, 0xfb, 0x9e, 0x04, 0xbd, 0x93, 0xfc, 0x20, 0x87, 0xca, 0x16, 0x53,
	0xde, 0xa2, 0xf4, 0x4c, 0xf7, 0xbf, 0xad, 0x70, 0x5c, 0x2d, 0xc6, 0x3f, 0x14, 0x70, 0x15, 0x5c,
	0x48, 0x7b, 0x4c, 0x10, 0xad, 0xc1, 0x71, 0xfb, 0x10, 0x35, 0x74, 0x02, 0x1a, 0x9c, 0x10, 0xac,
	0x0e, 0xd4, 0x3c, 0xa7, 0x7a, 0xae, 0x0c, 0xd6, 0x02, 0xe7, 0xda, 0x54, 0x28, 0x04, 0x1b, 0x9e,
	0x68, 0x25, 0xbd, 0x9b, 0x4c, 0xf5, 0x5c, 0x1a, 0xa0, 0x69, 0xca, 0x95, 0x6c, 0x87, 0x5a, 0x41,
	0x4e, 0x60, 0x2e, 0x26, 0xb5, 0x2a, 0x22, 0xf3, 0x2a, 0xbe, 0x13, 0x12, 0xa9, 0xc7, 0x09, 0xcf,
	0x90, 0xf5, 0x98, 0x21, 0x3d, 0x4e, 0x90, 0xae, 0x0e, 0x78, 0x7d, 0x4f, 0xb5, 0xbd, 0x3b, 0xe8,
	0x15, 0x3c, 0xd7, 0xd9, 0x06, 0x14, 0xbe, 0x5e, 0x45, 0x97, 0x07, 0xb9, 0xc9, 0xa6, 0xda, 0x56,
	0x07, 0xba, 0xa6, 0x75, 0xdd, 0x18, 0x38, 0x8c, 0x46, 0x84, 0x2b, 0xf6, 0xb2, 0x6e, 0x71, 0x25,
	0xfd, 0x0a, 0x2d, 0x4e, 0x4f, 0x44, 0xb8, 0x86, 0xa0, 0xc7, 0x0c, 0xe9, 0x89, 0x08, 0x57, 0xca,
	0x6d, 0x93, 0x2f, 0x5c, 0x69, 0x77, 0x46, 0x3c, 0x5c, 0xe1, 0x03, 0x3d, 0xba, 0x3c, 0xc8, 0xdd,
	0x49, 0x30, 0x5c, 0x89, 0x97, 0x0a, 0x7c, 0x4b, 0xf2, 0x21, 0x7a, 0xc4, 0xa6, 0x17, 0x73, 0x8a,
	0x59, 0xbc, 0x90, 0x76, 0xbe, 0x88, 0xd6, 0x10, 0xb1, 0xe9, 0x7d, 0x4b, 0x0d, 0x9d, 0x80, 0x86,
	0x88, 0x4d, 0x2f, 0xb1, 0x14, 0xf7, 0x6d, 0x7a, 0xc9, 0x25, 0x35, 0xdf, 0xf4, 0x82, 0x35, 0x10,
	0x5a, 0x49, 0x2f, 0x30, 0x83, 0x9b, 0x5e, 0x42, 0x05, 0x26, 0x8e, 0x6c, 0x2c, 0xfe, 0xfd, 0xed,
	0x92, 0xf0, 0xcd, 0xdb, 0x25, 0xe1, 0x5f, 0x6f, 0x97, 0x84, 0xdf, 0xfe, 0x7b, 0x69, 0xe4, 0xc5,
	0xd4, 0x8e, 0xd2, 0x61, 0x4f, 0x07, 0x5e, 0x67, 0xd8, 0x9f, 0xf7, 0xff, 0x1f, 0x00, 0x00, 0xff,
	0xff, 0x1e, 0x4b, 0x0f, 0xd4, 0x40, 0x31, 0x00, 0x00,
}
