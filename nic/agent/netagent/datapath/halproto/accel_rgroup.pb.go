// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: accel_rgroup.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AccelRGroupAddRequest struct {
	RgroupName string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
}

func (m *AccelRGroupAddRequest) Reset()                    { *m = AccelRGroupAddRequest{} }
func (m *AccelRGroupAddRequest) String() string            { return proto.CompactTextString(m) }
func (*AccelRGroupAddRequest) ProtoMessage()               {}
func (*AccelRGroupAddRequest) Descriptor() ([]byte, []int) { return fileDescriptorAccelRgroup, []int{0} }

func (m *AccelRGroupAddRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

type AccelRGroupAddRequestMsg struct {
	Request []*AccelRGroupAddRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupAddRequestMsg) Reset()         { *m = AccelRGroupAddRequestMsg{} }
func (m *AccelRGroupAddRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupAddRequestMsg) ProtoMessage()    {}
func (*AccelRGroupAddRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{1}
}

func (m *AccelRGroupAddRequestMsg) GetRequest() []*AccelRGroupAddRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupAddResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *AccelRGroupAddResponse) Reset()         { *m = AccelRGroupAddResponse{} }
func (m *AccelRGroupAddResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupAddResponse) ProtoMessage()    {}
func (*AccelRGroupAddResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{2}
}

func (m *AccelRGroupAddResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type AccelRGroupAddResponseMsg struct {
	Response []*AccelRGroupAddResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupAddResponseMsg) Reset()         { *m = AccelRGroupAddResponseMsg{} }
func (m *AccelRGroupAddResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupAddResponseMsg) ProtoMessage()    {}
func (*AccelRGroupAddResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{3}
}

func (m *AccelRGroupAddResponseMsg) GetResponse() []*AccelRGroupAddResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupDelRequest struct {
	RgroupName string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
}

func (m *AccelRGroupDelRequest) Reset()                    { *m = AccelRGroupDelRequest{} }
func (m *AccelRGroupDelRequest) String() string            { return proto.CompactTextString(m) }
func (*AccelRGroupDelRequest) ProtoMessage()               {}
func (*AccelRGroupDelRequest) Descriptor() ([]byte, []int) { return fileDescriptorAccelRgroup, []int{4} }

func (m *AccelRGroupDelRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

type AccelRGroupDelRequestMsg struct {
	Request []*AccelRGroupDelRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupDelRequestMsg) Reset()         { *m = AccelRGroupDelRequestMsg{} }
func (m *AccelRGroupDelRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupDelRequestMsg) ProtoMessage()    {}
func (*AccelRGroupDelRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{5}
}

func (m *AccelRGroupDelRequestMsg) GetRequest() []*AccelRGroupDelRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupDelResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *AccelRGroupDelResponse) Reset()         { *m = AccelRGroupDelResponse{} }
func (m *AccelRGroupDelResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupDelResponse) ProtoMessage()    {}
func (*AccelRGroupDelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{6}
}

func (m *AccelRGroupDelResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type AccelRGroupDelResponseMsg struct {
	Response []*AccelRGroupDelResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupDelResponseMsg) Reset()         { *m = AccelRGroupDelResponseMsg{} }
func (m *AccelRGroupDelResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupDelResponseMsg) ProtoMessage()    {}
func (*AccelRGroupDelResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{7}
}

func (m *AccelRGroupDelResponseMsg) GetResponse() []*AccelRGroupDelResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupRingAddRequest struct {
	RgroupName string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
	RingName   string `protobuf:"bytes,2,opt,name=ring_name,json=ringName,proto3" json:"ring_name,omitempty"`
	RingHandle uint32 `protobuf:"varint,3,opt,name=ring_handle,json=ringHandle,proto3" json:"ring_handle,omitempty"`
}

func (m *AccelRGroupRingAddRequest) Reset()         { *m = AccelRGroupRingAddRequest{} }
func (m *AccelRGroupRingAddRequest) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingAddRequest) ProtoMessage()    {}
func (*AccelRGroupRingAddRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{8}
}

func (m *AccelRGroupRingAddRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

func (m *AccelRGroupRingAddRequest) GetRingName() string {
	if m != nil {
		return m.RingName
	}
	return ""
}

func (m *AccelRGroupRingAddRequest) GetRingHandle() uint32 {
	if m != nil {
		return m.RingHandle
	}
	return 0
}

type AccelRGroupRingAddRequestMsg struct {
	Request []*AccelRGroupRingAddRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupRingAddRequestMsg) Reset()         { *m = AccelRGroupRingAddRequestMsg{} }
func (m *AccelRGroupRingAddRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingAddRequestMsg) ProtoMessage()    {}
func (*AccelRGroupRingAddRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{9}
}

func (m *AccelRGroupRingAddRequestMsg) GetRequest() []*AccelRGroupRingAddRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupRingAddResponse struct {
	ApiStatus  ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	RingHandle uint32    `protobuf:"varint,2,opt,name=ring_handle,json=ringHandle,proto3" json:"ring_handle,omitempty"`
}

func (m *AccelRGroupRingAddResponse) Reset()         { *m = AccelRGroupRingAddResponse{} }
func (m *AccelRGroupRingAddResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingAddResponse) ProtoMessage()    {}
func (*AccelRGroupRingAddResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{10}
}

func (m *AccelRGroupRingAddResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AccelRGroupRingAddResponse) GetRingHandle() uint32 {
	if m != nil {
		return m.RingHandle
	}
	return 0
}

type AccelRGroupRingAddResponseMsg struct {
	Response []*AccelRGroupRingAddResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupRingAddResponseMsg) Reset()         { *m = AccelRGroupRingAddResponseMsg{} }
func (m *AccelRGroupRingAddResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingAddResponseMsg) ProtoMessage()    {}
func (*AccelRGroupRingAddResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{11}
}

func (m *AccelRGroupRingAddResponseMsg) GetResponse() []*AccelRGroupRingAddResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupRingDelRequest struct {
	RgroupName string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
	RingName   string `protobuf:"bytes,2,opt,name=ring_name,json=ringName,proto3" json:"ring_name,omitempty"`
}

func (m *AccelRGroupRingDelRequest) Reset()         { *m = AccelRGroupRingDelRequest{} }
func (m *AccelRGroupRingDelRequest) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingDelRequest) ProtoMessage()    {}
func (*AccelRGroupRingDelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{12}
}

func (m *AccelRGroupRingDelRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

func (m *AccelRGroupRingDelRequest) GetRingName() string {
	if m != nil {
		return m.RingName
	}
	return ""
}

type AccelRGroupRingDelRequestMsg struct {
	Request []*AccelRGroupRingDelRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupRingDelRequestMsg) Reset()         { *m = AccelRGroupRingDelRequestMsg{} }
func (m *AccelRGroupRingDelRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingDelRequestMsg) ProtoMessage()    {}
func (*AccelRGroupRingDelRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{13}
}

func (m *AccelRGroupRingDelRequestMsg) GetRequest() []*AccelRGroupRingDelRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupRingDelResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
}

func (m *AccelRGroupRingDelResponse) Reset()         { *m = AccelRGroupRingDelResponse{} }
func (m *AccelRGroupRingDelResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingDelResponse) ProtoMessage()    {}
func (*AccelRGroupRingDelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{14}
}

func (m *AccelRGroupRingDelResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

type AccelRGroupRingDelResponseMsg struct {
	Response []*AccelRGroupRingDelResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupRingDelResponseMsg) Reset()         { *m = AccelRGroupRingDelResponseMsg{} }
func (m *AccelRGroupRingDelResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingDelResponseMsg) ProtoMessage()    {}
func (*AccelRGroupRingDelResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{15}
}

func (m *AccelRGroupRingDelResponseMsg) GetResponse() []*AccelRGroupRingDelResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupResetSetRequest struct {
	RgroupName string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
	SubRing    uint32 `protobuf:"varint,2,opt,name=sub_ring,json=subRing,proto3" json:"sub_ring,omitempty"`
	ResetSense uint32 `protobuf:"varint,3,opt,name=reset_sense,json=resetSense,proto3" json:"reset_sense,omitempty"`
}

func (m *AccelRGroupResetSetRequest) Reset()         { *m = AccelRGroupResetSetRequest{} }
func (m *AccelRGroupResetSetRequest) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupResetSetRequest) ProtoMessage()    {}
func (*AccelRGroupResetSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{16}
}

func (m *AccelRGroupResetSetRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

func (m *AccelRGroupResetSetRequest) GetSubRing() uint32 {
	if m != nil {
		return m.SubRing
	}
	return 0
}

func (m *AccelRGroupResetSetRequest) GetResetSense() uint32 {
	if m != nil {
		return m.ResetSense
	}
	return 0
}

type AccelRGroupResetSetRequestMsg struct {
	Request []*AccelRGroupResetSetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupResetSetRequestMsg) Reset()         { *m = AccelRGroupResetSetRequestMsg{} }
func (m *AccelRGroupResetSetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupResetSetRequestMsg) ProtoMessage()    {}
func (*AccelRGroupResetSetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{17}
}

func (m *AccelRGroupResetSetRequestMsg) GetRequest() []*AccelRGroupResetSetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupResetSetResponse struct {
	ApiStatus      ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	LastRingHandle uint32    `protobuf:"varint,2,opt,name=last_ring_handle,json=lastRingHandle,proto3" json:"last_ring_handle,omitempty"`
	LastSubRing    uint32    `protobuf:"varint,3,opt,name=last_sub_ring,json=lastSubRing,proto3" json:"last_sub_ring,omitempty"`
}

func (m *AccelRGroupResetSetResponse) Reset()         { *m = AccelRGroupResetSetResponse{} }
func (m *AccelRGroupResetSetResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupResetSetResponse) ProtoMessage()    {}
func (*AccelRGroupResetSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{18}
}

func (m *AccelRGroupResetSetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AccelRGroupResetSetResponse) GetLastRingHandle() uint32 {
	if m != nil {
		return m.LastRingHandle
	}
	return 0
}

func (m *AccelRGroupResetSetResponse) GetLastSubRing() uint32 {
	if m != nil {
		return m.LastSubRing
	}
	return 0
}

type AccelRGroupResetSetResponseMsg struct {
	Response []*AccelRGroupResetSetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupResetSetResponseMsg) Reset()         { *m = AccelRGroupResetSetResponseMsg{} }
func (m *AccelRGroupResetSetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupResetSetResponseMsg) ProtoMessage()    {}
func (*AccelRGroupResetSetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{19}
}

func (m *AccelRGroupResetSetResponseMsg) GetResponse() []*AccelRGroupResetSetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupEnableSetRequest struct {
	RgroupName  string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
	SubRing     uint32 `protobuf:"varint,2,opt,name=sub_ring,json=subRing,proto3" json:"sub_ring,omitempty"`
	EnableSense uint32 `protobuf:"varint,3,opt,name=enable_sense,json=enableSense,proto3" json:"enable_sense,omitempty"`
}

func (m *AccelRGroupEnableSetRequest) Reset()         { *m = AccelRGroupEnableSetRequest{} }
func (m *AccelRGroupEnableSetRequest) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupEnableSetRequest) ProtoMessage()    {}
func (*AccelRGroupEnableSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{20}
}

func (m *AccelRGroupEnableSetRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

func (m *AccelRGroupEnableSetRequest) GetSubRing() uint32 {
	if m != nil {
		return m.SubRing
	}
	return 0
}

func (m *AccelRGroupEnableSetRequest) GetEnableSense() uint32 {
	if m != nil {
		return m.EnableSense
	}
	return 0
}

type AccelRGroupEnableSetRequestMsg struct {
	Request []*AccelRGroupEnableSetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupEnableSetRequestMsg) Reset()         { *m = AccelRGroupEnableSetRequestMsg{} }
func (m *AccelRGroupEnableSetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupEnableSetRequestMsg) ProtoMessage()    {}
func (*AccelRGroupEnableSetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{21}
}

func (m *AccelRGroupEnableSetRequestMsg) GetRequest() []*AccelRGroupEnableSetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupEnableSetResponse struct {
	ApiStatus      ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	LastRingHandle uint32    `protobuf:"varint,2,opt,name=last_ring_handle,json=lastRingHandle,proto3" json:"last_ring_handle,omitempty"`
	LastSubRing    uint32    `protobuf:"varint,3,opt,name=last_sub_ring,json=lastSubRing,proto3" json:"last_sub_ring,omitempty"`
}

func (m *AccelRGroupEnableSetResponse) Reset()         { *m = AccelRGroupEnableSetResponse{} }
func (m *AccelRGroupEnableSetResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupEnableSetResponse) ProtoMessage()    {}
func (*AccelRGroupEnableSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{22}
}

func (m *AccelRGroupEnableSetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AccelRGroupEnableSetResponse) GetLastRingHandle() uint32 {
	if m != nil {
		return m.LastRingHandle
	}
	return 0
}

func (m *AccelRGroupEnableSetResponse) GetLastSubRing() uint32 {
	if m != nil {
		return m.LastSubRing
	}
	return 0
}

type AccelRGroupEnableSetResponseMsg struct {
	Response []*AccelRGroupEnableSetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupEnableSetResponseMsg) Reset()         { *m = AccelRGroupEnableSetResponseMsg{} }
func (m *AccelRGroupEnableSetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupEnableSetResponseMsg) ProtoMessage()    {}
func (*AccelRGroupEnableSetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{23}
}

func (m *AccelRGroupEnableSetResponseMsg) GetResponse() []*AccelRGroupEnableSetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupPndxSetRequest struct {
	RgroupName  string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
	SubRing     uint32 `protobuf:"varint,2,opt,name=sub_ring,json=subRing,proto3" json:"sub_ring,omitempty"`
	Val         uint32 `protobuf:"varint,3,opt,name=val,proto3" json:"val,omitempty"`
	Conditional uint32 `protobuf:"varint,4,opt,name=conditional,proto3" json:"conditional,omitempty"`
}

func (m *AccelRGroupPndxSetRequest) Reset()         { *m = AccelRGroupPndxSetRequest{} }
func (m *AccelRGroupPndxSetRequest) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupPndxSetRequest) ProtoMessage()    {}
func (*AccelRGroupPndxSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{24}
}

func (m *AccelRGroupPndxSetRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

func (m *AccelRGroupPndxSetRequest) GetSubRing() uint32 {
	if m != nil {
		return m.SubRing
	}
	return 0
}

func (m *AccelRGroupPndxSetRequest) GetVal() uint32 {
	if m != nil {
		return m.Val
	}
	return 0
}

func (m *AccelRGroupPndxSetRequest) GetConditional() uint32 {
	if m != nil {
		return m.Conditional
	}
	return 0
}

type AccelRGroupPndxSetRequestMsg struct {
	Request []*AccelRGroupPndxSetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupPndxSetRequestMsg) Reset()         { *m = AccelRGroupPndxSetRequestMsg{} }
func (m *AccelRGroupPndxSetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupPndxSetRequestMsg) ProtoMessage()    {}
func (*AccelRGroupPndxSetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{25}
}

func (m *AccelRGroupPndxSetRequestMsg) GetRequest() []*AccelRGroupPndxSetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupPndxSetResponse struct {
	ApiStatus      ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	LastRingHandle uint32    `protobuf:"varint,2,opt,name=last_ring_handle,json=lastRingHandle,proto3" json:"last_ring_handle,omitempty"`
	LastSubRing    uint32    `protobuf:"varint,3,opt,name=last_sub_ring,json=lastSubRing,proto3" json:"last_sub_ring,omitempty"`
}

func (m *AccelRGroupPndxSetResponse) Reset()         { *m = AccelRGroupPndxSetResponse{} }
func (m *AccelRGroupPndxSetResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupPndxSetResponse) ProtoMessage()    {}
func (*AccelRGroupPndxSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{26}
}

func (m *AccelRGroupPndxSetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AccelRGroupPndxSetResponse) GetLastRingHandle() uint32 {
	if m != nil {
		return m.LastRingHandle
	}
	return 0
}

func (m *AccelRGroupPndxSetResponse) GetLastSubRing() uint32 {
	if m != nil {
		return m.LastSubRing
	}
	return 0
}

type AccelRGroupPndxSetResponseMsg struct {
	Response []*AccelRGroupPndxSetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupPndxSetResponseMsg) Reset()         { *m = AccelRGroupPndxSetResponseMsg{} }
func (m *AccelRGroupPndxSetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupPndxSetResponseMsg) ProtoMessage()    {}
func (*AccelRGroupPndxSetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{27}
}

func (m *AccelRGroupPndxSetResponseMsg) GetResponse() []*AccelRGroupPndxSetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupInfoGetRequest struct {
	RgroupName string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
	SubRing    uint32 `protobuf:"varint,2,opt,name=sub_ring,json=subRing,proto3" json:"sub_ring,omitempty"`
}

func (m *AccelRGroupInfoGetRequest) Reset()         { *m = AccelRGroupInfoGetRequest{} }
func (m *AccelRGroupInfoGetRequest) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupInfoGetRequest) ProtoMessage()    {}
func (*AccelRGroupInfoGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{28}
}

func (m *AccelRGroupInfoGetRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

func (m *AccelRGroupInfoGetRequest) GetSubRing() uint32 {
	if m != nil {
		return m.SubRing
	}
	return 0
}

type AccelRGroupInfoGetRequestMsg struct {
	Request []*AccelRGroupInfoGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupInfoGetRequestMsg) Reset()         { *m = AccelRGroupInfoGetRequestMsg{} }
func (m *AccelRGroupInfoGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupInfoGetRequestMsg) ProtoMessage()    {}
func (*AccelRGroupInfoGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{29}
}

func (m *AccelRGroupInfoGetRequestMsg) GetRequest() []*AccelRGroupInfoGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupRingInfoSpec struct {
	RingHandle      uint32 `protobuf:"varint,1,opt,name=ring_handle,json=ringHandle,proto3" json:"ring_handle,omitempty"`
	SubRing         uint32 `protobuf:"varint,2,opt,name=sub_ring,json=subRing,proto3" json:"sub_ring,omitempty"`
	BasePa          uint64 `protobuf:"fixed64,3,opt,name=base_pa,json=basePa,proto3" json:"base_pa,omitempty"`
	PndxPa          uint64 `protobuf:"fixed64,4,opt,name=pndx_pa,json=pndxPa,proto3" json:"pndx_pa,omitempty"`
	ShadowPndxPa    uint64 `protobuf:"fixed64,5,opt,name=shadow_pndx_pa,json=shadowPndxPa,proto3" json:"shadow_pndx_pa,omitempty"`
	OpaqueTagPa     uint64 `protobuf:"fixed64,6,opt,name=opaque_tag_pa,json=opaqueTagPa,proto3" json:"opaque_tag_pa,omitempty"`
	OpaqueTagSize   uint32 `protobuf:"varint,7,opt,name=opaque_tag_size,json=opaqueTagSize,proto3" json:"opaque_tag_size,omitempty"`
	RingSize        uint32 `protobuf:"varint,8,opt,name=ring_size,json=ringSize,proto3" json:"ring_size,omitempty"`
	DescSize        uint32 `protobuf:"varint,9,opt,name=desc_size,json=descSize,proto3" json:"desc_size,omitempty"`
	PndxSize        uint32 `protobuf:"varint,10,opt,name=pndx_size,json=pndxSize,proto3" json:"pndx_size,omitempty"`
	SwResetCapable  uint32 `protobuf:"varint,11,opt,name=sw_reset_capable,json=swResetCapable,proto3" json:"sw_reset_capable,omitempty"`
	SwEnableCapable uint32 `protobuf:"varint,12,opt,name=sw_enable_capable,json=swEnableCapable,proto3" json:"sw_enable_capable,omitempty"`
}

func (m *AccelRGroupRingInfoSpec) Reset()         { *m = AccelRGroupRingInfoSpec{} }
func (m *AccelRGroupRingInfoSpec) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingInfoSpec) ProtoMessage()    {}
func (*AccelRGroupRingInfoSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{30}
}

func (m *AccelRGroupRingInfoSpec) GetRingHandle() uint32 {
	if m != nil {
		return m.RingHandle
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetSubRing() uint32 {
	if m != nil {
		return m.SubRing
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetBasePa() uint64 {
	if m != nil {
		return m.BasePa
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetPndxPa() uint64 {
	if m != nil {
		return m.PndxPa
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetShadowPndxPa() uint64 {
	if m != nil {
		return m.ShadowPndxPa
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetOpaqueTagPa() uint64 {
	if m != nil {
		return m.OpaqueTagPa
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetOpaqueTagSize() uint32 {
	if m != nil {
		return m.OpaqueTagSize
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetRingSize() uint32 {
	if m != nil {
		return m.RingSize
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetDescSize() uint32 {
	if m != nil {
		return m.DescSize
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetPndxSize() uint32 {
	if m != nil {
		return m.PndxSize
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetSwResetCapable() uint32 {
	if m != nil {
		return m.SwResetCapable
	}
	return 0
}

func (m *AccelRGroupRingInfoSpec) GetSwEnableCapable() uint32 {
	if m != nil {
		return m.SwEnableCapable
	}
	return 0
}

type AccelRGroupInfoGetResponse struct {
	ApiStatus    ApiStatus                  `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	RingInfoSpec []*AccelRGroupRingInfoSpec `protobuf:"bytes,2,rep,name=ring_info_spec,json=ringInfoSpec" json:"ring_info_spec,omitempty"`
}

func (m *AccelRGroupInfoGetResponse) Reset()         { *m = AccelRGroupInfoGetResponse{} }
func (m *AccelRGroupInfoGetResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupInfoGetResponse) ProtoMessage()    {}
func (*AccelRGroupInfoGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{31}
}

func (m *AccelRGroupInfoGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AccelRGroupInfoGetResponse) GetRingInfoSpec() []*AccelRGroupRingInfoSpec {
	if m != nil {
		return m.RingInfoSpec
	}
	return nil
}

type AccelRGroupInfoGetResponseMsg struct {
	Response []*AccelRGroupInfoGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupInfoGetResponseMsg) Reset()         { *m = AccelRGroupInfoGetResponseMsg{} }
func (m *AccelRGroupInfoGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupInfoGetResponseMsg) ProtoMessage()    {}
func (*AccelRGroupInfoGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{32}
}

func (m *AccelRGroupInfoGetResponseMsg) GetResponse() []*AccelRGroupInfoGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

type AccelRGroupIndicesGetRequest struct {
	RgroupName string `protobuf:"bytes,1,opt,name=rgroup_name,json=rgroupName,proto3" json:"rgroup_name,omitempty"`
	SubRing    uint32 `protobuf:"varint,2,opt,name=sub_ring,json=subRing,proto3" json:"sub_ring,omitempty"`
}

func (m *AccelRGroupIndicesGetRequest) Reset()         { *m = AccelRGroupIndicesGetRequest{} }
func (m *AccelRGroupIndicesGetRequest) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupIndicesGetRequest) ProtoMessage()    {}
func (*AccelRGroupIndicesGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{33}
}

func (m *AccelRGroupIndicesGetRequest) GetRgroupName() string {
	if m != nil {
		return m.RgroupName
	}
	return ""
}

func (m *AccelRGroupIndicesGetRequest) GetSubRing() uint32 {
	if m != nil {
		return m.SubRing
	}
	return 0
}

type AccelRGroupIndicesGetRequestMsg struct {
	Request []*AccelRGroupIndicesGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *AccelRGroupIndicesGetRequestMsg) Reset()         { *m = AccelRGroupIndicesGetRequestMsg{} }
func (m *AccelRGroupIndicesGetRequestMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupIndicesGetRequestMsg) ProtoMessage()    {}
func (*AccelRGroupIndicesGetRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{34}
}

func (m *AccelRGroupIndicesGetRequestMsg) GetRequest() []*AccelRGroupIndicesGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type AccelRGroupRingIndicesSpec struct {
	RingHandle uint32 `protobuf:"varint,1,opt,name=ring_handle,json=ringHandle,proto3" json:"ring_handle,omitempty"`
	SubRing    uint32 `protobuf:"varint,2,opt,name=sub_ring,json=subRing,proto3" json:"sub_ring,omitempty"`
	Pndx       uint32 `protobuf:"varint,3,opt,name=pndx,proto3" json:"pndx,omitempty"`
	Cndx       uint32 `protobuf:"varint,4,opt,name=cndx,proto3" json:"cndx,omitempty"`
}

func (m *AccelRGroupRingIndicesSpec) Reset()         { *m = AccelRGroupRingIndicesSpec{} }
func (m *AccelRGroupRingIndicesSpec) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupRingIndicesSpec) ProtoMessage()    {}
func (*AccelRGroupRingIndicesSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{35}
}

func (m *AccelRGroupRingIndicesSpec) GetRingHandle() uint32 {
	if m != nil {
		return m.RingHandle
	}
	return 0
}

func (m *AccelRGroupRingIndicesSpec) GetSubRing() uint32 {
	if m != nil {
		return m.SubRing
	}
	return 0
}

func (m *AccelRGroupRingIndicesSpec) GetPndx() uint32 {
	if m != nil {
		return m.Pndx
	}
	return 0
}

func (m *AccelRGroupRingIndicesSpec) GetCndx() uint32 {
	if m != nil {
		return m.Cndx
	}
	return 0
}

type AccelRGroupIndicesGetResponse struct {
	ApiStatus       ApiStatus                     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty"`
	RingIndicesSpec []*AccelRGroupRingIndicesSpec `protobuf:"bytes,2,rep,name=ring_indices_spec,json=ringIndicesSpec" json:"ring_indices_spec,omitempty"`
}

func (m *AccelRGroupIndicesGetResponse) Reset()         { *m = AccelRGroupIndicesGetResponse{} }
func (m *AccelRGroupIndicesGetResponse) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupIndicesGetResponse) ProtoMessage()    {}
func (*AccelRGroupIndicesGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{36}
}

func (m *AccelRGroupIndicesGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *AccelRGroupIndicesGetResponse) GetRingIndicesSpec() []*AccelRGroupRingIndicesSpec {
	if m != nil {
		return m.RingIndicesSpec
	}
	return nil
}

type AccelRGroupIndicesGetResponseMsg struct {
	Response []*AccelRGroupIndicesGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *AccelRGroupIndicesGetResponseMsg) Reset()         { *m = AccelRGroupIndicesGetResponseMsg{} }
func (m *AccelRGroupIndicesGetResponseMsg) String() string { return proto.CompactTextString(m) }
func (*AccelRGroupIndicesGetResponseMsg) ProtoMessage()    {}
func (*AccelRGroupIndicesGetResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorAccelRgroup, []int{37}
}

func (m *AccelRGroupIndicesGetResponseMsg) GetResponse() []*AccelRGroupIndicesGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*AccelRGroupAddRequest)(nil), "accelRGroup.AccelRGroupAddRequest")
	proto.RegisterType((*AccelRGroupAddRequestMsg)(nil), "accelRGroup.AccelRGroupAddRequestMsg")
	proto.RegisterType((*AccelRGroupAddResponse)(nil), "accelRGroup.AccelRGroupAddResponse")
	proto.RegisterType((*AccelRGroupAddResponseMsg)(nil), "accelRGroup.AccelRGroupAddResponseMsg")
	proto.RegisterType((*AccelRGroupDelRequest)(nil), "accelRGroup.AccelRGroupDelRequest")
	proto.RegisterType((*AccelRGroupDelRequestMsg)(nil), "accelRGroup.AccelRGroupDelRequestMsg")
	proto.RegisterType((*AccelRGroupDelResponse)(nil), "accelRGroup.AccelRGroupDelResponse")
	proto.RegisterType((*AccelRGroupDelResponseMsg)(nil), "accelRGroup.AccelRGroupDelResponseMsg")
	proto.RegisterType((*AccelRGroupRingAddRequest)(nil), "accelRGroup.AccelRGroupRingAddRequest")
	proto.RegisterType((*AccelRGroupRingAddRequestMsg)(nil), "accelRGroup.AccelRGroupRingAddRequestMsg")
	proto.RegisterType((*AccelRGroupRingAddResponse)(nil), "accelRGroup.AccelRGroupRingAddResponse")
	proto.RegisterType((*AccelRGroupRingAddResponseMsg)(nil), "accelRGroup.AccelRGroupRingAddResponseMsg")
	proto.RegisterType((*AccelRGroupRingDelRequest)(nil), "accelRGroup.AccelRGroupRingDelRequest")
	proto.RegisterType((*AccelRGroupRingDelRequestMsg)(nil), "accelRGroup.AccelRGroupRingDelRequestMsg")
	proto.RegisterType((*AccelRGroupRingDelResponse)(nil), "accelRGroup.AccelRGroupRingDelResponse")
	proto.RegisterType((*AccelRGroupRingDelResponseMsg)(nil), "accelRGroup.AccelRGroupRingDelResponseMsg")
	proto.RegisterType((*AccelRGroupResetSetRequest)(nil), "accelRGroup.AccelRGroupResetSetRequest")
	proto.RegisterType((*AccelRGroupResetSetRequestMsg)(nil), "accelRGroup.AccelRGroupResetSetRequestMsg")
	proto.RegisterType((*AccelRGroupResetSetResponse)(nil), "accelRGroup.AccelRGroupResetSetResponse")
	proto.RegisterType((*AccelRGroupResetSetResponseMsg)(nil), "accelRGroup.AccelRGroupResetSetResponseMsg")
	proto.RegisterType((*AccelRGroupEnableSetRequest)(nil), "accelRGroup.AccelRGroupEnableSetRequest")
	proto.RegisterType((*AccelRGroupEnableSetRequestMsg)(nil), "accelRGroup.AccelRGroupEnableSetRequestMsg")
	proto.RegisterType((*AccelRGroupEnableSetResponse)(nil), "accelRGroup.AccelRGroupEnableSetResponse")
	proto.RegisterType((*AccelRGroupEnableSetResponseMsg)(nil), "accelRGroup.AccelRGroupEnableSetResponseMsg")
	proto.RegisterType((*AccelRGroupPndxSetRequest)(nil), "accelRGroup.AccelRGroupPndxSetRequest")
	proto.RegisterType((*AccelRGroupPndxSetRequestMsg)(nil), "accelRGroup.AccelRGroupPndxSetRequestMsg")
	proto.RegisterType((*AccelRGroupPndxSetResponse)(nil), "accelRGroup.AccelRGroupPndxSetResponse")
	proto.RegisterType((*AccelRGroupPndxSetResponseMsg)(nil), "accelRGroup.AccelRGroupPndxSetResponseMsg")
	proto.RegisterType((*AccelRGroupInfoGetRequest)(nil), "accelRGroup.AccelRGroupInfoGetRequest")
	proto.RegisterType((*AccelRGroupInfoGetRequestMsg)(nil), "accelRGroup.AccelRGroupInfoGetRequestMsg")
	proto.RegisterType((*AccelRGroupRingInfoSpec)(nil), "accelRGroup.AccelRGroupRingInfoSpec")
	proto.RegisterType((*AccelRGroupInfoGetResponse)(nil), "accelRGroup.AccelRGroupInfoGetResponse")
	proto.RegisterType((*AccelRGroupInfoGetResponseMsg)(nil), "accelRGroup.AccelRGroupInfoGetResponseMsg")
	proto.RegisterType((*AccelRGroupIndicesGetRequest)(nil), "accelRGroup.AccelRGroupIndicesGetRequest")
	proto.RegisterType((*AccelRGroupIndicesGetRequestMsg)(nil), "accelRGroup.AccelRGroupIndicesGetRequestMsg")
	proto.RegisterType((*AccelRGroupRingIndicesSpec)(nil), "accelRGroup.AccelRGroupRingIndicesSpec")
	proto.RegisterType((*AccelRGroupIndicesGetResponse)(nil), "accelRGroup.AccelRGroupIndicesGetResponse")
	proto.RegisterType((*AccelRGroupIndicesGetResponseMsg)(nil), "accelRGroup.AccelRGroupIndicesGetResponseMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AccelRGroup service

type AccelRGroupClient interface {
	AccelRGroupAdd(ctx context.Context, in *AccelRGroupAddRequestMsg, opts ...grpc.CallOption) (*AccelRGroupAddResponseMsg, error)
	AccelRGroupDel(ctx context.Context, in *AccelRGroupDelRequestMsg, opts ...grpc.CallOption) (*AccelRGroupDelResponseMsg, error)
	AccelRGroupRingAdd(ctx context.Context, in *AccelRGroupRingAddRequestMsg, opts ...grpc.CallOption) (*AccelRGroupRingAddResponseMsg, error)
	AccelRGroupRingDel(ctx context.Context, in *AccelRGroupRingDelRequestMsg, opts ...grpc.CallOption) (*AccelRGroupRingDelResponseMsg, error)
	AccelRGroupResetSet(ctx context.Context, in *AccelRGroupResetSetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupResetSetResponseMsg, error)
	AccelRGroupEnableSet(ctx context.Context, in *AccelRGroupEnableSetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupEnableSetResponseMsg, error)
	AccelRGroupPndxSet(ctx context.Context, in *AccelRGroupPndxSetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupPndxSetResponseMsg, error)
	AccelRGroupInfoGet(ctx context.Context, in *AccelRGroupInfoGetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupInfoGetResponseMsg, error)
	AccelRGroupIndicesGet(ctx context.Context, in *AccelRGroupIndicesGetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupIndicesGetResponseMsg, error)
}

type accelRGroupClient struct {
	cc *grpc.ClientConn
}

func NewAccelRGroupClient(cc *grpc.ClientConn) AccelRGroupClient {
	return &accelRGroupClient{cc}
}

func (c *accelRGroupClient) AccelRGroupAdd(ctx context.Context, in *AccelRGroupAddRequestMsg, opts ...grpc.CallOption) (*AccelRGroupAddResponseMsg, error) {
	out := new(AccelRGroupAddResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupDel(ctx context.Context, in *AccelRGroupDelRequestMsg, opts ...grpc.CallOption) (*AccelRGroupDelResponseMsg, error) {
	out := new(AccelRGroupDelResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupDel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupRingAdd(ctx context.Context, in *AccelRGroupRingAddRequestMsg, opts ...grpc.CallOption) (*AccelRGroupRingAddResponseMsg, error) {
	out := new(AccelRGroupRingAddResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupRingAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupRingDel(ctx context.Context, in *AccelRGroupRingDelRequestMsg, opts ...grpc.CallOption) (*AccelRGroupRingDelResponseMsg, error) {
	out := new(AccelRGroupRingDelResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupRingDel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupResetSet(ctx context.Context, in *AccelRGroupResetSetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupResetSetResponseMsg, error) {
	out := new(AccelRGroupResetSetResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupResetSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupEnableSet(ctx context.Context, in *AccelRGroupEnableSetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupEnableSetResponseMsg, error) {
	out := new(AccelRGroupEnableSetResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupEnableSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupPndxSet(ctx context.Context, in *AccelRGroupPndxSetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupPndxSetResponseMsg, error) {
	out := new(AccelRGroupPndxSetResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupPndxSet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupInfoGet(ctx context.Context, in *AccelRGroupInfoGetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupInfoGetResponseMsg, error) {
	out := new(AccelRGroupInfoGetResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupInfoGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accelRGroupClient) AccelRGroupIndicesGet(ctx context.Context, in *AccelRGroupIndicesGetRequestMsg, opts ...grpc.CallOption) (*AccelRGroupIndicesGetResponseMsg, error) {
	out := new(AccelRGroupIndicesGetResponseMsg)
	err := grpc.Invoke(ctx, "/accelRGroup.AccelRGroup/AccelRGroupIndicesGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AccelRGroup service

type AccelRGroupServer interface {
	AccelRGroupAdd(context.Context, *AccelRGroupAddRequestMsg) (*AccelRGroupAddResponseMsg, error)
	AccelRGroupDel(context.Context, *AccelRGroupDelRequestMsg) (*AccelRGroupDelResponseMsg, error)
	AccelRGroupRingAdd(context.Context, *AccelRGroupRingAddRequestMsg) (*AccelRGroupRingAddResponseMsg, error)
	AccelRGroupRingDel(context.Context, *AccelRGroupRingDelRequestMsg) (*AccelRGroupRingDelResponseMsg, error)
	AccelRGroupResetSet(context.Context, *AccelRGroupResetSetRequestMsg) (*AccelRGroupResetSetResponseMsg, error)
	AccelRGroupEnableSet(context.Context, *AccelRGroupEnableSetRequestMsg) (*AccelRGroupEnableSetResponseMsg, error)
	AccelRGroupPndxSet(context.Context, *AccelRGroupPndxSetRequestMsg) (*AccelRGroupPndxSetResponseMsg, error)
	AccelRGroupInfoGet(context.Context, *AccelRGroupInfoGetRequestMsg) (*AccelRGroupInfoGetResponseMsg, error)
	AccelRGroupIndicesGet(context.Context, *AccelRGroupIndicesGetRequestMsg) (*AccelRGroupIndicesGetResponseMsg, error)
}

func RegisterAccelRGroupServer(s *grpc.Server, srv AccelRGroupServer) {
	s.RegisterService(&_AccelRGroup_serviceDesc, srv)
}

func _AccelRGroup_AccelRGroupAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupAddRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupAdd(ctx, req.(*AccelRGroupAddRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupDelRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupDel(ctx, req.(*AccelRGroupDelRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupRingAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupRingAddRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupRingAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupRingAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupRingAdd(ctx, req.(*AccelRGroupRingAddRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupRingDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupRingDelRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupRingDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupRingDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupRingDel(ctx, req.(*AccelRGroupRingDelRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupResetSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupResetSetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupResetSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupResetSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupResetSet(ctx, req.(*AccelRGroupResetSetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupEnableSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupEnableSetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupEnableSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupEnableSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupEnableSet(ctx, req.(*AccelRGroupEnableSetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupPndxSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupPndxSetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupPndxSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupPndxSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupPndxSet(ctx, req.(*AccelRGroupPndxSetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupInfoGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupInfoGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupInfoGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupInfoGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupInfoGet(ctx, req.(*AccelRGroupInfoGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccelRGroup_AccelRGroupIndicesGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccelRGroupIndicesGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccelRGroupServer).AccelRGroupIndicesGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/accelRGroup.AccelRGroup/AccelRGroupIndicesGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccelRGroupServer).AccelRGroupIndicesGet(ctx, req.(*AccelRGroupIndicesGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccelRGroup_serviceDesc = grpc.ServiceDesc{
	ServiceName: "accelRGroup.AccelRGroup",
	HandlerType: (*AccelRGroupServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AccelRGroupAdd",
			Handler:    _AccelRGroup_AccelRGroupAdd_Handler,
		},
		{
			MethodName: "AccelRGroupDel",
			Handler:    _AccelRGroup_AccelRGroupDel_Handler,
		},
		{
			MethodName: "AccelRGroupRingAdd",
			Handler:    _AccelRGroup_AccelRGroupRingAdd_Handler,
		},
		{
			MethodName: "AccelRGroupRingDel",
			Handler:    _AccelRGroup_AccelRGroupRingDel_Handler,
		},
		{
			MethodName: "AccelRGroupResetSet",
			Handler:    _AccelRGroup_AccelRGroupResetSet_Handler,
		},
		{
			MethodName: "AccelRGroupEnableSet",
			Handler:    _AccelRGroup_AccelRGroupEnableSet_Handler,
		},
		{
			MethodName: "AccelRGroupPndxSet",
			Handler:    _AccelRGroup_AccelRGroupPndxSet_Handler,
		},
		{
			MethodName: "AccelRGroupInfoGet",
			Handler:    _AccelRGroup_AccelRGroupInfoGet_Handler,
		},
		{
			MethodName: "AccelRGroupIndicesGet",
			Handler:    _AccelRGroup_AccelRGroupIndicesGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accel_rgroup.proto",
}

func (m *AccelRGroupAddRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupAddRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	return i, nil
}

func (m *AccelRGroupAddRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupAddRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupAddResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupAddResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *AccelRGroupAddResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupAddResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupDelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupDelRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	return i, nil
}

func (m *AccelRGroupDelRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupDelRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupDelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupDelResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *AccelRGroupDelResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupDelResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupRingAddRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingAddRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	if len(m.RingName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RingName)))
		i += copy(dAtA[i:], m.RingName)
	}
	if m.RingHandle != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.RingHandle))
	}
	return i, nil
}

func (m *AccelRGroupRingAddRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingAddRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupRingAddResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingAddResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	if m.RingHandle != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.RingHandle))
	}
	return i, nil
}

func (m *AccelRGroupRingAddResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingAddResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupRingDelRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingDelRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	if len(m.RingName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RingName)))
		i += copy(dAtA[i:], m.RingName)
	}
	return i, nil
}

func (m *AccelRGroupRingDelRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingDelRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupRingDelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingDelResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *AccelRGroupRingDelResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingDelResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupResetSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupResetSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	if m.SubRing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SubRing))
	}
	if m.ResetSense != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ResetSense))
	}
	return i, nil
}

func (m *AccelRGroupResetSetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupResetSetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupResetSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupResetSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	if m.LastRingHandle != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.LastRingHandle))
	}
	if m.LastSubRing != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.LastSubRing))
	}
	return i, nil
}

func (m *AccelRGroupResetSetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupResetSetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupEnableSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupEnableSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	if m.SubRing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SubRing))
	}
	if m.EnableSense != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.EnableSense))
	}
	return i, nil
}

func (m *AccelRGroupEnableSetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupEnableSetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupEnableSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupEnableSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	if m.LastRingHandle != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.LastRingHandle))
	}
	if m.LastSubRing != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.LastSubRing))
	}
	return i, nil
}

func (m *AccelRGroupEnableSetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupEnableSetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupPndxSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupPndxSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	if m.SubRing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SubRing))
	}
	if m.Val != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.Val))
	}
	if m.Conditional != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.Conditional))
	}
	return i, nil
}

func (m *AccelRGroupPndxSetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupPndxSetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupPndxSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupPndxSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	if m.LastRingHandle != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.LastRingHandle))
	}
	if m.LastSubRing != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.LastSubRing))
	}
	return i, nil
}

func (m *AccelRGroupPndxSetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupPndxSetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupInfoGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupInfoGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	if m.SubRing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SubRing))
	}
	return i, nil
}

func (m *AccelRGroupInfoGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupInfoGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupRingInfoSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingInfoSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RingHandle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.RingHandle))
	}
	if m.SubRing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SubRing))
	}
	if m.BasePa != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.BasePa))
		i += 8
	}
	if m.PndxPa != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.PndxPa))
		i += 8
	}
	if m.ShadowPndxPa != 0 {
		dAtA[i] = 0x29
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.ShadowPndxPa))
		i += 8
	}
	if m.OpaqueTagPa != 0 {
		dAtA[i] = 0x31
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.OpaqueTagPa))
		i += 8
	}
	if m.OpaqueTagSize != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.OpaqueTagSize))
	}
	if m.RingSize != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.RingSize))
	}
	if m.DescSize != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.DescSize))
	}
	if m.PndxSize != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.PndxSize))
	}
	if m.SwResetCapable != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SwResetCapable))
	}
	if m.SwEnableCapable != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SwEnableCapable))
	}
	return i, nil
}

func (m *AccelRGroupInfoGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupInfoGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.RingInfoSpec) > 0 {
		for _, msg := range m.RingInfoSpec {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupInfoGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupInfoGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupIndicesGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupIndicesGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RgroupName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(len(m.RgroupName)))
		i += copy(dAtA[i:], m.RgroupName)
	}
	if m.SubRing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SubRing))
	}
	return i, nil
}

func (m *AccelRGroupIndicesGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupIndicesGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupRingIndicesSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupRingIndicesSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RingHandle != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.RingHandle))
	}
	if m.SubRing != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.SubRing))
	}
	if m.Pndx != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.Pndx))
	}
	if m.Cndx != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.Cndx))
	}
	return i, nil
}

func (m *AccelRGroupIndicesGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupIndicesGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccelRgroup(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.RingIndicesSpec) > 0 {
		for _, msg := range m.RingIndicesSpec {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccelRGroupIndicesGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccelRGroupIndicesGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccelRgroup(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintAccelRgroup(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AccelRGroupAddRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	return n
}

func (m *AccelRGroupAddRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupAddResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	return n
}

func (m *AccelRGroupAddResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupDelRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	return n
}

func (m *AccelRGroupDelRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupDelResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	return n
}

func (m *AccelRGroupDelResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupRingAddRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	l = len(m.RingName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	if m.RingHandle != 0 {
		n += 1 + sovAccelRgroup(uint64(m.RingHandle))
	}
	return n
}

func (m *AccelRGroupRingAddRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupRingAddResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	if m.RingHandle != 0 {
		n += 1 + sovAccelRgroup(uint64(m.RingHandle))
	}
	return n
}

func (m *AccelRGroupRingAddResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupRingDelRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	l = len(m.RingName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	return n
}

func (m *AccelRGroupRingDelRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupRingDelResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	return n
}

func (m *AccelRGroupRingDelResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupResetSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	if m.SubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SubRing))
	}
	if m.ResetSense != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ResetSense))
	}
	return n
}

func (m *AccelRGroupResetSetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupResetSetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	if m.LastRingHandle != 0 {
		n += 1 + sovAccelRgroup(uint64(m.LastRingHandle))
	}
	if m.LastSubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.LastSubRing))
	}
	return n
}

func (m *AccelRGroupResetSetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupEnableSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	if m.SubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SubRing))
	}
	if m.EnableSense != 0 {
		n += 1 + sovAccelRgroup(uint64(m.EnableSense))
	}
	return n
}

func (m *AccelRGroupEnableSetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupEnableSetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	if m.LastRingHandle != 0 {
		n += 1 + sovAccelRgroup(uint64(m.LastRingHandle))
	}
	if m.LastSubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.LastSubRing))
	}
	return n
}

func (m *AccelRGroupEnableSetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupPndxSetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	if m.SubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SubRing))
	}
	if m.Val != 0 {
		n += 1 + sovAccelRgroup(uint64(m.Val))
	}
	if m.Conditional != 0 {
		n += 1 + sovAccelRgroup(uint64(m.Conditional))
	}
	return n
}

func (m *AccelRGroupPndxSetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupPndxSetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	if m.LastRingHandle != 0 {
		n += 1 + sovAccelRgroup(uint64(m.LastRingHandle))
	}
	if m.LastSubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.LastSubRing))
	}
	return n
}

func (m *AccelRGroupPndxSetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupInfoGetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	if m.SubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SubRing))
	}
	return n
}

func (m *AccelRGroupInfoGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupRingInfoSpec) Size() (n int) {
	var l int
	_ = l
	if m.RingHandle != 0 {
		n += 1 + sovAccelRgroup(uint64(m.RingHandle))
	}
	if m.SubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SubRing))
	}
	if m.BasePa != 0 {
		n += 9
	}
	if m.PndxPa != 0 {
		n += 9
	}
	if m.ShadowPndxPa != 0 {
		n += 9
	}
	if m.OpaqueTagPa != 0 {
		n += 9
	}
	if m.OpaqueTagSize != 0 {
		n += 1 + sovAccelRgroup(uint64(m.OpaqueTagSize))
	}
	if m.RingSize != 0 {
		n += 1 + sovAccelRgroup(uint64(m.RingSize))
	}
	if m.DescSize != 0 {
		n += 1 + sovAccelRgroup(uint64(m.DescSize))
	}
	if m.PndxSize != 0 {
		n += 1 + sovAccelRgroup(uint64(m.PndxSize))
	}
	if m.SwResetCapable != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SwResetCapable))
	}
	if m.SwEnableCapable != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SwEnableCapable))
	}
	return n
}

func (m *AccelRGroupInfoGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	if len(m.RingInfoSpec) > 0 {
		for _, e := range m.RingInfoSpec {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupInfoGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupIndicesGetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RgroupName)
	if l > 0 {
		n += 1 + l + sovAccelRgroup(uint64(l))
	}
	if m.SubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SubRing))
	}
	return n
}

func (m *AccelRGroupIndicesGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupRingIndicesSpec) Size() (n int) {
	var l int
	_ = l
	if m.RingHandle != 0 {
		n += 1 + sovAccelRgroup(uint64(m.RingHandle))
	}
	if m.SubRing != 0 {
		n += 1 + sovAccelRgroup(uint64(m.SubRing))
	}
	if m.Pndx != 0 {
		n += 1 + sovAccelRgroup(uint64(m.Pndx))
	}
	if m.Cndx != 0 {
		n += 1 + sovAccelRgroup(uint64(m.Cndx))
	}
	return n
}

func (m *AccelRGroupIndicesGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovAccelRgroup(uint64(m.ApiStatus))
	}
	if len(m.RingIndicesSpec) > 0 {
		for _, e := range m.RingIndicesSpec {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func (m *AccelRGroupIndicesGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovAccelRgroup(uint64(l))
		}
	}
	return n
}

func sovAccelRgroup(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAccelRgroup(x uint64) (n int) {
	return sovAccelRgroup(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccelRGroupAddRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupAddRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupAddRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupAddRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupAddRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupAddRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupAddRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupAddResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupAddResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupAddResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupAddResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupAddResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupAddResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupAddResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupDelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupDelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupDelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupDelRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupDelRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupDelRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupDelRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupDelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupDelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupDelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupDelResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupDelResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupDelResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupDelResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingAddRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingAddRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingAddRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RingName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingHandle", wireType)
			}
			m.RingHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingAddRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingAddRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingAddRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupRingAddRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingAddResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingAddResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingAddResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingHandle", wireType)
			}
			m.RingHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingAddResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingAddResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingAddResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupRingAddResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingDelRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingDelRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingDelRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RingName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingDelRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingDelRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingDelRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupRingDelRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingDelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingDelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingDelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingDelResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingDelResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingDelResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupRingDelResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupResetSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupResetSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupResetSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRing", wireType)
			}
			m.SubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetSense", wireType)
			}
			m.ResetSense = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetSense |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupResetSetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupResetSetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupResetSetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupResetSetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupResetSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupResetSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupResetSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRingHandle", wireType)
			}
			m.LastRingHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRingHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSubRing", wireType)
			}
			m.LastSubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupResetSetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupResetSetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupResetSetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupResetSetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupEnableSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupEnableSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupEnableSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRing", wireType)
			}
			m.SubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableSense", wireType)
			}
			m.EnableSense = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnableSense |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupEnableSetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupEnableSetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupEnableSetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupEnableSetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupEnableSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupEnableSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupEnableSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRingHandle", wireType)
			}
			m.LastRingHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRingHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSubRing", wireType)
			}
			m.LastSubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupEnableSetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupEnableSetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupEnableSetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupEnableSetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupPndxSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupPndxSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupPndxSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRing", wireType)
			}
			m.SubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			m.Val = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Val |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditional", wireType)
			}
			m.Conditional = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Conditional |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupPndxSetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupPndxSetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupPndxSetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupPndxSetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupPndxSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupPndxSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupPndxSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRingHandle", wireType)
			}
			m.LastRingHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRingHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSubRing", wireType)
			}
			m.LastSubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupPndxSetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupPndxSetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupPndxSetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupPndxSetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupInfoGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupInfoGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupInfoGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRing", wireType)
			}
			m.SubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupInfoGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupInfoGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupInfoGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupInfoGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingInfoSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingInfoSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingInfoSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingHandle", wireType)
			}
			m.RingHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRing", wireType)
			}
			m.SubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePa", wireType)
			}
			m.BasePa = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.BasePa = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PndxPa", wireType)
			}
			m.PndxPa = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.PndxPa = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShadowPndxPa", wireType)
			}
			m.ShadowPndxPa = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.ShadowPndxPa = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpaqueTagPa", wireType)
			}
			m.OpaqueTagPa = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.OpaqueTagPa = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpaqueTagSize", wireType)
			}
			m.OpaqueTagSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpaqueTagSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingSize", wireType)
			}
			m.RingSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescSize", wireType)
			}
			m.DescSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DescSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PndxSize", wireType)
			}
			m.PndxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PndxSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwResetCapable", wireType)
			}
			m.SwResetCapable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwResetCapable |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwEnableCapable", wireType)
			}
			m.SwEnableCapable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwEnableCapable |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupInfoGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupInfoGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupInfoGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingInfoSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RingInfoSpec = append(m.RingInfoSpec, &AccelRGroupRingInfoSpec{})
			if err := m.RingInfoSpec[len(m.RingInfoSpec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupInfoGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupInfoGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupInfoGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupInfoGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupIndicesGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RgroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RgroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRing", wireType)
			}
			m.SubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupIndicesGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &AccelRGroupIndicesGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupRingIndicesSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupRingIndicesSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupRingIndicesSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingHandle", wireType)
			}
			m.RingHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RingHandle |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubRing", wireType)
			}
			m.SubRing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubRing |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pndx", wireType)
			}
			m.Pndx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pndx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cndx", wireType)
			}
			m.Cndx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cndx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupIndicesGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RingIndicesSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RingIndicesSpec = append(m.RingIndicesSpec, &AccelRGroupRingIndicesSpec{})
			if err := m.RingIndicesSpec[len(m.RingIndicesSpec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccelRGroupIndicesGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccelRGroupIndicesGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &AccelRGroupIndicesGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccelRgroup(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccelRgroup
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccelRgroup(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccelRgroup
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccelRgroup
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAccelRgroup
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAccelRgroup
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAccelRgroup(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAccelRgroup = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccelRgroup   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("accel_rgroup.proto", fileDescriptorAccelRgroup) }

var fileDescriptorAccelRgroup = []byte{
	// 1173 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x73, 0xdb, 0x44,
	0x14, 0x8f, 0x9a, 0x90, 0x38, 0x4f, 0x89, 0x93, 0x2e, 0x7f, 0xea, 0xa6, 0xe0, 0x1a, 0x51, 0x52,
	0x3b, 0x2d, 0x61, 0x26, 0x5c, 0x38, 0x30, 0x03, 0x69, 0x53, 0x4a, 0x99, 0x09, 0xe3, 0x91, 0x99,
	0x01, 0x3a, 0xcc, 0x88, 0xb5, 0xb5, 0x71, 0xc4, 0x38, 0x92, 0xea, 0x95, 0xeb, 0x36, 0xc3, 0x81,
	0x3b, 0x5f, 0x00, 0x06, 0x38, 0xc2, 0x67, 0xe1, 0xc8, 0x47, 0x60, 0xc2, 0x9d, 0xcf, 0xc0, 0xec,
	0xae, 0x6c, 0x69, 0x77, 0x25, 0x47, 0x72, 0x7d, 0xe8, 0xc9, 0xd6, 0xfb, 0xb3, 0xef, 0xcf, 0xef,
	0xbd, 0xa7, 0xb7, 0x02, 0x84, 0x7b, 0x3d, 0x32, 0x70, 0x86, 0xfd, 0x61, 0x30, 0x0a, 0xf7, 0xc3,
	0x61, 0x10, 0x05, 0xc8, 0xe4, 0x34, 0xfb, 0x21, 0x23, 0xed, 0x98, 0xd1, 0xf3, 0x90, 0x50, 0xc1,
	0xb1, 0x3e, 0x84, 0xd7, 0x0f, 0x13, 0xde, 0xa1, 0xeb, 0xda, 0xe4, 0xc9, 0x88, 0xd0, 0x08, 0xdd,
	0x04, 0x53, 0x1c, 0xe1, 0xf8, 0xf8, 0x8c, 0xd4, 0x8c, 0x86, 0xd1, 0x5c, 0xb7, 0x41, 0x90, 0xbe,
	0xc0, 0x67, 0xc4, 0xfa, 0x1a, 0x6a, 0x99, 0x9a, 0xc7, 0xb4, 0x8f, 0x3e, 0x82, 0xb5, 0xa1, 0x78,
	0xaa, 0x19, 0x8d, 0xe5, 0xa6, 0x79, 0x60, 0xed, 0xa7, 0x3c, 0xd8, 0xcf, 0xd4, 0xb3, 0x27, 0x2a,
	0xd6, 0x23, 0x78, 0x43, 0x95, 0xa0, 0x61, 0xe0, 0x53, 0x82, 0xde, 0x07, 0xc0, 0xa1, 0xe7, 0xd0,
	0x08, 0x47, 0x23, 0xca, 0x7d, 0xaa, 0x1e, 0x6c, 0xef, 0x8b, 0x78, 0x0e, 0x43, 0xaf, 0xc3, 0xe9,
	0xf6, 0x3a, 0x9e, 0xfc, 0xb5, 0xbe, 0x85, 0xeb, 0xd9, 0x47, 0x31, 0x2f, 0x3f, 0x86, 0xca, 0x30,
	0x7e, 0x8c, 0xdd, 0x7c, 0x67, 0xa6, 0x9b, 0x42, 0xd4, 0x9e, 0x2a, 0x29, 0xc9, 0x3b, 0x22, 0x83,
	0x39, 0x93, 0x97, 0x68, 0x96, 0x4b, 0x5e, 0xa2, 0x97, 0x97, 0x3c, 0x2e, 0xb1, 0x98, 0xe4, 0xa5,
	0x8e, 0x2a, 0x99, 0xbc, 0x94, 0x66, 0x2a, 0x79, 0xe7, 0xd2, 0xe9, 0xb6, 0xe7, 0xf7, 0x4b, 0x54,
	0x1f, 0xba, 0x01, 0xeb, 0x43, 0xcf, 0xef, 0x0b, 0xf6, 0x15, 0xce, 0xae, 0x30, 0x02, 0x67, 0x32,
	0x6d, 0xc6, 0x3c, 0xc5, 0xbe, 0x3b, 0x20, 0xb5, 0xe5, 0x86, 0xd1, 0xdc, 0xb4, 0x81, 0x91, 0x3e,
	0xe3, 0x14, 0xeb, 0x3b, 0x78, 0x33, 0xd7, 0x36, 0x0b, 0xee, 0x13, 0x15, 0x82, 0xdd, 0xbc, 0xd8,
	0x64, 0xdd, 0x04, 0x06, 0x1f, 0x76, 0xb2, 0xa4, 0xe6, 0x84, 0x42, 0x8d, 0xe8, 0x8a, 0x16, 0x91,
	0x0b, 0x6f, 0xe5, 0xdb, 0x63, 0x21, 0xdd, 0xd7, 0xf0, 0xba, 0x7d, 0x69, 0x4c, 0x1a, 0x66, 0xdf,
	0x68, 0x98, 0x95, 0x28, 0xfa, 0x99, 0x98, 0x65, 0x40, 0x22, 0x77, 0x45, 0x39, 0x48, 0xb2, 0x3a,
	0xe3, 0x58, 0x83, 0xe4, 0x85, 0xba, 0x43, 0xcf, 0xb8, 0xd2, 0x21, 0x25, 0x33, 0x9e, 0xdd, 0x25,
	0xcf, 0x65, 0xa7, 0x09, 0x25, 0x51, 0x87, 0x44, 0x85, 0x53, 0x7e, 0x1d, 0x2a, 0x74, 0xd4, 0x75,
	0x58, 0x96, 0xe3, 0xa2, 0x59, 0xa3, 0xa3, 0x2e, 0x33, 0xc7, 0x75, 0xd9, 0x71, 0x0e, 0x25, 0xcc,
	0xc3, 0x49, 0x93, 0x08, 0x0b, 0xcc, 0x74, 0x57, 0x0e, 0x50, 0x36, 0xcd, 0x02, 0x3c, 0x54, 0x21,
	0xc9, 0x8f, 0x4f, 0x56, 0x4e, 0x30, 0xf9, 0xcd, 0x80, 0x1b, 0x99, 0x72, 0xf3, 0x36, 0x4a, 0x13,
	0xb6, 0x07, 0x98, 0x46, 0x8e, 0xde, 0x2d, 0x55, 0x46, 0xb7, 0xa7, 0x1d, 0x83, 0x2c, 0xd8, 0xe4,
	0x92, 0xd3, 0xfc, 0x88, 0x0c, 0x98, 0x8c, 0xd8, 0x11, 0x39, 0xb2, 0x4e, 0xa0, 0x3e, 0xc3, 0x3b,
	0x96, 0x83, 0x23, 0x0d, 0xe4, 0xe6, 0xe5, 0x49, 0xd0, 0x50, 0xfe, 0x41, 0xca, 0xc2, 0x03, 0x1f,
	0x77, 0x07, 0x64, 0x41, 0x30, 0xbf, 0x0d, 0x1b, 0x84, 0x9f, 0x27, 0xe1, 0x6c, 0x92, 0xd8, 0x06,
	0xb3, 0xee, 0x4a, 0x51, 0xaa, 0xd6, 0x59, 0x94, 0xf7, 0x54, 0xa4, 0x73, 0x83, 0x54, 0xb5, 0x13,
	0xa8, 0x7f, 0x37, 0xa4, 0x0e, 0x4f, 0x09, 0xbe, 0x1c, 0x58, 0x9f, 0xc2, 0xcd, 0x59, 0xee, 0xb1,
	0x34, 0x3c, 0xd0, 0xc0, 0x6e, 0x15, 0xc8, 0x83, 0x86, 0xf6, 0x4f, 0x86, 0x34, 0x46, 0xdb, 0xbe,
	0xfb, 0x6c, 0x41, 0x60, 0x6f, 0xc3, 0xf2, 0x53, 0x3c, 0x88, 0xa3, 0x63, 0x7f, 0x51, 0x03, 0xcc,
	0x5e, 0xe0, 0xbb, 0x5e, 0xe4, 0x05, 0x3e, 0x1e, 0xd4, 0x56, 0x44, 0xdc, 0x29, 0x92, 0x32, 0x78,
	0x65, 0x67, 0xca, 0x0d, 0x5e, 0x59, 0x37, 0x41, 0xfe, 0x57, 0x43, 0x1a, 0x62, 0x53, 0xb1, 0x97,
	0x03, 0x77, 0x79, 0x8e, 0x2b, 0xce, 0x95, 0x9c, 0xe3, 0x8a, 0x76, 0x0a, 0xf3, 0xaf, 0x24, 0xc8,
	0x1f, 0xf9, 0x27, 0xc1, 0xc3, 0x85, 0x40, 0xae, 0xc0, 0x27, 0x1f, 0x5c, 0x0e, 0x3e, 0x59, 0x37,
	0x81, 0xef, 0xcf, 0x65, 0xb8, 0xa6, 0xbc, 0xab, 0x98, 0x68, 0x27, 0x24, 0x3d, 0x75, 0x2f, 0x31,
	0xd4, 0xbd, 0x64, 0x56, 0xb1, 0x5e, 0x83, 0xb5, 0x2e, 0xa6, 0xc4, 0x09, 0x31, 0x87, 0x65, 0xd5,
	0x5e, 0x65, 0x8f, 0x6d, 0xcc, 0x18, 0xa1, 0xef, 0x3e, 0x63, 0x8c, 0x15, 0xc1, 0x60, 0x8f, 0x6d,
	0x8c, 0x6e, 0x41, 0x95, 0x9e, 0x62, 0x37, 0x18, 0x3b, 0x13, 0xfe, 0x2b, 0x9c, 0xbf, 0x21, 0xa8,
	0x6d, 0x21, 0x65, 0xc1, 0x66, 0x10, 0xe2, 0x27, 0x23, 0xe2, 0x44, 0xb8, 0xcf, 0x84, 0x56, 0xb9,
	0x90, 0x29, 0x88, 0x5f, 0xe2, 0x7e, 0x1b, 0xa3, 0x5d, 0xd8, 0x4a, 0xc9, 0x50, 0xef, 0x9c, 0xd4,
	0xd6, 0xb8, 0x77, 0x9b, 0x53, 0xa9, 0x8e, 0x77, 0x9e, 0xac, 0x2c, 0x5c, 0xa2, 0xc2, 0x25, 0xf8,
	0xca, 0x32, 0x61, 0xba, 0x84, 0xf6, 0x04, 0x73, 0x5d, 0x30, 0x19, 0x61, 0xc2, 0xe4, 0x4e, 0x72,
	0x26, 0x08, 0x26, 0x23, 0x70, 0x66, 0x13, 0xb6, 0xe9, 0xd8, 0x11, 0xaf, 0xdf, 0x1e, 0x0e, 0xd9,
	0xa8, 0xa8, 0x99, 0xa2, 0x82, 0xe9, 0x98, 0xbf, 0x27, 0xee, 0x0b, 0x2a, 0xda, 0x83, 0xab, 0x74,
	0xec, 0xc4, 0x13, 0x7c, 0x22, 0xba, 0xc1, 0x45, 0xb7, 0xe8, 0x58, 0x4c, 0x99, 0x58, 0xd6, 0xfa,
	0x45, 0xee, 0xb3, 0x29, 0x9e, 0xf3, 0xf6, 0xd9, 0xe7, 0x50, 0xe5, 0xc1, 0x7b, 0xfe, 0x49, 0xe0,
	0xd0, 0x90, 0xf4, 0x6a, 0x57, 0x78, 0x05, 0xdd, 0x9a, 0xb5, 0xc6, 0x4c, 0x4a, 0xc3, 0xde, 0x18,
	0xa6, 0x9e, 0x94, 0x2e, 0x53, 0x5c, 0x2b, 0xd9, 0x65, 0x8a, 0x76, 0xaa, 0xcb, 0x1e, 0x2b, 0xcd,
	0xe0, 0x7a, 0x3d, 0x42, 0x17, 0xd4, 0x68, 0x27, 0xd2, 0xfb, 0x41, 0x3b, 0x5b, 0xc4, 0xa0, 0xf4,
	0x5a, 0x2b, 0x3f, 0x04, 0x45, 0x3d, 0x69, 0xb7, 0x1f, 0x0d, 0x6d, 0x4f, 0x8d, 0xa5, 0x5f, 0xb8,
	0xe3, 0x10, 0xac, 0xb0, 0x12, 0x8c, 0xa7, 0x20, 0xff, 0xcf, 0x68, 0x3d, 0x46, 0x13, 0x6f, 0x06,
	0xfe, 0xdf, 0xfa, 0xc3, 0x50, 0xd0, 0x4a, 0x9c, 0x9d, 0xb7, 0x96, 0x3a, 0x70, 0x35, 0xae, 0x25,
	0x7e, 0x56, 0xba, 0x9c, 0x6e, 0xcf, 0x2e, 0xa7, 0x69, 0xe8, 0xf6, 0xd6, 0x50, 0x26, 0x58, 0xdf,
	0x43, 0x63, 0xa6, 0x9b, 0x0c, 0x93, 0x4f, 0xb5, 0xba, 0xda, 0x2b, 0x02, 0x8a, 0x5a, 0x5a, 0x07,
	0xff, 0xad, 0x81, 0x99, 0x92, 0x45, 0x18, 0xaa, 0xf2, 0xf7, 0x01, 0xf4, 0xee, 0xe5, 0xdf, 0x38,
	0x8e, 0x69, 0x7f, 0x67, 0xb7, 0xc0, 0x37, 0x86, 0x63, 0xda, 0xb7, 0x96, 0x14, 0x13, 0x47, 0x64,
	0x90, 0x6f, 0x42, 0xba, 0x2b, 0xe5, 0x9b, 0x90, 0x6f, 0x28, 0xd6, 0x12, 0x3a, 0x03, 0xa4, 0x5f,
	0xfc, 0x50, 0xab, 0xd8, 0x6d, 0x97, 0x99, 0xda, 0x2b, 0x78, 0x89, 0xcc, 0x33, 0xc7, 0xa2, 0x6a,
	0x15, 0xbb, 0xc9, 0x5d, 0x6a, 0x4e, 0x8b, 0x2e, 0x84, 0x57, 0x33, 0xf6, 0x6f, 0xb4, 0x57, 0xf0,
	0x9a, 0xc2, 0x0c, 0xde, 0x29, 0xba, 0xcd, 0x0b, 0x8b, 0x14, 0x5e, 0xcb, 0x5a, 0x02, 0xd1, 0x9d,
	0xa2, 0xfb, 0x32, 0xb3, 0x79, 0xb7, 0xf0, 0x52, 0x99, 0x95, 0xd5, 0x78, 0x07, 0xc9, 0xcf, 0xaa,
	0xb6, 0xe2, 0xe5, 0x67, 0x55, 0xdf, 0x86, 0x34, 0x73, 0xf1, 0x30, 0x46, 0xad, 0x62, 0x6b, 0xc5,
	0x4c, 0x73, 0xfa, 0x6b, 0xc1, 0x5a, 0x42, 0x4f, 0xa5, 0x8f, 0x6c, 0x49, 0x8f, 0xa2, 0xbb, 0x85,
	0x87, 0x2b, 0x33, 0xfa, 0x5e, 0xf1, 0xae, 0xe7, 0x76, 0xef, 0xed, 0xfc, 0x75, 0x51, 0x37, 0xfe,
	0xbe, 0xa8, 0x1b, 0xff, 0x5c, 0xd4, 0x8d, 0x9f, 0xff, 0xad, 0x2f, 0x3d, 0xae, 0x9c, 0xe2, 0x01,
	0xff, 0x6a, 0xda, 0x5d, 0xe5, 0x3f, 0x1f, 0xfc, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xd8, 0xa7, 0x3a,
	0x22, 0x6c, 0x15, 0x00, 0x00,
}
