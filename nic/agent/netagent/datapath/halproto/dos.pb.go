// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dos.proto

package halproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ICMPMsg struct {
	Type ICMPMsgType `protobuf:"varint,1,opt,name=type,proto3,enum=types.ICMPMsgType" json:"type,omitempty"`
	Code uint32      `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *ICMPMsg) Reset()                    { *m = ICMPMsg{} }
func (m *ICMPMsg) String() string            { return proto.CompactTextString(m) }
func (*ICMPMsg) ProtoMessage()               {}
func (*ICMPMsg) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{0} }

func (m *ICMPMsg) GetType() ICMPMsgType {
	if m != nil {
		return m.Type
	}
	return ICMPMsgType_ICMP_MSG_TYPE_NONE
}

func (m *ICMPMsg) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type DoSService struct {
	IpProtocol IPProtocol `protobuf:"varint,1,opt,name=ip_protocol,json=ipProtocol,proto3,enum=types.IPProtocol" json:"ip_protocol,omitempty"`
	// Types that are valid to be assigned to L4Info:
	//	*DoSService_DstPort
	//	*DoSService_IcmpMsg
	L4Info isDoSService_L4Info `protobuf_oneof:"l4_info"`
}

func (m *DoSService) Reset()                    { *m = DoSService{} }
func (m *DoSService) String() string            { return proto.CompactTextString(m) }
func (*DoSService) ProtoMessage()               {}
func (*DoSService) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{1} }

type isDoSService_L4Info interface {
	isDoSService_L4Info()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DoSService_DstPort struct {
	DstPort uint32 `protobuf:"varint,2,opt,name=dst_port,json=dstPort,proto3,oneof"`
}
type DoSService_IcmpMsg struct {
	IcmpMsg *ICMPMsg `protobuf:"bytes,3,opt,name=icmp_msg,json=icmpMsg,oneof"`
}

func (*DoSService_DstPort) isDoSService_L4Info() {}
func (*DoSService_IcmpMsg) isDoSService_L4Info() {}

func (m *DoSService) GetL4Info() isDoSService_L4Info {
	if m != nil {
		return m.L4Info
	}
	return nil
}

func (m *DoSService) GetIpProtocol() IPProtocol {
	if m != nil {
		return m.IpProtocol
	}
	return IPProtocol_IPPROTO_NONE
}

func (m *DoSService) GetDstPort() uint32 {
	if x, ok := m.GetL4Info().(*DoSService_DstPort); ok {
		return x.DstPort
	}
	return 0
}

func (m *DoSService) GetIcmpMsg() *ICMPMsg {
	if x, ok := m.GetL4Info().(*DoSService_IcmpMsg); ok {
		return x.IcmpMsg
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DoSService) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DoSService_OneofMarshaler, _DoSService_OneofUnmarshaler, _DoSService_OneofSizer, []interface{}{
		(*DoSService_DstPort)(nil),
		(*DoSService_IcmpMsg)(nil),
	}
}

func _DoSService_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DoSService)
	// l4_info
	switch x := m.L4Info.(type) {
	case *DoSService_DstPort:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DstPort))
	case *DoSService_IcmpMsg:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IcmpMsg); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DoSService.L4Info has unexpected type %T", x)
	}
	return nil
}

func _DoSService_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DoSService)
	switch tag {
	case 2: // l4_info.dst_port
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.L4Info = &DoSService_DstPort{uint32(x)}
		return true, err
	case 3: // l4_info.icmp_msg
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ICMPMsg)
		err := b.DecodeMessage(msg)
		m.L4Info = &DoSService_IcmpMsg{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DoSService_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DoSService)
	// l4_info
	switch x := m.L4Info.(type) {
	case *DoSService_DstPort:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DstPort))
	case *DoSService_IcmpMsg:
		s := proto.Size(x.IcmpMsg)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DoSSessionLimits captures the session limits to be enforced on a security
// group
type DoSSessionLimits struct {
	MaxSessions     uint32 `protobuf:"varint,1,opt,name=max_sessions,json=maxSessions,proto3" json:"max_sessions,omitempty"`
	BlockingTimeout uint32 `protobuf:"varint,2,opt,name=blocking_timeout,json=blockingTimeout,proto3" json:"blocking_timeout,omitempty"`
}

func (m *DoSSessionLimits) Reset()                    { *m = DoSSessionLimits{} }
func (m *DoSSessionLimits) String() string            { return proto.CompactTextString(m) }
func (*DoSSessionLimits) ProtoMessage()               {}
func (*DoSSessionLimits) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{2} }

func (m *DoSSessionLimits) GetMaxSessions() uint32 {
	if m != nil {
		return m.MaxSessions
	}
	return 0
}

func (m *DoSSessionLimits) GetBlockingTimeout() uint32 {
	if m != nil {
		return m.BlockingTimeout
	}
	return 0
}

// DoSPolicer is aggregate DoS policer object
type DoSPolicer struct {
	BytesPerSecond uint32 `protobuf:"varint,1,opt,name=bytes_per_second,json=bytesPerSecond,proto3" json:"bytes_per_second,omitempty"`
	PeakRate       uint32 `protobuf:"varint,2,opt,name=peak_rate,json=peakRate,proto3" json:"peak_rate,omitempty"`
	BurstSize      uint32 `protobuf:"varint,3,opt,name=burst_size,json=burstSize,proto3" json:"burst_size,omitempty"`
}

func (m *DoSPolicer) Reset()                    { *m = DoSPolicer{} }
func (m *DoSPolicer) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicer) ProtoMessage()               {}
func (*DoSPolicer) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{3} }

func (m *DoSPolicer) GetBytesPerSecond() uint32 {
	if m != nil {
		return m.BytesPerSecond
	}
	return 0
}

func (m *DoSPolicer) GetPeakRate() uint32 {
	if m != nil {
		return m.PeakRate
	}
	return 0
}

func (m *DoSPolicer) GetBurstSize() uint32 {
	if m != nil {
		return m.BurstSize
	}
	return 0
}

// DoSFloodLimits object captures the flood limits configuration
type DoSFloodLimits struct {
	RestrictLimits *DoSFloodLimits_RestrictLimits `protobuf:"bytes,1,opt,name=restrict_limits,json=restrictLimits" json:"restrict_limits,omitempty"`
	ProtectLimits  *DoSFloodLimits_ProtectLimits  `protobuf:"bytes,2,opt,name=protect_limits,json=protectLimits" json:"protect_limits,omitempty"`
}

func (m *DoSFloodLimits) Reset()                    { *m = DoSFloodLimits{} }
func (m *DoSFloodLimits) String() string            { return proto.CompactTextString(m) }
func (*DoSFloodLimits) ProtoMessage()               {}
func (*DoSFloodLimits) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{4} }

func (m *DoSFloodLimits) GetRestrictLimits() *DoSFloodLimits_RestrictLimits {
	if m != nil {
		return m.RestrictLimits
	}
	return nil
}

func (m *DoSFloodLimits) GetProtectLimits() *DoSFloodLimits_ProtectLimits {
	if m != nil {
		return m.ProtectLimits
	}
	return nil
}

// default and only action in restrict phase is Random Early Drop (RED)
type DoSFloodLimits_RestrictLimits struct {
	Pps      uint32 `protobuf:"varint,1,opt,name=pps,proto3" json:"pps,omitempty"`
	BurstPps uint32 `protobuf:"varint,2,opt,name=burst_pps,json=burstPps,proto3" json:"burst_pps,omitempty"`
	Duration uint32 `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *DoSFloodLimits_RestrictLimits) Reset()         { *m = DoSFloodLimits_RestrictLimits{} }
func (m *DoSFloodLimits_RestrictLimits) String() string { return proto.CompactTextString(m) }
func (*DoSFloodLimits_RestrictLimits) ProtoMessage()    {}
func (*DoSFloodLimits_RestrictLimits) Descriptor() ([]byte, []int) {
	return fileDescriptorDos, []int{4, 0}
}

func (m *DoSFloodLimits_RestrictLimits) GetPps() uint32 {
	if m != nil {
		return m.Pps
	}
	return 0
}

func (m *DoSFloodLimits_RestrictLimits) GetBurstPps() uint32 {
	if m != nil {
		return m.BurstPps
	}
	return 0
}

func (m *DoSFloodLimits_RestrictLimits) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// default and only action in protection phase is drop
type DoSFloodLimits_ProtectLimits struct {
	Pps      uint32 `protobuf:"varint,1,opt,name=pps,proto3" json:"pps,omitempty"`
	BurstPps uint32 `protobuf:"varint,2,opt,name=burst_pps,json=burstPps,proto3" json:"burst_pps,omitempty"`
	Duration uint32 `protobuf:"varint,3,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *DoSFloodLimits_ProtectLimits) Reset()         { *m = DoSFloodLimits_ProtectLimits{} }
func (m *DoSFloodLimits_ProtectLimits) String() string { return proto.CompactTextString(m) }
func (*DoSFloodLimits_ProtectLimits) ProtoMessage()    {}
func (*DoSFloodLimits_ProtectLimits) Descriptor() ([]byte, []int) {
	return fileDescriptorDos, []int{4, 1}
}

func (m *DoSFloodLimits_ProtectLimits) GetPps() uint32 {
	if m != nil {
		return m.Pps
	}
	return 0
}

func (m *DoSFloodLimits_ProtectLimits) GetBurstPps() uint32 {
	if m != nil {
		return m.BurstPps
	}
	return 0
}

func (m *DoSFloodLimits_ProtectLimits) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// DoSProtectionSpec defines DoS protection policy for a security group
type DoSProtectionSpec struct {
	Svc *DoSService `protobuf:"bytes,1,opt,name=svc" json:"svc,omitempty"`
	// service for which rest of
	// the DoS config to be
	// applied on
	SessionSetupRate  uint32            `protobuf:"varint,2,opt,name=session_setup_rate,json=sessionSetupRate,proto3" json:"session_setup_rate,omitempty"`
	SessionLimits     *DoSSessionLimits `protobuf:"bytes,3,opt,name=session_limits,json=sessionLimits" json:"session_limits,omitempty"`
	Policer           *DoSPolicer       `protobuf:"bytes,4,opt,name=policer" json:"policer,omitempty"`
	TcpSynFloodLimits *DoSFloodLimits   `protobuf:"bytes,5,opt,name=tcp_syn_flood_limits,json=tcpSynFloodLimits" json:"tcp_syn_flood_limits,omitempty"`
	UdpFloodLimits    *DoSFloodLimits   `protobuf:"bytes,6,opt,name=udp_flood_limits,json=udpFloodLimits" json:"udp_flood_limits,omitempty"`
	IcmpFloodLimits   *DoSFloodLimits   `protobuf:"bytes,7,opt,name=icmp_flood_limits,json=icmpFloodLimits" json:"icmp_flood_limits,omitempty"`
	OtherFloodLimits  *DoSFloodLimits   `protobuf:"bytes,8,opt,name=other_flood_limits,json=otherFloodLimits" json:"other_flood_limits,omitempty"`
	// traffic (IP and non-IP)
	PeerSgHandle uint64 `protobuf:"varint,9,opt,name=peer_sg_handle,json=peerSgHandle,proto3" json:"peer_sg_handle,omitempty"`
}

func (m *DoSProtectionSpec) Reset()                    { *m = DoSProtectionSpec{} }
func (m *DoSProtectionSpec) String() string            { return proto.CompactTextString(m) }
func (*DoSProtectionSpec) ProtoMessage()               {}
func (*DoSProtectionSpec) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{5} }

func (m *DoSProtectionSpec) GetSvc() *DoSService {
	if m != nil {
		return m.Svc
	}
	return nil
}

func (m *DoSProtectionSpec) GetSessionSetupRate() uint32 {
	if m != nil {
		return m.SessionSetupRate
	}
	return 0
}

func (m *DoSProtectionSpec) GetSessionLimits() *DoSSessionLimits {
	if m != nil {
		return m.SessionLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetPolicer() *DoSPolicer {
	if m != nil {
		return m.Policer
	}
	return nil
}

func (m *DoSProtectionSpec) GetTcpSynFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.TcpSynFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetUdpFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.UdpFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetIcmpFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.IcmpFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetOtherFloodLimits() *DoSFloodLimits {
	if m != nil {
		return m.OtherFloodLimits
	}
	return nil
}

func (m *DoSProtectionSpec) GetPeerSgHandle() uint64 {
	if m != nil {
		return m.PeerSgHandle
	}
	return 0
}

// ingress policy for DoS
type IngressDoSPolicy struct {
	DosProtection *DoSProtectionSpec `protobuf:"bytes,1,opt,name=dos_protection,json=dosProtection" json:"dos_protection,omitempty"`
}

func (m *IngressDoSPolicy) Reset()                    { *m = IngressDoSPolicy{} }
func (m *IngressDoSPolicy) String() string            { return proto.CompactTextString(m) }
func (*IngressDoSPolicy) ProtoMessage()               {}
func (*IngressDoSPolicy) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{6} }

func (m *IngressDoSPolicy) GetDosProtection() *DoSProtectionSpec {
	if m != nil {
		return m.DosProtection
	}
	return nil
}

// egress policy for DoS
type EgressDoSPolicy struct {
	DosProtection *DoSProtectionSpec `protobuf:"bytes,1,opt,name=dos_protection,json=dosProtection" json:"dos_protection,omitempty"`
}

func (m *EgressDoSPolicy) Reset()                    { *m = EgressDoSPolicy{} }
func (m *EgressDoSPolicy) String() string            { return proto.CompactTextString(m) }
func (*EgressDoSPolicy) ProtoMessage()               {}
func (*EgressDoSPolicy) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{7} }

func (m *EgressDoSPolicy) GetDosProtection() *DoSProtectionSpec {
	if m != nil {
		return m.DosProtection
	}
	return nil
}

// DoSPolicySpec that has the ingressDosPolicy and EgressDoSPolicy,
// Spec is identified by the handle. HAL will assign a unique handle for each
// DoSPolicy object and the clients are expected to pass the handle for
// Get/Modify/Delete calls. Note that there is no identifier for this object
type DoSPolicySpec struct {
	Meta          *ObjectMeta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	IngressPolicy *IngressDoSPolicy `protobuf:"bytes,2,opt,name=ingress_policy,json=ingressPolicy" json:"ingress_policy,omitempty"`
	EgressPolicy  *EgressDoSPolicy  `protobuf:"bytes,3,opt,name=egress_policy,json=egressPolicy" json:"egress_policy,omitempty"`
	DosHandle     uint64            `protobuf:"fixed64,4,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
	SgHandle      []uint64          `protobuf:"varint,5,rep,packed,name=sg_handle,json=sgHandle" json:"sg_handle,omitempty"`
}

func (m *DoSPolicySpec) Reset()                    { *m = DoSPolicySpec{} }
func (m *DoSPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicySpec) ProtoMessage()               {}
func (*DoSPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{8} }

func (m *DoSPolicySpec) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DoSPolicySpec) GetIngressPolicy() *IngressDoSPolicy {
	if m != nil {
		return m.IngressPolicy
	}
	return nil
}

func (m *DoSPolicySpec) GetEgressPolicy() *EgressDoSPolicy {
	if m != nil {
		return m.EgressPolicy
	}
	return nil
}

func (m *DoSPolicySpec) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

func (m *DoSPolicySpec) GetSgHandle() []uint64 {
	if m != nil {
		return m.SgHandle
	}
	return nil
}

// DoSPolicyRequestMsg is batched add or modify DoS request
type DoSPolicyRequestMsg struct {
	Request []*DoSPolicySpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DoSPolicyRequestMsg) Reset()                    { *m = DoSPolicyRequestMsg{} }
func (m *DoSPolicyRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyRequestMsg) ProtoMessage()               {}
func (*DoSPolicyRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{9} }

func (m *DoSPolicyRequestMsg) GetRequest() []*DoSPolicySpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// DoS operational status
type DoSPolicyStatus struct {
	DosHandle uint64 `protobuf:"fixed64,1,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
}

func (m *DoSPolicyStatus) Reset()                    { *m = DoSPolicyStatus{} }
func (m *DoSPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyStatus) ProtoMessage()               {}
func (*DoSPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{10} }

func (m *DoSPolicyStatus) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

// DoSResponse is the response to DoSPolicySpec
type DoSPolicyResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Status    *DoSPolicyStatus `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *DoSPolicyResponse) Reset()                    { *m = DoSPolicyResponse{} }
func (m *DoSPolicyResponse) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyResponse) ProtoMessage()               {}
func (*DoSPolicyResponse) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{11} }

func (m *DoSPolicyResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DoSPolicyResponse) GetStatus() *DoSPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// DoSPolicyResponseMsg is batched response to DoSPolicyRequestMsg
type DoSPolicyResponseMsg struct {
	Response []*DoSPolicyResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DoSPolicyResponseMsg) Reset()                    { *m = DoSPolicyResponseMsg{} }
func (m *DoSPolicyResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyResponseMsg) ProtoMessage()               {}
func (*DoSPolicyResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{12} }

func (m *DoSPolicyResponseMsg) GetResponse() []*DoSPolicyResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// DoSRequest is used to delete a DoS
type DoSPolicyDeleteRequest struct {
	Meta      *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	DosHandle uint64      `protobuf:"fixed64,2,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
}

func (m *DoSPolicyDeleteRequest) Reset()                    { *m = DoSPolicyDeleteRequest{} }
func (m *DoSPolicyDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteRequest) ProtoMessage()               {}
func (*DoSPolicyDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{13} }

func (m *DoSPolicyDeleteRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DoSPolicyDeleteRequest) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

// DoSPolicyDeleteRequestMsg is used to delete a batch of security groups
type DoSPolicyDeleteRequestMsg struct {
	Request []*DoSPolicyDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DoSPolicyDeleteRequestMsg) Reset()                    { *m = DoSPolicyDeleteRequestMsg{} }
func (m *DoSPolicyDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteRequestMsg) ProtoMessage()               {}
func (*DoSPolicyDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{14} }

func (m *DoSPolicyDeleteRequestMsg) GetRequest() []*DoSPolicyDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type DoSPolicyDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *DoSPolicyDeleteResponse) Reset()                    { *m = DoSPolicyDeleteResponse{} }
func (m *DoSPolicyDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteResponse) ProtoMessage()               {}
func (*DoSPolicyDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{15} }

func (m *DoSPolicyDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// DoSPolicyDeleteResponseMsg is batched response to
// DoSPolicyDeleteRequestMsg
type DoSPolicyDeleteResponseMsg struct {
	Response []*DoSPolicyDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DoSPolicyDeleteResponseMsg) Reset()                    { *m = DoSPolicyDeleteResponseMsg{} }
func (m *DoSPolicyDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyDeleteResponseMsg) ProtoMessage()               {}
func (*DoSPolicyDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{16} }

func (m *DoSPolicyDeleteResponseMsg) GetResponse() []*DoSPolicyDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// DoSGetRequest is used to get information about a DoS
type DoSPolicyGetRequest struct {
	Meta      *ObjectMeta `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	DosHandle uint64      `protobuf:"fixed64,2,opt,name=dos_handle,json=dosHandle,proto3" json:"dos_handle,omitempty"`
}

func (m *DoSPolicyGetRequest) Reset()                    { *m = DoSPolicyGetRequest{} }
func (m *DoSPolicyGetRequest) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetRequest) ProtoMessage()               {}
func (*DoSPolicyGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{17} }

func (m *DoSPolicyGetRequest) GetMeta() *ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DoSPolicyGetRequest) GetDosHandle() uint64 {
	if m != nil {
		return m.DosHandle
	}
	return 0
}

// DoSPolicyGetRequestMsg is batched GET request for DoS
type DoSPolicyGetRequestMsg struct {
	Request []*DoSPolicyGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *DoSPolicyGetRequestMsg) Reset()                    { *m = DoSPolicyGetRequestMsg{} }
func (m *DoSPolicyGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetRequestMsg) ProtoMessage()               {}
func (*DoSPolicyGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{18} }

func (m *DoSPolicyGetRequestMsg) GetRequest() []*DoSPolicyGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// DoSPolicyStats is the statistics object for a security group
type DoSPolicyStats struct {
}

func (m *DoSPolicyStats) Reset()                    { *m = DoSPolicyStats{} }
func (m *DoSPolicyStats) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyStats) ProtoMessage()               {}
func (*DoSPolicyStats) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{19} }

// DoSGetResponse captures all the information about a security group
type DoSPolicyGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *DoSPolicySpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *DoSPolicyStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *DoSPolicyStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *DoSPolicyGetResponse) Reset()                    { *m = DoSPolicyGetResponse{} }
func (m *DoSPolicyGetResponse) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetResponse) ProtoMessage()               {}
func (*DoSPolicyGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{20} }

func (m *DoSPolicyGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *DoSPolicyGetResponse) GetSpec() *DoSPolicySpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *DoSPolicyGetResponse) GetStatus() *DoSPolicyStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DoSPolicyGetResponse) GetStats() *DoSPolicyStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// DoSPolicyGetResponseMsg is batched response to DoSPolicyGetRequestMsg
type DoSPolicyGetResponseMsg struct {
	Response []*DoSPolicyGetResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *DoSPolicyGetResponseMsg) Reset()                    { *m = DoSPolicyGetResponseMsg{} }
func (m *DoSPolicyGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*DoSPolicyGetResponseMsg) ProtoMessage()               {}
func (*DoSPolicyGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorDos, []int{21} }

func (m *DoSPolicyGetResponseMsg) GetResponse() []*DoSPolicyGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*ICMPMsg)(nil), "dos.ICMPMsg")
	proto.RegisterType((*DoSService)(nil), "dos.DoSService")
	proto.RegisterType((*DoSSessionLimits)(nil), "dos.DoSSessionLimits")
	proto.RegisterType((*DoSPolicer)(nil), "dos.DoSPolicer")
	proto.RegisterType((*DoSFloodLimits)(nil), "dos.DoSFloodLimits")
	proto.RegisterType((*DoSFloodLimits_RestrictLimits)(nil), "dos.DoSFloodLimits.RestrictLimits")
	proto.RegisterType((*DoSFloodLimits_ProtectLimits)(nil), "dos.DoSFloodLimits.ProtectLimits")
	proto.RegisterType((*DoSProtectionSpec)(nil), "dos.DoSProtectionSpec")
	proto.RegisterType((*IngressDoSPolicy)(nil), "dos.IngressDoSPolicy")
	proto.RegisterType((*EgressDoSPolicy)(nil), "dos.EgressDoSPolicy")
	proto.RegisterType((*DoSPolicySpec)(nil), "dos.DoSPolicySpec")
	proto.RegisterType((*DoSPolicyRequestMsg)(nil), "dos.DoSPolicyRequestMsg")
	proto.RegisterType((*DoSPolicyStatus)(nil), "dos.DoSPolicyStatus")
	proto.RegisterType((*DoSPolicyResponse)(nil), "dos.DoSPolicyResponse")
	proto.RegisterType((*DoSPolicyResponseMsg)(nil), "dos.DoSPolicyResponseMsg")
	proto.RegisterType((*DoSPolicyDeleteRequest)(nil), "dos.DoSPolicyDeleteRequest")
	proto.RegisterType((*DoSPolicyDeleteRequestMsg)(nil), "dos.DoSPolicyDeleteRequestMsg")
	proto.RegisterType((*DoSPolicyDeleteResponse)(nil), "dos.DoSPolicyDeleteResponse")
	proto.RegisterType((*DoSPolicyDeleteResponseMsg)(nil), "dos.DoSPolicyDeleteResponseMsg")
	proto.RegisterType((*DoSPolicyGetRequest)(nil), "dos.DoSPolicyGetRequest")
	proto.RegisterType((*DoSPolicyGetRequestMsg)(nil), "dos.DoSPolicyGetRequestMsg")
	proto.RegisterType((*DoSPolicyStats)(nil), "dos.DoSPolicyStats")
	proto.RegisterType((*DoSPolicyGetResponse)(nil), "dos.DoSPolicyGetResponse")
	proto.RegisterType((*DoSPolicyGetResponseMsg)(nil), "dos.DoSPolicyGetResponseMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Dos service

type DosClient interface {
	DoSPolicyCreate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error)
	DoSPolicyUpdate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error)
	DoSPolicyDelete(ctx context.Context, in *DoSPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*DoSPolicyDeleteResponseMsg, error)
	DoSPolicyGet(ctx context.Context, in *DoSPolicyGetRequestMsg, opts ...grpc.CallOption) (*DoSPolicyGetResponseMsg, error)
}

type dosClient struct {
	cc *grpc.ClientConn
}

func NewDosClient(cc *grpc.ClientConn) DosClient {
	return &dosClient{cc}
}

func (c *dosClient) DoSPolicyCreate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error) {
	out := new(DoSPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/dos.Dos/DoSPolicyCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dosClient) DoSPolicyUpdate(ctx context.Context, in *DoSPolicyRequestMsg, opts ...grpc.CallOption) (*DoSPolicyResponseMsg, error) {
	out := new(DoSPolicyResponseMsg)
	err := grpc.Invoke(ctx, "/dos.Dos/DoSPolicyUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dosClient) DoSPolicyDelete(ctx context.Context, in *DoSPolicyDeleteRequestMsg, opts ...grpc.CallOption) (*DoSPolicyDeleteResponseMsg, error) {
	out := new(DoSPolicyDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/dos.Dos/DoSPolicyDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dosClient) DoSPolicyGet(ctx context.Context, in *DoSPolicyGetRequestMsg, opts ...grpc.CallOption) (*DoSPolicyGetResponseMsg, error) {
	out := new(DoSPolicyGetResponseMsg)
	err := grpc.Invoke(ctx, "/dos.Dos/DoSPolicyGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Dos service

type DosServer interface {
	DoSPolicyCreate(context.Context, *DoSPolicyRequestMsg) (*DoSPolicyResponseMsg, error)
	DoSPolicyUpdate(context.Context, *DoSPolicyRequestMsg) (*DoSPolicyResponseMsg, error)
	DoSPolicyDelete(context.Context, *DoSPolicyDeleteRequestMsg) (*DoSPolicyDeleteResponseMsg, error)
	DoSPolicyGet(context.Context, *DoSPolicyGetRequestMsg) (*DoSPolicyGetResponseMsg, error)
}

func RegisterDosServer(s *grpc.Server, srv DosServer) {
	s.RegisterService(&_Dos_serviceDesc, srv)
}

func _Dos_DoSPolicyCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DosServer).DoSPolicyCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dos.Dos/DoSPolicyCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DosServer).DoSPolicyCreate(ctx, req.(*DoSPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dos_DoSPolicyUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DosServer).DoSPolicyUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dos.Dos/DoSPolicyUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DosServer).DoSPolicyUpdate(ctx, req.(*DoSPolicyRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dos_DoSPolicyDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DosServer).DoSPolicyDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dos.Dos/DoSPolicyDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DosServer).DoSPolicyDelete(ctx, req.(*DoSPolicyDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Dos_DoSPolicyGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoSPolicyGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DosServer).DoSPolicyGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dos.Dos/DoSPolicyGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DosServer).DoSPolicyGet(ctx, req.(*DoSPolicyGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Dos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dos.Dos",
	HandlerType: (*DosServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DoSPolicyCreate",
			Handler:    _Dos_DoSPolicyCreate_Handler,
		},
		{
			MethodName: "DoSPolicyUpdate",
			Handler:    _Dos_DoSPolicyUpdate_Handler,
		},
		{
			MethodName: "DoSPolicyDelete",
			Handler:    _Dos_DoSPolicyDelete_Handler,
		},
		{
			MethodName: "DoSPolicyGet",
			Handler:    _Dos_DoSPolicyGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dos.proto",
}

func (m *ICMPMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ICMPMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Type))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *DoSService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpProtocol != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		nn1, err := m.L4Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *DoSService_DstPort) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintDos(dAtA, i, uint64(m.DstPort))
	return i, nil
}
func (m *DoSService_IcmpMsg) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.IcmpMsg != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.IcmpMsg.Size()))
		n2, err := m.IcmpMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *DoSSessionLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSSessionLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxSessions != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.MaxSessions))
	}
	if m.BlockingTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.BlockingTimeout))
	}
	return i, nil
}

func (m *DoSPolicer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BytesPerSecond != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.BytesPerSecond))
	}
	if m.PeakRate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.PeakRate))
	}
	if m.BurstSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.BurstSize))
	}
	return i, nil
}

func (m *DoSFloodLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSFloodLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RestrictLimits != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.RestrictLimits.Size()))
		n3, err := m.RestrictLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ProtectLimits != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.ProtectLimits.Size()))
		n4, err := m.ProtectLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *DoSFloodLimits_RestrictLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSFloodLimits_RestrictLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *DoSFloodLimits_ProtectLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSFloodLimits_ProtectLimits) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pps != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Duration))
	}
	return i, nil
}

func (m *DoSProtectionSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSProtectionSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Svc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Svc.Size()))
		n5, err := m.Svc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.SessionSetupRate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.SessionSetupRate))
	}
	if m.SessionLimits != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.SessionLimits.Size()))
		n6, err := m.SessionLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Policer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Policer.Size()))
		n7, err := m.Policer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.TcpSynFloodLimits != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.TcpSynFloodLimits.Size()))
		n8, err := m.TcpSynFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.UdpFloodLimits != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.UdpFloodLimits.Size()))
		n9, err := m.UdpFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.IcmpFloodLimits != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.IcmpFloodLimits.Size()))
		n10, err := m.IcmpFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.OtherFloodLimits != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.OtherFloodLimits.Size()))
		n11, err := m.OtherFloodLimits.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.PeerSgHandle != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.PeerSgHandle))
	}
	return i, nil
}

func (m *IngressDoSPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngressDoSPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DosProtection != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.DosProtection.Size()))
		n12, err := m.DosProtection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *EgressDoSPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressDoSPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DosProtection != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.DosProtection.Size()))
		n13, err := m.DosProtection.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *DoSPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Meta.Size()))
		n14, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.IngressPolicy != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.IngressPolicy.Size()))
		n15, err := m.IngressPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.EgressPolicy != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.EgressPolicy.Size()))
		n16, err := m.EgressPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DosHandle != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DosHandle))
		i += 8
	}
	if len(m.SgHandle) > 0 {
		dAtA18 := make([]byte, len(m.SgHandle)*10)
		var j17 int
		for _, num := range m.SgHandle {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDos(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func (m *DoSPolicyRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DosHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DosHandle))
		i += 8
	}
	return i, nil
}

func (m *DoSPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Status.Size()))
		n19, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *DoSPolicyResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Meta.Size()))
		n20, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.DosHandle != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DosHandle))
		i += 8
	}
	return i, nil
}

func (m *DoSPolicyDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *DoSPolicyDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Meta.Size()))
		n21, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DosHandle != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.DosHandle))
		i += 8
	}
	return i, nil
}

func (m *DoSPolicyGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSPolicyStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DoSPolicyGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Spec.Size()))
		n22, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Status.Size()))
		n23, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDos(dAtA, i, uint64(m.Stats.Size()))
		n24, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *DoSPolicyGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSPolicyGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintDos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintDos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ICMPMsg) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDos(uint64(m.Type))
	}
	if m.Code != 0 {
		n += 1 + sovDos(uint64(m.Code))
	}
	return n
}

func (m *DoSService) Size() (n int) {
	var l int
	_ = l
	if m.IpProtocol != 0 {
		n += 1 + sovDos(uint64(m.IpProtocol))
	}
	if m.L4Info != nil {
		n += m.L4Info.Size()
	}
	return n
}

func (m *DoSService_DstPort) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovDos(uint64(m.DstPort))
	return n
}
func (m *DoSService_IcmpMsg) Size() (n int) {
	var l int
	_ = l
	if m.IcmpMsg != nil {
		l = m.IcmpMsg.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	return n
}
func (m *DoSSessionLimits) Size() (n int) {
	var l int
	_ = l
	if m.MaxSessions != 0 {
		n += 1 + sovDos(uint64(m.MaxSessions))
	}
	if m.BlockingTimeout != 0 {
		n += 1 + sovDos(uint64(m.BlockingTimeout))
	}
	return n
}

func (m *DoSPolicer) Size() (n int) {
	var l int
	_ = l
	if m.BytesPerSecond != 0 {
		n += 1 + sovDos(uint64(m.BytesPerSecond))
	}
	if m.PeakRate != 0 {
		n += 1 + sovDos(uint64(m.PeakRate))
	}
	if m.BurstSize != 0 {
		n += 1 + sovDos(uint64(m.BurstSize))
	}
	return n
}

func (m *DoSFloodLimits) Size() (n int) {
	var l int
	_ = l
	if m.RestrictLimits != nil {
		l = m.RestrictLimits.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.ProtectLimits != nil {
		l = m.ProtectLimits.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	return n
}

func (m *DoSFloodLimits_RestrictLimits) Size() (n int) {
	var l int
	_ = l
	if m.Pps != 0 {
		n += 1 + sovDos(uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		n += 1 + sovDos(uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		n += 1 + sovDos(uint64(m.Duration))
	}
	return n
}

func (m *DoSFloodLimits_ProtectLimits) Size() (n int) {
	var l int
	_ = l
	if m.Pps != 0 {
		n += 1 + sovDos(uint64(m.Pps))
	}
	if m.BurstPps != 0 {
		n += 1 + sovDos(uint64(m.BurstPps))
	}
	if m.Duration != 0 {
		n += 1 + sovDos(uint64(m.Duration))
	}
	return n
}

func (m *DoSProtectionSpec) Size() (n int) {
	var l int
	_ = l
	if m.Svc != nil {
		l = m.Svc.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.SessionSetupRate != 0 {
		n += 1 + sovDos(uint64(m.SessionSetupRate))
	}
	if m.SessionLimits != nil {
		l = m.SessionLimits.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.Policer != nil {
		l = m.Policer.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.TcpSynFloodLimits != nil {
		l = m.TcpSynFloodLimits.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.UdpFloodLimits != nil {
		l = m.UdpFloodLimits.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.IcmpFloodLimits != nil {
		l = m.IcmpFloodLimits.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.OtherFloodLimits != nil {
		l = m.OtherFloodLimits.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.PeerSgHandle != 0 {
		n += 1 + sovDos(uint64(m.PeerSgHandle))
	}
	return n
}

func (m *IngressDoSPolicy) Size() (n int) {
	var l int
	_ = l
	if m.DosProtection != nil {
		l = m.DosProtection.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	return n
}

func (m *EgressDoSPolicy) Size() (n int) {
	var l int
	_ = l
	if m.DosProtection != nil {
		l = m.DosProtection.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	return n
}

func (m *DoSPolicySpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.IngressPolicy != nil {
		l = m.IngressPolicy.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.EgressPolicy != nil {
		l = m.EgressPolicy.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.DosHandle != 0 {
		n += 9
	}
	if len(m.SgHandle) > 0 {
		l = 0
		for _, e := range m.SgHandle {
			l += sovDos(uint64(e))
		}
		n += 1 + sovDos(uint64(l)) + l
	}
	return n
}

func (m *DoSPolicyRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDos(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.DosHandle != 0 {
		n += 9
	}
	return n
}

func (m *DoSPolicyResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDos(uint64(m.ApiStatus))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	return n
}

func (m *DoSPolicyResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDos(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.DosHandle != 0 {
		n += 9
	}
	return n
}

func (m *DoSPolicyDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDos(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDos(uint64(m.ApiStatus))
	}
	return n
}

func (m *DoSPolicyDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDos(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.DosHandle != 0 {
		n += 9
	}
	return n
}

func (m *DoSPolicyGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovDos(uint64(l))
		}
	}
	return n
}

func (m *DoSPolicyStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DoSPolicyGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovDos(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovDos(uint64(l))
	}
	return n
}

func (m *DoSPolicyGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovDos(uint64(l))
		}
	}
	return n
}

func sovDos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDos(x uint64) (n int) {
	return sovDos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ICMPMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ICMPMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ICMPMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ICMPMsgType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpProtocol", wireType)
			}
			m.IpProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpProtocol |= (IPProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.L4Info = &DoSService_DstPort{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ICMPMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.L4Info = &DoSService_IcmpMsg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSSessionLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSSessionLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSSessionLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessions", wireType)
			}
			m.MaxSessions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockingTimeout", wireType)
			}
			m.BlockingTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockingTimeout |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPerSecond", wireType)
			}
			m.BytesPerSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesPerSecond |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakRate", wireType)
			}
			m.PeakRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstSize", wireType)
			}
			m.BurstSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSFloodLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSFloodLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSFloodLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestrictLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RestrictLimits == nil {
				m.RestrictLimits = &DoSFloodLimits_RestrictLimits{}
			}
			if err := m.RestrictLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtectLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtectLimits == nil {
				m.ProtectLimits = &DoSFloodLimits_ProtectLimits{}
			}
			if err := m.ProtectLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSFloodLimits_RestrictLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestrictLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestrictLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pps", wireType)
			}
			m.Pps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstPps", wireType)
			}
			m.BurstPps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstPps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSFloodLimits_ProtectLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtectLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtectLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pps", wireType)
			}
			m.Pps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurstPps", wireType)
			}
			m.BurstPps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurstPps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSProtectionSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSProtectionSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSProtectionSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Svc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Svc == nil {
				m.Svc = &DoSService{}
			}
			if err := m.Svc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionSetupRate", wireType)
			}
			m.SessionSetupRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionSetupRate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionLimits == nil {
				m.SessionLimits = &DoSSessionLimits{}
			}
			if err := m.SessionLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policer == nil {
				m.Policer = &DoSPolicer{}
			}
			if err := m.Policer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpSynFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TcpSynFloodLimits == nil {
				m.TcpSynFloodLimits = &DoSFloodLimits{}
			}
			if err := m.TcpSynFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UdpFloodLimits == nil {
				m.UdpFloodLimits = &DoSFloodLimits{}
			}
			if err := m.UdpFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcmpFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IcmpFloodLimits == nil {
				m.IcmpFloodLimits = &DoSFloodLimits{}
			}
			if err := m.IcmpFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherFloodLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherFloodLimits == nil {
				m.OtherFloodLimits = &DoSFloodLimits{}
			}
			if err := m.OtherFloodLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerSgHandle", wireType)
			}
			m.PeerSgHandle = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerSgHandle |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressDoSPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressDoSPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressDoSPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosProtection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DosProtection == nil {
				m.DosProtection = &DoSProtectionSpec{}
			}
			if err := m.DosProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressDoSPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressDoSPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressDoSPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosProtection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DosProtection == nil {
				m.DosProtection = &DoSProtectionSpec{}
			}
			if err := m.DosProtection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IngressPolicy == nil {
				m.IngressPolicy = &IngressDoSPolicy{}
			}
			if err := m.IngressPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EgressPolicy == nil {
				m.EgressPolicy = &EgressDoSPolicy{}
			}
			if err := m.EgressPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.DosHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SgHandle = append(m.SgHandle, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDos
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDos
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDos
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SgHandle = append(m.SgHandle, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SgHandle", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DoSPolicySpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.DosHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DoSPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DoSPolicyResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.DosHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DoSPolicyDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DoSPolicyDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DosHandle", wireType)
			}
			m.DosHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.DosHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &DoSPolicyGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DoSPolicySpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DoSPolicyStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &DoSPolicyStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSPolicyGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSPolicyGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSPolicyGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &DoSPolicyGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("dos.proto", fileDescriptorDos) }

var fileDescriptorDos = []byte{
	// 1164 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xee, 0xda, 0x4e, 0x6c, 0x1f, 0xc7, 0x3f, 0x99, 0xa4, 0xc1, 0x71, 0xda, 0xd4, 0x59, 0x41,
	0xe5, 0x48, 0x51, 0x84, 0x0c, 0x48, 0x80, 0xa8, 0x50, 0x93, 0xb4, 0xa4, 0xb4, 0x11, 0x66, 0x1c,
	0xb8, 0x68, 0x25, 0x96, 0xcd, 0xee, 0xd4, 0x59, 0x6a, 0xef, 0x0c, 0x3b, 0xe3, 0xa8, 0xee, 0x1b,
	0x70, 0xcd, 0x0d, 0x0f, 0xc3, 0x03, 0x70, 0xc9, 0x13, 0x40, 0x15, 0x2e, 0xb9, 0xe3, 0x9a, 0x0b,
	0x34, 0x3f, 0xeb, 0xdd, 0x75, 0xec, 0x82, 0x44, 0xae, 0xb2, 0x73, 0xce, 0x37, 0xdf, 0x9c, 0xf9,
	0xce, 0x77, 0x76, 0x1d, 0x28, 0xfb, 0x94, 0xef, 0xb3, 0x88, 0x0a, 0x8a, 0xf2, 0x3e, 0xe5, 0xad,
	0x8a, 0x98, 0x30, 0x62, 0x22, 0xf6, 0x03, 0x28, 0x3e, 0x3a, 0x3c, 0xe9, 0x9d, 0xf0, 0x01, 0xba,
	0x0b, 0x05, 0x99, 0x69, 0x5a, 0x6d, 0xab, 0x53, 0xeb, 0xa2, 0x7d, 0x0d, 0x33, 0xd9, 0xd3, 0x09,
	0x23, 0x58, 0xe5, 0x11, 0x82, 0x82, 0x47, 0x7d, 0xd2, 0xcc, 0xb5, 0xad, 0x4e, 0x15, 0xab, 0x67,
	0xfb, 0x47, 0x0b, 0xe0, 0x88, 0xf6, 0xfb, 0x24, 0xba, 0x08, 0x3c, 0x82, 0xba, 0x50, 0x09, 0x98,
	0xa3, 0x4e, 0xf0, 0xe8, 0xd0, 0x30, 0xae, 0xc6, 0x8c, 0xbd, 0x9e, 0x49, 0x60, 0x08, 0x58, 0xfc,
	0x8c, 0xb6, 0xa0, 0xe4, 0x73, 0xe1, 0x30, 0x1a, 0x09, 0x4d, 0x7d, 0x7c, 0x03, 0x17, 0x7d, 0x2e,
	0x7a, 0x34, 0x12, 0x68, 0x17, 0x4a, 0x81, 0x37, 0x62, 0xce, 0x88, 0x0f, 0x9a, 0xf9, 0xb6, 0xd5,
	0xa9, 0x74, 0x57, 0xf6, 0xe5, 0xb5, 0x4c, 0x75, 0x12, 0x2a, 0xf3, 0x27, 0x7c, 0x70, 0x50, 0x86,
	0xe2, 0xf0, 0x7d, 0x27, 0x08, 0x9f, 0x53, 0xfb, 0x5b, 0x68, 0xa8, 0xa2, 0x38, 0x0f, 0x68, 0xf8,
	0x24, 0x18, 0x05, 0x82, 0xa3, 0x1d, 0x58, 0x19, 0xb9, 0x2f, 0x1d, 0xae, 0x83, 0x5c, 0xd5, 0x56,
	0xc5, 0x95, 0x91, 0xfb, 0xd2, 0xe0, 0x38, 0xda, 0x85, 0xc6, 0xd9, 0x90, 0x7a, 0x2f, 0x82, 0x70,
	0xe0, 0x88, 0x60, 0x44, 0xe8, 0xd8, 0x54, 0x84, 0xeb, 0x71, 0xfc, 0x54, 0x87, 0xed, 0x48, 0x5d,
	0xbb, 0x47, 0x87, 0x81, 0x47, 0x22, 0xd4, 0x81, 0xc6, 0xd9, 0x44, 0x10, 0xee, 0x30, 0x12, 0x39,
	0x9c, 0x78, 0x34, 0xf4, 0x0d, 0x7f, 0x4d, 0xc5, 0x7b, 0x24, 0xea, 0xab, 0x28, 0xda, 0x82, 0x32,
	0x23, 0xee, 0x0b, 0x27, 0x72, 0x45, 0x2c, 0x64, 0x49, 0x06, 0xb0, 0x2b, 0x08, 0xba, 0x0d, 0x70,
	0x36, 0x8e, 0xb8, 0x70, 0x78, 0xf0, 0x8a, 0xa8, 0xeb, 0x56, 0x71, 0x59, 0x45, 0xfa, 0xc1, 0x2b,
	0x62, 0xbf, 0xce, 0x41, 0xed, 0x88, 0xf6, 0x1f, 0x0e, 0x29, 0xf5, 0xcd, 0xa5, 0x1e, 0x43, 0x3d,
	0x22, 0x5c, 0x44, 0x81, 0x27, 0x9c, 0xa1, 0x0a, 0xa9, 0x73, 0x2b, 0x5d, 0x5b, 0xa9, 0x94, 0x45,
	0xef, 0x63, 0x03, 0xd5, 0x4b, 0x5c, 0x8b, 0x32, 0x6b, 0x74, 0x0c, 0x35, 0xd9, 0x39, 0x92, 0x70,
	0xe5, 0x14, 0xd7, 0xce, 0x3c, 0xae, 0x9e, 0x46, 0x1a, 0xaa, 0x2a, 0x4b, 0x2f, 0x5b, 0xcf, 0xa0,
	0x96, 0x3d, 0x0b, 0x35, 0x20, 0xcf, 0x58, 0x2c, 0xba, 0x7c, 0x94, 0x4a, 0xe8, 0xcb, 0xca, 0xb8,
	0x51, 0x42, 0x05, 0x7a, 0x8c, 0xa3, 0x16, 0x94, 0xfc, 0x71, 0xe4, 0x8a, 0x80, 0x86, 0x46, 0x87,
	0xe9, 0xba, 0xf5, 0x14, 0xaa, 0x99, 0xc3, 0xaf, 0x91, 0xdb, 0xfe, 0x3b, 0x0f, 0xab, 0xb2, 0xaf,
	0x9a, 0x3f, 0xa0, 0x61, 0x9f, 0x11, 0x0f, 0xed, 0x40, 0x9e, 0x5f, 0x78, 0x46, 0xd9, 0x7a, 0xac,
	0x86, 0xf1, 0x3c, 0x96, 0x39, 0xb4, 0x07, 0xc8, 0x38, 0xcb, 0xe1, 0x44, 0x8c, 0x59, 0xba, 0xc1,
	0x0d, 0x93, 0xe9, 0xcb, 0x84, 0x6a, 0xf4, 0x27, 0x50, 0x8b, 0xd1, 0x46, 0x69, 0xed, 0xed, 0x9b,
	0x09, 0x77, 0xca, 0xba, 0xb8, 0xca, 0x33, 0x4e, 0xde, 0x85, 0x22, 0xd3, 0xc6, 0x6b, 0x16, 0xb2,
	0x25, 0x19, 0x3f, 0xe2, 0x38, 0x8f, 0x8e, 0x60, 0x5d, 0x78, 0xcc, 0xe1, 0x93, 0xd0, 0x79, 0x2e,
	0x9b, 0x17, 0x1f, 0xb7, 0xa4, 0xf6, 0xad, 0xcd, 0x69, 0x2c, 0x5e, 0x15, 0x1e, 0xeb, 0x4f, 0xc2,
	0xb4, 0xcb, 0xee, 0x41, 0x63, 0xec, 0xb3, 0x2c, 0xc3, 0xf2, 0x62, 0x86, 0xda, 0xd8, 0x67, 0xe9,
	0xed, 0x9f, 0xc2, 0xaa, 0x9a, 0xe1, 0xcc, 0xfe, 0xe2, 0xe2, 0xfd, 0x75, 0x89, 0x4e, 0x13, 0xdc,
	0x07, 0x44, 0xc5, 0x39, 0x89, 0xb2, 0x0c, 0xa5, 0xc5, 0x0c, 0x0d, 0x05, 0x4f, 0x53, 0xbc, 0x0d,
	0x35, 0x46, 0xe4, 0x70, 0x0e, 0x9c, 0x73, 0x37, 0xf4, 0x87, 0xa4, 0x59, 0x6e, 0x5b, 0x9d, 0x02,
	0x5e, 0x91, 0xd1, 0xfe, 0xe0, 0x58, 0xc5, 0xec, 0x2f, 0xa1, 0xf1, 0x28, 0x1c, 0x44, 0x84, 0xf3,
	0x58, 0xcc, 0x09, 0xba, 0x07, 0x35, 0x9f, 0x72, 0x87, 0x4d, 0x2d, 0x61, 0x7c, 0xb0, 0x31, 0x15,
	0x3d, 0x63, 0x16, 0x5c, 0xf5, 0x29, 0x4f, 0x42, 0x76, 0x0f, 0xea, 0x0f, 0xae, 0x97, 0xf1, 0x4f,
	0x0b, 0xaa, 0x53, 0x32, 0xe5, 0xcf, 0x77, 0xa0, 0x30, 0x22, 0xc2, 0x35, 0x34, 0xf1, 0xeb, 0xf6,
	0x8b, 0xb3, 0xef, 0x88, 0x27, 0x4e, 0x88, 0x70, 0xb1, 0x4a, 0x4b, 0xd7, 0x05, 0xfa, 0x76, 0x8e,
	0xf2, 0xc7, 0xc4, 0xcc, 0xb7, 0x76, 0xdd, 0xec, 0xc5, 0x71, 0xd5, 0x80, 0x4d, 0xd5, 0x1f, 0x41,
	0x95, 0x64, 0x36, 0x6b, 0xcb, 0xae, 0xab, 0xcd, 0x33, 0x57, 0xc4, 0x2b, 0x24, 0xbd, 0xf5, 0x36,
	0x80, 0xbc, 0xb0, 0x11, 0x5e, 0x7a, 0x76, 0x19, 0xcb, 0x8f, 0x93, 0x56, 0x5d, 0x4e, 0x6b, 0xd2,
	0x96, 0xa5, 0x76, 0xbe, 0x53, 0xc0, 0x25, 0x1e, 0xb7, 0xe4, 0x10, 0xd6, 0x12, 0x5a, 0xf2, 0xfd,
	0x98, 0x70, 0x21, 0xbf, 0x59, 0x7b, 0x50, 0x8c, 0xf4, 0xaa, 0x69, 0xb5, 0xf3, 0x9d, 0x4a, 0x17,
	0x65, 0x66, 0x40, 0xe9, 0x82, 0x63, 0x88, 0xfd, 0x2e, 0xd4, 0x93, 0x8c, 0x70, 0xc5, 0x98, 0xcf,
	0xd4, 0x64, 0xcd, 0xd4, 0x64, 0xff, 0x60, 0xe9, 0x17, 0x81, 0x39, 0x97, 0x33, 0x1a, 0x72, 0x82,
	0x1e, 0x02, 0xb8, 0x2c, 0x70, 0xb8, 0xa2, 0x30, 0x5f, 0xb7, 0x86, 0x91, 0xfb, 0x3e, 0x0b, 0x34,
	0xf5, 0xc1, 0xcd, 0xbf, 0x7e, 0xbb, 0xb3, 0x7a, 0x41, 0xc2, 0xc0, 0x23, 0x1f, 0x27, 0x70, 0x5c,
	0x76, 0x63, 0x04, 0xda, 0x83, 0x65, 0xc3, 0x91, 0x4b, 0x89, 0x38, 0x53, 0x22, 0x36, 0x18, 0xfb,
	0x73, 0x58, 0xbf, 0x52, 0x8a, 0xd4, 0xa0, 0x0b, 0xa5, 0xc8, 0x2c, 0x8d, 0x08, 0x1b, 0x59, 0x9e,
	0x18, 0x8c, 0xa7, 0x38, 0xfb, 0x1b, 0xd8, 0x98, 0xa6, 0x8f, 0xc8, 0x90, 0x08, 0x62, 0x44, 0xfd,
	0xaf, 0x26, 0xca, 0xea, 0x96, 0x9b, 0xd5, 0x0d, 0xc3, 0xe6, 0x7c, 0x7e, 0x59, 0xf0, 0x07, 0xb3,
	0x4d, 0xdb, 0xca, 0xd6, 0x9b, 0xd9, 0x90, 0x74, 0xcf, 0x85, 0xb7, 0xae, 0x40, 0xae, 0xb7, 0x21,
	0xf6, 0xd7, 0xd0, 0x5a, 0x70, 0x84, 0xac, 0xfb, 0xc3, 0x2b, 0x42, 0xdf, 0x9a, 0x5f, 0xf8, 0x15,
	0xb9, 0x9f, 0xa5, 0xdc, 0xfb, 0x19, 0x11, 0xd7, 0xab, 0xf5, 0x93, 0x54, 0x2f, 0x13, 0x72, 0xed,
	0x8c, 0x19, 0xa1, 0x9b, 0xd9, 0x7a, 0x13, 0x74, 0xa2, 0x72, 0x43, 0xfd, 0xb8, 0x48, 0x0c, 0xc8,
	0xed, 0xdf, 0xad, 0x94, 0xf1, 0xd4, 0x96, 0x6b, 0x1e, 0x83, 0xbb, 0x50, 0xe0, 0x8c, 0x78, 0x66,
	0x08, 0xe6, 0x4d, 0xb0, 0xca, 0xa7, 0xc6, 0x25, 0xff, 0xef, 0xe3, 0x82, 0x76, 0x61, 0x49, 0x3e,
	0x71, 0xf3, 0x71, 0x5c, 0xbb, 0x0a, 0xe6, 0x58, 0x23, 0xec, 0x5e, 0xca, 0x59, 0xa9, 0x0b, 0x6a,
	0xaf, 0xce, 0xf6, 0x7c, 0x73, 0x8e, 0x86, 0xb3, 0x0d, 0xef, 0xfe, 0x9c, 0x83, 0xfc, 0x11, 0x95,
	0xbf, 0xa5, 0x92, 0x37, 0xce, 0x61, 0x44, 0xe4, 0x47, 0xbf, 0x39, 0x3b, 0x9c, 0x71, 0xbb, 0x5a,
	0x9b, 0xf3, 0xc7, 0xf6, 0x84, 0x0f, 0xec, 0x1b, 0x19, 0xa6, 0xaf, 0x98, 0xff, 0x3f, 0x98, 0x4e,
	0x53, 0x4c, 0xda, 0xb1, 0x68, 0xfb, 0x0d, 0x03, 0x28, 0xf9, 0xee, 0xbc, 0xc9, 0xe7, 0x9a, 0xf5,
	0x31, 0xac, 0xa4, 0x35, 0x41, 0x5b, 0x8b, 0xac, 0x26, 0xf9, 0x6e, 0x2d, 0xd4, 0x50, 0x91, 0x1d,
	0xb4, 0x7e, 0xb9, 0xdc, 0xb6, 0x7e, 0xbd, 0xdc, 0xb6, 0x5e, 0x5f, 0x6e, 0x5b, 0x3f, 0xfd, 0xb1,
	0x7d, 0xe3, 0x69, 0xe9, 0xdc, 0x1d, 0xaa, 0xff, 0x27, 0xce, 0x96, 0xd5, 0x9f, 0xf7, 0xfe, 0x09,
	0x00, 0x00, 0xff, 0xff, 0x64, 0x53, 0x5f, 0xae, 0xd7, 0x0c, 0x00, 0x00,
}
