// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: bgp.proto

package pds

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/pensando/sw/nic/apollo/agent/gen/pds/meta/pds"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// BGP address family identifier
type BGPAfi int32

const (
	BGPAfi_BGP_AFI_NONE  BGPAfi = 0
	BGPAfi_BGP_AFI_IPV4  BGPAfi = 1
	BGPAfi_BGP_AFI_L2VPN BGPAfi = 25
)

var BGPAfi_name = map[int32]string{
	0:  "BGP_AFI_NONE",
	1:  "BGP_AFI_IPV4",
	25: "BGP_AFI_L2VPN",
}
var BGPAfi_value = map[string]int32{
	"BGP_AFI_NONE":  0,
	"BGP_AFI_IPV4":  1,
	"BGP_AFI_L2VPN": 25,
}

func (x BGPAfi) String() string {
	return proto.EnumName(BGPAfi_name, int32(x))
}
func (BGPAfi) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{0} }

// BGP sub-address family identitfier
type BGPSafi int32

const (
	BGPSafi_BGP_SAFI_NONE    BGPSafi = 0
	BGPSafi_BGP_SAFI_UNICAST BGPSafi = 1
	BGPSafi_BGP_SAFI_EVPN    BGPSafi = 70
)

var BGPSafi_name = map[int32]string{
	0:  "BGP_SAFI_NONE",
	1:  "BGP_SAFI_UNICAST",
	70: "BGP_SAFI_EVPN",
}
var BGPSafi_value = map[string]int32{
	"BGP_SAFI_NONE":    0,
	"BGP_SAFI_UNICAST": 1,
	"BGP_SAFI_EVPN":    70,
}

func (x BGPSafi) String() string {
	return proto.EnumName(BGPSafi_name, int32(x))
}
func (BGPSafi) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{1} }

// BGP peer RR client
type BGPPeerRRClient int32

const (
	BGPPeerRRClient_BGP_PEER_RR_NONE          BGPPeerRRClient = 0
	BGPPeerRRClient_BGP_PEER_RR_CLIENT        BGPPeerRRClient = 1
	BGPPeerRRClient_BGP_PEER_RR_MESHED_CLIENT BGPPeerRRClient = 2
)

var BGPPeerRRClient_name = map[int32]string{
	0: "BGP_PEER_RR_NONE",
	1: "BGP_PEER_RR_CLIENT",
	2: "BGP_PEER_RR_MESHED_CLIENT",
}
var BGPPeerRRClient_value = map[string]int32{
	"BGP_PEER_RR_NONE":          0,
	"BGP_PEER_RR_CLIENT":        1,
	"BGP_PEER_RR_MESHED_CLIENT": 2,
}

func (x BGPPeerRRClient) String() string {
	return proto.EnumName(BGPPeerRRClient_name, int32(x))
}
func (BGPPeerRRClient) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{2} }

// BGP peer last_state
type BGPPeerState int32

const (
	BGPPeerState_BGP_PEER_STATE_NONE        BGPPeerState = 0
	BGPPeerState_BGP_PEER_STATE_IDLE        BGPPeerState = 1
	BGPPeerState_BGP_PEER_STATE_CONNECT     BGPPeerState = 2
	BGPPeerState_BGP_PEER_STATE_ACTIVE      BGPPeerState = 3
	BGPPeerState_BGP_PEER_STATE_OPENSENT    BGPPeerState = 4
	BGPPeerState_BGP_PEER_STATE_OPENCONFIRM BGPPeerState = 5
	BGPPeerState_BGP_PEER_STATE_ESTABLISHED BGPPeerState = 6
)

var BGPPeerState_name = map[int32]string{
	0: "BGP_PEER_STATE_NONE",
	1: "BGP_PEER_STATE_IDLE",
	2: "BGP_PEER_STATE_CONNECT",
	3: "BGP_PEER_STATE_ACTIVE",
	4: "BGP_PEER_STATE_OPENSENT",
	5: "BGP_PEER_STATE_OPENCONFIRM",
	6: "BGP_PEER_STATE_ESTABLISHED",
}
var BGPPeerState_value = map[string]int32{
	"BGP_PEER_STATE_NONE":        0,
	"BGP_PEER_STATE_IDLE":        1,
	"BGP_PEER_STATE_CONNECT":     2,
	"BGP_PEER_STATE_ACTIVE":      3,
	"BGP_PEER_STATE_OPENSENT":    4,
	"BGP_PEER_STATE_OPENCONFIRM": 5,
	"BGP_PEER_STATE_ESTABLISHED": 6,
}

func (x BGPPeerState) String() string {
	return proto.EnumName(BGPPeerState_name, int32(x))
}
func (BGPPeerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{3} }

type BGPASSize int32

const (
	BGPASSize_BGP_AS_SIZE_NONE       BGPASSize = 0
	BGPASSize_BGP_AS_SIZE_TWO_OCTET  BGPASSize = 1
	BGPASSize_BGP_AS_SIZE_FOUR_OCTET BGPASSize = 2
)

var BGPASSize_name = map[int32]string{
	0: "BGP_AS_SIZE_NONE",
	1: "BGP_AS_SIZE_TWO_OCTET",
	2: "BGP_AS_SIZE_FOUR_OCTET",
}
var BGPASSize_value = map[string]int32{
	"BGP_AS_SIZE_NONE":       0,
	"BGP_AS_SIZE_TWO_OCTET":  1,
	"BGP_AS_SIZE_FOUR_OCTET": 2,
}

func (x BGPASSize) String() string {
	return proto.EnumName(BGPASSize_name, int32(x))
}
func (BGPASSize) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{4} }

type BGPAddrType int32

const (
	BGPAddrType_BGP_ADDR_TYPE_OTHER     BGPAddrType = 0
	BGPAddrType_BGP_ADDR_TYPE_IPV4      BGPAddrType = 1
	BGPAddrType_BGP_ADDR_TYPE_IPV6      BGPAddrType = 2
	BGPAddrType_BGP_ADDR_TYPE_NSAP      BGPAddrType = 3
	BGPAddrType_BGP_ADDR_TYPE_HDLC      BGPAddrType = 4
	BGPAddrType_BGP_ADDR_TYPE_BBN1822   BGPAddrType = 5
	BGPAddrType_BGP_ADDR_TYPE_IEEE802   BGPAddrType = 6
	BGPAddrType_BGP_ADDR_TYPE_E163      BGPAddrType = 7
	BGPAddrType_BGP_ADDR_TYPE_E164      BGPAddrType = 8
	BGPAddrType_BGP_ADDR_TYPE_F69       BGPAddrType = 9
	BGPAddrType_BGP_ADDR_TYPE_X121      BGPAddrType = 10
	BGPAddrType_BGP_ADDR_TYPE_IPX       BGPAddrType = 11
	BGPAddrType_BGP_ADDR_TYPE_APPLETALK BGPAddrType = 12
	BGPAddrType_BGP_ADDR_TYPE_DECNETIV  BGPAddrType = 13
	BGPAddrType_BGP_ADDR_TYPE_BANYANVIN BGPAddrType = 14
	BGPAddrType_BGP_ADDR_TYPE_E164_NSAP BGPAddrType = 15
	BGPAddrType_BGP_ADDR_TYPE_IPV4_TNA  BGPAddrType = 16
	BGPAddrType_BGP_ADDR_TYPE_IPV6_TNA  BGPAddrType = 17
	BGPAddrType_BGP_ADDR_TYPE_NSAP_TNA  BGPAddrType = 18
	BGPAddrType_BGP_ADDR_TYPE_VPN_IPV4  BGPAddrType = 19
	BGPAddrType_BGP_ADDR_TYPE_VPN_IPV6  BGPAddrType = 20
	BGPAddrType_BGP_ADDR_TYPE_L2VPN     BGPAddrType = 25
)

var BGPAddrType_name = map[int32]string{
	0:  "BGP_ADDR_TYPE_OTHER",
	1:  "BGP_ADDR_TYPE_IPV4",
	2:  "BGP_ADDR_TYPE_IPV6",
	3:  "BGP_ADDR_TYPE_NSAP",
	4:  "BGP_ADDR_TYPE_HDLC",
	5:  "BGP_ADDR_TYPE_BBN1822",
	6:  "BGP_ADDR_TYPE_IEEE802",
	7:  "BGP_ADDR_TYPE_E163",
	8:  "BGP_ADDR_TYPE_E164",
	9:  "BGP_ADDR_TYPE_F69",
	10: "BGP_ADDR_TYPE_X121",
	11: "BGP_ADDR_TYPE_IPX",
	12: "BGP_ADDR_TYPE_APPLETALK",
	13: "BGP_ADDR_TYPE_DECNETIV",
	14: "BGP_ADDR_TYPE_BANYANVIN",
	15: "BGP_ADDR_TYPE_E164_NSAP",
	16: "BGP_ADDR_TYPE_IPV4_TNA",
	17: "BGP_ADDR_TYPE_IPV6_TNA",
	18: "BGP_ADDR_TYPE_NSAP_TNA",
	19: "BGP_ADDR_TYPE_VPN_IPV4",
	20: "BGP_ADDR_TYPE_VPN_IPV6",
	25: "BGP_ADDR_TYPE_L2VPN",
}
var BGPAddrType_value = map[string]int32{
	"BGP_ADDR_TYPE_OTHER":     0,
	"BGP_ADDR_TYPE_IPV4":      1,
	"BGP_ADDR_TYPE_IPV6":      2,
	"BGP_ADDR_TYPE_NSAP":      3,
	"BGP_ADDR_TYPE_HDLC":      4,
	"BGP_ADDR_TYPE_BBN1822":   5,
	"BGP_ADDR_TYPE_IEEE802":   6,
	"BGP_ADDR_TYPE_E163":      7,
	"BGP_ADDR_TYPE_E164":      8,
	"BGP_ADDR_TYPE_F69":       9,
	"BGP_ADDR_TYPE_X121":      10,
	"BGP_ADDR_TYPE_IPX":       11,
	"BGP_ADDR_TYPE_APPLETALK": 12,
	"BGP_ADDR_TYPE_DECNETIV":  13,
	"BGP_ADDR_TYPE_BANYANVIN": 14,
	"BGP_ADDR_TYPE_E164_NSAP": 15,
	"BGP_ADDR_TYPE_IPV4_TNA":  16,
	"BGP_ADDR_TYPE_IPV6_TNA":  17,
	"BGP_ADDR_TYPE_NSAP_TNA":  18,
	"BGP_ADDR_TYPE_VPN_IPV4":  19,
	"BGP_ADDR_TYPE_VPN_IPV6":  20,
	"BGP_ADDR_TYPE_L2VPN":     25,
}

func (x BGPAddrType) String() string {
	return proto.EnumName(BGPAddrType_name, int32(x))
}
func (BGPAddrType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{5} }

type BGPOperStatus int32

const (
	BGPOperStatus_BGP_OPER_STATUS_NONE       BGPOperStatus = 0
	BGPOperStatus_BGP_OPER_STATUS_UP         BGPOperStatus = 1
	BGPOperStatus_BGP_OPER_STATUS_DOWN       BGPOperStatus = 2
	BGPOperStatus_BGP_OPER_STATUS_GOING_UP   BGPOperStatus = 3
	BGPOperStatus_BGP_OPER_STATUS_GOING_DOWN BGPOperStatus = 4
	BGPOperStatus_BGP_OPER_STATUS_ACT_FAILED BGPOperStatus = 5
)

var BGPOperStatus_name = map[int32]string{
	0: "BGP_OPER_STATUS_NONE",
	1: "BGP_OPER_STATUS_UP",
	2: "BGP_OPER_STATUS_DOWN",
	3: "BGP_OPER_STATUS_GOING_UP",
	4: "BGP_OPER_STATUS_GOING_DOWN",
	5: "BGP_OPER_STATUS_ACT_FAILED",
}
var BGPOperStatus_value = map[string]int32{
	"BGP_OPER_STATUS_NONE":       0,
	"BGP_OPER_STATUS_UP":         1,
	"BGP_OPER_STATUS_DOWN":       2,
	"BGP_OPER_STATUS_GOING_UP":   3,
	"BGP_OPER_STATUS_GOING_DOWN": 4,
	"BGP_OPER_STATUS_ACT_FAILED": 5,
}

func (x BGPOperStatus) String() string {
	return proto.EnumName(BGPOperStatus_name, int32(x))
}
func (BGPOperStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{6} }

type BgpAddPathCapNegCap int32

const (
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_DISABLE BgpAddPathCapNegCap = 0
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_RECEIVE BgpAddPathCapNegCap = 1
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_SEND    BgpAddPathCapNegCap = 2
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_BOTH    BgpAddPathCapNegCap = 3
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_INHERIT BgpAddPathCapNegCap = 4
	BgpAddPathCapNegCap_BGP_ADD_PATH_SR_UNKNOWN BgpAddPathCapNegCap = 5
)

var BgpAddPathCapNegCap_name = map[int32]string{
	0: "BGP_ADD_PATH_SR_DISABLE",
	1: "BGP_ADD_PATH_SR_RECEIVE",
	2: "BGP_ADD_PATH_SR_SEND",
	3: "BGP_ADD_PATH_SR_BOTH",
	4: "BGP_ADD_PATH_SR_INHERIT",
	5: "BGP_ADD_PATH_SR_UNKNOWN",
}
var BgpAddPathCapNegCap_value = map[string]int32{
	"BGP_ADD_PATH_SR_DISABLE": 0,
	"BGP_ADD_PATH_SR_RECEIVE": 1,
	"BGP_ADD_PATH_SR_SEND":    2,
	"BGP_ADD_PATH_SR_BOTH":    3,
	"BGP_ADD_PATH_SR_INHERIT": 4,
	"BGP_ADD_PATH_SR_UNKNOWN": 5,
}

func (x BgpAddPathCapNegCap) String() string {
	return proto.EnumName(BgpAddPathCapNegCap_name, int32(x))
}
func (BgpAddPathCapNegCap) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{7} }

type BGPClearRouteOptions int32

const (
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_NONE         BGPClearRouteOptions = 0
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_HARD         BGPClearRouteOptions = 1
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_IN   BGPClearRouteOptions = 2
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_OUT  BGPClearRouteOptions = 3
	BGPClearRouteOptions_BGP_CLEAR_ROUTE_REFRESH_BOTH BGPClearRouteOptions = 4
)

var BGPClearRouteOptions_name = map[int32]string{
	0: "BGP_CLEAR_ROUTE_NONE",
	1: "BGP_CLEAR_ROUTE_HARD",
	2: "BGP_CLEAR_ROUTE_REFRESH_IN",
	3: "BGP_CLEAR_ROUTE_REFRESH_OUT",
	4: "BGP_CLEAR_ROUTE_REFRESH_BOTH",
}
var BGPClearRouteOptions_value = map[string]int32{
	"BGP_CLEAR_ROUTE_NONE":         0,
	"BGP_CLEAR_ROUTE_HARD":         1,
	"BGP_CLEAR_ROUTE_REFRESH_IN":   2,
	"BGP_CLEAR_ROUTE_REFRESH_OUT":  3,
	"BGP_CLEAR_ROUTE_REFRESH_BOTH": 4,
}

func (x BGPClearRouteOptions) String() string {
	return proto.EnumName(BGPClearRouteOptions_name, int32(x))
}
func (BGPClearRouteOptions) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{8} }

// NLRI source
type NLRISrc int32

const (
	NLRISrc_NLRI_NONE NLRISrc = 0
	NLRISrc_NLRI_PEER NLRISrc = 1
	NLRISrc_NLRI_AFM  NLRISrc = 2
	NLRISrc_NLRI_SELF NLRISrc = 3
)

var NLRISrc_name = map[int32]string{
	0: "NLRI_NONE",
	1: "NLRI_PEER",
	2: "NLRI_AFM",
	3: "NLRI_SELF",
}
var NLRISrc_value = map[string]int32{
	"NLRI_NONE": 0,
	"NLRI_PEER": 1,
	"NLRI_AFM":  2,
	"NLRI_SELF": 3,
}

func (x NLRISrc) String() string {
	return proto.EnumName(NLRISrc_name, int32(x))
}
func (NLRISrc) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{9} }

type BGPNLRIIsActive int32

const (
	BGPNLRIIsActive_BGP_NLRI_ISA_NONE        BGPNLRIIsActive = 0
	BGPNLRIIsActive_BGP_NLRI_ISA_NOT_TRACKED BGPNLRIIsActive = 1
	BGPNLRIIsActive_BGP_NLRI_ISA_INACTIVE    BGPNLRIIsActive = 2
	BGPNLRIIsActive_BGP_NLRI_ISA_ACTIVE      BGPNLRIIsActive = 3
)

var BGPNLRIIsActive_name = map[int32]string{
	0: "BGP_NLRI_ISA_NONE",
	1: "BGP_NLRI_ISA_NOT_TRACKED",
	2: "BGP_NLRI_ISA_INACTIVE",
	3: "BGP_NLRI_ISA_ACTIVE",
}
var BGPNLRIIsActive_value = map[string]int32{
	"BGP_NLRI_ISA_NONE":        0,
	"BGP_NLRI_ISA_NOT_TRACKED": 1,
	"BGP_NLRI_ISA_INACTIVE":    2,
	"BGP_NLRI_ISA_ACTIVE":      3,
}

func (x BGPNLRIIsActive) String() string {
	return proto.EnumName(BGPNLRIIsActive_name, int32(x))
}
func (BGPNLRIIsActive) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{10} }

type BGPRsnNotBest int32

const (
	BGPRsnNotBest_BGP_REASON_NOT_CONSIDERED   BGPRsnNotBest = 0
	BGPRsnNotBest_BGP_REASON_ROUTE_IS_BEST    BGPRsnNotBest = 1
	BGPRsnNotBest_BGP_REASON_WEIGHT           BGPRsnNotBest = 2
	BGPRsnNotBest_BGP_REASON_LOCAL_PREF       BGPRsnNotBest = 3
	BGPRsnNotBest_BGP_REASON_LCL_ORIG_PRFRRED BGPRsnNotBest = 4
	BGPRsnNotBest_BGP_REASON_AS_PATH_LEN      BGPRsnNotBest = 5
	BGPRsnNotBest_BGP_REASON_ORIGIN           BGPRsnNotBest = 6
	BGPRsnNotBest_BGP_REASON_MED              BGPRsnNotBest = 7
	BGPRsnNotBest_BGP_REASON_LOCAL_ORIG_TIE   BGPRsnNotBest = 8
	BGPRsnNotBest_BGP_REASON_EBGP_V_IBGP_PEER BGPRsnNotBest = 9
	BGPRsnNotBest_BGP_REASON_ADMIN_DISTANCE   BGPRsnNotBest = 10
	BGPRsnNotBest_BGP_REASON_PATH_TO_NEXT_CST BGPRsnNotBest = 11
	BGPRsnNotBest_BGP_REASON_PREF_EXISTING    BGPRsnNotBest = 12
	BGPRsnNotBest_BGP_REASON_IDENTIFIER       BGPRsnNotBest = 13
	BGPRsnNotBest_BGP_REASON_CLUSTER_LEN      BGPRsnNotBest = 14
	BGPRsnNotBest_BGP_REASON_PEER_ADDR_TYPE   BGPRsnNotBest = 15
	BGPRsnNotBest_BGP_REASON_PEER_ADDR        BGPRsnNotBest = 16
	BGPRsnNotBest_BGP_REASON_PEER_PORT        BGPRsnNotBest = 17
	BGPRsnNotBest_BGP_REASON_PATH_ID          BGPRsnNotBest = 18
)

var BGPRsnNotBest_name = map[int32]string{
	0:  "BGP_REASON_NOT_CONSIDERED",
	1:  "BGP_REASON_ROUTE_IS_BEST",
	2:  "BGP_REASON_WEIGHT",
	3:  "BGP_REASON_LOCAL_PREF",
	4:  "BGP_REASON_LCL_ORIG_PRFRRED",
	5:  "BGP_REASON_AS_PATH_LEN",
	6:  "BGP_REASON_ORIGIN",
	7:  "BGP_REASON_MED",
	8:  "BGP_REASON_LOCAL_ORIG_TIE",
	9:  "BGP_REASON_EBGP_V_IBGP_PEER",
	10: "BGP_REASON_ADMIN_DISTANCE",
	11: "BGP_REASON_PATH_TO_NEXT_CST",
	12: "BGP_REASON_PREF_EXISTING",
	13: "BGP_REASON_IDENTIFIER",
	14: "BGP_REASON_CLUSTER_LEN",
	15: "BGP_REASON_PEER_ADDR_TYPE",
	16: "BGP_REASON_PEER_ADDR",
	17: "BGP_REASON_PEER_PORT",
	18: "BGP_REASON_PATH_ID",
}
var BGPRsnNotBest_value = map[string]int32{
	"BGP_REASON_NOT_CONSIDERED":   0,
	"BGP_REASON_ROUTE_IS_BEST":    1,
	"BGP_REASON_WEIGHT":           2,
	"BGP_REASON_LOCAL_PREF":       3,
	"BGP_REASON_LCL_ORIG_PRFRRED": 4,
	"BGP_REASON_AS_PATH_LEN":      5,
	"BGP_REASON_ORIGIN":           6,
	"BGP_REASON_MED":              7,
	"BGP_REASON_LOCAL_ORIG_TIE":   8,
	"BGP_REASON_EBGP_V_IBGP_PEER": 9,
	"BGP_REASON_ADMIN_DISTANCE":   10,
	"BGP_REASON_PATH_TO_NEXT_CST": 11,
	"BGP_REASON_PREF_EXISTING":    12,
	"BGP_REASON_IDENTIFIER":       13,
	"BGP_REASON_CLUSTER_LEN":      14,
	"BGP_REASON_PEER_ADDR_TYPE":   15,
	"BGP_REASON_PEER_ADDR":        16,
	"BGP_REASON_PEER_PORT":        17,
	"BGP_REASON_PATH_ID":          18,
}

func (x BGPRsnNotBest) String() string {
	return proto.EnumName(BGPRsnNotBest_name, int32(x))
}
func (BGPRsnNotBest) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{11} }

type BGPOrfAssoc int32

const (
	BGPOrfAssoc_BGP_ORF_ASSOC_NONE   BGPOrfAssoc = 0
	BGPOrfAssoc_BGP_ORF_ASSOC_LOCAL  BGPOrfAssoc = 1
	BGPOrfAssoc_BGP_ORF_ASSOC_REMOTE BGPOrfAssoc = 2
)

var BGPOrfAssoc_name = map[int32]string{
	0: "BGP_ORF_ASSOC_NONE",
	1: "BGP_ORF_ASSOC_LOCAL",
	2: "BGP_ORF_ASSOC_REMOTE",
}
var BGPOrfAssoc_value = map[string]int32{
	"BGP_ORF_ASSOC_NONE":   0,
	"BGP_ORF_ASSOC_LOCAL":  1,
	"BGP_ORF_ASSOC_REMOTE": 2,
}

func (x BGPOrfAssoc) String() string {
	return proto.EnumName(BGPOrfAssoc_name, int32(x))
}
func (BGPOrfAssoc) EnumDescriptor() ([]byte, []int) { return fileDescriptorBgp, []int{12} }

// BGP configuration
type BGPSpec struct {
	// unique key/identifier of BGP config
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// the local autonomous system number
	LocalASN uint32 `protobuf:"varint,2,opt,name=LocalASN,proto3" json:"LocalASN,omitempty"`
	// router ID for this bgp instance
	RouterId uint32 `protobuf:"fixed32,3,opt,name=RouterId,proto3" json:"RouterId,omitempty"`
	// cluster ID of the local router. router ID will be used as cluster ID
	// if cluster ID is not configured or configured to zero
	ClusterId uint32 `protobuf:"fixed32,4,opt,name=ClusterId,proto3" json:"ClusterId,omitempty"`
}

func (m *BGPSpec) Reset()                    { *m = BGPSpec{} }
func (m *BGPSpec) String() string            { return proto.CompactTextString(m) }
func (*BGPSpec) ProtoMessage()               {}
func (*BGPSpec) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{0} }

func (m *BGPSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPSpec) GetLocalASN() uint32 {
	if m != nil {
		return m.LocalASN
	}
	return 0
}

func (m *BGPSpec) GetRouterId() uint32 {
	if m != nil {
		return m.RouterId
	}
	return 0
}

func (m *BGPSpec) GetClusterId() uint32 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

// operational status of BGP
type BGPStatus struct {
	// BGP current oper status
	Status BGPOperStatus `protobuf:"varint,1,opt,name=Status,proto3,enum=pds.BGPOperStatus" json:"Status,omitempty"`
	// The total number of Adj-RIB-Out routes currently allocated
	NumAdjRibOutRoutes uint32 `protobuf:"varint,2,opt,name=NumAdjRibOutRoutes,proto3" json:"NumAdjRibOutRoutes,omitempty"`
	// The peak number of Adj-RIB-Out routes that have been allocated at any one time
	PeakNumAdjRibOutRoutes uint32 `protobuf:"varint,3,opt,name=PeakNumAdjRibOutRoutes,proto3" json:"PeakNumAdjRibOutRoutes,omitempty"`
	// The maximum time remaining until route selection takes place following a restart, in hundredths of a second.
	RemDelayTime uint32 `protobuf:"varint,4,opt,name=RemDelayTime,proto3" json:"RemDelayTime,omitempty"`
	// The table version number of the Loc-RIB
	TableVer uint32 `protobuf:"varint,5,opt,name=TableVer,proto3" json:"TableVer,omitempty"`
}

func (m *BGPStatus) Reset()                    { *m = BGPStatus{} }
func (m *BGPStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPStatus) ProtoMessage()               {}
func (*BGPStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{1} }

func (m *BGPStatus) GetStatus() BGPOperStatus {
	if m != nil {
		return m.Status
	}
	return BGPOperStatus_BGP_OPER_STATUS_NONE
}

func (m *BGPStatus) GetNumAdjRibOutRoutes() uint32 {
	if m != nil {
		return m.NumAdjRibOutRoutes
	}
	return 0
}

func (m *BGPStatus) GetPeakNumAdjRibOutRoutes() uint32 {
	if m != nil {
		return m.PeakNumAdjRibOutRoutes
	}
	return 0
}

func (m *BGPStatus) GetRemDelayTime() uint32 {
	if m != nil {
		return m.RemDelayTime
	}
	return 0
}

func (m *BGPStatus) GetTableVer() uint32 {
	if m != nil {
		return m.TableVer
	}
	return 0
}

// BGP object
type BGP struct {
	Spec   *BGPSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *BGPStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *BGP) Reset()                    { *m = BGP{} }
func (m *BGP) String() string            { return proto.CompactTextString(m) }
func (*BGP) ProtoMessage()               {}
func (*BGP) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{2} }

func (m *BGP) GetSpec() *BGPSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGP) GetStatus() *BGPStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP create and update request
type BGPRequest struct {
	Request *BGPSpec `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
}

func (m *BGPRequest) Reset()                    { *m = BGPRequest{} }
func (m *BGPRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPRequest) ProtoMessage()               {}
func (*BGPRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{3} }

func (m *BGPRequest) GetRequest() *BGPSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP create and update response
type BGPResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPResponse) Reset()                    { *m = BGPResponse{} }
func (m *BGPResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPResponse) ProtoMessage()               {}
func (*BGPResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{4} }

func (m *BGPResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP KeyHandle used in Get/Delete
type BGPKeyHandle struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty"`
}

func (m *BGPKeyHandle) Reset()                    { *m = BGPKeyHandle{} }
func (m *BGPKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPKeyHandle) ProtoMessage()               {}
func (*BGPKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{5} }

func (m *BGPKeyHandle) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

// BGP delete request
type BGPDeleteRequest struct {
	Request *BGPKeyHandle `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
}

func (m *BGPDeleteRequest) Reset()                    { *m = BGPDeleteRequest{} }
func (m *BGPDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPDeleteRequest) ProtoMessage()               {}
func (*BGPDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{6} }

func (m *BGPDeleteRequest) GetRequest() *BGPKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP delete response
type BGPDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPDeleteResponse) Reset()                    { *m = BGPDeleteResponse{} }
func (m *BGPDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPDeleteResponse) ProtoMessage()               {}
func (*BGPDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{7} }

func (m *BGPDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP get request
type BGPGetRequest struct {
	Request *BGPKeyHandle `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
}

func (m *BGPGetRequest) Reset()                    { *m = BGPGetRequest{} }
func (m *BGPGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPGetRequest) ProtoMessage()               {}
func (*BGPGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{8} }

func (m *BGPGetRequest) GetRequest() *BGPKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP get response
type BGPGetResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  *BGP      `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *BGPGetResponse) Reset()                    { *m = BGPGetResponse{} }
func (m *BGPGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPGetResponse) ProtoMessage()               {}
func (*BGPGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{9} }

func (m *BGPGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPGetResponse) GetResponse() *BGP {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP peer configurations
type BGPPeerSpec struct {
	// unique key/identifier of peer
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// peer enable/disable admin state. if peer is not enabled then local router
	// must not initiate connections to the neighbor and must not respond to
	// TCP connections attempts from neighbor
	State AdminState `protobuf:"varint,2,opt,name=State,proto3,enum=types.AdminState" json:"State,omitempty"`
	// BGP local IP address. control plane chooses the local IP address of the
	// session if an all 0 IP address is provided
	LocalAddr *IPAddress `protobuf:"bytes,3,opt,name=LocalAddr" json:"LocalAddr,omitempty" meta:mandatory,immutable`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,4,opt,name=PeerAddr" json:"PeerAddr,omitempty" meta:mandatory,immutable`
	// remote 4-byte AS number
	RemoteASN uint32 `protobuf:"varint,5,opt,name=RemoteASN,proto3" json:"RemoteASN,omitempty"`
	// send regular community attributes to neighbor
	SendComm bool `protobuf:"varint,6,opt,name=SendComm,proto3" json:"SendComm,omitempty"`
	// send extended community attributes to neighbor
	SendExtComm bool `protobuf:"varint,7,opt,name=SendExtComm,proto3" json:"SendExtComm,omitempty"`
	// peer is a route reflector client
	RRClient BGPPeerRRClient `protobuf:"varint,8,opt,name=RRClient,proto3,enum=pds.BGPPeerRRClient" json:"RRClient,omitempty"`
	// BGP session connect-retry timer in seconds
	ConnectRetry uint32 `protobuf:"varint,9,opt,name=ConnectRetry,proto3" json:"ConnectRetry,omitempty"`
	// BGP session configured holdtime timer in seconds
	HoldTime uint32 `protobuf:"varint,10,opt,name=HoldTime,proto3" json:"HoldTime,omitempty"`
	// BGP session configured keepalive timer in seconds
	KeepAlive uint32 `protobuf:"varint,11,opt,name=KeepAlive,proto3" json:"KeepAlive,omitempty"`
	// MD5 authentication
	Password []byte `protobuf:"bytes,12,opt,name=Password,proto3" json:"Password,omitempty"`
	// TTL
	TTL uint32 `protobuf:"varint,13,opt,name=TTL,proto3" json:"TTL,omitempty"`
}

func (m *BGPPeerSpec) Reset()                    { *m = BGPPeerSpec{} }
func (m *BGPPeerSpec) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerSpec) ProtoMessage()               {}
func (*BGPPeerSpec) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{10} }

func (m *BGPPeerSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPPeerSpec) GetState() AdminState {
	if m != nil {
		return m.State
	}
	return AdminState_ADMIN_STATE_NONE
}

func (m *BGPPeerSpec) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerSpec) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerSpec) GetRemoteASN() uint32 {
	if m != nil {
		return m.RemoteASN
	}
	return 0
}

func (m *BGPPeerSpec) GetSendComm() bool {
	if m != nil {
		return m.SendComm
	}
	return false
}

func (m *BGPPeerSpec) GetSendExtComm() bool {
	if m != nil {
		return m.SendExtComm
	}
	return false
}

func (m *BGPPeerSpec) GetRRClient() BGPPeerRRClient {
	if m != nil {
		return m.RRClient
	}
	return BGPPeerRRClient_BGP_PEER_RR_NONE
}

func (m *BGPPeerSpec) GetConnectRetry() uint32 {
	if m != nil {
		return m.ConnectRetry
	}
	return 0
}

func (m *BGPPeerSpec) GetHoldTime() uint32 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *BGPPeerSpec) GetKeepAlive() uint32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *BGPPeerSpec) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *BGPPeerSpec) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

// BGP peer status
type BGPPeerStatus struct {
	// BGP session status
	Status BGPPeerState `protobuf:"varint,1,opt,name=Status,proto3,enum=pds.BGPPeerState" json:"Status,omitempty"`
	// BGP session previous status
	PrevStatus BGPPeerState `protobuf:"varint,2,opt,name=PrevStatus,proto3,enum=pds.BGPPeerState" json:"PrevStatus,omitempty"`
	// last error received
	LastErrorRcvd []byte `protobuf:"bytes,3,opt,name=LastErrorRcvd,proto3" json:"LastErrorRcvd,omitempty"`
	// Last error sent
	LastErrorSent []byte `protobuf:"bytes,4,opt,name=LastErrorSent,proto3" json:"LastErrorSent,omitempty"`
	// selected local address of the peer
	LocalAddr *IPAddress `protobuf:"bytes,5,opt,name=LocalAddr" json:"LocalAddr,omitempty"`
	// BGP session holdtime in seconds established with peer
	HoldTime uint32 `protobuf:"varint,6,opt,name=HoldTime,proto3" json:"HoldTime,omitempty"`
	// BGP session keepalive in seconds established with peer
	KeepAlive uint32 `protobuf:"varint,7,opt,name=KeepAlive,proto3" json:"KeepAlive,omitempty"`
	// BGP The capabilities announced to the peer on the most recent open message sent to the peer.
	CapsSent uint32 `protobuf:"varint,8,opt,name=CapsSent,proto3" json:"CapsSent,omitempty"`
	// BGP The capabilities received on the most recent open message received from the peer.
	CapsRcvd uint32 `protobuf:"varint,9,opt,name=CapsRcvd,proto3" json:"CapsRcvd,omitempty"`
	// BGP The capabilities negotiated for the session with the peer
	CapsNeg uint32 `protobuf:"varint,10,opt,name=CapsNeg,proto3" json:"CapsNeg,omitempty"`
	// BGP The address family of the local address used by the transport connection for the peering session.
	SelLocalAddrType BGPAddrType `protobuf:"varint,11,opt,name=SelLocalAddrType,proto3,enum=pds.BGPAddrType" json:"SelLocalAddrType,omitempty"`
	// Number of BGP Notifications received for this connection.
	InNotifications uint32 `protobuf:"varint,12,opt,name=InNotifications,proto3" json:"InNotifications,omitempty"`
	// Number of BGP Notifications sent for this connection.
	OutNotifications uint32 `protobuf:"varint,13,opt,name=OutNotifications,proto3" json:"OutNotifications,omitempty"`
	// Number of BGP Updates received for this connection.
	InUpdates uint32 `protobuf:"varint,14,opt,name=InUpdates,proto3" json:"InUpdates,omitempty"`
	// Number of BGP Updates received for this connection.
	OutUpdates uint32 `protobuf:"varint,15,opt,name=OutUpdates,proto3" json:"OutUpdates,omitempty"`
	// Number of BGP Keepalives received for this connection.
	InKeepalives uint32 `protobuf:"varint,16,opt,name=InKeepalives,proto3" json:"InKeepalives,omitempty"`
	// Number of BGP Opens sent for this connection.
	OutKeepalives uint32 `protobuf:"varint,17,opt,name=OutKeepalives,proto3" json:"OutKeepalives,omitempty"`
	// Number of BGP Route Refreshes received for this connection.
	InRefreshes uint32 `protobuf:"varint,18,opt,name=InRefreshes,proto3" json:"InRefreshes,omitempty"`
	// Number of BGP Route Refreshes sent for this connection.
	OutRefreshes uint32 `protobuf:"varint,19,opt,name=OutRefreshes,proto3" json:"OutRefreshes,omitempty"`
	// Total number of BGP messages received for this connection.
	InTotalMessages uint32 `protobuf:"varint,20,opt,name=InTotalMessages,proto3" json:"InTotalMessages,omitempty"`
	// Total number of BGP messages sent for this connection.
	OutTotalMessages uint32 `protobuf:"varint,21,opt,name=OutTotalMessages,proto3" json:"OutTotalMessages,omitempty"`
	// Number of times BGP FSM transitioned to established state.
	FsmEstTransitions uint32 `protobuf:"varint,22,opt,name=FsmEstTransitions,proto3" json:"FsmEstTransitions,omitempty"`
	// Number of retries after a flap.
	ConnectRetryCount uint32 `protobuf:"varint,23,opt,name=ConnectRetryCount,proto3" json:"ConnectRetryCount,omitempty"`
	// Peer Group ID.
	Peergr uint32 `protobuf:"varint,24,opt,name=Peergr,proto3" json:"Peergr,omitempty"`
	// Number of sec to stale the routes before deleting them.
	StalePathTime uint32 `protobuf:"varint,25,opt,name=StalePathTime,proto3" json:"StalePathTime,omitempty"`
	// Number of ORF entries of all types received from the peer.
	OrfEntryCount uint32 `protobuf:"varint,26,opt,name=OrfEntryCount,proto3" json:"OrfEntryCount,omitempty"`
	// Time in 1/100 of sec since last message received from peer.
	RcvdMsgElpsTime uint32 `protobuf:"varint,27,opt,name=RcvdMsgElpsTime,proto3" json:"RcvdMsgElpsTime,omitempty"`
	// Number of Route Refreshes sent to the peer.
	RouteRefrSent uint32 `protobuf:"varint,28,opt,name=RouteRefrSent,proto3" json:"RouteRefrSent,omitempty"`
	// Number of Route Refreshes received from the peer.
	RouteRefrRcvd uint32 `protobuf:"varint,29,opt,name=RouteRefrRcvd,proto3" json:"RouteRefrRcvd,omitempty"`
	// Number of prefixes received from the peer.
	InPrfxes uint32 `protobuf:"varint,30,opt,name=InPrfxes,proto3" json:"InPrfxes,omitempty"`
	// Number of prefixes advertised to the peer including withdrawn prefixes.
	OutPrfxes uint32 `protobuf:"varint,31,opt,name=OutPrfxes,proto3" json:"OutPrfxes,omitempty"`
	// Number of prefixes advertised to the peer.
	OutPrfxesAdvertised uint32 `protobuf:"varint,32,opt,name=OutPrfxesAdvertised,proto3" json:"OutPrfxesAdvertised,omitempty"`
	// Connection retry time interval.
	ConnectRetryInt uint32 `protobuf:"varint,33,opt,name=ConnectRetryInt,proto3" json:"ConnectRetryInt,omitempty"`
	// Time in sec since last update was sent to the peer.
	OutUpdateElpsTime uint32 `protobuf:"varint,34,opt,name=OutUpdateElpsTime,proto3" json:"OutUpdateElpsTime,omitempty"`
	// Number of prefixes failed export policy.
	OutPrfxesDenied uint32 `protobuf:"varint,35,opt,name=OutPrfxesDenied,proto3" json:"OutPrfxesDenied,omitempty"`
	// Number of prefixes for which implicit withdraw has been sent.
	OutPrfxesImpWdr uint32 `protobuf:"varint,36,opt,name=OutPrfxesImpWdr,proto3" json:"OutPrfxesImpWdr,omitempty"`
	// Number of prefixes for which explicit withdraw has been sent.
	OutPrfxesExpWdr uint32 `protobuf:"varint,37,opt,name=OutPrfxesExpWdr,proto3" json:"OutPrfxesExpWdr,omitempty"`
	// Number of prefixes for which implicit withdraw has been rcvd.
	InPrfxesImpWdr uint32 `protobuf:"varint,38,opt,name=InPrfxesImpWdr,proto3" json:"InPrfxesImpWdr,omitempty"`
	// Number of prefixes for which explicit withdraw has been rcvd.
	InPrfxesExpWdr uint32 `protobuf:"varint,39,opt,name=InPrfxesExpWdr,proto3" json:"InPrfxesExpWdr,omitempty"`
	// Hold time received in open message.
	ReceivedHoldTime uint32 `protobuf:"varint,40,opt,name=ReceivedHoldTime,proto3" json:"ReceivedHoldTime,omitempty"`
	// For how long is this peer in established state in sec.
	FsmEstablishedTime uint32 `protobuf:"varint,41,opt,name=FsmEstablishedTime,proto3" json:"FsmEstablishedTime,omitempty"`
	// Elapsed time in sec since the last BGP message is received.
	InUpdatesElpsTime uint32 `protobuf:"varint,42,opt,name=InUpdatesElpsTime,proto3" json:"InUpdatesElpsTime,omitempty"`
	// Number of BGP Opens received for this connection.
	InOpens uint32 `protobuf:"varint,43,opt,name=InOpens,proto3" json:"InOpens,omitempty"`
	// Number of BGP Opens sent for this connection.
	OutOpens uint32 `protobuf:"varint,44,opt,name=OutOpens,proto3" json:"OutOpens,omitempty"`
}

func (m *BGPPeerStatus) Reset()                    { *m = BGPPeerStatus{} }
func (m *BGPPeerStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerStatus) ProtoMessage()               {}
func (*BGPPeerStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{11} }

func (m *BGPPeerStatus) GetStatus() BGPPeerState {
	if m != nil {
		return m.Status
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPeerStatus) GetPrevStatus() BGPPeerState {
	if m != nil {
		return m.PrevStatus
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPeerStatus) GetLastErrorRcvd() []byte {
	if m != nil {
		return m.LastErrorRcvd
	}
	return nil
}

func (m *BGPPeerStatus) GetLastErrorSent() []byte {
	if m != nil {
		return m.LastErrorSent
	}
	return nil
}

func (m *BGPPeerStatus) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerStatus) GetHoldTime() uint32 {
	if m != nil {
		return m.HoldTime
	}
	return 0
}

func (m *BGPPeerStatus) GetKeepAlive() uint32 {
	if m != nil {
		return m.KeepAlive
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsSent() uint32 {
	if m != nil {
		return m.CapsSent
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsRcvd() uint32 {
	if m != nil {
		return m.CapsRcvd
	}
	return 0
}

func (m *BGPPeerStatus) GetCapsNeg() uint32 {
	if m != nil {
		return m.CapsNeg
	}
	return 0
}

func (m *BGPPeerStatus) GetSelLocalAddrType() BGPAddrType {
	if m != nil {
		return m.SelLocalAddrType
	}
	return BGPAddrType_BGP_ADDR_TYPE_OTHER
}

func (m *BGPPeerStatus) GetInNotifications() uint32 {
	if m != nil {
		return m.InNotifications
	}
	return 0
}

func (m *BGPPeerStatus) GetOutNotifications() uint32 {
	if m != nil {
		return m.OutNotifications
	}
	return 0
}

func (m *BGPPeerStatus) GetInUpdates() uint32 {
	if m != nil {
		return m.InUpdates
	}
	return 0
}

func (m *BGPPeerStatus) GetOutUpdates() uint32 {
	if m != nil {
		return m.OutUpdates
	}
	return 0
}

func (m *BGPPeerStatus) GetInKeepalives() uint32 {
	if m != nil {
		return m.InKeepalives
	}
	return 0
}

func (m *BGPPeerStatus) GetOutKeepalives() uint32 {
	if m != nil {
		return m.OutKeepalives
	}
	return 0
}

func (m *BGPPeerStatus) GetInRefreshes() uint32 {
	if m != nil {
		return m.InRefreshes
	}
	return 0
}

func (m *BGPPeerStatus) GetOutRefreshes() uint32 {
	if m != nil {
		return m.OutRefreshes
	}
	return 0
}

func (m *BGPPeerStatus) GetInTotalMessages() uint32 {
	if m != nil {
		return m.InTotalMessages
	}
	return 0
}

func (m *BGPPeerStatus) GetOutTotalMessages() uint32 {
	if m != nil {
		return m.OutTotalMessages
	}
	return 0
}

func (m *BGPPeerStatus) GetFsmEstTransitions() uint32 {
	if m != nil {
		return m.FsmEstTransitions
	}
	return 0
}

func (m *BGPPeerStatus) GetConnectRetryCount() uint32 {
	if m != nil {
		return m.ConnectRetryCount
	}
	return 0
}

func (m *BGPPeerStatus) GetPeergr() uint32 {
	if m != nil {
		return m.Peergr
	}
	return 0
}

func (m *BGPPeerStatus) GetStalePathTime() uint32 {
	if m != nil {
		return m.StalePathTime
	}
	return 0
}

func (m *BGPPeerStatus) GetOrfEntryCount() uint32 {
	if m != nil {
		return m.OrfEntryCount
	}
	return 0
}

func (m *BGPPeerStatus) GetRcvdMsgElpsTime() uint32 {
	if m != nil {
		return m.RcvdMsgElpsTime
	}
	return 0
}

func (m *BGPPeerStatus) GetRouteRefrSent() uint32 {
	if m != nil {
		return m.RouteRefrSent
	}
	return 0
}

func (m *BGPPeerStatus) GetRouteRefrRcvd() uint32 {
	if m != nil {
		return m.RouteRefrRcvd
	}
	return 0
}

func (m *BGPPeerStatus) GetInPrfxes() uint32 {
	if m != nil {
		return m.InPrfxes
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxes() uint32 {
	if m != nil {
		return m.OutPrfxes
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesAdvertised() uint32 {
	if m != nil {
		return m.OutPrfxesAdvertised
	}
	return 0
}

func (m *BGPPeerStatus) GetConnectRetryInt() uint32 {
	if m != nil {
		return m.ConnectRetryInt
	}
	return 0
}

func (m *BGPPeerStatus) GetOutUpdateElpsTime() uint32 {
	if m != nil {
		return m.OutUpdateElpsTime
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesDenied() uint32 {
	if m != nil {
		return m.OutPrfxesDenied
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesImpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesImpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetOutPrfxesExpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesExpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetInPrfxesImpWdr() uint32 {
	if m != nil {
		return m.InPrfxesImpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetInPrfxesExpWdr() uint32 {
	if m != nil {
		return m.InPrfxesExpWdr
	}
	return 0
}

func (m *BGPPeerStatus) GetReceivedHoldTime() uint32 {
	if m != nil {
		return m.ReceivedHoldTime
	}
	return 0
}

func (m *BGPPeerStatus) GetFsmEstablishedTime() uint32 {
	if m != nil {
		return m.FsmEstablishedTime
	}
	return 0
}

func (m *BGPPeerStatus) GetInUpdatesElpsTime() uint32 {
	if m != nil {
		return m.InUpdatesElpsTime
	}
	return 0
}

func (m *BGPPeerStatus) GetInOpens() uint32 {
	if m != nil {
		return m.InOpens
	}
	return 0
}

func (m *BGPPeerStatus) GetOutOpens() uint32 {
	if m != nil {
		return m.OutOpens
	}
	return 0
}

// BGP peer object
type BGPPeer struct {
	Spec   *BGPPeerSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *BGPPeerStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *BGPPeer) Reset()                    { *m = BGPPeer{} }
func (m *BGPPeer) String() string            { return proto.CompactTextString(m) }
func (*BGPPeer) ProtoMessage()               {}
func (*BGPPeer) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{12} }

func (m *BGPPeer) GetSpec() *BGPPeerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGPPeer) GetStatus() *BGPPeerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP peer create and update response
type BGPPeerResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerResponse) Reset()                    { *m = BGPPeerResponse{} }
func (m *BGPPeerResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerResponse) ProtoMessage()               {}
func (*BGPPeerResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{13} }

func (m *BGPPeerResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer create and update request
type BGPPeerRequest struct {
	Request []*BGPPeerSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerRequest) Reset()                    { *m = BGPPeerRequest{} }
func (m *BGPPeerRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerRequest) ProtoMessage()               {}
func (*BGPPeerRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{14} }

func (m *BGPPeerRequest) GetRequest() []*BGPPeerSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer get response
type BGPPeerGetResponse struct {
	ApiStatus ApiStatus  `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPPeer `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPPeerGetResponse) Reset()                    { *m = BGPPeerGetResponse{} }
func (m *BGPPeerGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerGetResponse) ProtoMessage()               {}
func (*BGPPeerGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{15} }

func (m *BGPPeerGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPeerGetResponse) GetResponse() []*BGPPeer {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP peer key parameters
type BGPPeerKey struct {
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,1,opt,name=LocalAddr" json:"LocalAddr,omitempty"`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,2,opt,name=PeerAddr" json:"PeerAddr,omitempty"`
}

func (m *BGPPeerKey) Reset()                    { *m = BGPPeerKey{} }
func (m *BGPPeerKey) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerKey) ProtoMessage()               {}
func (*BGPPeerKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{16} }

func (m *BGPPeerKey) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerKey) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

// BGP peer get and delete key handle
type BGPPeerKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*BGPPeerKeyHandle_Id
	//	*BGPPeerKeyHandle_Key
	IdOrKey isBGPPeerKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *BGPPeerKeyHandle) Reset()                    { *m = BGPPeerKeyHandle{} }
func (m *BGPPeerKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerKeyHandle) ProtoMessage()               {}
func (*BGPPeerKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{17} }

type isBGPPeerKeyHandle_IdOrKey interface {
	isBGPPeerKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPPeerKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type BGPPeerKeyHandle_Key struct {
	Key *BGPPeerKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*BGPPeerKeyHandle_Id) isBGPPeerKeyHandle_IdOrKey()  {}
func (*BGPPeerKeyHandle_Key) isBGPPeerKeyHandle_IdOrKey() {}

func (m *BGPPeerKeyHandle) GetIdOrKey() isBGPPeerKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *BGPPeerKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*BGPPeerKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *BGPPeerKeyHandle) GetKey() *BGPPeerKey {
	if x, ok := m.GetIdOrKey().(*BGPPeerKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BGPPeerKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BGPPeerKeyHandle_OneofMarshaler, _BGPPeerKeyHandle_OneofUnmarshaler, _BGPPeerKeyHandle_OneofSizer, []interface{}{
		(*BGPPeerKeyHandle_Id)(nil),
		(*BGPPeerKeyHandle_Key)(nil),
	}
}

func _BGPPeerKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BGPPeerKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *BGPPeerKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BGPPeerKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _BGPPeerKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BGPPeerKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &BGPPeerKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &BGPPeerKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BGPPeerKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BGPPeerKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *BGPPeerKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BGP peer delete request
type BGPPeerDeleteRequest struct {
	Request []*BGPPeerKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerDeleteRequest) Reset()                    { *m = BGPPeerDeleteRequest{} }
func (m *BGPPeerDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerDeleteRequest) ProtoMessage()               {}
func (*BGPPeerDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{18} }

func (m *BGPPeerDeleteRequest) GetRequest() []*BGPPeerKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer delete response
type BGPPeerDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerDeleteResponse) Reset()                    { *m = BGPPeerDeleteResponse{} }
func (m *BGPPeerDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerDeleteResponse) ProtoMessage()               {}
func (*BGPPeerDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{19} }

func (m *BGPPeerDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer get request
type BGPPeerGetRequest struct {
	Request []*BGPPeerKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerGetRequest) Reset()                    { *m = BGPPeerGetRequest{} }
func (m *BGPPeerGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerGetRequest) ProtoMessage()               {}
func (*BGPPeerGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{20} }

func (m *BGPPeerGetRequest) GetRequest() []*BGPPeerKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer AF configurations
type BGPPeerAfSpec struct {
	// unique key/identifier of peer AF config
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3" json:"Id,omitempty" meta:mandatory,immutable`
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,2,opt,name=LocalAddr" json:"LocalAddr,omitempty" meta:mandatory,immutable`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,3,opt,name=PeerAddr" json:"PeerAddr,omitempty" meta:mandatory,immutable`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,4,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty" meta:mandatory,immutable`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,5,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty" meta:mandatory,immutable`
	// enforce this router to set self as next-hop for advertised routes
	NexthopSelf bool `protobuf:"varint,6,opt,name=NexthopSelf,proto3" json:"NexthopSelf,omitempty"`
	// originate a default route to this peer
	DefaultOrig bool `protobuf:"varint,7,opt,name=DefaultOrig,proto3" json:"DefaultOrig,omitempty"`
	// The local port configured for the peering session
	LocalPort uint32 `protobuf:"varint,8,opt,name=LocalPort,proto3" json:"LocalPort,omitempty"`
	// The remote port configured for the peering session
	RemotePort uint32 `protobuf:"varint,9,opt,name=RemotePort,proto3" json:"RemotePort,omitempty"`
	// For a peer identified by a link-local IPv6 addresses, this is the scope ID of bgpPeerLocalAddr and bgpPeerRemoteAddr. For a peer identified only by interface (bgpPeerLocalAddr and bgpPeerRemoteAddr are both zero), this is the interface index of the local point-to-point interface through which the peer is reachable
	LocalAddrScopeId uint32 `protobuf:"varint,10,opt,name=LocalAddrScopeId,proto3" json:"LocalAddrScopeId,omitempty"`
}

func (m *BGPPeerAfSpec) Reset()                    { *m = BGPPeerAfSpec{} }
func (m *BGPPeerAfSpec) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfSpec) ProtoMessage()               {}
func (*BGPPeerAfSpec) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{21} }

func (m *BGPPeerAfSpec) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *BGPPeerAfSpec) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerAfSpec) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerAfSpec) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPeerAfSpec) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPPeerAfSpec) GetNexthopSelf() bool {
	if m != nil {
		return m.NexthopSelf
	}
	return false
}

func (m *BGPPeerAfSpec) GetDefaultOrig() bool {
	if m != nil {
		return m.DefaultOrig
	}
	return false
}

func (m *BGPPeerAfSpec) GetLocalPort() uint32 {
	if m != nil {
		return m.LocalPort
	}
	return 0
}

func (m *BGPPeerAfSpec) GetRemotePort() uint32 {
	if m != nil {
		return m.RemotePort
	}
	return 0
}

func (m *BGPPeerAfSpec) GetLocalAddrScopeId() uint32 {
	if m != nil {
		return m.LocalAddrScopeId
	}
	return 0
}

// BGP peer AF status
type BGPPeerAfStatus struct {
	// BGP The index of the update group that the peer is a member of for this AFI/SAFI
	UpdateGroup uint32 `protobuf:"varint,1,opt,name=UpdateGroup,proto3" json:"UpdateGroup,omitempty"`
	// For a peer identified by a link-local IPv6 addresses, this is the scope ID of bgpPeerLocalAddr and bgpPeerRemoteAddr. For a peer
	LocalAddrScopeId uint32 `protobuf:"varint,2,opt,name=LocalAddrScopeId,proto3" json:"LocalAddrScopeId,omitempty"`
	// send a Route Refresh request to the peer for this AFI/SAFI.
	RtRefresh bool `protobuf:"varint,3,opt,name=RtRefresh,proto3" json:"RtRefresh,omitempty"`
	// The BGP additional path capability negotiated with this peer for this AFI/SAFI.
	AddPathCapNeg BgpAddPathCapNegCap `protobuf:"varint,4,opt,name=AddPathCapNeg,proto3,enum=pds.BgpAddPathCapNegCap" json:"AddPathCapNeg,omitempty"`
	// This value indicates whether the given peer is a reflector client of this router for this AFI/SAFI, or not
	ReflectorClient BGPPeerRRClient `protobuf:"varint,5,opt,name=ReflectorClient,proto3,enum=pds.BGPPeerRRClient" json:"ReflectorClient,omitempty"`
}

func (m *BGPPeerAfStatus) Reset()                    { *m = BGPPeerAfStatus{} }
func (m *BGPPeerAfStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfStatus) ProtoMessage()               {}
func (*BGPPeerAfStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{22} }

func (m *BGPPeerAfStatus) GetUpdateGroup() uint32 {
	if m != nil {
		return m.UpdateGroup
	}
	return 0
}

func (m *BGPPeerAfStatus) GetLocalAddrScopeId() uint32 {
	if m != nil {
		return m.LocalAddrScopeId
	}
	return 0
}

func (m *BGPPeerAfStatus) GetRtRefresh() bool {
	if m != nil {
		return m.RtRefresh
	}
	return false
}

func (m *BGPPeerAfStatus) GetAddPathCapNeg() BgpAddPathCapNegCap {
	if m != nil {
		return m.AddPathCapNeg
	}
	return BgpAddPathCapNegCap_BGP_ADD_PATH_SR_DISABLE
}

func (m *BGPPeerAfStatus) GetReflectorClient() BGPPeerRRClient {
	if m != nil {
		return m.ReflectorClient
	}
	return BGPPeerRRClient_BGP_PEER_RR_NONE
}

// BGP peer AF object
type BGPPeerAf struct {
	Spec   *BGPPeerAfSpec   `protobuf:"bytes,1,opt,name=Spec" json:"spec,omitempty"`
	Status *BGPPeerAfStatus `protobuf:"bytes,2,opt,name=Status" json:"status,omitempty"`
}

func (m *BGPPeerAf) Reset()                    { *m = BGPPeerAf{} }
func (m *BGPPeerAf) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAf) ProtoMessage()               {}
func (*BGPPeerAf) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{23} }

func (m *BGPPeerAf) GetSpec() *BGPPeerAfSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *BGPPeerAf) GetStatus() *BGPPeerAfStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP peer AF create and update response
type BGPPeerAfResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerAfResponse) Reset()                    { *m = BGPPeerAfResponse{} }
func (m *BGPPeerAfResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfResponse) ProtoMessage()               {}
func (*BGPPeerAfResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{24} }

func (m *BGPPeerAfResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer AF create and update request
type BGPPeerAfRequest struct {
	Request []*BGPPeerAfSpec `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerAfRequest) Reset()                    { *m = BGPPeerAfRequest{} }
func (m *BGPPeerAfRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfRequest) ProtoMessage()               {}
func (*BGPPeerAfRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{25} }

func (m *BGPPeerAfRequest) GetRequest() []*BGPPeerAfSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer key parameters
type BGPPeerAfKey struct {
	// BGP local IP address
	LocalAddr *IPAddress `protobuf:"bytes,1,opt,name=LocalAddr" json:"LocalAddr,omitempty"`
	// BGP peer IP address
	PeerAddr *IPAddress `protobuf:"bytes,2,opt,name=PeerAddr" json:"PeerAddr,omitempty"`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,3,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,4,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
}

func (m *BGPPeerAfKey) Reset()                    { *m = BGPPeerAfKey{} }
func (m *BGPPeerAfKey) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfKey) ProtoMessage()               {}
func (*BGPPeerAfKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{26} }

func (m *BGPPeerAfKey) GetLocalAddr() *IPAddress {
	if m != nil {
		return m.LocalAddr
	}
	return nil
}

func (m *BGPPeerAfKey) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPPeerAfKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPeerAfKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

// BGP peer delete spec
type BGPPeerAfKeyHandle struct {
	// unique identifier or key parameters
	//
	// Types that are valid to be assigned to IdOrKey:
	//	*BGPPeerAfKeyHandle_Id
	//	*BGPPeerAfKeyHandle_Key
	IdOrKey isBGPPeerAfKeyHandle_IdOrKey `protobuf_oneof:"id_or_key"`
}

func (m *BGPPeerAfKeyHandle) Reset()                    { *m = BGPPeerAfKeyHandle{} }
func (m *BGPPeerAfKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfKeyHandle) ProtoMessage()               {}
func (*BGPPeerAfKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{27} }

type isBGPPeerAfKeyHandle_IdOrKey interface {
	isBGPPeerAfKeyHandle_IdOrKey()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPPeerAfKeyHandle_Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=Id,proto3,oneof"`
}
type BGPPeerAfKeyHandle_Key struct {
	Key *BGPPeerAfKey `protobuf:"bytes,2,opt,name=Key,oneof"`
}

func (*BGPPeerAfKeyHandle_Id) isBGPPeerAfKeyHandle_IdOrKey()  {}
func (*BGPPeerAfKeyHandle_Key) isBGPPeerAfKeyHandle_IdOrKey() {}

func (m *BGPPeerAfKeyHandle) GetIdOrKey() isBGPPeerAfKeyHandle_IdOrKey {
	if m != nil {
		return m.IdOrKey
	}
	return nil
}

func (m *BGPPeerAfKeyHandle) GetId() []byte {
	if x, ok := m.GetIdOrKey().(*BGPPeerAfKeyHandle_Id); ok {
		return x.Id
	}
	return nil
}

func (m *BGPPeerAfKeyHandle) GetKey() *BGPPeerAfKey {
	if x, ok := m.GetIdOrKey().(*BGPPeerAfKeyHandle_Key); ok {
		return x.Key
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BGPPeerAfKeyHandle) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BGPPeerAfKeyHandle_OneofMarshaler, _BGPPeerAfKeyHandle_OneofUnmarshaler, _BGPPeerAfKeyHandle_OneofSizer, []interface{}{
		(*BGPPeerAfKeyHandle_Id)(nil),
		(*BGPPeerAfKeyHandle_Key)(nil),
	}
}

func _BGPPeerAfKeyHandle_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BGPPeerAfKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerAfKeyHandle_Id:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Id)
	case *BGPPeerAfKeyHandle_Key:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Key); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BGPPeerAfKeyHandle.IdOrKey has unexpected type %T", x)
	}
	return nil
}

func _BGPPeerAfKeyHandle_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BGPPeerAfKeyHandle)
	switch tag {
	case 1: // id_or_key.Id
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.IdOrKey = &BGPPeerAfKeyHandle_Id{x}
		return true, err
	case 2: // id_or_key.Key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerAfKey)
		err := b.DecodeMessage(msg)
		m.IdOrKey = &BGPPeerAfKeyHandle_Key{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BGPPeerAfKeyHandle_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BGPPeerAfKeyHandle)
	// id_or_key
	switch x := m.IdOrKey.(type) {
	case *BGPPeerAfKeyHandle_Id:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Id)))
		n += len(x.Id)
	case *BGPPeerAfKeyHandle_Key:
		s := proto.Size(x.Key)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BGP peer af delete request
type BGPPeerAfDeleteRequest struct {
	Request []*BGPPeerAfKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerAfDeleteRequest) Reset()                    { *m = BGPPeerAfDeleteRequest{} }
func (m *BGPPeerAfDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfDeleteRequest) ProtoMessage()               {}
func (*BGPPeerAfDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{28} }

func (m *BGPPeerAfDeleteRequest) GetRequest() []*BGPPeerAfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer delete response
type BGPPeerAfDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPPeerAfDeleteResponse) Reset()                    { *m = BGPPeerAfDeleteResponse{} }
func (m *BGPPeerAfDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfDeleteResponse) ProtoMessage()               {}
func (*BGPPeerAfDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{29} }

func (m *BGPPeerAfDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP peer af get request
type BGPPeerAfGetRequest struct {
	Request []*BGPPeerAfKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPeerAfGetRequest) Reset()                    { *m = BGPPeerAfGetRequest{} }
func (m *BGPPeerAfGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfGetRequest) ProtoMessage()               {}
func (*BGPPeerAfGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{30} }

func (m *BGPPeerAfGetRequest) GetRequest() []*BGPPeerAfKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP peer AF get response
type BGPPeerAfGetResponse struct {
	ApiStatus ApiStatus    `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPPeerAf `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPPeerAfGetResponse) Reset()                    { *m = BGPPeerAfGetResponse{} }
func (m *BGPPeerAfGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPeerAfGetResponse) ProtoMessage()               {}
func (*BGPPeerAfGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{31} }

func (m *BGPPeerAfGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPeerAfGetResponse) GetResponse() []*BGPPeerAf {
	if m != nil {
		return m.Response
	}
	return nil
}

type BGPClearRouteRequest struct {
	// clear route options
	Option BGPClearRouteOptions `protobuf:"varint,1,opt,name=Option,proto3,enum=pds.BGPClearRouteOptions" json:"Option,omitempty"`
	// Types that are valid to be assigned to PeerOrPeeraf:
	//	*BGPClearRouteRequest_Peer
	//	*BGPClearRouteRequest_PeerAf
	PeerOrPeeraf isBGPClearRouteRequest_PeerOrPeeraf `protobuf_oneof:"peer_or_peeraf"`
}

func (m *BGPClearRouteRequest) Reset()                    { *m = BGPClearRouteRequest{} }
func (m *BGPClearRouteRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPClearRouteRequest) ProtoMessage()               {}
func (*BGPClearRouteRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{32} }

type isBGPClearRouteRequest_PeerOrPeeraf interface {
	isBGPClearRouteRequest_PeerOrPeeraf()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BGPClearRouteRequest_Peer struct {
	Peer *BGPPeerKeyHandle `protobuf:"bytes,2,opt,name=Peer,oneof"`
}
type BGPClearRouteRequest_PeerAf struct {
	PeerAf *BGPPeerAfKeyHandle `protobuf:"bytes,3,opt,name=PeerAf,oneof"`
}

func (*BGPClearRouteRequest_Peer) isBGPClearRouteRequest_PeerOrPeeraf()   {}
func (*BGPClearRouteRequest_PeerAf) isBGPClearRouteRequest_PeerOrPeeraf() {}

func (m *BGPClearRouteRequest) GetPeerOrPeeraf() isBGPClearRouteRequest_PeerOrPeeraf {
	if m != nil {
		return m.PeerOrPeeraf
	}
	return nil
}

func (m *BGPClearRouteRequest) GetOption() BGPClearRouteOptions {
	if m != nil {
		return m.Option
	}
	return BGPClearRouteOptions_BGP_CLEAR_ROUTE_NONE
}

func (m *BGPClearRouteRequest) GetPeer() *BGPPeerKeyHandle {
	if x, ok := m.GetPeerOrPeeraf().(*BGPClearRouteRequest_Peer); ok {
		return x.Peer
	}
	return nil
}

func (m *BGPClearRouteRequest) GetPeerAf() *BGPPeerAfKeyHandle {
	if x, ok := m.GetPeerOrPeeraf().(*BGPClearRouteRequest_PeerAf); ok {
		return x.PeerAf
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BGPClearRouteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BGPClearRouteRequest_OneofMarshaler, _BGPClearRouteRequest_OneofUnmarshaler, _BGPClearRouteRequest_OneofSizer, []interface{}{
		(*BGPClearRouteRequest_Peer)(nil),
		(*BGPClearRouteRequest_PeerAf)(nil),
	}
}

func _BGPClearRouteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BGPClearRouteRequest)
	// peer_or_peeraf
	switch x := m.PeerOrPeeraf.(type) {
	case *BGPClearRouteRequest_Peer:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Peer); err != nil {
			return err
		}
	case *BGPClearRouteRequest_PeerAf:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PeerAf); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("BGPClearRouteRequest.PeerOrPeeraf has unexpected type %T", x)
	}
	return nil
}

func _BGPClearRouteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BGPClearRouteRequest)
	switch tag {
	case 2: // peer_or_peeraf.Peer
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerKeyHandle)
		err := b.DecodeMessage(msg)
		m.PeerOrPeeraf = &BGPClearRouteRequest_Peer{msg}
		return true, err
	case 3: // peer_or_peeraf.PeerAf
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BGPPeerAfKeyHandle)
		err := b.DecodeMessage(msg)
		m.PeerOrPeeraf = &BGPClearRouteRequest_PeerAf{msg}
		return true, err
	default:
		return false, nil
	}
}

func _BGPClearRouteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BGPClearRouteRequest)
	// peer_or_peeraf
	switch x := m.PeerOrPeeraf.(type) {
	case *BGPClearRouteRequest_Peer:
		s := proto.Size(x.Peer)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *BGPClearRouteRequest_PeerAf:
		s := proto.Size(x.PeerAf)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BGP clear route response
type BGPClearRouteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
}

func (m *BGPClearRouteResponse) Reset()                    { *m = BGPClearRouteResponse{} }
func (m *BGPClearRouteResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPClearRouteResponse) ProtoMessage()               {}
func (*BGPClearRouteResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{33} }

func (m *BGPClearRouteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// BGP NLRI prefix table
type BGPNLRIPrefixStatus struct {
	// BGP address family
	Afi BGPAfi `protobuf:"varint,1,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,2,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// prefix in NLRI
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// prefix length
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// route source (learned from BGP peer or AFM)
	RouteSource NLRISrc `protobuf:"varint,5,opt,name=RouteSource,proto3,enum=pds.NLRISrc" json:"RouteSource,omitempty"`
	// route source index
	RouteSourceIndex uint32 `protobuf:"varint,6,opt,name=RouteSourceIndex,proto3" json:"RouteSourceIndex,omitempty"`
	// path ID
	PathID uint32 `protobuf:"varint,7,opt,name=PathID,proto3" json:"PathID,omitempty"`
	// chosen as BGP best route or not
	BestRoute bool `protobuf:"varint,8,opt,name=BestRoute,proto3" json:"BestRoute,omitempty"`
	// AS path string
	ASPathStr []byte `protobuf:"bytes,9,opt,name=ASPathStr,proto3" json:"ASPathStr,omitempty"`
	// originator ID
	PathOrigId []byte `protobuf:"bytes,10,opt,name=PathOrigId,proto3" json:"PathOrigId,omitempty"`
	// next-hop address
	NextHopAddr []byte `protobuf:"bytes,11,opt,name=NextHopAddr,proto3" json:"NextHopAddr,omitempty"`
	// Size of each ASN in the AS path string
	ASSize BGPASSize `protobuf:"varint,12,opt,name=ASSize,proto3,enum=pds.BGPASSize" json:"ASSize,omitempty"`
	// Is this route part of an ECMP set
	EcmpRoute bool `protobuf:"varint,13,opt,name=EcmpRoute,proto3" json:"EcmpRoute,omitempty"`
	// Peer IP
	PeerAddr *IPAddress `protobuf:"bytes,14,opt,name=PeerAddr" json:"PeerAddr,omitempty"`
	// The number of times this route has flapped since statistics were last cleared.
	FlapStatsFlapcnt uint32 `protobuf:"varint,15,opt,name=FlapStatsFlapcnt,proto3" json:"FlapStatsFlapcnt,omitempty"`
	// Whether or not this route is suppressed.
	FlapStatsSupprsd bool `protobuf:"varint,16,opt,name=FlapStatsSupprsd,proto3" json:"FlapStatsSupprsd,omitempty"`
	// An indication of whether or not this route is installed in the forwarding table
	IsActive BGPNLRIIsActive `protobuf:"varint,17,opt,name=IsActive,proto3,enum=pds.BGPNLRIIsActive" json:"IsActive,omitempty"`
	// Whether or not this route was last sent by the peer before BGP detected that the peer was restarting.
	Stale bool `protobuf:"varint,18,opt,name=Stale,proto3" json:"Stale,omitempty"`
	// The value of sysUpTime when this route flapped
	FlapStartTime uint32 `protobuf:"varint,19,opt,name=FlapStartTime,proto3" json:"FlapStartTime,omitempty"`
	// If bgpNlriPrefixBest is 'true', then this field is set to 'routeIsBest'.  Otherwise, it reports the stage in the decision process when the route was determined to be non-best.
	ReasonNotBest BGPRsnNotBest `protobuf:"varint,20,opt,name=ReasonNotBest,proto3,enum=pds.BGPRsnNotBest" json:"ReasonNotBest,omitempty"`
	// The extended community membership associated with the route after import policy has been applied.
	ExtComm [][]byte `protobuf:"bytes,21,rep,name=ExtComm" json:"ExtComm,omitempty"`
}

func (m *BGPNLRIPrefixStatus) Reset()                    { *m = BGPNLRIPrefixStatus{} }
func (m *BGPNLRIPrefixStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixStatus) ProtoMessage()               {}
func (*BGPNLRIPrefixStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{34} }

func (m *BGPNLRIPrefixStatus) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPNLRIPrefixStatus) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPNLRIPrefixStatus) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetRouteSource() NLRISrc {
	if m != nil {
		return m.RouteSource
	}
	return NLRISrc_NLRI_NONE
}

func (m *BGPNLRIPrefixStatus) GetRouteSourceIndex() uint32 {
	if m != nil {
		return m.RouteSourceIndex
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetBestRoute() bool {
	if m != nil {
		return m.BestRoute
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetASPathStr() []byte {
	if m != nil {
		return m.ASPathStr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetPathOrigId() []byte {
	if m != nil {
		return m.PathOrigId
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetNextHopAddr() []byte {
	if m != nil {
		return m.NextHopAddr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetASSize() BGPASSize {
	if m != nil {
		return m.ASSize
	}
	return BGPASSize_BGP_AS_SIZE_NONE
}

func (m *BGPNLRIPrefixStatus) GetEcmpRoute() bool {
	if m != nil {
		return m.EcmpRoute
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetPeerAddr() *IPAddress {
	if m != nil {
		return m.PeerAddr
	}
	return nil
}

func (m *BGPNLRIPrefixStatus) GetFlapStatsFlapcnt() uint32 {
	if m != nil {
		return m.FlapStatsFlapcnt
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetFlapStatsSupprsd() bool {
	if m != nil {
		return m.FlapStatsSupprsd
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetIsActive() BGPNLRIIsActive {
	if m != nil {
		return m.IsActive
	}
	return BGPNLRIIsActive_BGP_NLRI_ISA_NONE
}

func (m *BGPNLRIPrefixStatus) GetStale() bool {
	if m != nil {
		return m.Stale
	}
	return false
}

func (m *BGPNLRIPrefixStatus) GetFlapStartTime() uint32 {
	if m != nil {
		return m.FlapStartTime
	}
	return 0
}

func (m *BGPNLRIPrefixStatus) GetReasonNotBest() BGPRsnNotBest {
	if m != nil {
		return m.ReasonNotBest
	}
	return BGPRsnNotBest_BGP_REASON_NOT_CONSIDERED
}

func (m *BGPNLRIPrefixStatus) GetExtComm() [][]byte {
	if m != nil {
		return m.ExtComm
	}
	return nil
}

// BGP NLRI prefix key object
type BGPNLRIPrefixKey struct {
	// BGP address family
	Afi BGPAfi `protobuf:"varint,1,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,2,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// prefix in NLRI
	Prefix []byte `protobuf:"bytes,3,opt,name=Prefix,proto3" json:"Prefix,omitempty"`
	// prefix length
	PrefixLen uint32 `protobuf:"varint,4,opt,name=PrefixLen,proto3" json:"PrefixLen,omitempty"`
	// route source (learned from BGP peer or AFM)
	RouteSource NLRISrc `protobuf:"varint,5,opt,name=RouteSource,proto3,enum=pds.NLRISrc" json:"RouteSource,omitempty"`
	// route source index
	RouteSourceIndex uint32 `protobuf:"varint,6,opt,name=RouteSourceIndex,proto3" json:"RouteSourceIndex,omitempty"`
	// path ID
	PathID uint32 `protobuf:"varint,7,opt,name=PathID,proto3" json:"PathID,omitempty"`
}

func (m *BGPNLRIPrefixKey) Reset()                    { *m = BGPNLRIPrefixKey{} }
func (m *BGPNLRIPrefixKey) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixKey) ProtoMessage()               {}
func (*BGPNLRIPrefixKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{35} }

func (m *BGPNLRIPrefixKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPNLRIPrefixKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPNLRIPrefixKey) GetPrefix() []byte {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BGPNLRIPrefixKey) GetPrefixLen() uint32 {
	if m != nil {
		return m.PrefixLen
	}
	return 0
}

func (m *BGPNLRIPrefixKey) GetRouteSource() NLRISrc {
	if m != nil {
		return m.RouteSource
	}
	return NLRISrc_NLRI_NONE
}

func (m *BGPNLRIPrefixKey) GetRouteSourceIndex() uint32 {
	if m != nil {
		return m.RouteSourceIndex
	}
	return 0
}

func (m *BGPNLRIPrefixKey) GetPathID() uint32 {
	if m != nil {
		return m.PathID
	}
	return 0
}

// BGP NLRI prefix object
type BGPNLRIPrefix struct {
	Status *BGPNLRIPrefixStatus `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
}

func (m *BGPNLRIPrefix) Reset()                    { *m = BGPNLRIPrefix{} }
func (m *BGPNLRIPrefix) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefix) ProtoMessage()               {}
func (*BGPNLRIPrefix) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{36} }

func (m *BGPNLRIPrefix) GetStatus() *BGPNLRIPrefixStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP NLRI prefix get response
type BGPNLRIPrefixGetResponse struct {
	ApiStatus ApiStatus        `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPNLRIPrefix `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPNLRIPrefixGetResponse) Reset()                    { *m = BGPNLRIPrefixGetResponse{} }
func (m *BGPNLRIPrefixGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixGetResponse) ProtoMessage()               {}
func (*BGPNLRIPrefixGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{37} }

func (m *BGPNLRIPrefixGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPNLRIPrefixGetResponse) GetResponse() []*BGPNLRIPrefix {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP NLRI key handle
type BGPNLRIPrefixKeyHandle struct {
	Key *BGPNLRIPrefixKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
}

func (m *BGPNLRIPrefixKeyHandle) Reset()                    { *m = BGPNLRIPrefixKeyHandle{} }
func (m *BGPNLRIPrefixKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixKeyHandle) ProtoMessage()               {}
func (*BGPNLRIPrefixKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{38} }

func (m *BGPNLRIPrefixKeyHandle) GetKey() *BGPNLRIPrefixKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// BGP NLRI prefix get request
type BGPNLRIPrefixGetRequest struct {
	Request []*BGPNLRIPrefixKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPNLRIPrefixGetRequest) Reset()                    { *m = BGPNLRIPrefixGetRequest{} }
func (m *BGPNLRIPrefixGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPNLRIPrefixGetRequest) ProtoMessage()               {}
func (*BGPNLRIPrefixGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{39} }

func (m *BGPNLRIPrefixGetRequest) GetRequest() []*BGPNLRIPrefixKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP PrfxCntrs table
type BGPPrfxCntrsStatus struct {
	// Identifies a RIB Manager entity
	EntIndex uint32 `protobuf:"varint,1,opt,name=EntIndex,proto3" json:"EntIndex,omitempty"`
	// The peer index
	PeerIndex uint32 `protobuf:"varint,2,opt,name=PeerIndex,proto3" json:"PeerIndex,omitempty"`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,3,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,4,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
	// The number of prefixes received from a peer and are stored in the Adj-RIB-In for that peer.
	InPrfxes uint32 `protobuf:"varint,5,opt,name=InPrfxes,proto3" json:"InPrfxes,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and are eligible to become active in the Loc-Rib
	InPrfxesAccepted uint32 `protobuf:"varint,6,opt,name=InPrfxesAccepted,proto3" json:"InPrfxesAccepted,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and are NOT eligible to become active in the Loc-Rib
	InPrfxesRejected uint32 `protobuf:"varint,7,opt,name=InPrfxesRejected,proto3" json:"InPrfxesRejected,omitempty"`
	// The number of prefixes for a peer that are installed in that peer's Adj-RIB-Out.
	OutPrfxes uint32 `protobuf:"varint,8,opt,name=OutPrfxes,proto3" json:"OutPrfxes,omitempty"`
	// The number of advertised prefixes currently associated with the peer
	OutPrfxesAdvertised uint32 `protobuf:"varint,9,opt,name=OutPrfxesAdvertised,proto3" json:"OutPrfxesAdvertised,omitempty"`
	// User data for this BGP prefix counters entry
	UserData string `protobuf:"bytes,10,opt,name=UserData,proto3" json:"UserData,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and for which RIB Manager is tracking a route flap damping penalty.
	InPrfxesFlapped uint32 `protobuf:"varint,11,opt,name=InPrfxesFlapped,proto3" json:"InPrfxesFlapped,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and that are suppressed as a result of route flapping.
	InPrfxesFlapSuppressed uint32 `protobuf:"varint,12,opt,name=InPrfxesFlapSuppressed,proto3" json:"InPrfxesFlapSuppressed,omitempty"`
	// The number of prefixes for a peer that are not currently in the Adj-RIB-In, but which have an associated route flap damping penalty
	InPrfxesFlapHistory uint32 `protobuf:"varint,13,opt,name=InPrfxesFlapHistory,proto3" json:"InPrfxesFlapHistory,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and are marked as 'active' in the Loc-Rib.
	InPrfxesActive uint32 `protobuf:"varint,14,opt,name=InPrfxesActive,proto3" json:"InPrfxesActive,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because of local filter policy
	InPrfxesDeniedByPol uint32 `protobuf:"varint,15,opt,name=InPrfxesDeniedByPol,proto3" json:"InPrfxesDeniedByPol,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and included in the Loc-RIB
	NumLocRibRoutes uint32 `protobuf:"varint,16,opt,name=NumLocRibRoutes,proto3" json:"NumLocRibRoutes,omitempty"`
	// The number of prefixes for a peer that are installed in the Adj-RIB-In and included in the Loc-RIB as 'best' routes
	NumLocRibBestRoutes uint32 `protobuf:"varint,17,opt,name=NumLocRibBestRoutes,proto3" json:"NumLocRibBestRoutes,omitempty"`
	// The number of times a received Martian prefix has been denied and therefore not installed in the Adj-RIB-In
	InPrfxesDeniedMartian uint32 `protobuf:"varint,18,opt,name=InPrfxesDeniedMartian,proto3" json:"InPrfxesDeniedMartian,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, due to loops as determined by the AS Path
	InPrfxesDeniedAsLoop uint32 `protobuf:"varint,19,opt,name=InPrfxesDeniedAsLoop,proto3" json:"InPrfxesDeniedAsLoop,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because the next hop is invalid
	InPrfxesDeniedNextHop uint32 `protobuf:"varint,20,opt,name=InPrfxesDeniedNextHop,proto3" json:"InPrfxesDeniedNextHop,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because the AS Path length is too long
	InPrfxesDeniedAsLength uint32 `protobuf:"varint,21,opt,name=InPrfxesDeniedAsLength,proto3" json:"InPrfxesDeniedAsLength,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, due to well-known community checks
	InPrfxesDeniedCommunity uint32 `protobuf:"varint,22,opt,name=InPrfxesDeniedCommunity,proto3" json:"InPrfxesDeniedCommunity,omitempty"`
	// The number of times a received prefix has been denied, and therefore not installed in the Adj-RIB-In, because it is locally originated
	InPrfxesDeniedLocalOrig uint32 `protobuf:"varint,23,opt,name=InPrfxesDeniedLocalOrig,proto3" json:"InPrfxesDeniedLocalOrig,omitempty"`
	// The total number of prefixes learned from all sessions with this peer
	InTotalPrfxes uint32 `protobuf:"varint,24,opt,name=InTotalPrfxes,proto3" json:"InTotalPrfxes,omitempty"`
	// The total number of prefixes sent on all sessions with this peer
	OutTotalPrfxes uint32 `protobuf:"varint,25,opt,name=OutTotalPrfxes,proto3" json:"OutTotalPrfxes,omitempty"`
	// The BGP peer's FSM state
	PeerState BGPPeerState `protobuf:"varint,26,opt,name=PeerState,proto3,enum=pds.BGPPeerState" json:"PeerState,omitempty"`
	// This is the number of prefixes in the Loc-RIB that have have failed export policy checks and so have not been installed in the Adj-RIB-Out
	OutPrfxesDenied uint32 `protobuf:"varint,27,opt,name=OutPrfxesDenied,proto3" json:"OutPrfxesDenied,omitempty"`
	// The total number of routes for which an implicit withdraw has been sent to this peer
	OutPrfxesImpWdr uint32 `protobuf:"varint,28,opt,name=OutPrfxesImpWdr,proto3" json:"OutPrfxesImpWdr,omitempty"`
	// The total number of routes for which an explicit withdraw has been sent to this peer
	OutPrfxesExpWdr uint32 `protobuf:"varint,29,opt,name=OutPrfxesExpWdr,proto3" json:"OutPrfxesExpWdr,omitempty"`
	// The total number of routes that have been implicitly withdrawn by this peer
	InPrfxesImpWdr uint32 `protobuf:"varint,30,opt,name=InPrfxesImpWdr,proto3" json:"InPrfxesImpWdr,omitempty"`
	// The total number of routes that have been explicitly withdrawn by this peer
	InPrfxesExpWdr uint32 `protobuf:"varint,31,opt,name=InPrfxesExpWdr,proto3" json:"InPrfxesExpWdr,omitempty"`
	// The number of stored prefixes from the peer that have failed import policy checks and so have not been installed in the Adj-RIB-In
	CurPrfxesDeniedByPol uint32 `protobuf:"varint,32,opt,name=CurPrfxesDeniedByPol,proto3" json:"CurPrfxesDeniedByPol,omitempty"`
}

func (m *BGPPrfxCntrsStatus) Reset()                    { *m = BGPPrfxCntrsStatus{} }
func (m *BGPPrfxCntrsStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsStatus) ProtoMessage()               {}
func (*BGPPrfxCntrsStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{40} }

func (m *BGPPrfxCntrsStatus) GetEntIndex() uint32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetPeerIndex() uint32 {
	if m != nil {
		return m.PeerIndex
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPrfxCntrsStatus) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

func (m *BGPPrfxCntrsStatus) GetInPrfxes() uint32 {
	if m != nil {
		return m.InPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesAccepted() uint32 {
	if m != nil {
		return m.InPrfxesAccepted
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesRejected() uint32 {
	if m != nil {
		return m.InPrfxesRejected
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxes() uint32 {
	if m != nil {
		return m.OutPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesAdvertised() uint32 {
	if m != nil {
		return m.OutPrfxesAdvertised
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetUserData() string {
	if m != nil {
		return m.UserData
	}
	return ""
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesFlapped() uint32 {
	if m != nil {
		return m.InPrfxesFlapped
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesFlapSuppressed() uint32 {
	if m != nil {
		return m.InPrfxesFlapSuppressed
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesFlapHistory() uint32 {
	if m != nil {
		return m.InPrfxesFlapHistory
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesActive() uint32 {
	if m != nil {
		return m.InPrfxesActive
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedByPol() uint32 {
	if m != nil {
		return m.InPrfxesDeniedByPol
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetNumLocRibRoutes() uint32 {
	if m != nil {
		return m.NumLocRibRoutes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetNumLocRibBestRoutes() uint32 {
	if m != nil {
		return m.NumLocRibBestRoutes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedMartian() uint32 {
	if m != nil {
		return m.InPrfxesDeniedMartian
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedAsLoop() uint32 {
	if m != nil {
		return m.InPrfxesDeniedAsLoop
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedNextHop() uint32 {
	if m != nil {
		return m.InPrfxesDeniedNextHop
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedAsLength() uint32 {
	if m != nil {
		return m.InPrfxesDeniedAsLength
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedCommunity() uint32 {
	if m != nil {
		return m.InPrfxesDeniedCommunity
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesDeniedLocalOrig() uint32 {
	if m != nil {
		return m.InPrfxesDeniedLocalOrig
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInTotalPrfxes() uint32 {
	if m != nil {
		return m.InTotalPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutTotalPrfxes() uint32 {
	if m != nil {
		return m.OutTotalPrfxes
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetPeerState() BGPPeerState {
	if m != nil {
		return m.PeerState
	}
	return BGPPeerState_BGP_PEER_STATE_NONE
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesDenied() uint32 {
	if m != nil {
		return m.OutPrfxesDenied
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesImpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesImpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetOutPrfxesExpWdr() uint32 {
	if m != nil {
		return m.OutPrfxesExpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesImpWdr() uint32 {
	if m != nil {
		return m.InPrfxesImpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetInPrfxesExpWdr() uint32 {
	if m != nil {
		return m.InPrfxesExpWdr
	}
	return 0
}

func (m *BGPPrfxCntrsStatus) GetCurPrfxesDeniedByPol() uint32 {
	if m != nil {
		return m.CurPrfxesDeniedByPol
	}
	return 0
}

// BGP PrfxCntrs key object
type BGPPrfxCntrsKey struct {
	// Identifies a RIB Manager entity
	EntIndex uint32 `protobuf:"varint,1,opt,name=EntIndex,proto3" json:"EntIndex,omitempty"`
	// The peer index
	PeerIndex uint32 `protobuf:"varint,2,opt,name=PeerIndex,proto3" json:"PeerIndex,omitempty"`
	// BGP address family
	Afi BGPAfi `protobuf:"varint,3,opt,name=Afi,proto3,enum=pds.BGPAfi" json:"Afi,omitempty"`
	// BGP sub-address family
	Safi BGPSafi `protobuf:"varint,4,opt,name=Safi,proto3,enum=pds.BGPSafi" json:"Safi,omitempty"`
}

func (m *BGPPrfxCntrsKey) Reset()                    { *m = BGPPrfxCntrsKey{} }
func (m *BGPPrfxCntrsKey) String() string            { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsKey) ProtoMessage()               {}
func (*BGPPrfxCntrsKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{41} }

func (m *BGPPrfxCntrsKey) GetEntIndex() uint32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *BGPPrfxCntrsKey) GetPeerIndex() uint32 {
	if m != nil {
		return m.PeerIndex
	}
	return 0
}

func (m *BGPPrfxCntrsKey) GetAfi() BGPAfi {
	if m != nil {
		return m.Afi
	}
	return BGPAfi_BGP_AFI_NONE
}

func (m *BGPPrfxCntrsKey) GetSafi() BGPSafi {
	if m != nil {
		return m.Safi
	}
	return BGPSafi_BGP_SAFI_NONE
}

// BGP PrfxCntrs object
type BGPPrfxCntrs struct {
	Status *BGPPrfxCntrsStatus `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
}

func (m *BGPPrfxCntrs) Reset()                    { *m = BGPPrfxCntrs{} }
func (m *BGPPrfxCntrs) String() string            { return proto.CompactTextString(m) }
func (*BGPPrfxCntrs) ProtoMessage()               {}
func (*BGPPrfxCntrs) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{42} }

func (m *BGPPrfxCntrs) GetStatus() *BGPPrfxCntrsStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP PrfxCntrs get response
type BGPPrfxCntrsGetResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPPrfxCntrs `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPPrfxCntrsGetResponse) Reset()                    { *m = BGPPrfxCntrsGetResponse{} }
func (m *BGPPrfxCntrsGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsGetResponse) ProtoMessage()               {}
func (*BGPPrfxCntrsGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{43} }

func (m *BGPPrfxCntrsGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPPrfxCntrsGetResponse) GetResponse() []*BGPPrfxCntrs {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP PrfxCntrs key handle
type BGPPrfxCntrsKeyHandle struct {
	Key *BGPPrfxCntrsKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
}

func (m *BGPPrfxCntrsKeyHandle) Reset()                    { *m = BGPPrfxCntrsKeyHandle{} }
func (m *BGPPrfxCntrsKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsKeyHandle) ProtoMessage()               {}
func (*BGPPrfxCntrsKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{44} }

func (m *BGPPrfxCntrsKeyHandle) GetKey() *BGPPrfxCntrsKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// BGP PrfxCntrs get request
type BGPPrfxCntrsGetRequest struct {
	Request []*BGPPrfxCntrsKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPPrfxCntrsGetRequest) Reset()                    { *m = BGPPrfxCntrsGetRequest{} }
func (m *BGPPrfxCntrsGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPPrfxCntrsGetRequest) ProtoMessage()               {}
func (*BGPPrfxCntrsGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{45} }

func (m *BGPPrfxCntrsGetRequest) GetRequest() []*BGPPrfxCntrsKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

// BGP routemap table
type BGPRouteMapStatus struct {
	// Identifies a RIB Manager entity
	EntIndex uint32 `protobuf:"varint,1,opt,name=EntIndex,proto3" json:"EntIndex,omitempty"`
	// The index of this bgpRouteMapEntry
	Index uint32 `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	// The index of this bgpRouteMapEntry.  This is a number used to reference more than one filter per route map index.
	Number uint32 `protobuf:"varint,3,opt,name=Number,proto3" json:"Number,omitempty"`
	// The number of times this row has been matched on
	Hitcnt int32 `protobuf:"varint,4,opt,name=Hitcnt,proto3" json:"Hitcnt,omitempty"`
	// The type of association (if any) this route map has with the ORF protocol.
	OrfAssoc BGPOrfAssoc `protobuf:"varint,5,opt,name=OrfAssoc,proto3,enum=pds.BGPOrfAssoc" json:"OrfAssoc,omitempty"`
}

func (m *BGPRouteMapStatus) Reset()                    { *m = BGPRouteMapStatus{} }
func (m *BGPRouteMapStatus) String() string            { return proto.CompactTextString(m) }
func (*BGPRouteMapStatus) ProtoMessage()               {}
func (*BGPRouteMapStatus) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{46} }

func (m *BGPRouteMapStatus) GetEntIndex() uint32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *BGPRouteMapStatus) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *BGPRouteMapStatus) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *BGPRouteMapStatus) GetHitcnt() int32 {
	if m != nil {
		return m.Hitcnt
	}
	return 0
}

func (m *BGPRouteMapStatus) GetOrfAssoc() BGPOrfAssoc {
	if m != nil {
		return m.OrfAssoc
	}
	return BGPOrfAssoc_BGP_ORF_ASSOC_NONE
}

// BGP routemap key object
type BGPRouteMapKey struct {
	// Identifies a RIB Manager entity
	EntIndex uint32 `protobuf:"varint,1,opt,name=EntIndex,proto3" json:"EntIndex,omitempty"`
	// The index of this bgpRouteMapEntry
	Index uint32 `protobuf:"varint,2,opt,name=Index,proto3" json:"Index,omitempty"`
	// The index of this bgpRouteMapEntry.  This is a number used to reference more than one filter per route map index.
	Number uint32 `protobuf:"varint,3,opt,name=Number,proto3" json:"Number,omitempty"`
}

func (m *BGPRouteMapKey) Reset()                    { *m = BGPRouteMapKey{} }
func (m *BGPRouteMapKey) String() string            { return proto.CompactTextString(m) }
func (*BGPRouteMapKey) ProtoMessage()               {}
func (*BGPRouteMapKey) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{47} }

func (m *BGPRouteMapKey) GetEntIndex() uint32 {
	if m != nil {
		return m.EntIndex
	}
	return 0
}

func (m *BGPRouteMapKey) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *BGPRouteMapKey) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

// BGP routemap object
type BGPRouteMap struct {
	Status *BGPRouteMapStatus `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
}

func (m *BGPRouteMap) Reset()                    { *m = BGPRouteMap{} }
func (m *BGPRouteMap) String() string            { return proto.CompactTextString(m) }
func (*BGPRouteMap) ProtoMessage()               {}
func (*BGPRouteMap) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{48} }

func (m *BGPRouteMap) GetStatus() *BGPRouteMapStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// BGP routemap get response
type BGPRouteMapGetResponse struct {
	ApiStatus ApiStatus      `protobuf:"varint,1,opt,name=ApiStatus,proto3,enum=types.ApiStatus" json:"ApiStatus,omitempty"`
	Response  []*BGPRouteMap `protobuf:"bytes,2,rep,name=Response" json:"Response,omitempty"`
}

func (m *BGPRouteMapGetResponse) Reset()                    { *m = BGPRouteMapGetResponse{} }
func (m *BGPRouteMapGetResponse) String() string            { return proto.CompactTextString(m) }
func (*BGPRouteMapGetResponse) ProtoMessage()               {}
func (*BGPRouteMapGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{49} }

func (m *BGPRouteMapGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *BGPRouteMapGetResponse) GetResponse() []*BGPRouteMap {
	if m != nil {
		return m.Response
	}
	return nil
}

// BGP routemap key handle
type BGPRouteMapKeyHandle struct {
	Key *BGPRouteMapKey `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
}

func (m *BGPRouteMapKeyHandle) Reset()                    { *m = BGPRouteMapKeyHandle{} }
func (m *BGPRouteMapKeyHandle) String() string            { return proto.CompactTextString(m) }
func (*BGPRouteMapKeyHandle) ProtoMessage()               {}
func (*BGPRouteMapKeyHandle) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{50} }

func (m *BGPRouteMapKeyHandle) GetKey() *BGPRouteMapKey {
	if m != nil {
		return m.Key
	}
	return nil
}

// BGP routemap get request
type BGPRouteMapGetRequest struct {
	Request []*BGPRouteMapKeyHandle `protobuf:"bytes,1,rep,name=Request" json:"Request,omitempty"`
}

func (m *BGPRouteMapGetRequest) Reset()                    { *m = BGPRouteMapGetRequest{} }
func (m *BGPRouteMapGetRequest) String() string            { return proto.CompactTextString(m) }
func (*BGPRouteMapGetRequest) ProtoMessage()               {}
func (*BGPRouteMapGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorBgp, []int{51} }

func (m *BGPRouteMapGetRequest) GetRequest() []*BGPRouteMapKeyHandle {
	if m != nil {
		return m.Request
	}
	return nil
}

func init() {
	proto.RegisterType((*BGPSpec)(nil), "pds.BGPSpec")
	proto.RegisterType((*BGPStatus)(nil), "pds.BGPStatus")
	proto.RegisterType((*BGP)(nil), "pds.BGP")
	proto.RegisterType((*BGPRequest)(nil), "pds.BGPRequest")
	proto.RegisterType((*BGPResponse)(nil), "pds.BGPResponse")
	proto.RegisterType((*BGPKeyHandle)(nil), "pds.BGPKeyHandle")
	proto.RegisterType((*BGPDeleteRequest)(nil), "pds.BGPDeleteRequest")
	proto.RegisterType((*BGPDeleteResponse)(nil), "pds.BGPDeleteResponse")
	proto.RegisterType((*BGPGetRequest)(nil), "pds.BGPGetRequest")
	proto.RegisterType((*BGPGetResponse)(nil), "pds.BGPGetResponse")
	proto.RegisterType((*BGPPeerSpec)(nil), "pds.BGPPeerSpec")
	proto.RegisterType((*BGPPeerStatus)(nil), "pds.BGPPeerStatus")
	proto.RegisterType((*BGPPeer)(nil), "pds.BGPPeer")
	proto.RegisterType((*BGPPeerResponse)(nil), "pds.BGPPeerResponse")
	proto.RegisterType((*BGPPeerRequest)(nil), "pds.BGPPeerRequest")
	proto.RegisterType((*BGPPeerGetResponse)(nil), "pds.BGPPeerGetResponse")
	proto.RegisterType((*BGPPeerKey)(nil), "pds.BGPPeerKey")
	proto.RegisterType((*BGPPeerKeyHandle)(nil), "pds.BGPPeerKeyHandle")
	proto.RegisterType((*BGPPeerDeleteRequest)(nil), "pds.BGPPeerDeleteRequest")
	proto.RegisterType((*BGPPeerDeleteResponse)(nil), "pds.BGPPeerDeleteResponse")
	proto.RegisterType((*BGPPeerGetRequest)(nil), "pds.BGPPeerGetRequest")
	proto.RegisterType((*BGPPeerAfSpec)(nil), "pds.BGPPeerAfSpec")
	proto.RegisterType((*BGPPeerAfStatus)(nil), "pds.BGPPeerAfStatus")
	proto.RegisterType((*BGPPeerAf)(nil), "pds.BGPPeerAf")
	proto.RegisterType((*BGPPeerAfResponse)(nil), "pds.BGPPeerAfResponse")
	proto.RegisterType((*BGPPeerAfRequest)(nil), "pds.BGPPeerAfRequest")
	proto.RegisterType((*BGPPeerAfKey)(nil), "pds.BGPPeerAfKey")
	proto.RegisterType((*BGPPeerAfKeyHandle)(nil), "pds.BGPPeerAfKeyHandle")
	proto.RegisterType((*BGPPeerAfDeleteRequest)(nil), "pds.BGPPeerAfDeleteRequest")
	proto.RegisterType((*BGPPeerAfDeleteResponse)(nil), "pds.BGPPeerAfDeleteResponse")
	proto.RegisterType((*BGPPeerAfGetRequest)(nil), "pds.BGPPeerAfGetRequest")
	proto.RegisterType((*BGPPeerAfGetResponse)(nil), "pds.BGPPeerAfGetResponse")
	proto.RegisterType((*BGPClearRouteRequest)(nil), "pds.BGPClearRouteRequest")
	proto.RegisterType((*BGPClearRouteResponse)(nil), "pds.BGPClearRouteResponse")
	proto.RegisterType((*BGPNLRIPrefixStatus)(nil), "pds.BGPNLRIPrefixStatus")
	proto.RegisterType((*BGPNLRIPrefixKey)(nil), "pds.BGPNLRIPrefixKey")
	proto.RegisterType((*BGPNLRIPrefix)(nil), "pds.BGPNLRIPrefix")
	proto.RegisterType((*BGPNLRIPrefixGetResponse)(nil), "pds.BGPNLRIPrefixGetResponse")
	proto.RegisterType((*BGPNLRIPrefixKeyHandle)(nil), "pds.BGPNLRIPrefixKeyHandle")
	proto.RegisterType((*BGPNLRIPrefixGetRequest)(nil), "pds.BGPNLRIPrefixGetRequest")
	proto.RegisterType((*BGPPrfxCntrsStatus)(nil), "pds.BGPPrfxCntrsStatus")
	proto.RegisterType((*BGPPrfxCntrsKey)(nil), "pds.BGPPrfxCntrsKey")
	proto.RegisterType((*BGPPrfxCntrs)(nil), "pds.BGPPrfxCntrs")
	proto.RegisterType((*BGPPrfxCntrsGetResponse)(nil), "pds.BGPPrfxCntrsGetResponse")
	proto.RegisterType((*BGPPrfxCntrsKeyHandle)(nil), "pds.BGPPrfxCntrsKeyHandle")
	proto.RegisterType((*BGPPrfxCntrsGetRequest)(nil), "pds.BGPPrfxCntrsGetRequest")
	proto.RegisterType((*BGPRouteMapStatus)(nil), "pds.BGPRouteMapStatus")
	proto.RegisterType((*BGPRouteMapKey)(nil), "pds.BGPRouteMapKey")
	proto.RegisterType((*BGPRouteMap)(nil), "pds.BGPRouteMap")
	proto.RegisterType((*BGPRouteMapGetResponse)(nil), "pds.BGPRouteMapGetResponse")
	proto.RegisterType((*BGPRouteMapKeyHandle)(nil), "pds.BGPRouteMapKeyHandle")
	proto.RegisterType((*BGPRouteMapGetRequest)(nil), "pds.BGPRouteMapGetRequest")
	proto.RegisterEnum("pds.BGPAfi", BGPAfi_name, BGPAfi_value)
	proto.RegisterEnum("pds.BGPSafi", BGPSafi_name, BGPSafi_value)
	proto.RegisterEnum("pds.BGPPeerRRClient", BGPPeerRRClient_name, BGPPeerRRClient_value)
	proto.RegisterEnum("pds.BGPPeerState", BGPPeerState_name, BGPPeerState_value)
	proto.RegisterEnum("pds.BGPASSize", BGPASSize_name, BGPASSize_value)
	proto.RegisterEnum("pds.BGPAddrType", BGPAddrType_name, BGPAddrType_value)
	proto.RegisterEnum("pds.BGPOperStatus", BGPOperStatus_name, BGPOperStatus_value)
	proto.RegisterEnum("pds.BgpAddPathCapNegCap", BgpAddPathCapNegCap_name, BgpAddPathCapNegCap_value)
	proto.RegisterEnum("pds.BGPClearRouteOptions", BGPClearRouteOptions_name, BGPClearRouteOptions_value)
	proto.RegisterEnum("pds.NLRISrc", NLRISrc_name, NLRISrc_value)
	proto.RegisterEnum("pds.BGPNLRIIsActive", BGPNLRIIsActive_name, BGPNLRIIsActive_value)
	proto.RegisterEnum("pds.BGPRsnNotBest", BGPRsnNotBest_name, BGPRsnNotBest_value)
	proto.RegisterEnum("pds.BGPOrfAssoc", BGPOrfAssoc_name, BGPOrfAssoc_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BGPSvc service

type BGPSvcClient interface {
	BGPCreate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error)
	BGPUpdate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error)
	BGPDelete(ctx context.Context, in *BGPDeleteRequest, opts ...grpc.CallOption) (*BGPDeleteResponse, error)
	BGPGet(ctx context.Context, in *BGPGetRequest, opts ...grpc.CallOption) (*BGPGetResponse, error)
	BGPPeerCreate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error)
	BGPPeerUpdate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error)
	BGPPeerDelete(ctx context.Context, in *BGPPeerDeleteRequest, opts ...grpc.CallOption) (*BGPPeerDeleteResponse, error)
	BGPPeerGet(ctx context.Context, in *BGPPeerGetRequest, opts ...grpc.CallOption) (*BGPPeerGetResponse, error)
	BGPPeerAfCreate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error)
	BGPPeerAfUpdate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error)
	BGPPeerAfDelete(ctx context.Context, in *BGPPeerAfDeleteRequest, opts ...grpc.CallOption) (*BGPPeerAfDeleteResponse, error)
	BGPPeerAfGet(ctx context.Context, in *BGPPeerAfGetRequest, opts ...grpc.CallOption) (*BGPPeerAfGetResponse, error)
	BGPClearRoute(ctx context.Context, in *BGPClearRouteRequest, opts ...grpc.CallOption) (*BGPClearRouteResponse, error)
	BGPNLRIPrefixGet(ctx context.Context, in *BGPNLRIPrefixGetRequest, opts ...grpc.CallOption) (*BGPNLRIPrefixGetResponse, error)
	BGPPrfxCntrsGet(ctx context.Context, in *BGPPrfxCntrsGetRequest, opts ...grpc.CallOption) (*BGPPrfxCntrsGetResponse, error)
	BGPRouteMapGet(ctx context.Context, in *BGPRouteMapGetRequest, opts ...grpc.CallOption) (*BGPRouteMapGetResponse, error)
}

type bGPSvcClient struct {
	cc *grpc.ClientConn
}

func NewBGPSvcClient(cc *grpc.ClientConn) BGPSvcClient {
	return &bGPSvcClient{cc}
}

func (c *bGPSvcClient) BGPCreate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error) {
	out := new(BGPResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPUpdate(ctx context.Context, in *BGPRequest, opts ...grpc.CallOption) (*BGPResponse, error) {
	out := new(BGPResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPDelete(ctx context.Context, in *BGPDeleteRequest, opts ...grpc.CallOption) (*BGPDeleteResponse, error) {
	out := new(BGPDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPGet(ctx context.Context, in *BGPGetRequest, opts ...grpc.CallOption) (*BGPGetResponse, error) {
	out := new(BGPGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerCreate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error) {
	out := new(BGPPeerResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerUpdate(ctx context.Context, in *BGPPeerRequest, opts ...grpc.CallOption) (*BGPPeerResponse, error) {
	out := new(BGPPeerResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerDelete(ctx context.Context, in *BGPPeerDeleteRequest, opts ...grpc.CallOption) (*BGPPeerDeleteResponse, error) {
	out := new(BGPPeerDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerGet(ctx context.Context, in *BGPPeerGetRequest, opts ...grpc.CallOption) (*BGPPeerGetResponse, error) {
	out := new(BGPPeerGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfCreate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error) {
	out := new(BGPPeerAfResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfUpdate(ctx context.Context, in *BGPPeerAfRequest, opts ...grpc.CallOption) (*BGPPeerAfResponse, error) {
	out := new(BGPPeerAfResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfDelete(ctx context.Context, in *BGPPeerAfDeleteRequest, opts ...grpc.CallOption) (*BGPPeerAfDeleteResponse, error) {
	out := new(BGPPeerAfDeleteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPeerAfGet(ctx context.Context, in *BGPPeerAfGetRequest, opts ...grpc.CallOption) (*BGPPeerAfGetResponse, error) {
	out := new(BGPPeerAfGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPeerAfGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPClearRoute(ctx context.Context, in *BGPClearRouteRequest, opts ...grpc.CallOption) (*BGPClearRouteResponse, error) {
	out := new(BGPClearRouteResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPClearRoute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPNLRIPrefixGet(ctx context.Context, in *BGPNLRIPrefixGetRequest, opts ...grpc.CallOption) (*BGPNLRIPrefixGetResponse, error) {
	out := new(BGPNLRIPrefixGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPNLRIPrefixGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPPrfxCntrsGet(ctx context.Context, in *BGPPrfxCntrsGetRequest, opts ...grpc.CallOption) (*BGPPrfxCntrsGetResponse, error) {
	out := new(BGPPrfxCntrsGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPPrfxCntrsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bGPSvcClient) BGPRouteMapGet(ctx context.Context, in *BGPRouteMapGetRequest, opts ...grpc.CallOption) (*BGPRouteMapGetResponse, error) {
	out := new(BGPRouteMapGetResponse)
	err := grpc.Invoke(ctx, "/pds.BGPSvc/BGPRouteMapGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BGPSvc service

type BGPSvcServer interface {
	BGPCreate(context.Context, *BGPRequest) (*BGPResponse, error)
	BGPUpdate(context.Context, *BGPRequest) (*BGPResponse, error)
	BGPDelete(context.Context, *BGPDeleteRequest) (*BGPDeleteResponse, error)
	BGPGet(context.Context, *BGPGetRequest) (*BGPGetResponse, error)
	BGPPeerCreate(context.Context, *BGPPeerRequest) (*BGPPeerResponse, error)
	BGPPeerUpdate(context.Context, *BGPPeerRequest) (*BGPPeerResponse, error)
	BGPPeerDelete(context.Context, *BGPPeerDeleteRequest) (*BGPPeerDeleteResponse, error)
	BGPPeerGet(context.Context, *BGPPeerGetRequest) (*BGPPeerGetResponse, error)
	BGPPeerAfCreate(context.Context, *BGPPeerAfRequest) (*BGPPeerAfResponse, error)
	BGPPeerAfUpdate(context.Context, *BGPPeerAfRequest) (*BGPPeerAfResponse, error)
	BGPPeerAfDelete(context.Context, *BGPPeerAfDeleteRequest) (*BGPPeerAfDeleteResponse, error)
	BGPPeerAfGet(context.Context, *BGPPeerAfGetRequest) (*BGPPeerAfGetResponse, error)
	BGPClearRoute(context.Context, *BGPClearRouteRequest) (*BGPClearRouteResponse, error)
	BGPNLRIPrefixGet(context.Context, *BGPNLRIPrefixGetRequest) (*BGPNLRIPrefixGetResponse, error)
	BGPPrfxCntrsGet(context.Context, *BGPPrfxCntrsGetRequest) (*BGPPrfxCntrsGetResponse, error)
	BGPRouteMapGet(context.Context, *BGPRouteMapGetRequest) (*BGPRouteMapGetResponse, error)
}

func RegisterBGPSvcServer(s *grpc.Server, srv BGPSvcServer) {
	s.RegisterService(&_BGPSvc_serviceDesc, srv)
}

func _BGPSvc_BGPCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPCreate(ctx, req.(*BGPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPUpdate(ctx, req.(*BGPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPDelete(ctx, req.(*BGPDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPGet(ctx, req.(*BGPGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerCreate(ctx, req.(*BGPPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerUpdate(ctx, req.(*BGPPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerDelete(ctx, req.(*BGPPeerDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerGet(ctx, req.(*BGPPeerGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfCreate(ctx, req.(*BGPPeerAfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfUpdate(ctx, req.(*BGPPeerAfRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfDelete(ctx, req.(*BGPPeerAfDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPeerAfGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPeerAfGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPeerAfGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPeerAfGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPeerAfGet(ctx, req.(*BGPPeerAfGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPClearRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPClearRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPClearRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPClearRoute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPClearRoute(ctx, req.(*BGPClearRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPNLRIPrefixGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPNLRIPrefixGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPNLRIPrefixGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPNLRIPrefixGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPNLRIPrefixGet(ctx, req.(*BGPNLRIPrefixGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPPrfxCntrsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPPrfxCntrsGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPPrfxCntrsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPPrfxCntrsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPPrfxCntrsGet(ctx, req.(*BGPPrfxCntrsGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BGPSvc_BGPRouteMapGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BGPRouteMapGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BGPSvcServer).BGPRouteMapGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pds.BGPSvc/BGPRouteMapGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BGPSvcServer).BGPRouteMapGet(ctx, req.(*BGPRouteMapGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BGPSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pds.BGPSvc",
	HandlerType: (*BGPSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BGPCreate",
			Handler:    _BGPSvc_BGPCreate_Handler,
		},
		{
			MethodName: "BGPUpdate",
			Handler:    _BGPSvc_BGPUpdate_Handler,
		},
		{
			MethodName: "BGPDelete",
			Handler:    _BGPSvc_BGPDelete_Handler,
		},
		{
			MethodName: "BGPGet",
			Handler:    _BGPSvc_BGPGet_Handler,
		},
		{
			MethodName: "BGPPeerCreate",
			Handler:    _BGPSvc_BGPPeerCreate_Handler,
		},
		{
			MethodName: "BGPPeerUpdate",
			Handler:    _BGPSvc_BGPPeerUpdate_Handler,
		},
		{
			MethodName: "BGPPeerDelete",
			Handler:    _BGPSvc_BGPPeerDelete_Handler,
		},
		{
			MethodName: "BGPPeerGet",
			Handler:    _BGPSvc_BGPPeerGet_Handler,
		},
		{
			MethodName: "BGPPeerAfCreate",
			Handler:    _BGPSvc_BGPPeerAfCreate_Handler,
		},
		{
			MethodName: "BGPPeerAfUpdate",
			Handler:    _BGPSvc_BGPPeerAfUpdate_Handler,
		},
		{
			MethodName: "BGPPeerAfDelete",
			Handler:    _BGPSvc_BGPPeerAfDelete_Handler,
		},
		{
			MethodName: "BGPPeerAfGet",
			Handler:    _BGPSvc_BGPPeerAfGet_Handler,
		},
		{
			MethodName: "BGPClearRoute",
			Handler:    _BGPSvc_BGPClearRoute_Handler,
		},
		{
			MethodName: "BGPNLRIPrefixGet",
			Handler:    _BGPSvc_BGPNLRIPrefixGet_Handler,
		},
		{
			MethodName: "BGPPrfxCntrsGet",
			Handler:    _BGPSvc_BGPPrfxCntrsGet_Handler,
		},
		{
			MethodName: "BGPRouteMapGet",
			Handler:    _BGPSvc_BGPRouteMapGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "bgp.proto",
}

func (m *BGPSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.LocalASN != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalASN))
	}
	if m.RouterId != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.RouterId))
		i += 4
	}
	if m.ClusterId != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(m.ClusterId))
		i += 4
	}
	return i, nil
}

func (m *BGPStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status))
	}
	if m.NumAdjRibOutRoutes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.NumAdjRibOutRoutes))
	}
	if m.PeakNumAdjRibOutRoutes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeakNumAdjRibOutRoutes))
	}
	if m.RemDelayTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RemDelayTime))
	}
	if m.TableVer != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.TableVer))
	}
	return i, nil
}

func (m *BGP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGP) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Spec.Size()))
		n1, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *BGPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Request.Size()))
		n3, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *BGPResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *BGPDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Request.Size()))
		n4, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *BGPDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Request != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Request.Size()))
		n5, err := m.Request.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *BGPGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Response.Size()))
		n6, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *BGPPeerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.State))
	}
	if m.LocalAddr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n7, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n8, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.RemoteASN != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RemoteASN))
	}
	if m.SendComm {
		dAtA[i] = 0x30
		i++
		if m.SendComm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendExtComm {
		dAtA[i] = 0x38
		i++
		if m.SendExtComm {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RRClient != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RRClient))
	}
	if m.ConnectRetry != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.KeepAlive))
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.TTL != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.TTL))
	}
	return i, nil
}

func (m *BGPPeerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status))
	}
	if m.PrevStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PrevStatus))
	}
	if len(m.LastErrorRcvd) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.LastErrorRcvd)))
		i += copy(dAtA[i:], m.LastErrorRcvd)
	}
	if len(m.LastErrorSent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.LastErrorSent)))
		i += copy(dAtA[i:], m.LastErrorSent)
	}
	if m.LocalAddr != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n9, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.HoldTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.KeepAlive))
	}
	if m.CapsSent != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsSent))
	}
	if m.CapsRcvd != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsRcvd))
	}
	if m.CapsNeg != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.CapsNeg))
	}
	if m.SelLocalAddrType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.SelLocalAddrType))
	}
	if m.InNotifications != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InNotifications))
	}
	if m.OutNotifications != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutNotifications))
	}
	if m.InUpdates != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InUpdates))
	}
	if m.OutUpdates != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutUpdates))
	}
	if m.InKeepalives != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InKeepalives))
	}
	if m.OutKeepalives != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutKeepalives))
	}
	if m.InRefreshes != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InRefreshes))
	}
	if m.OutRefreshes != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutRefreshes))
	}
	if m.InTotalMessages != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InTotalMessages))
	}
	if m.OutTotalMessages != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutTotalMessages))
	}
	if m.FsmEstTransitions != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.FsmEstTransitions))
	}
	if m.ConnectRetryCount != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ConnectRetryCount))
	}
	if m.Peergr != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Peergr))
	}
	if m.StalePathTime != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.StalePathTime))
	}
	if m.OrfEntryCount != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OrfEntryCount))
	}
	if m.RcvdMsgElpsTime != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RcvdMsgElpsTime))
	}
	if m.RouteRefrSent != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteRefrSent))
	}
	if m.RouteRefrRcvd != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteRefrRcvd))
	}
	if m.InPrfxes != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxes))
	}
	if m.OutPrfxes != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxes))
	}
	if m.OutPrfxesAdvertised != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesAdvertised))
	}
	if m.ConnectRetryInt != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ConnectRetryInt))
	}
	if m.OutUpdateElpsTime != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutUpdateElpsTime))
	}
	if m.OutPrfxesDenied != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesDenied))
	}
	if m.OutPrfxesImpWdr != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesImpWdr))
	}
	if m.OutPrfxesExpWdr != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesExpWdr))
	}
	if m.InPrfxesImpWdr != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesImpWdr))
	}
	if m.InPrfxesExpWdr != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesExpWdr))
	}
	if m.ReceivedHoldTime != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ReceivedHoldTime))
	}
	if m.FsmEstablishedTime != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.FsmEstablishedTime))
	}
	if m.InUpdatesElpsTime != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InUpdatesElpsTime))
	}
	if m.InOpens != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InOpens))
	}
	if m.OutOpens != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutOpens))
	}
	return i, nil
}

func (m *BGPPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Spec.Size()))
		n10, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n11, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *BGPPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n12, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n13, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *BGPPeerKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn14, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *BGPPeerKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *BGPPeerKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n15, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *BGPPeerDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.LocalAddr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n16, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n17, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Afi != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	if m.NexthopSelf {
		dAtA[i] = 0x30
		i++
		if m.NexthopSelf {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DefaultOrig {
		dAtA[i] = 0x38
		i++
		if m.DefaultOrig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LocalPort != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalPort))
	}
	if m.RemotePort != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RemotePort))
	}
	if m.LocalAddrScopeId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddrScopeId))
	}
	return i, nil
}

func (m *BGPPeerAfStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdateGroup != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.UpdateGroup))
	}
	if m.LocalAddrScopeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddrScopeId))
	}
	if m.RtRefresh {
		dAtA[i] = 0x18
		i++
		if m.RtRefresh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AddPathCapNeg != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.AddPathCapNeg))
	}
	if m.ReflectorClient != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ReflectorClient))
	}
	return i, nil
}

func (m *BGPPeerAf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAf) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Spec != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Spec.Size()))
		n18, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Status != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n19, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *BGPPeerAfResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerAfRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalAddr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.LocalAddr.Size()))
		n20, err := m.LocalAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n21, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Afi != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	return i, nil
}

func (m *BGPPeerAfKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IdOrKey != nil {
		nn22, err := m.IdOrKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	return i, nil
}

func (m *BGPPeerAfKeyHandle_Id) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Id != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}
func (m *BGPPeerAfKeyHandle_Key) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Key != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n23, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *BGPPeerAfDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPPeerAfGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPeerAfGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPeerAfGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPClearRouteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPClearRouteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Option != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Option))
	}
	if m.PeerOrPeeraf != nil {
		nn24, err := m.PeerOrPeeraf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn24
	}
	return i, nil
}

func (m *BGPClearRouteRequest_Peer) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Peer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Peer.Size()))
		n25, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *BGPClearRouteRequest_PeerAf) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PeerAf != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAf.Size()))
		n26, err := m.PeerAf.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *BGPClearRouteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPClearRouteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *BGPNLRIPrefixStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Afi != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PathID))
	}
	if m.BestRoute {
		dAtA[i] = 0x40
		i++
		if m.BestRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ASPathStr) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.ASPathStr)))
		i += copy(dAtA[i:], m.ASPathStr)
	}
	if len(m.PathOrigId) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.PathOrigId)))
		i += copy(dAtA[i:], m.PathOrigId)
	}
	if len(m.NextHopAddr) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.NextHopAddr)))
		i += copy(dAtA[i:], m.NextHopAddr)
	}
	if m.ASSize != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ASSize))
	}
	if m.EcmpRoute {
		dAtA[i] = 0x68
		i++
		if m.EcmpRoute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PeerAddr != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerAddr.Size()))
		n27, err := m.PeerAddr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.FlapStatsFlapcnt != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.FlapStatsFlapcnt))
	}
	if m.FlapStatsSupprsd {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.FlapStatsSupprsd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsActive != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.IsActive))
	}
	if m.Stale {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.Stale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FlapStartTime != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.FlapStartTime))
	}
	if m.ReasonNotBest != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ReasonNotBest))
	}
	if len(m.ExtComm) > 0 {
		for _, b := range m.ExtComm {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintBgp(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *BGPNLRIPrefixKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Afi != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	if len(m.Prefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.Prefix)))
		i += copy(dAtA[i:], m.Prefix)
	}
	if m.PrefixLen != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PathID))
	}
	return i, nil
}

func (m *BGPNLRIPrefix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefix) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n28, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *BGPNLRIPrefixGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPNLRIPrefixKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n29, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *BGPNLRIPrefixGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPNLRIPrefixGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPrfxCntrsStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.EntIndex))
	}
	if m.PeerIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerIndex))
	}
	if m.Afi != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	if m.InPrfxes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxes))
	}
	if m.InPrfxesAccepted != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesAccepted))
	}
	if m.InPrfxesRejected != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesRejected))
	}
	if m.OutPrfxes != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxes))
	}
	if m.OutPrfxesAdvertised != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesAdvertised))
	}
	if len(m.UserData) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBgp(dAtA, i, uint64(len(m.UserData)))
		i += copy(dAtA[i:], m.UserData)
	}
	if m.InPrfxesFlapped != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesFlapped))
	}
	if m.InPrfxesFlapSuppressed != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesFlapSuppressed))
	}
	if m.InPrfxesFlapHistory != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesFlapHistory))
	}
	if m.InPrfxesActive != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesActive))
	}
	if m.InPrfxesDeniedByPol != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedByPol))
	}
	if m.NumLocRibRoutes != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibRoutes))
	}
	if m.NumLocRibBestRoutes != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.NumLocRibBestRoutes))
	}
	if m.InPrfxesDeniedMartian != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedMartian))
	}
	if m.InPrfxesDeniedAsLoop != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedAsLoop))
	}
	if m.InPrfxesDeniedNextHop != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedNextHop))
	}
	if m.InPrfxesDeniedAsLength != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedAsLength))
	}
	if m.InPrfxesDeniedCommunity != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedCommunity))
	}
	if m.InPrfxesDeniedLocalOrig != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesDeniedLocalOrig))
	}
	if m.InTotalPrfxes != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InTotalPrfxes))
	}
	if m.OutTotalPrfxes != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutTotalPrfxes))
	}
	if m.PeerState != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerState))
	}
	if m.OutPrfxesDenied != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesDenied))
	}
	if m.OutPrfxesImpWdr != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesImpWdr))
	}
	if m.OutPrfxesExpWdr != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OutPrfxesExpWdr))
	}
	if m.InPrfxesImpWdr != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesImpWdr))
	}
	if m.InPrfxesExpWdr != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.InPrfxesExpWdr))
	}
	if m.CurPrfxesDeniedByPol != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.CurPrfxesDeniedByPol))
	}
	return i, nil
}

func (m *BGPPrfxCntrsKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.EntIndex))
	}
	if m.PeerIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.PeerIndex))
	}
	if m.Afi != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Afi))
	}
	if m.Safi != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Safi))
	}
	return i, nil
}

func (m *BGPPrfxCntrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n30, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *BGPPrfxCntrsGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPPrfxCntrsKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n31, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *BGPPrfxCntrsGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPPrfxCntrsGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPRouteMapStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRouteMapStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.EntIndex))
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Index))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Number))
	}
	if m.Hitcnt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Hitcnt))
	}
	if m.OrfAssoc != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.OrfAssoc))
	}
	return i, nil
}

func (m *BGPRouteMapKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRouteMapKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.EntIndex))
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Index))
	}
	if m.Number != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Number))
	}
	return i, nil
}

func (m *BGPRouteMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRouteMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Status.Size()))
		n32, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *BGPRouteMapGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRouteMapGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BGPRouteMapKeyHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRouteMapKeyHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBgp(dAtA, i, uint64(m.Key.Size()))
		n33, err := m.Key.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *BGPRouteMapGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BGPRouteMapGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBgp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintBgp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BGPSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalASN != 0 {
		n += 1 + sovBgp(uint64(m.LocalASN))
	}
	if m.RouterId != 0 {
		n += 5
	}
	if m.ClusterId != 0 {
		n += 5
	}
	return n
}

func (m *BGPStatus) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovBgp(uint64(m.Status))
	}
	if m.NumAdjRibOutRoutes != 0 {
		n += 1 + sovBgp(uint64(m.NumAdjRibOutRoutes))
	}
	if m.PeakNumAdjRibOutRoutes != 0 {
		n += 1 + sovBgp(uint64(m.PeakNumAdjRibOutRoutes))
	}
	if m.RemDelayTime != 0 {
		n += 1 + sovBgp(uint64(m.RemDelayTime))
	}
	if m.TableVer != 0 {
		n += 1 + sovBgp(uint64(m.TableVer))
	}
	return n
}

func (m *BGP) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPRequest) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPKeyHandle) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovBgp(uint64(m.State))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.RemoteASN != 0 {
		n += 1 + sovBgp(uint64(m.RemoteASN))
	}
	if m.SendComm {
		n += 2
	}
	if m.SendExtComm {
		n += 2
	}
	if m.RRClient != 0 {
		n += 1 + sovBgp(uint64(m.RRClient))
	}
	if m.ConnectRetry != 0 {
		n += 1 + sovBgp(uint64(m.ConnectRetry))
	}
	if m.HoldTime != 0 {
		n += 1 + sovBgp(uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovBgp(uint64(m.KeepAlive))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovBgp(uint64(m.TTL))
	}
	return n
}

func (m *BGPPeerStatus) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovBgp(uint64(m.Status))
	}
	if m.PrevStatus != 0 {
		n += 1 + sovBgp(uint64(m.PrevStatus))
	}
	l = len(m.LastErrorRcvd)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.LastErrorSent)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.HoldTime != 0 {
		n += 1 + sovBgp(uint64(m.HoldTime))
	}
	if m.KeepAlive != 0 {
		n += 1 + sovBgp(uint64(m.KeepAlive))
	}
	if m.CapsSent != 0 {
		n += 1 + sovBgp(uint64(m.CapsSent))
	}
	if m.CapsRcvd != 0 {
		n += 1 + sovBgp(uint64(m.CapsRcvd))
	}
	if m.CapsNeg != 0 {
		n += 1 + sovBgp(uint64(m.CapsNeg))
	}
	if m.SelLocalAddrType != 0 {
		n += 1 + sovBgp(uint64(m.SelLocalAddrType))
	}
	if m.InNotifications != 0 {
		n += 1 + sovBgp(uint64(m.InNotifications))
	}
	if m.OutNotifications != 0 {
		n += 1 + sovBgp(uint64(m.OutNotifications))
	}
	if m.InUpdates != 0 {
		n += 1 + sovBgp(uint64(m.InUpdates))
	}
	if m.OutUpdates != 0 {
		n += 1 + sovBgp(uint64(m.OutUpdates))
	}
	if m.InKeepalives != 0 {
		n += 2 + sovBgp(uint64(m.InKeepalives))
	}
	if m.OutKeepalives != 0 {
		n += 2 + sovBgp(uint64(m.OutKeepalives))
	}
	if m.InRefreshes != 0 {
		n += 2 + sovBgp(uint64(m.InRefreshes))
	}
	if m.OutRefreshes != 0 {
		n += 2 + sovBgp(uint64(m.OutRefreshes))
	}
	if m.InTotalMessages != 0 {
		n += 2 + sovBgp(uint64(m.InTotalMessages))
	}
	if m.OutTotalMessages != 0 {
		n += 2 + sovBgp(uint64(m.OutTotalMessages))
	}
	if m.FsmEstTransitions != 0 {
		n += 2 + sovBgp(uint64(m.FsmEstTransitions))
	}
	if m.ConnectRetryCount != 0 {
		n += 2 + sovBgp(uint64(m.ConnectRetryCount))
	}
	if m.Peergr != 0 {
		n += 2 + sovBgp(uint64(m.Peergr))
	}
	if m.StalePathTime != 0 {
		n += 2 + sovBgp(uint64(m.StalePathTime))
	}
	if m.OrfEntryCount != 0 {
		n += 2 + sovBgp(uint64(m.OrfEntryCount))
	}
	if m.RcvdMsgElpsTime != 0 {
		n += 2 + sovBgp(uint64(m.RcvdMsgElpsTime))
	}
	if m.RouteRefrSent != 0 {
		n += 2 + sovBgp(uint64(m.RouteRefrSent))
	}
	if m.RouteRefrRcvd != 0 {
		n += 2 + sovBgp(uint64(m.RouteRefrRcvd))
	}
	if m.InPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxes))
	}
	if m.OutPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxes))
	}
	if m.OutPrfxesAdvertised != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesAdvertised))
	}
	if m.ConnectRetryInt != 0 {
		n += 2 + sovBgp(uint64(m.ConnectRetryInt))
	}
	if m.OutUpdateElpsTime != 0 {
		n += 2 + sovBgp(uint64(m.OutUpdateElpsTime))
	}
	if m.OutPrfxesDenied != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesDenied))
	}
	if m.OutPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesImpWdr))
	}
	if m.OutPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesExpWdr))
	}
	if m.InPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesImpWdr))
	}
	if m.InPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesExpWdr))
	}
	if m.ReceivedHoldTime != 0 {
		n += 2 + sovBgp(uint64(m.ReceivedHoldTime))
	}
	if m.FsmEstablishedTime != 0 {
		n += 2 + sovBgp(uint64(m.FsmEstablishedTime))
	}
	if m.InUpdatesElpsTime != 0 {
		n += 2 + sovBgp(uint64(m.InUpdatesElpsTime))
	}
	if m.InOpens != 0 {
		n += 2 + sovBgp(uint64(m.InOpens))
	}
	if m.OutOpens != 0 {
		n += 2 + sovBgp(uint64(m.OutOpens))
	}
	return n
}

func (m *BGPPeer) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerKey) Size() (n int) {
	var l int
	_ = l
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *BGPPeerKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.NexthopSelf {
		n += 2
	}
	if m.DefaultOrig {
		n += 2
	}
	if m.LocalPort != 0 {
		n += 1 + sovBgp(uint64(m.LocalPort))
	}
	if m.RemotePort != 0 {
		n += 1 + sovBgp(uint64(m.RemotePort))
	}
	if m.LocalAddrScopeId != 0 {
		n += 1 + sovBgp(uint64(m.LocalAddrScopeId))
	}
	return n
}

func (m *BGPPeerAfStatus) Size() (n int) {
	var l int
	_ = l
	if m.UpdateGroup != 0 {
		n += 1 + sovBgp(uint64(m.UpdateGroup))
	}
	if m.LocalAddrScopeId != 0 {
		n += 1 + sovBgp(uint64(m.LocalAddrScopeId))
	}
	if m.RtRefresh {
		n += 2
	}
	if m.AddPathCapNeg != 0 {
		n += 1 + sovBgp(uint64(m.AddPathCapNeg))
	}
	if m.ReflectorClient != 0 {
		n += 1 + sovBgp(uint64(m.ReflectorClient))
	}
	return n
}

func (m *BGPPeerAf) Size() (n int) {
	var l int
	_ = l
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPeerAfResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerAfRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfKey) Size() (n int) {
	var l int
	_ = l
	if m.LocalAddr != nil {
		l = m.LocalAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	return n
}

func (m *BGPPeerAfKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.IdOrKey != nil {
		n += m.IdOrKey.Size()
	}
	return n
}

func (m *BGPPeerAfKeyHandle_Id) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerAfKeyHandle_Key) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPPeerAfDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPPeerAfGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPeerAfGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPClearRouteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Option != 0 {
		n += 1 + sovBgp(uint64(m.Option))
	}
	if m.PeerOrPeeraf != nil {
		n += m.PeerOrPeeraf.Size()
	}
	return n
}

func (m *BGPClearRouteRequest_Peer) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPClearRouteRequest_PeerAf) Size() (n int) {
	var l int
	_ = l
	if m.PeerAf != nil {
		l = m.PeerAf.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}
func (m *BGPClearRouteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	return n
}

func (m *BGPNLRIPrefixStatus) Size() (n int) {
	var l int
	_ = l
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovBgp(uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		n += 1 + sovBgp(uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		n += 1 + sovBgp(uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		n += 1 + sovBgp(uint64(m.PathID))
	}
	if m.BestRoute {
		n += 2
	}
	l = len(m.ASPathStr)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.PathOrigId)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	l = len(m.NextHopAddr)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.ASSize != 0 {
		n += 1 + sovBgp(uint64(m.ASSize))
	}
	if m.EcmpRoute {
		n += 2
	}
	if m.PeerAddr != nil {
		l = m.PeerAddr.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.FlapStatsFlapcnt != 0 {
		n += 1 + sovBgp(uint64(m.FlapStatsFlapcnt))
	}
	if m.FlapStatsSupprsd {
		n += 3
	}
	if m.IsActive != 0 {
		n += 2 + sovBgp(uint64(m.IsActive))
	}
	if m.Stale {
		n += 3
	}
	if m.FlapStartTime != 0 {
		n += 2 + sovBgp(uint64(m.FlapStartTime))
	}
	if m.ReasonNotBest != 0 {
		n += 2 + sovBgp(uint64(m.ReasonNotBest))
	}
	if len(m.ExtComm) > 0 {
		for _, b := range m.ExtComm {
			l = len(b)
			n += 2 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPNLRIPrefixKey) Size() (n int) {
	var l int
	_ = l
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	l = len(m.Prefix)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.PrefixLen != 0 {
		n += 1 + sovBgp(uint64(m.PrefixLen))
	}
	if m.RouteSource != 0 {
		n += 1 + sovBgp(uint64(m.RouteSource))
	}
	if m.RouteSourceIndex != 0 {
		n += 1 + sovBgp(uint64(m.RouteSourceIndex))
	}
	if m.PathID != 0 {
		n += 1 + sovBgp(uint64(m.PathID))
	}
	return n
}

func (m *BGPNLRIPrefix) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPNLRIPrefixGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPNLRIPrefixKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPNLRIPrefixGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPrfxCntrsStatus) Size() (n int) {
	var l int
	_ = l
	if m.EntIndex != 0 {
		n += 1 + sovBgp(uint64(m.EntIndex))
	}
	if m.PeerIndex != 0 {
		n += 1 + sovBgp(uint64(m.PeerIndex))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	if m.InPrfxes != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxes))
	}
	if m.InPrfxesAccepted != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesAccepted))
	}
	if m.InPrfxesRejected != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesRejected))
	}
	if m.OutPrfxes != 0 {
		n += 1 + sovBgp(uint64(m.OutPrfxes))
	}
	if m.OutPrfxesAdvertised != 0 {
		n += 1 + sovBgp(uint64(m.OutPrfxesAdvertised))
	}
	l = len(m.UserData)
	if l > 0 {
		n += 1 + l + sovBgp(uint64(l))
	}
	if m.InPrfxesFlapped != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesFlapped))
	}
	if m.InPrfxesFlapSuppressed != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesFlapSuppressed))
	}
	if m.InPrfxesFlapHistory != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesFlapHistory))
	}
	if m.InPrfxesActive != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesActive))
	}
	if m.InPrfxesDeniedByPol != 0 {
		n += 1 + sovBgp(uint64(m.InPrfxesDeniedByPol))
	}
	if m.NumLocRibRoutes != 0 {
		n += 2 + sovBgp(uint64(m.NumLocRibRoutes))
	}
	if m.NumLocRibBestRoutes != 0 {
		n += 2 + sovBgp(uint64(m.NumLocRibBestRoutes))
	}
	if m.InPrfxesDeniedMartian != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedMartian))
	}
	if m.InPrfxesDeniedAsLoop != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedAsLoop))
	}
	if m.InPrfxesDeniedNextHop != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedNextHop))
	}
	if m.InPrfxesDeniedAsLength != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedAsLength))
	}
	if m.InPrfxesDeniedCommunity != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedCommunity))
	}
	if m.InPrfxesDeniedLocalOrig != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesDeniedLocalOrig))
	}
	if m.InTotalPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.InTotalPrfxes))
	}
	if m.OutTotalPrfxes != 0 {
		n += 2 + sovBgp(uint64(m.OutTotalPrfxes))
	}
	if m.PeerState != 0 {
		n += 2 + sovBgp(uint64(m.PeerState))
	}
	if m.OutPrfxesDenied != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesDenied))
	}
	if m.OutPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesImpWdr))
	}
	if m.OutPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.OutPrfxesExpWdr))
	}
	if m.InPrfxesImpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesImpWdr))
	}
	if m.InPrfxesExpWdr != 0 {
		n += 2 + sovBgp(uint64(m.InPrfxesExpWdr))
	}
	if m.CurPrfxesDeniedByPol != 0 {
		n += 2 + sovBgp(uint64(m.CurPrfxesDeniedByPol))
	}
	return n
}

func (m *BGPPrfxCntrsKey) Size() (n int) {
	var l int
	_ = l
	if m.EntIndex != 0 {
		n += 1 + sovBgp(uint64(m.EntIndex))
	}
	if m.PeerIndex != 0 {
		n += 1 + sovBgp(uint64(m.PeerIndex))
	}
	if m.Afi != 0 {
		n += 1 + sovBgp(uint64(m.Afi))
	}
	if m.Safi != 0 {
		n += 1 + sovBgp(uint64(m.Safi))
	}
	return n
}

func (m *BGPPrfxCntrs) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPrfxCntrsGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPPrfxCntrsKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPPrfxCntrsGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPRouteMapStatus) Size() (n int) {
	var l int
	_ = l
	if m.EntIndex != 0 {
		n += 1 + sovBgp(uint64(m.EntIndex))
	}
	if m.Index != 0 {
		n += 1 + sovBgp(uint64(m.Index))
	}
	if m.Number != 0 {
		n += 1 + sovBgp(uint64(m.Number))
	}
	if m.Hitcnt != 0 {
		n += 1 + sovBgp(uint64(m.Hitcnt))
	}
	if m.OrfAssoc != 0 {
		n += 1 + sovBgp(uint64(m.OrfAssoc))
	}
	return n
}

func (m *BGPRouteMapKey) Size() (n int) {
	var l int
	_ = l
	if m.EntIndex != 0 {
		n += 1 + sovBgp(uint64(m.EntIndex))
	}
	if m.Index != 0 {
		n += 1 + sovBgp(uint64(m.Index))
	}
	if m.Number != 0 {
		n += 1 + sovBgp(uint64(m.Number))
	}
	return n
}

func (m *BGPRouteMap) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPRouteMapGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovBgp(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func (m *BGPRouteMapKeyHandle) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovBgp(uint64(l))
	}
	return n
}

func (m *BGPRouteMapGetRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovBgp(uint64(l))
		}
	}
	return n
}

func sovBgp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBgp(x uint64) (n int) {
	return sovBgp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BGPSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalASN", wireType)
			}
			m.LocalASN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalASN |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouterId", wireType)
			}
			m.RouterId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.RouterId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (BGPOperStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumAdjRibOutRoutes", wireType)
			}
			m.NumAdjRibOutRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumAdjRibOutRoutes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeakNumAdjRibOutRoutes", wireType)
			}
			m.PeakNumAdjRibOutRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeakNumAdjRibOutRoutes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemDelayTime", wireType)
			}
			m.RemDelayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemDelayTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableVer", wireType)
			}
			m.TableVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableVer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGP) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPSpec{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPKeyHandle{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &BGPKeyHandle{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &BGP{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (AdminState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteASN", wireType)
			}
			m.RemoteASN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteASN |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendComm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendComm = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendExtComm", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendExtComm = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRClient", wireType)
			}
			m.RRClient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RRClient |= (BGPPeerRRClient(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetry", wireType)
			}
			m.ConnectRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetry |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (BGPPeerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevStatus", wireType)
			}
			m.PrevStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevStatus |= (BGPPeerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorRcvd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorRcvd = append(m.LastErrorRcvd[:0], dAtA[iNdEx:postIndex]...)
			if m.LastErrorRcvd == nil {
				m.LastErrorRcvd = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorSent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorSent = append(m.LastErrorSent[:0], dAtA[iNdEx:postIndex]...)
			if m.LastErrorSent == nil {
				m.LastErrorSent = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldTime", wireType)
			}
			m.HoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HoldTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepAlive", wireType)
			}
			m.KeepAlive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepAlive |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsSent", wireType)
			}
			m.CapsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsSent |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsRcvd", wireType)
			}
			m.CapsRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsRcvd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsNeg", wireType)
			}
			m.CapsNeg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CapsNeg |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelLocalAddrType", wireType)
			}
			m.SelLocalAddrType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelLocalAddrType |= (BGPAddrType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InNotifications", wireType)
			}
			m.InNotifications = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InNotifications |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutNotifications", wireType)
			}
			m.OutNotifications = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutNotifications |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUpdates", wireType)
			}
			m.InUpdates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUpdates |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutUpdates", wireType)
			}
			m.OutUpdates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutUpdates |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InKeepalives", wireType)
			}
			m.InKeepalives = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InKeepalives |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutKeepalives", wireType)
			}
			m.OutKeepalives = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutKeepalives |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InRefreshes", wireType)
			}
			m.InRefreshes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InRefreshes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutRefreshes", wireType)
			}
			m.OutRefreshes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutRefreshes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTotalMessages", wireType)
			}
			m.InTotalMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InTotalMessages |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTotalMessages", wireType)
			}
			m.OutTotalMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutTotalMessages |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsmEstTransitions", wireType)
			}
			m.FsmEstTransitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FsmEstTransitions |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetryCount", wireType)
			}
			m.ConnectRetryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetryCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peergr", wireType)
			}
			m.Peergr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Peergr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StalePathTime", wireType)
			}
			m.StalePathTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StalePathTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrfEntryCount", wireType)
			}
			m.OrfEntryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrfEntryCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcvdMsgElpsTime", wireType)
			}
			m.RcvdMsgElpsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RcvdMsgElpsTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRefrSent", wireType)
			}
			m.RouteRefrSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteRefrSent |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteRefrRcvd", wireType)
			}
			m.RouteRefrRcvd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteRefrRcvd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxes", wireType)
			}
			m.InPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxes", wireType)
			}
			m.OutPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesAdvertised", wireType)
			}
			m.OutPrfxesAdvertised = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesAdvertised |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectRetryInt", wireType)
			}
			m.ConnectRetryInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectRetryInt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutUpdateElpsTime", wireType)
			}
			m.OutUpdateElpsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutUpdateElpsTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesDenied", wireType)
			}
			m.OutPrfxesDenied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesDenied |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesImpWdr", wireType)
			}
			m.OutPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesImpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesExpWdr", wireType)
			}
			m.OutPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesExpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesImpWdr", wireType)
			}
			m.InPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesImpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesExpWdr", wireType)
			}
			m.InPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesExpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivedHoldTime", wireType)
			}
			m.ReceivedHoldTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivedHoldTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsmEstablishedTime", wireType)
			}
			m.FsmEstablishedTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FsmEstablishedTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InUpdatesElpsTime", wireType)
			}
			m.InUpdatesElpsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InUpdatesElpsTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InOpens", wireType)
			}
			m.InOpens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InOpens |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutOpens", wireType)
			}
			m.OutOpens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutOpens |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPPeerSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPeerStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPeer{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &BGPPeerKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &BGPPeerKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopSelf", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NexthopSelf = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultOrig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultOrig = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPort", wireType)
			}
			m.LocalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemotePort", wireType)
			}
			m.RemotePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemotePort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddrScopeId", wireType)
			}
			m.LocalAddrScopeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAddrScopeId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateGroup", wireType)
			}
			m.UpdateGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateGroup |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddrScopeId", wireType)
			}
			m.LocalAddrScopeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAddrScopeId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtRefresh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RtRefresh = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddPathCapNeg", wireType)
			}
			m.AddPathCapNeg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddPathCapNeg |= (BgpAddPathCapNegCap(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReflectorClient", wireType)
			}
			m.ReflectorClient = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReflectorClient |= (BGPPeerRRClient(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &BGPPeerAfSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPeerAfStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalAddr == nil {
				m.LocalAddr = &IPAddress{}
			}
			if err := m.LocalAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.IdOrKey = &BGPPeerAfKeyHandle_Id{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerAfKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IdOrKey = &BGPPeerAfKeyHandle_Key{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPeerAfKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPeerAfGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPeerAfGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPeerAfGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPeerAf{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPClearRouteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPClearRouteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPClearRouteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= (BGPClearRouteOptions(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerOrPeeraf = &BGPClearRouteRequest_Peer{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BGPPeerAfKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PeerOrPeeraf = &BGPClearRouteRequest_PeerAf{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPClearRouteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPClearRouteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPClearRouteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSource", wireType)
			}
			m.RouteSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSource |= (NLRISrc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSourceIndex", wireType)
			}
			m.RouteSourceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSourceIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BestRoute = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASPathStr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ASPathStr = append(m.ASPathStr[:0], dAtA[iNdEx:postIndex]...)
			if m.ASPathStr == nil {
				m.ASPathStr = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathOrigId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathOrigId = append(m.PathOrigId[:0], dAtA[iNdEx:postIndex]...)
			if m.PathOrigId == nil {
				m.PathOrigId = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHopAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextHopAddr = append(m.NextHopAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.NextHopAddr == nil {
				m.NextHopAddr = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ASSize", wireType)
			}
			m.ASSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ASSize |= (BGPASSize(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcmpRoute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EcmpRoute = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeerAddr == nil {
				m.PeerAddr = &IPAddress{}
			}
			if err := m.PeerAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlapStatsFlapcnt", wireType)
			}
			m.FlapStatsFlapcnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlapStatsFlapcnt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlapStatsSupprsd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlapStatsSupprsd = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			m.IsActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsActive |= (BGPNLRIIsActive(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stale = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlapStartTime", wireType)
			}
			m.FlapStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlapStartTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonNotBest", wireType)
			}
			m.ReasonNotBest = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReasonNotBest |= (BGPRsnNotBest(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtComm", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtComm = append(m.ExtComm, make([]byte, postIndex-iNdEx))
			copy(m.ExtComm[len(m.ExtComm)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefix = append(m.Prefix[:0], dAtA[iNdEx:postIndex]...)
			if m.Prefix == nil {
				m.Prefix = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixLen", wireType)
			}
			m.PrefixLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefixLen |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSource", wireType)
			}
			m.RouteSource = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSource |= (NLRISrc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteSourceIndex", wireType)
			}
			m.RouteSourceIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RouteSourceIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathID", wireType)
			}
			m.PathID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PathID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPNLRIPrefixStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPNLRIPrefix{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &BGPNLRIPrefixKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPNLRIPrefixGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPNLRIPrefixGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPNLRIPrefixKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIndex", wireType)
			}
			m.PeerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxes", wireType)
			}
			m.InPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesAccepted", wireType)
			}
			m.InPrfxesAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesAccepted |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesRejected", wireType)
			}
			m.InPrfxesRejected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesRejected |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxes", wireType)
			}
			m.OutPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesAdvertised", wireType)
			}
			m.OutPrfxesAdvertised = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesAdvertised |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesFlapped", wireType)
			}
			m.InPrfxesFlapped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesFlapped |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesFlapSuppressed", wireType)
			}
			m.InPrfxesFlapSuppressed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesFlapSuppressed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesFlapHistory", wireType)
			}
			m.InPrfxesFlapHistory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesFlapHistory |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesActive", wireType)
			}
			m.InPrfxesActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesActive |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedByPol", wireType)
			}
			m.InPrfxesDeniedByPol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedByPol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibRoutes", wireType)
			}
			m.NumLocRibRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibRoutes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumLocRibBestRoutes", wireType)
			}
			m.NumLocRibBestRoutes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumLocRibBestRoutes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedMartian", wireType)
			}
			m.InPrfxesDeniedMartian = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedMartian |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedAsLoop", wireType)
			}
			m.InPrfxesDeniedAsLoop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedAsLoop |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedNextHop", wireType)
			}
			m.InPrfxesDeniedNextHop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedNextHop |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedAsLength", wireType)
			}
			m.InPrfxesDeniedAsLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedAsLength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedCommunity", wireType)
			}
			m.InPrfxesDeniedCommunity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedCommunity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesDeniedLocalOrig", wireType)
			}
			m.InPrfxesDeniedLocalOrig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesDeniedLocalOrig |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InTotalPrfxes", wireType)
			}
			m.InTotalPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InTotalPrfxes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutTotalPrfxes", wireType)
			}
			m.OutTotalPrfxes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutTotalPrfxes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerState", wireType)
			}
			m.PeerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerState |= (BGPPeerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesDenied", wireType)
			}
			m.OutPrfxesDenied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesDenied |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesImpWdr", wireType)
			}
			m.OutPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesImpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPrfxesExpWdr", wireType)
			}
			m.OutPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPrfxesExpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesImpWdr", wireType)
			}
			m.InPrfxesImpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesImpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPrfxesExpWdr", wireType)
			}
			m.InPrfxesExpWdr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InPrfxesExpWdr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurPrfxesDeniedByPol", wireType)
			}
			m.CurPrfxesDeniedByPol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurPrfxesDeniedByPol |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerIndex", wireType)
			}
			m.PeerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Afi", wireType)
			}
			m.Afi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Afi |= (BGPAfi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Safi", wireType)
			}
			m.Safi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Safi |= (BGPSafi(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPPrfxCntrsStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPPrfxCntrs{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &BGPPrfxCntrsKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPPrfxCntrsGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPPrfxCntrsGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPPrfxCntrsKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRouteMapStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRouteMapStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRouteMapStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hitcnt", wireType)
			}
			m.Hitcnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hitcnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrfAssoc", wireType)
			}
			m.OrfAssoc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrfAssoc |= (BGPOrfAssoc(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRouteMapKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRouteMapKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRouteMapKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntIndex", wireType)
			}
			m.EntIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRouteMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRouteMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRouteMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &BGPRouteMapStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRouteMapGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRouteMapGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRouteMapGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &BGPRouteMap{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRouteMapKeyHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRouteMapKeyHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRouteMapKeyHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = &BGPRouteMapKey{}
			}
			if err := m.Key.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BGPRouteMapGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BGPRouteMapGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BGPRouteMapGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBgp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &BGPRouteMapKeyHandle{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBgp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBgp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBgp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBgp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBgp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBgp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBgp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBgp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBgp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBgp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("bgp.proto", fileDescriptorBgp) }

var fileDescriptorBgp = []byte{
	// 4001 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5b, 0x4d, 0x70, 0xdb, 0x48,
	0x76, 0x36, 0x49, 0xfd, 0x50, 0x2d, 0x89, 0x86, 0xda, 0xb2, 0x4c, 0xcb, 0x7f, 0x0a, 0x77, 0xc6,
	0xe3, 0xe5, 0x38, 0x1a, 0x5b, 0xe3, 0xb8, 0x9c, 0xcd, 0xec, 0x78, 0x41, 0x12, 0x22, 0x11, 0x51,
	0x20, 0xd3, 0x80, 0x34, 0xde, 0x39, 0x84, 0x05, 0x93, 0x4d, 0x99, 0xb3, 0x24, 0x81, 0x00, 0xa0,
	0x63, 0xcd, 0x31, 0x55, 0xc9, 0x25, 0x9b, 0x7b, 0xee, 0xa9, 0xca, 0x6d, 0x8f, 0x39, 0xa4, 0x52,
	0xa9, 0x5c, 0x53, 0x39, 0xe5, 0x90, 0xf3, 0x24, 0x35, 0xc7, 0x3d, 0xe6, 0x9e, 0xaa, 0x54, 0xff,
	0xa2, 0xf1, 0xa3, 0x91, 0x47, 0x4e, 0x2a, 0x87, 0x5c, 0x6c, 0xe0, 0x7d, 0xaf, 0x5f, 0xbf, 0x7e,
	0xfd, 0xfa, 0xbd, 0xd7, 0x0f, 0x14, 0x58, 0x7b, 0x7d, 0xe6, 0xef, 0xfb, 0x81, 0x17, 0x79, 0xb0,
	0xe4, 0x8f, 0xc2, 0x5d, 0x70, 0xe6, 0x9d, 0x79, 0x8c, 0xb0, 0x7b, 0x7d, 0x86, 0x23, 0xf7, 0x33,
	0xf2, 0x0f, 0x27, 0xac, 0x47, 0xe7, 0x3e, 0x0e, 0xd9, 0x4b, 0xed, 0xaf, 0x0a, 0x60, 0xb5, 0xd1,
	0xee, 0xdb, 0x3e, 0x1e, 0xc2, 0xc7, 0xa0, 0x68, 0x8e, 0xaa, 0x85, 0xbd, 0xc2, 0xa3, 0x8d, 0xc6,
	0xdd, 0xff, 0xfc, 0xee, 0x41, 0x95, 0x0c, 0xfa, 0xd9, 0xcc, 0x9d, 0x8f, 0xdc, 0xc8, 0x0b, 0xce,
	0x1f, 0x4f, 0x66, 0xb3, 0x45, 0xe4, 0xbe, 0x9e, 0x62, 0x54, 0x34, 0x47, 0x70, 0x17, 0x94, 0xbb,
	0xde, 0xd0, 0x9d, 0xea, 0xb6, 0x55, 0x2d, 0xee, 0x15, 0x1e, 0x6d, 0x22, 0xf9, 0x4e, 0x30, 0xe4,
	0x2d, 0x22, 0x1c, 0x98, 0xa3, 0x6a, 0x69, 0xaf, 0xf0, 0x68, 0x15, 0xc9, 0x77, 0x78, 0x17, 0xac,
	0x35, 0xa7, 0x8b, 0x90, 0x81, 0x4b, 0x14, 0x8c, 0x09, 0xb5, 0x7f, 0x2f, 0x80, 0x35, 0xa2, 0x4f,
	0xe4, 0x46, 0x8b, 0x10, 0xd6, 0xc1, 0x0a, 0x7b, 0xa2, 0x5a, 0x55, 0x0e, 0xe0, 0xbe, 0x3f, 0x0a,
	0xf7, 0x1b, 0xed, 0x7e, 0xcf, 0xc7, 0x01, 0x43, 0x10, 0xe7, 0x80, 0xfb, 0x00, 0x5a, 0x8b, 0x99,
	0x3e, 0xfa, 0x06, 0x4d, 0x5e, 0xf7, 0x16, 0x11, 0x9d, 0x2f, 0xe4, 0x9a, 0xe5, 0x20, 0xf0, 0x39,
	0xd8, 0xe9, 0x63, 0xf7, 0x57, 0x39, 0x63, 0x4a, 0x74, 0xcc, 0x05, 0x28, 0xac, 0x81, 0x0d, 0x84,
	0x67, 0x2d, 0x3c, 0x75, 0xcf, 0x9d, 0xc9, 0x0c, 0xd3, 0x25, 0x6c, 0xa2, 0x04, 0x8d, 0xac, 0xdf,
	0x21, 0x86, 0x3a, 0xc5, 0x41, 0x75, 0x99, 0xd9, 0x46, 0xbc, 0xd7, 0xce, 0x41, 0xa9, 0xd1, 0xee,
	0xc3, 0x67, 0x60, 0x89, 0x18, 0x9d, 0x2e, 0x6c, 0xfd, 0x60, 0x43, 0x2c, 0x8c, 0xd0, 0x1a, 0xf0,
	0xb7, 0xdf, 0x3d, 0xa8, 0x84, 0x3e, 0x1e, 0x3e, 0xf6, 0x66, 0x93, 0x08, 0xcf, 0xfc, 0xe8, 0x1c,
	0x51, 0x6e, 0xf8, 0x85, 0x34, 0x48, 0x91, 0x8e, 0xab, 0xc8, 0x71, 0x94, 0xda, 0xd8, 0xfe, 0xed,
	0x77, 0x0f, 0xb4, 0x90, 0x3e, 0x2b, 0x63, 0xf9, 0x98, 0xda, 0x33, 0x00, 0x1a, 0xed, 0x3e, 0xc2,
	0x7f, 0xb2, 0xc0, 0x61, 0x04, 0x1f, 0x82, 0x55, 0xfe, 0x98, 0xa7, 0x04, 0x12, 0x60, 0xed, 0xe7,
	0x60, 0x9d, 0x8e, 0x0a, 0x7d, 0x6f, 0x1e, 0x62, 0xb8, 0x0f, 0xd6, 0x74, 0x7f, 0x92, 0xd8, 0x16,
	0x6d, 0x9f, 0xb9, 0x94, 0xa4, 0xa3, 0x98, 0xa5, 0x76, 0x1f, 0x6c, 0x34, 0xda, 0xfd, 0x23, 0x7c,
	0xde, 0x71, 0xe7, 0xa3, 0x29, 0x86, 0x95, 0xd8, 0xcb, 0x88, 0x1f, 0xd5, 0x5e, 0x02, 0xad, 0xd1,
	0xee, 0xb7, 0xf0, 0x14, 0x47, 0x58, 0xa8, 0xf6, 0x69, 0x5a, 0xb5, 0x2d, 0xa1, 0x9a, 0x94, 0x13,
	0xeb, 0xd7, 0x04, 0x5b, 0x8a, 0x80, 0x2b, 0x6a, 0xf9, 0x05, 0xd8, 0x6c, 0xb4, 0xfb, 0x6d, 0x1c,
	0x5d, 0x49, 0x85, 0x31, 0xa8, 0x88, 0xd1, 0x57, 0x9b, 0x1f, 0x7e, 0x04, 0xca, 0x62, 0x2c, 0xdf,
	0xda, 0xb2, 0x98, 0x0f, 0x49, 0xa4, 0xf6, 0xd7, 0x4b, 0x74, 0x2f, 0xfa, 0x18, 0x07, 0x57, 0x38,
	0xb1, 0x9f, 0x80, 0x65, 0x32, 0x1b, 0x9b, 0xa0, 0x72, 0xb0, 0x25, 0xf4, 0x19, 0xcd, 0x26, 0x73,
	0x0a, 0x20, 0x86, 0xc3, 0x2e, 0x58, 0x63, 0x47, 0x79, 0x34, 0x0a, 0xe8, 0x69, 0x58, 0x97, 0xca,
	0x9b, 0x7d, 0x42, 0xc4, 0x61, 0x78, 0xc9, 0x7c, 0xb1, 0x00, 0xf8, 0x87, 0xa0, 0x4c, 0x14, 0xa6,
	0xc2, 0x96, 0xae, 0x24, 0x4c, 0x8e, 0x27, 0xc1, 0x03, 0xe1, 0x99, 0x17, 0x61, 0x12, 0x75, 0xd8,
	0xc9, 0x8a, 0x09, 0xe4, 0xd8, 0xd9, 0x78, 0x3e, 0x6a, 0x7a, 0xb3, 0x59, 0x75, 0x65, 0xaf, 0xf0,
	0xa8, 0x8c, 0xe4, 0x3b, 0xdc, 0x03, 0xeb, 0xe4, 0xd9, 0x78, 0x17, 0x51, 0x78, 0x95, 0xc2, 0x2a,
	0x09, 0x3e, 0x01, 0x65, 0x84, 0x9a, 0xd3, 0x09, 0x9e, 0x47, 0xd5, 0x32, 0xb5, 0xd0, 0xb6, 0xd8,
	0x02, 0x32, 0xbf, 0xc0, 0x90, 0xe4, 0x22, 0xa1, 0xa0, 0xe9, 0xcd, 0xe7, 0x78, 0x18, 0x21, 0x1c,
	0x05, 0xe7, 0xd5, 0x35, 0x16, 0x0a, 0x54, 0x1a, 0xd1, 0xa9, 0xe3, 0x4d, 0x47, 0x34, 0x54, 0x00,
	0x16, 0x0a, 0xc4, 0x3b, 0x59, 0xcd, 0x11, 0xc6, 0xbe, 0x3e, 0x9d, 0xbc, 0xc5, 0xd5, 0x75, 0xb6,
	0x1a, 0x49, 0x20, 0x23, 0xfb, 0x6e, 0x18, 0xfe, 0xa9, 0x17, 0x8c, 0xaa, 0x1b, 0xf4, 0xb8, 0xc8,
	0x77, 0xa8, 0x81, 0x92, 0xe3, 0x74, 0xab, 0x9b, 0x74, 0x0c, 0x79, 0xac, 0xfd, 0xdd, 0x26, 0xf5,
	0x60, 0xea, 0x1a, 0xcc, 0xa5, 0x7e, 0x9a, 0x0a, 0x9e, 0x5b, 0xea, 0x6a, 0xd8, 0x7e, 0x8b, 0xd8,
	0xf9, 0x14, 0x80, 0x7e, 0x80, 0xdf, 0x2a, 0xa1, 0x25, 0x97, 0x5d, 0x61, 0x82, 0x1f, 0x81, 0xcd,
	0xae, 0x1b, 0x46, 0x46, 0x10, 0x78, 0x01, 0x1a, 0xbe, 0x65, 0x71, 0x7e, 0x03, 0x25, 0x89, 0x09,
	0x2e, 0x9b, 0x18, 0x76, 0x29, 0xc5, 0x45, 0x88, 0xe4, 0xb0, 0xc4, 0xfe, 0xb6, 0x9c, 0xef, 0x22,
	0xaa, 0x47, 0xa9, 0x36, 0x5d, 0xf9, 0x21, 0x9b, 0xae, 0xe6, 0xd8, 0xb4, 0xe9, 0xfa, 0xa1, 0x2d,
	0xf6, 0x78, 0x13, 0xc9, 0x77, 0x81, 0xd1, 0xc5, 0xac, 0xc5, 0x18, 0x5d, 0x47, 0x15, 0xac, 0x92,
	0x67, 0x0b, 0x9f, 0xf1, 0x4d, 0x14, 0xaf, 0xf0, 0x0b, 0xa0, 0xd9, 0x78, 0x2a, 0x75, 0x73, 0xce,
	0x7d, 0xb6, 0x95, 0xe4, 0xbc, 0x73, 0x03, 0x0a, 0x3a, 0xca, 0x70, 0xc2, 0x47, 0xe0, 0xba, 0x39,
	0xb7, 0xbc, 0x68, 0x32, 0x9e, 0x0c, 0xdd, 0x68, 0xe2, 0xcd, 0x43, 0xba, 0xd5, 0x9b, 0x28, 0x4d,
	0x86, 0x75, 0xa0, 0xf5, 0x16, 0x51, 0x92, 0x95, 0x6d, 0x7f, 0x86, 0x4e, 0x6c, 0x60, 0xce, 0x4f,
	0xfc, 0x91, 0x4b, 0xb2, 0x59, 0x85, 0xd9, 0x40, 0x12, 0xe0, 0x7d, 0x00, 0x7a, 0x8b, 0x48, 0xc0,
	0xd7, 0x29, 0xac, 0x50, 0x88, 0x57, 0x9b, 0x73, 0x62, 0x32, 0x97, 0x98, 0x2c, 0xac, 0x6a, 0xcc,
	0xab, 0x55, 0x1a, 0xd9, 0xd7, 0xde, 0x22, 0x52, 0x98, 0xb6, 0x28, 0x53, 0x92, 0x48, 0xce, 0x9c,
	0x39, 0x47, 0x78, 0x1c, 0xe0, 0xf0, 0x0d, 0x0e, 0xab, 0x90, 0xf2, 0xa8, 0x24, 0x32, 0x17, 0xc9,
	0xac, 0x92, 0xe5, 0x06, 0x9b, 0x4b, 0xa5, 0x31, 0x1b, 0x39, 0x5e, 0xe4, 0x4e, 0x8f, 0x71, 0x18,
	0xba, 0x67, 0x38, 0xac, 0x6e, 0x0b, 0x1b, 0x25, 0xc8, 0xdc, 0x46, 0x49, 0xd6, 0x9b, 0xd2, 0x46,
	0x49, 0xde, 0xc7, 0x60, 0xeb, 0x30, 0x9c, 0x19, 0x61, 0xe4, 0x04, 0xee, 0x3c, 0x9c, 0x30, 0x83,
	0xee, 0x50, 0xe6, 0x2c, 0x40, 0xb8, 0xd5, 0x53, 0xdd, 0xf4, 0x16, 0xf3, 0xa8, 0x7a, 0x8b, 0x71,
	0x67, 0x00, 0xb8, 0x03, 0x56, 0xc8, 0xa1, 0x39, 0x0b, 0xaa, 0x55, 0xca, 0xc2, 0xdf, 0x88, 0xd5,
	0xec, 0xc8, 0x9d, 0xe2, 0xbe, 0x1b, 0xbd, 0xa1, 0xce, 0x7b, 0x9b, 0x59, 0x2d, 0x41, 0xa4, 0xb6,
	0x0d, 0xc6, 0xc6, 0x5c, 0xce, 0xb3, 0xcb, 0x6d, 0xab, 0x12, 0x89, 0x55, 0x88, 0x67, 0x1e, 0x87,
	0x67, 0xc6, 0xd4, 0x0f, 0xa9, 0xb4, 0x3b, 0xcc, 0x2a, 0x29, 0x32, 0x91, 0x47, 0x4b, 0x17, 0x62,
	0x51, 0xea, 0xf8, 0x77, 0x99, 0xbc, 0x04, 0x31, 0xc1, 0x45, 0x8f, 0xc0, 0xbd, 0x14, 0x17, 0x3d,
	0x07, 0xbb, 0xa0, 0x6c, 0xce, 0xfb, 0xc1, 0xf8, 0x1d, 0x0e, 0xab, 0xf7, 0xd9, 0x19, 0x11, 0xef,
	0xc4, 0xeb, 0x7a, 0x8b, 0x88, 0x83, 0x0f, 0x98, 0xd7, 0x49, 0x02, 0x7c, 0x02, 0x6e, 0xc8, 0x17,
	0x7d, 0xf4, 0x16, 0x07, 0xd1, 0x24, 0xc4, 0xa3, 0xea, 0x1e, 0xe5, 0xcb, 0x83, 0xc8, 0x0a, 0x55,
	0xd3, 0x9a, 0xf3, 0xa8, 0xfa, 0x3b, 0x6c, 0x85, 0x29, 0x32, 0xd9, 0x1d, 0xe9, 0xbf, 0xd2, 0x1a,
	0x35, 0xb6, 0x3b, 0x19, 0x80, 0xc8, 0x95, 0xd3, 0xb5, 0xf0, 0x7c, 0x82, 0x47, 0xd5, 0x9f, 0x30,
	0xb9, 0x29, 0x72, 0x82, 0xd3, 0x9c, 0xf9, 0x5f, 0x8d, 0x82, 0xea, 0x47, 0x29, 0x4e, 0x46, 0x4e,
	0x70, 0x1a, 0xef, 0x28, 0xe7, 0xc7, 0x29, 0x4e, 0x46, 0x86, 0x0f, 0x41, 0x45, 0x58, 0x8c, 0x8b,
	0x7c, 0x48, 0x19, 0x53, 0x54, 0x95, 0x8f, 0x0b, 0xfc, 0x24, 0xc9, 0xc7, 0xe5, 0xd5, 0x81, 0x86,
	0xf0, 0x10, 0x4f, 0xde, 0xe2, 0x91, 0x8c, 0x89, 0x8f, 0x98, 0xcf, 0xa7, 0xe9, 0xa4, 0x44, 0x66,
	0xae, 0xed, 0xbe, 0x9e, 0x4e, 0xc2, 0x37, 0x98, 0x71, 0xff, 0x94, 0x95, 0xc8, 0x59, 0x84, 0xd8,
	0x55, 0x86, 0x0d, 0x69, 0xd7, 0x3a, 0xb3, 0x6b, 0x06, 0x20, 0x31, 0xd2, 0x9c, 0xf7, 0x7c, 0x3c,
	0x0f, 0xab, 0x9f, 0xb2, 0x18, 0xc9, 0x5f, 0x89, 0xd7, 0xf4, 0x16, 0x11, 0x83, 0x1e, 0x33, 0xaf,
	0x11, 0xef, 0xb5, 0x3f, 0x67, 0x17, 0x10, 0x72, 0x42, 0xe0, 0x8b, 0x44, 0x4d, 0xac, 0x25, 0x12,
	0xd0, 0x0f, 0xd7, 0xc5, 0xbf, 0x48, 0xd5, 0xc5, 0x30, 0x9d, 0xbc, 0x2e, 0xad, 0x8d, 0x75, 0x70,
	0x5d, 0x24, 0xfa, 0xab, 0xd7, 0x90, 0x15, 0x29, 0x82, 0x15, 0x91, 0x75, 0xb5, 0x88, 0x2c, 0xe5,
	0xad, 0x29, 0xae, 0x21, 0xe7, 0x00, 0x72, 0xfa, 0x87, 0xd4, 0x91, 0x8f, 0x12, 0x75, 0x64, 0x49,
	0xad, 0xea, 0xa9, 0x62, 0x71, 0x2d, 0xf9, 0x0d, 0xbd, 0x0c, 0x10, 0xe2, 0x11, 0x3e, 0x4f, 0xa6,
	0xe0, 0xc2, 0xe5, 0x29, 0xf8, 0xb1, 0x52, 0xd4, 0x15, 0x2f, 0x60, 0x97, 0x1c, 0xb5, 0x53, 0x5a,
	0xe3, 0xf3, 0xb9, 0xf8, 0x3d, 0x40, 0x8b, 0x6b, 0xd7, 0xce, 0x35, 0x5a, 0x9f, 0xfe, 0x04, 0x94,
	0x8e, 0xf0, 0x39, 0x17, 0x77, 0x5d, 0x55, 0x9b, 0x8c, 0xba, 0x86, 0x08, 0xda, 0x58, 0x07, 0x6b,
	0x93, 0xd1, 0xc0, 0x0b, 0x06, 0xbf, 0xc2, 0xe7, 0xb5, 0x36, 0xd8, 0xe6, 0x1c, 0xc9, 0xfb, 0xc3,
	0x67, 0x69, 0xbb, 0xdf, 0x4c, 0x4b, 0x4b, 0x15, 0xf0, 0x6d, 0x70, 0x33, 0x25, 0xe8, 0x8a, 0x3e,
	0xd0, 0xa2, 0x97, 0x11, 0xb9, 0x8b, 0x57, 0x54, 0xe7, 0xcf, 0x96, 0x64, 0x31, 0xa7, 0x8f, 0xaf,
	0x50, 0xe9, 0x27, 0x0a, 0xf8, 0xe2, 0xff, 0x64, 0x01, 0x5f, 0xfa, 0xc0, 0x02, 0xfe, 0x0f, 0x40,
	0x49, 0x1f, 0x4f, 0x68, 0x19, 0x58, 0x39, 0x58, 0x97, 0x15, 0xd2, 0x78, 0x72, 0x89, 0x04, 0x32,
	0x0a, 0x7e, 0x09, 0x96, 0x6c, 0x77, 0x3c, 0xa1, 0x25, 0x62, 0x45, 0xb9, 0xae, 0xba, 0x97, 0x0e,
	0xa7, 0xe3, 0x48, 0x3d, 0x62, 0xe1, 0x77, 0xd1, 0x1b, 0xcf, 0xb7, 0xf1, 0x74, 0xcc, 0xaf, 0x08,
	0x2a, 0x89, 0x70, 0xb4, 0xf0, 0xd8, 0x5d, 0x4c, 0xa3, 0x5e, 0x30, 0x39, 0x13, 0xb7, 0x04, 0x85,
	0x44, 0xb2, 0x1c, 0xb5, 0x4c, 0xdf, 0x0b, 0x44, 0x09, 0x19, 0x13, 0x48, 0x6d, 0xc5, 0xae, 0x23,
	0x14, 0x66, 0x55, 0xa4, 0x42, 0x21, 0xd1, 0x5a, 0xda, 0xd5, 0x1e, 0x7a, 0x3e, 0x36, 0x47, 0xbc,
	0xa0, 0xcc, 0xd0, 0x6b, 0xff, 0x55, 0x90, 0x21, 0x49, 0x1f, 0xf3, 0xe3, 0xbd, 0x07, 0xd6, 0x59,
	0xd8, 0x6d, 0x07, 0xde, 0xc2, 0xa7, 0xfe, 0xb0, 0x89, 0x54, 0x52, 0xee, 0x0c, 0xc5, 0xfc, 0x19,
	0xe8, 0x6d, 0x4a, 0x14, 0x5a, 0x74, 0x67, 0xcb, 0x28, 0x26, 0xc0, 0x2f, 0xc1, 0xa6, 0x3e, 0x1a,
	0x91, 0xb2, 0xa4, 0xe9, 0xfa, 0xa4, 0xf2, 0x65, 0x9b, 0x56, 0x65, 0x66, 0x3f, 0xf3, 0x13, 0x60,
	0xd3, 0xf5, 0x51, 0x92, 0x1d, 0x7e, 0x09, 0xae, 0x23, 0x3c, 0x9e, 0xe2, 0x61, 0xe4, 0x05, 0xfc,
	0x5a, 0xb5, 0xfc, 0x03, 0xd7, 0xaa, 0x34, 0x73, 0xed, 0x2f, 0x59, 0x2b, 0x88, 0xad, 0x1f, 0xfe,
	0x2c, 0x91, 0x1b, 0x12, 0xf1, 0x9d, 0x1d, 0x91, 0x1f, 0xc8, 0x0e, 0x8d, 0x54, 0x76, 0xd8, 0x4e,
	0x8d, 0x7e, 0x9f, 0xfc, 0xd0, 0x94, 0x07, 0x5b, 0x1f, 0x5f, 0x39, 0x3a, 0xfc, 0x42, 0xc6, 0x41,
	0x22, 0x84, 0x05, 0x87, 0xc7, 0xe9, 0xe0, 0x90, 0xb3, 0xb6, 0x38, 0x32, 0xfc, 0xa6, 0x40, 0xdb,
	0x29, 0x0c, 0xfa, 0x5f, 0x0f, 0xdc, 0xf0, 0x1e, 0x3b, 0xae, 0xa5, 0xcc, 0x71, 0x65, 0x07, 0x72,
	0x8f, 0x1f, 0xc8, 0xa5, 0xec, 0x81, 0x64, 0x47, 0xae, 0xf6, 0xb5, 0xcc, 0x6a, 0x54, 0xdd, 0x0b,
	0x63, 0xff, 0xc7, 0x6a, 0xec, 0xdf, 0x4a, 0x5a, 0xe0, 0xa2, 0xe8, 0x7f, 0x04, 0x76, 0x24, 0x4f,
	0x32, 0xfe, 0x3f, 0x4d, 0xdb, 0xf4, 0x56, 0x56, 0x62, 0x2a, 0xe4, 0x9a, 0xe0, 0x56, 0x46, 0xd8,
	0x15, 0x77, 0xb9, 0x03, 0x6e, 0x48, 0x51, 0x4a, 0x16, 0xb8, 0x82, 0x52, 0x81, 0xcc, 0x6f, 0x5c,
	0xd2, 0x15, 0xab, 0x82, 0x7a, 0xa6, 0x2a, 0xa8, 0x24, 0xe7, 0x56, 0xea, 0x82, 0x7f, 0x28, 0xd0,
	0x49, 0x9b, 0x53, 0xec, 0x06, 0xbc, 0xf8, 0x17, 0xfa, 0xaf, 0xf4, 0x7c, 0x72, 0x1d, 0xe2, 0x33,
	0xde, 0x16, 0x22, 0x62, 0x56, 0x86, 0x87, 0x88, 0x33, 0xc2, 0x4f, 0xc1, 0x12, 0x91, 0xcf, 0xb7,
	0x35, 0x3f, 0xeb, 0x75, 0xae, 0x21, 0xca, 0x44, 0xe4, 0x33, 0x65, 0x78, 0x92, 0xb9, 0xc8, 0x3c,
	0x9d, 0x6b, 0x88, 0x33, 0x36, 0x34, 0x50, 0xf1, 0x31, 0x0e, 0x88, 0x43, 0x90, 0xff, 0xdd, 0x31,
	0x4f, 0xe4, 0xaa, 0xf2, 0x57, 0xdc, 0xc4, 0x5f, 0xaf, 0xd0, 0x5d, 0xb4, 0xba, 0xc8, 0xec, 0x07,
	0x78, 0x3c, 0x79, 0xc7, 0x4d, 0xc9, 0x4f, 0x44, 0xe1, 0x92, 0x13, 0x51, 0xbc, 0xe8, 0x44, 0xd0,
	0xcb, 0x21, 0x15, 0xc8, 0x3b, 0x26, 0xfc, 0x8d, 0x04, 0x63, 0xf6, 0xd4, 0xc5, 0x73, 0xde, 0x54,
	0x8e, 0x09, 0x70, 0x1f, 0xac, 0xd3, 0xf5, 0xd8, 0xde, 0x22, 0x18, 0xe2, 0x44, 0x06, 0x24, 0x2a,
	0xda, 0xc1, 0x10, 0xa9, 0x0c, 0xf4, 0x5a, 0x10, 0xbf, 0x9a, 0xf3, 0x11, 0x7e, 0xc7, 0x5b, 0x25,
	0x19, 0x3a, 0xd5, 0xc8, 0x8d, 0xde, 0x98, 0x2d, 0xde, 0x2f, 0xe1, 0x6f, 0x44, 0xa3, 0x06, 0x0e,
	0x59, 0xdf, 0x9b, 0xa6, 0xba, 0x32, 0x8a, 0x09, 0x04, 0xd5, 0x6d, 0xc2, 0x69, 0x47, 0x01, 0xcd,
	0x74, 0x1b, 0x28, 0x26, 0x90, 0x44, 0x48, 0x1e, 0x49, 0xca, 0xe4, 0x29, 0x6e, 0x03, 0x29, 0x14,
	0x91, 0x8a, 0x3b, 0x9e, 0x4f, 0x23, 0xd1, 0x3a, 0x65, 0x50, 0x49, 0xf0, 0x21, 0x58, 0xd1, 0x6d,
	0x7b, 0xf2, 0x2d, 0xa6, 0x1d, 0x91, 0x4a, 0xec, 0xb1, 0x8c, 0x8a, 0x38, 0x4a, 0xf4, 0x30, 0x86,
	0x33, 0x9f, 0x69, 0xb9, 0xc9, 0xb4, 0x94, 0x84, 0x44, 0xb8, 0xab, 0x5c, 0x1a, 0xee, 0xea, 0x40,
	0x3b, 0x9c, 0xba, 0x3e, 0xd9, 0xea, 0x90, 0x3c, 0x0c, 0xe7, 0x11, 0x6f, 0x90, 0x64, 0xe8, 0x09,
	0x5e, 0x7b, 0xe1, 0xfb, 0x41, 0x38, 0xa2, 0xad, 0x92, 0x32, 0xca, 0xd0, 0xe1, 0x13, 0x50, 0x36,
	0x43, 0x7d, 0x18, 0x4d, 0xde, 0x62, 0xda, 0x29, 0x51, 0x72, 0x20, 0xd9, 0x3d, 0x81, 0x21, 0xc9,
	0x05, 0xb7, 0x69, 0xaf, 0x76, 0x8a, 0x69, 0xd3, 0xa4, 0x8c, 0xd8, 0x0b, 0xb9, 0xa4, 0x73, 0xd9,
	0x41, 0x44, 0x2f, 0x63, 0xac, 0x5f, 0x92, 0x24, 0xc2, 0x17, 0x60, 0x13, 0x61, 0x37, 0xf4, 0xe6,
	0x96, 0x17, 0x91, 0xfd, 0xa2, 0xed, 0x12, 0xe5, 0xe3, 0x09, 0x0a, 0x05, 0x82, 0x92, 0x8c, 0xe4,
	0x0a, 0x27, 0x1a, 0xa4, 0x37, 0xf7, 0x4a, 0x8f, 0x36, 0x90, 0x78, 0x25, 0xc5, 0x88, 0x96, 0x38,
	0x0e, 0x24, 0xf7, 0xfc, 0xff, 0x39, 0x0b, 0x35, 0x9d, 0x16, 0xe4, 0xf1, 0xf2, 0xe1, 0x93, 0x44,
	0x77, 0x75, 0x5d, 0x94, 0x45, 0xd9, 0x88, 0x21, 0x2b, 0x88, 0x6f, 0x41, 0x35, 0x01, 0x7f, 0x48,
	0x40, 0xdf, 0xcf, 0x04, 0x74, 0x98, 0x9d, 0x5f, 0x09, 0xea, 0x3a, 0x4d, 0x95, 0x89, 0xdd, 0xe3,
	0xa9, 0xf8, 0x13, 0x96, 0x78, 0x0b, 0xc9, 0x08, 0x9d, 0xe0, 0xa4, 0xa9, 0xb7, 0xd6, 0xa7, 0x09,
	0x32, 0xa5, 0x3e, 0xcb, 0x0c, 0xbf, 0x97, 0xce, 0x6c, 0x77, 0x72, 0xe5, 0xa4, 0xb3, 0xdb, 0x5f,
	0xac, 0xb3, 0xe2, 0x20, 0x18, 0xbf, 0x6b, 0xce, 0xa3, 0x20, 0xe4, 0x6b, 0xdb, 0x05, 0x65, 0x63,
	0x1e, 0xb1, 0x6d, 0x62, 0x05, 0xae, 0x7c, 0xa7, 0x8e, 0x81, 0x71, 0xc0, 0xc0, 0x22, 0x77, 0x0c,
	0x41, 0xf8, 0xe0, 0x6a, 0x25, 0xd1, 0xde, 0x5a, 0x4e, 0xb5, 0xb7, 0xea, 0x40, 0x13, 0xcf, 0xfa,
	0x70, 0x88, 0xfd, 0x08, 0x8f, 0x84, 0x17, 0xa5, 0xe9, 0x2a, 0x2f, 0xc2, 0xdf, 0xe0, 0x21, 0xe1,
	0x5d, 0x4d, 0xf2, 0x0a, 0x7a, 0xb2, 0x6d, 0x56, 0x7e, 0xcf, 0xb6, 0xd9, 0xda, 0xc5, 0x6d, 0xb3,
	0x5d, 0x50, 0x3e, 0x09, 0x71, 0xd0, 0x72, 0x23, 0x97, 0xc6, 0xdd, 0x35, 0x24, 0xdf, 0x59, 0x2b,
	0x95, 0x8d, 0x20, 0x21, 0xc3, 0xc7, 0x23, 0xfe, 0xd9, 0x21, 0x4d, 0x86, 0xcf, 0xc1, 0x8e, 0x4a,
	0xa2, 0x81, 0x0c, 0x87, 0x64, 0x6a, 0xd6, 0x9f, 0xbe, 0x00, 0x25, 0xfa, 0xaa, 0x48, 0x67, 0x12,
	0x92, 0x9b, 0x18, 0xef, 0x54, 0xe7, 0x41, 0x6a, 0xa3, 0x8b, 0x47, 0xc8, 0x4a, 0xb2, 0xd1, 0xc5,
	0x23, 0xa2, 0x22, 0x99, 0xb5, 0xe7, 0x1a, 0xe7, 0x7d, 0x6f, 0xca, 0xc3, 0x73, 0x1e, 0x44, 0x56,
	0x6b, 0x2d, 0x66, 0x5d, 0x6f, 0x88, 0x26, 0xaf, 0xf9, 0xa7, 0x5d, 0xd6, 0xcb, 0x4e, 0x93, 0x89,
	0x6c, 0x49, 0x92, 0x19, 0x4e, 0x34, 0xb5, 0xf3, 0x20, 0xf8, 0x0c, 0xdc, 0x4c, 0x4e, 0x79, 0xec,
	0x06, 0xd1, 0xc4, 0x9d, 0xf3, 0x26, 0x77, 0x3e, 0x08, 0x0f, 0xc0, 0x76, 0x12, 0xd0, 0xc3, 0xae,
	0xe7, 0xf9, 0x3c, 0x8c, 0xe7, 0x62, 0xd9, 0x99, 0x78, 0x92, 0xe4, 0x4d, 0xf0, 0x7c, 0x50, 0xdd,
	0x3f, 0x29, 0x0d, 0xcf, 0xcf, 0xa2, 0x37, 0xbc, 0x21, 0x7e, 0x01, 0x0a, 0x5f, 0x80, 0x5b, 0x49,
	0x84, 0x44, 0xff, 0xc5, 0x7c, 0x12, 0x9d, 0xf3, 0xe6, 0xf8, 0x45, 0x70, 0x76, 0x24, 0xbd, 0x73,
	0xd0, 0x6b, 0xf4, 0xad, 0xbc, 0x91, 0x12, 0x26, 0x59, 0x8d, 0x77, 0xf2, 0xf9, 0x29, 0x60, 0x5d,
	0xf3, 0x24, 0x91, 0xf8, 0x89, 0x68, 0xe2, 0x73, 0x36, 0xd6, 0x3d, 0x4f, 0x51, 0xe1, 0x67, 0x2c,
	0x44, 0xb0, 0x2f, 0x9d, 0xbb, 0x17, 0x7d, 0xca, 0x8a, 0x79, 0xf2, 0xfa, 0xc1, 0x77, 0xde, 0xbb,
	0x1f, 0x7c, 0xf7, 0xbd, 0xfb, 0xc1, 0xf7, 0xde, 0xb7, 0x1f, 0x7c, 0xff, 0x3d, 0xfb, 0xc1, 0x0f,
	0x72, 0xfb, 0xc1, 0x07, 0x60, 0xbb, 0xb9, 0x08, 0xb2, 0xe7, 0x84, 0x35, 0xda, 0x73, 0xb1, 0xda,
	0xaf, 0x79, 0xa7, 0x41, 0x04, 0x62, 0x92, 0xdb, 0xff, 0xef, 0xa2, 0x70, 0xed, 0x25, 0xbb, 0xe2,
	0x0a, 0x6d, 0xe0, 0x67, 0xa9, 0x54, 0x1b, 0x5f, 0x0c, 0x92, 0x99, 0x43, 0x66, 0xda, 0x77, 0xec,
	0x2e, 0x27, 0xd0, 0x0f, 0x49, 0xb4, 0xbf, 0x9b, 0x49, 0xb4, 0x5b, 0x99, 0xd9, 0x95, 0x3c, 0xfb,
	0x92, 0xf5, 0x11, 0x15, 0x43, 0xf2, 0x34, 0xfb, 0x50, 0x4d, 0xb3, 0xdb, 0x19, 0x11, 0x32, 0xcb,
	0x5a, 0xec, 0x4e, 0x9b, 0x50, 0x9d, 0x25, 0xd9, 0x67, 0xe9, 0x24, 0xbb, 0x9b, 0x27, 0x25, 0x9d,
	0x63, 0xff, 0xa6, 0x40, 0xfb, 0x16, 0x34, 0x6a, 0x1d, 0xb3, 0xaa, 0xf4, 0x92, 0x14, 0xbb, 0x0d,
	0x96, 0xd5, 0x8d, 0x5d, 0x96, 0x75, 0x91, 0xb5, 0x98, 0xbd, 0xc6, 0x01, 0xff, 0x75, 0x0c, 0x7f,
	0x23, 0xf4, 0xce, 0x24, 0x1a, 0xf2, 0x2f, 0xbb, 0xcb, 0x88, 0xbf, 0x91, 0xba, 0xbb, 0x17, 0x8c,
	0xf5, 0x30, 0xf4, 0x86, 0xbc, 0x40, 0x93, 0xad, 0x6f, 0x41, 0x47, 0x92, 0xa3, 0xf6, 0x35, 0xed,
	0x9c, 0x0b, 0x25, 0x2f, 0x73, 0xbf, 0x1f, 0xa5, 0xa1, 0xf8, 0xf9, 0x0a, 0x97, 0x0d, 0xf7, 0x53,
	0xce, 0xb4, 0x23, 0xab, 0xe2, 0x84, 0x89, 0xa4, 0x2f, 0xbd, 0xa5, 0x1b, 0x22, 0xc0, 0x0f, 0x71,
	0xa5, 0xc7, 0x19, 0x57, 0xd2, 0xd2, 0x73, 0x2b, 0x9e, 0xf4, 0x73, 0x7a, 0x0b, 0x57, 0x4c, 0xc2,
	0x1d, 0xe9, 0x63, 0xd5, 0x91, 0x6e, 0xa4, 0x05, 0x48, 0x3f, 0xea, 0x52, 0x47, 0x4c, 0xa8, 0xcd,
	0xdc, 0xe8, 0xf3, 0xb4, 0x1b, 0xdd, 0xce, 0x91, 0x91, 0xf2, 0xa2, 0xfa, 0x4b, 0xb0, 0xc2, 0x8e,
	0x30, 0xd4, 0xe8, 0xd9, 0x1c, 0xe8, 0x87, 0xe6, 0xc0, 0xea, 0x59, 0x86, 0x76, 0x4d, 0xa5, 0x98,
	0xfd, 0xd3, 0x67, 0x5a, 0x01, 0x6e, 0xd1, 0x5a, 0x99, 0x52, 0xba, 0x07, 0xa7, 0x7d, 0x4b, 0xbb,
	0x5d, 0x37, 0xd8, 0xaf, 0xcc, 0x48, 0x8d, 0xc5, 0x51, 0x5b, 0x11, 0xb1, 0x4d, 0xef, 0x16, 0x8c,
	0x74, 0x62, 0x99, 0x4d, 0xdd, 0x76, 0x62, 0x31, 0x94, 0x6a, 0x10, 0x31, 0x87, 0xf5, 0x3f, 0x8e,
	0x3f, 0xd2, 0x88, 0xdf, 0x60, 0xf0, 0xb1, 0x7d, 0xc3, 0x40, 0x03, 0x84, 0x84, 0xc4, 0x1d, 0x5a,
	0x59, 0x4a, 0x6a, 0xb3, 0x6b, 0x1a, 0x16, 0x91, 0x79, 0x0f, 0xdc, 0x56, 0xe9, 0xc7, 0x86, 0xdd,
	0x31, 0x5a, 0x02, 0x2e, 0xd6, 0xff, 0x2d, 0xee, 0xae, 0xb1, 0xdc, 0x70, 0x8b, 0x36, 0x01, 0x18,
	0xbf, 0xed, 0xe8, 0x8e, 0x21, 0x26, 0xc8, 0x02, 0x66, 0xab, 0x6b, 0x68, 0x05, 0xb8, 0x4b, 0xfd,
	0x45, 0x05, 0x9a, 0x3d, 0xcb, 0x32, 0x9a, 0x8e, 0x56, 0x84, 0xb7, 0xe9, 0xa6, 0xa8, 0x98, 0xde,
	0x74, 0xcc, 0x53, 0x43, 0x2b, 0xc1, 0x3b, 0x34, 0x64, 0xa9, 0x50, 0xaf, 0x6f, 0x58, 0x36, 0x51,
	0x6b, 0x09, 0xde, 0x07, 0xbb, 0x39, 0x60, 0xb3, 0x67, 0x1d, 0x9a, 0xe8, 0x58, 0x5b, 0xce, 0xc1,
	0x0d, 0xdb, 0xd1, 0x1b, 0x5d, 0x93, 0xac, 0x4e, 0x5b, 0xa9, 0xbf, 0xa2, 0x8d, 0x54, 0x7e, 0x5f,
	0xe6, 0x06, 0xd3, 0xed, 0x81, 0x6d, 0x7e, 0x2d, 0xd7, 0xc3, 0x55, 0x13, 0x54, 0xe7, 0xab, 0xde,
	0xa0, 0xd7, 0x74, 0x0c, 0x27, 0x5e, 0x91, 0x80, 0x0e, 0x7b, 0x27, 0x88, 0x63, 0xc5, 0xfa, 0xbf,
	0xb0, 0x1f, 0x24, 0xc9, 0xdf, 0x33, 0x70, 0xb3, 0xe8, 0xad, 0x16, 0x1a, 0x38, 0xbf, 0xec, 0x1b,
	0x83, 0x9e, 0xd3, 0x31, 0x50, 0xbc, 0x21, 0x31, 0xc0, 0x7d, 0x25, 0x8f, 0xfe, 0x5c, 0x2b, 0x66,
	0xe9, 0x96, 0xad, 0xf7, 0xb5, 0x52, 0x96, 0xde, 0x69, 0x75, 0x9b, 0xda, 0x92, 0xd4, 0x5f, 0xd2,
	0x1b, 0x0d, 0xeb, 0xe9, 0x8b, 0x83, 0x03, 0x6d, 0x39, 0x0b, 0x99, 0x86, 0x61, 0xbc, 0x78, 0x72,
	0xa0, 0xad, 0x64, 0xa5, 0x19, 0x4f, 0x9f, 0x7f, 0xae, 0xad, 0xe6, 0xd2, 0x9f, 0x69, 0x65, 0x78,
	0x93, 0x06, 0x53, 0x85, 0x7e, 0xf8, 0xfc, 0xf7, 0xb5, 0xb5, 0x2c, 0xfb, 0xab, 0xa7, 0x07, 0x4f,
	0x35, 0x90, 0x65, 0x37, 0xfb, 0xaf, 0xb4, 0x75, 0xb1, 0xd7, 0x31, 0x59, 0xef, 0xf7, 0xbb, 0x86,
	0xa3, 0x77, 0x8f, 0xb4, 0x0d, 0x69, 0x6d, 0x09, 0xb6, 0x8c, 0xa6, 0x65, 0x38, 0xe6, 0xa9, 0xb6,
	0x99, 0x1d, 0xd8, 0xd0, 0xad, 0x5f, 0xea, 0xd6, 0xa9, 0x69, 0x69, 0x95, 0x2c, 0x48, 0x74, 0x66,
	0x66, 0xbb, 0x9e, 0x95, 0x4a, 0xcc, 0x3f, 0x70, 0x2c, 0x5d, 0xd3, 0x72, 0xb1, 0xe7, 0x14, 0xdb,
	0xca, 0x62, 0x44, 0x1e, 0xc5, 0x60, 0x16, 0x3b, 0xed, 0x5b, 0x6c, 0x5b, 0x6f, 0x5c, 0x88, 0x3d,
	0xd7, 0xb6, 0xb3, 0x3e, 0x22, 0x82, 0xc4, 0xdf, 0x17, 0xe8, 0x89, 0x8f, 0x7f, 0xdb, 0x09, 0xab,
	0x34, 0x08, 0x12, 0x6f, 0x67, 0x8e, 0x7d, 0x62, 0xa7, 0x0e, 0xb8, 0x8a, 0x9c, 0xf4, 0xb5, 0x42,
	0xde, 0x88, 0x56, 0xef, 0x2b, 0x4b, 0x2b, 0xc2, 0xbb, 0xf4, 0xfa, 0x9d, 0x40, 0xda, 0x3d, 0xd3,
	0x6a, 0x93, 0x71, 0x25, 0x71, 0x84, 0xb2, 0x28, 0x1d, 0xbd, 0x94, 0x87, 0xeb, 0x4d, 0x67, 0x70,
	0xa8, 0x9b, 0x5d, 0xa3, 0xa5, 0x2d, 0xd7, 0xff, 0xb1, 0x00, 0x6e, 0xe4, 0x7c, 0x13, 0x51, 0x76,
	0x65, 0xd0, 0xd7, 0x9d, 0xce, 0xc0, 0x46, 0x83, 0x96, 0x69, 0xeb, 0x8d, 0x2e, 0x59, 0x44, 0x0e,
	0x88, 0x8c, 0xa6, 0x41, 0x22, 0x82, 0x5c, 0x89, 0x0a, 0xda, 0x86, 0xd5, 0xd2, 0x8a, 0x79, 0x48,
	0xa3, 0xe7, 0x74, 0xe2, 0x28, 0xa2, 0x22, 0xa6, 0xd5, 0x31, 0x90, 0x49, 0xa2, 0x48, 0x0e, 0x78,
	0x62, 0x1d, 0x59, 0x64, 0x7d, 0xcb, 0xf5, 0xdf, 0xa4, 0xbb, 0xbe, 0xbc, 0x95, 0x2b, 0x26, 0x6b,
	0x76, 0x0d, 0x1d, 0x0d, 0x50, 0xef, 0x24, 0x0e, 0x81, 0x39, 0x48, 0x47, 0x47, 0x2d, 0xad, 0x20,
	0x8c, 0xa5, 0x22, 0xc8, 0x38, 0x44, 0x86, 0xdd, 0x19, 0x98, 0x64, 0x2b, 0x1e, 0x80, 0x3b, 0x17,
	0xe1, 0xbd, 0x13, 0x47, 0x2b, 0xc1, 0x3d, 0x70, 0xf7, 0x22, 0x06, 0xba, 0xd2, 0xa5, 0x7a, 0x0b,
	0xac, 0xf2, 0x5e, 0x0f, 0xdc, 0x04, 0x6b, 0xe4, 0x51, 0xa8, 0x25, 0x5e, 0x49, 0x34, 0xd4, 0x0a,
	0x70, 0x03, 0x94, 0xe9, 0xab, 0x7e, 0x78, 0xac, 0x15, 0x25, 0x68, 0x1b, 0xdd, 0x43, 0xad, 0x54,
	0xff, 0x96, 0xe6, 0x13, 0xb5, 0x05, 0x27, 0xce, 0x2c, 0xe5, 0x32, 0x6d, 0x5d, 0x48, 0xe5, 0xde,
	0xa3, 0x90, 0x9d, 0x81, 0x83, 0xf4, 0xe6, 0x91, 0x41, 0x16, 0xcc, 0x43, 0x8c, 0x44, 0x4d, 0x8b,
	0x07, 0xf6, 0xa2, 0xf0, 0x76, 0x09, 0x89, 0x88, 0x5f, 0xff, 0x5b, 0xf6, 0x8d, 0x37, 0x6e, 0xc6,
	0x89, 0xe4, 0x84, 0x0c, 0xdd, 0xee, 0x59, 0x74, 0x86, 0x66, 0xcf, 0xb2, 0xcd, 0x96, 0x81, 0x8c,
	0x56, 0xac, 0x02, 0x87, 0x99, 0x55, 0x4c, 0x7b, 0xd0, 0x30, 0x68, 0xb6, 0xe4, 0x7a, 0x73, 0xf4,
	0x2b, 0xc3, 0x6c, 0x77, 0x94, 0x94, 0xc3, 0xc9, 0xdd, 0x5e, 0x53, 0xef, 0x0e, 0xfa, 0xc8, 0x38,
	0xd4, 0x4a, 0x62, 0x17, 0x04, 0xd4, 0xec, 0x0e, 0x7a, 0xc8, 0x6c, 0x0f, 0xfa, 0xe8, 0x10, 0x91,
	0x09, 0x97, 0xc4, 0x21, 0xe6, 0x0c, 0xba, 0xcd, 0xdc, 0xa6, 0x6b, 0x58, 0xda, 0x72, 0x6a, 0x3a,
	0x32, 0xd0, 0xb4, 0xb4, 0x15, 0x08, 0x69, 0x21, 0x27, 0xc8, 0xc7, 0x46, 0x4b, 0x5b, 0x4d, 0x2d,
	0x8b, 0xa9, 0x40, 0x67, 0x72, 0x4c, 0x43, 0x2b, 0xa7, 0xd4, 0x30, 0xc8, 0xf3, 0xe9, 0xc0, 0x14,
	0xf9, 0x4c, 0x5b, 0x4b, 0x8d, 0xd7, 0x5b, 0xc7, 0xa6, 0x45, 0xce, 0x90, 0xa3, 0x5b, 0x4d, 0x43,
	0x03, 0xa9, 0xf1, 0x54, 0x45, 0xa7, 0x37, 0xb0, 0x8c, 0x57, 0xce, 0xa0, 0x69, 0x3b, 0xda, 0x7a,
	0xca, 0x6e, 0x64, 0xf1, 0x03, 0xe3, 0x95, 0x69, 0x3b, 0xa6, 0xd5, 0xd6, 0x36, 0x52, 0x06, 0x32,
	0x5b, 0x86, 0xe5, 0x98, 0x87, 0xa6, 0x81, 0xb4, 0xcd, 0xd4, 0xfa, 0x9b, 0xdd, 0x13, 0xdb, 0x31,
	0x10, 0x5d, 0x7f, 0x25, 0xa5, 0x14, 0xcd, 0xbc, 0x32, 0xa0, 0x69, 0xd7, 0xc5, 0xd9, 0x48, 0xc3,
	0x9a, 0x96, 0x87, 0xf4, 0x7b, 0xc8, 0xd1, 0xb6, 0x44, 0x48, 0x53, 0x17, 0x62, 0xb6, 0x34, 0x58,
	0x7f, 0x45, 0x53, 0xac, 0xa8, 0x95, 0x65, 0xe4, 0x43, 0x87, 0x03, 0xdd, 0xb6, 0x7b, 0xcd, 0x54,
	0x45, 0x12, 0xd3, 0xa9, 0xa5, 0x95, 0x90, 0x28, 0x01, 0x64, 0x1c, 0xf7, 0x1c, 0x43, 0x2b, 0x1e,
	0xfc, 0x53, 0x99, 0xd6, 0x75, 0xf6, 0xdb, 0x21, 0x7c, 0x42, 0x4b, 0x84, 0x66, 0x80, 0x49, 0xd5,
	0x23, 0x7f, 0x7b, 0xc1, 0xeb, 0xbf, 0xdd, 0xb8, 0x50, 0x15, 0xe5, 0xe9, 0x35, 0x3e, 0x82, 0x7d,
	0x7a, 0x7e, 0xbf, 0x11, 0x5f, 0xd0, 0x11, 0xec, 0xe3, 0x1a, 0x94, 0xad, 0xc6, 0xc4, 0x97, 0xbb,
	0xdd, 0x9d, 0x34, 0x59, 0x8e, 0xfe, 0x9c, 0xea, 0xda, 0xc6, 0x11, 0x94, 0xad, 0xce, 0xb8, 0xac,
	0xdd, 0xbd, 0x91, 0xa0, 0x29, 0x53, 0x8a, 0xdf, 0x51, 0xf0, 0xa5, 0xdd, 0x48, 0x7c, 0x7b, 0xe6,
	0x83, 0x93, 0x1f, 0xa4, 0xf3, 0x46, 0xf3, 0x65, 0xfe, 0xa8, 0xd1, 0x1d, 0x39, 0x9a, 0x2f, 0xf9,
	0xb6, 0xca, 0x98, 0x5c, 0xf6, 0x6e, 0x1e, 0x24, 0x25, 0xbd, 0x94, 0x3f, 0xd5, 0x21, 0xcb, 0xdf,
	0x51, 0x79, 0x15, 0x13, 0xdc, 0xca, 0xd0, 0xa5, 0x80, 0x86, 0xf2, 0x4b, 0x02, 0x6e, 0x88, 0x9b,
	0xa9, 0x0f, 0x80, 0x69, 0xfb, 0x27, 0xbf, 0x74, 0xa7, 0x64, 0x70, 0x73, 0xfc, 0x68, 0x19, 0x96,
	0x22, 0x83, 0x1b, 0xe5, 0x4e, 0x92, 0x39, 0x69, 0x96, 0xbb, 0xf9, 0xa0, 0x94, 0x67, 0x28, 0x1f,
	0xc3, 0x89, 0x69, 0xaa, 0x49, 0x7e, 0xc5, 0x38, 0xb7, 0x73, 0x90, 0xd4, 0x4e, 0xc5, 0xb9, 0x0f,
	0xe6, 0x7c, 0xda, 0xcc, 0xec, 0x54, 0xf6, 0x1b, 0x63, 0xed, 0x1a, 0xfc, 0xa3, 0xd4, 0x57, 0x12,
	0xa2, 0xd4, 0xdd, 0x6c, 0x33, 0x5c, 0x51, 0xec, 0xde, 0x05, 0x68, 0xda, 0x66, 0x4a, 0x47, 0x40,
	0xb1, 0x59, 0xb6, 0x4f, 0xa0, 0xd8, 0x2c, 0xa7, 0xff, 0x51, 0xbb, 0x06, 0x8f, 0x12, 0x77, 0x6d,
	0x22, 0x6e, 0x37, 0x7d, 0x03, 0x54, 0xa4, 0xdd, 0xc9, 0xc5, 0x84, 0xb0, 0xc6, 0xc6, 0x3f, 0x7f,
	0x7f, 0xbf, 0xf0, 0xaf, 0xdf, 0xdf, 0x2f, 0xfc, 0xc7, 0xf7, 0xf7, 0x0b, 0xaf, 0x57, 0xe8, 0xdf,
	0x14, 0x7d, 0xfe, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x83, 0xdc, 0xe5, 0x50, 0x8f, 0x34, 0x00,
	0x00,
}
