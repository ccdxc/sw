// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: endpoint.proto

/*
	Package halproto is a generated protocol buffer package.

	It is generated from these files:
		endpoint.proto
		eplearn.proto
		event.proto
		events.proto
		fwlog.proto
		interface.proto
		kh.proto
		l2segment.proto
		multicast.proto
		nwsec.proto
		port.proto
		qos.proto
		system.proto
		telemetry.proto
		types.proto
		vrf.proto

	It has these top-level messages:
		EndpointVmotion
		EndpointAttributes
		EndpointSpec
		EndpointRequestMsg
		EndpointIpAddress
		EndpointStatusEpd
		EndpointStatusCpd
		EndpointStatus
		EndpointResponse
		EndpointResponseMsg
		EndpointUpdateRequest
		EndpointUpdateRequestMsg
		EndpointUpdateResponseMsg
		EndpointFilter
		EndpointDeleteRequest
		EndpointDeleteRequestMsg
		EndpointDeleteResponse
		EndpointDeleteResponseMsg
		EndpointGetRequest
		EndpointGetRequestMsg
		EndpointGetByInterfaceRequest
		EndpointGetByInterfaceRequestMsg
		EndpointGetAllRequestMsg
		EndpointStats
		EndpointGetResponse
		EndpointGetResponseMsg
		FilterSpec
		FilterRequestMsg
		FilterStatus
		FilterResponse
		FilterResponseMsg
		FilterDeleteRequest
		FilterDeleteRequestMsg
		FilterDeleteResponse
		FilterDeleteResponseMsg
		FilterGetRequest
		FilterGetRequestMsg
		FilterGetResponse
		FilterGetResponseMsg
		EplearnDhcpCfg
		EplearnArpCfg
		EplearnDataPacketCfg
		EplearnCfg
		ArpStats
		DhcpStats
		L2EplearnStats
		DhcpStatus
		ArpStatus
		EplearnStats
		EplearnStatus
		EventRequest
		EventResponse
		Event
		FWEvent
		LifQStateMapEntry
		PktFilter
		BcastPktFilter
		McastPktFilter
		LifSpec
		LifRequestMsg
		LifStatus
		LifQState
		LifRdmaData
		LifResponse
		LifResponseMsg
		QStateGetReq
		GetQStateRequestMsg
		QStateGetResp
		GetQStateResponseMsg
		P4ProgLabel
		QStateSetReq
		SetQStateRequestMsg
		QStateSetResp
		SetQStateResponseMsg
		LifDeleteRequest
		LifDeleteRequestMsg
		LifDeleteResponse
		LifDeleteResponseMsg
		LifTxStats
		LifRxStats
		DataLifStats
		CpuQueueStats
		CpuLifStats
		LifStats
		LifGetRequest
		LifGetRequestMsg
		LifGetResponse
		LifGetResponseMsg
		LifRssSpec
		EnicInfo
		EnicClassicInfo
		IfEnicInfo
		IfUplinkInfo
		IfUplinkPCInfo
		IfTunnelVxlanInfo
		IfTunnelGREInfo
		IfTunnelProprietaryMpls
		IfTunnelInfo
		IfCPUInfo
		IfAppRedirInfo
		InterfaceSpec
		InterfaceRequestMsg
		UplinkResponseInfo
		EnicL2SegInfo
		SmartEnicInfo
		ClassicEnicInfo
		EnicResponseInfo
		CpuIfResponseInfo
		TunnelIfResponseInfo
		AppRedirIfInfo
		InterfaceStatus
		InterfaceResponse
		InterfaceResponseMsg
		InterfaceDeleteRequest
		InterfaceDeleteRequestMsg
		InterfaceDeleteResponse
		InterfaceDeleteResponseMsg
		InterfaceStats
		InterfaceGetRequest
		InterfaceGetRequestMsg
		InterfaceGetResponse
		InterfaceGetResponseMsg
		InterfaceL2SegmentSpec
		InterfaceL2SegmentRequestMsg
		InterfaceL2SegmentResponse
		InterfaceL2SegmentResponseMsg
		SecurityProfileKeyHandle
		CollectorKeyHandle
		ExportControlKeyHandle
		FlowMonitorRuleKeyHandle
		DropMonitorRuleKeyHandle
		MirrorSessionKeyHandle
		VrfKeyHandle
		NetworkKey
		NetworkKeyHandle
		NexthopKeyHandle
		RouteKey
		RouteKeyHandle
		L2SegmentKeyHandle
		SecurityPolicyKey
		SecurityPolicyKeyHandle
		SecurityGroupPolicyId
		SecurityGroupPolicyKeyHandle
		SecurityGroupKeyHandle
		PortKeyHandle
		LifKeyHandle
		InterfaceKeyHandle
		EndpointL2Key
		EndpointL3Key
		EndpointKey
		EndpointKeyHandle
		FilterKey
		FilterKeyHandle
		MulticastEntryKeyIP
		MulticastEntryKeyMac
		MulticastEntryKey
		MulticastEntryKeyHandle
		AclKeyHandle
		GftExactMatchProfileKeyHandle
		GftHeaderTranspositionProfileKeyHandle
		GftExactMatchFlowEntryKeyHandle
		NatPoolKey
		NatPoolKeyHandle
		NATPolicyKey
		NatPolicyKeyHandle
		Svc
		NatMappingKeyHandle
		IPSecRuleKey
		IpsecRuleKeyHandle
		IpsecSAEncryptKeyHandle
		IpsecSADecryptKeyHandle
		TcpProxyRuleKey
		TcpProxyRuleKeyHandle
		QosClassKeyHandle
		CoppKeyHandle
		AppKeyHandle
		L2SegmentSpec
		L2SegmentRequestMsg
		L2SegmentStatusEpd
		L2SegmentStatusCpd
		L2SegmentStatus
		L2SegmentResponse
		L2SegmentResponseMsg
		L2SegmentDeleteRequest
		L2SegmentDeleteRequestMsg
		L2SegmentDeleteResponse
		L2SegmentDeleteResponseMsg
		L2SegmentGetRequest
		L2SegmentGetRequestMsg
		L2SegmentStats
		L2SegmentGetResponse
		L2SegmentGetResponseMsg
		Oif
		OifListEpd
		OifListCpd
		OifList
		MulticastEntryStatusEpd
		MulticastEntryStatusCpd
		MulticastEntryStatus
		MulticastEntrySpec
		MulticastEntryRequestMsg
		MulticastEntryResponse
		MulticastEntryResponseMsg
		MulticastEntryDeleteRequest
		MulticastEntryDeleteRequestMsg
		MulticastEntryDeleteResponse
		MulticastEntryDeleteResponseMsg
		MulticastEntryGetRequest
		MulticastEntryGetRequestMsg
		MulticastEntryStats
		MulticastEntryGetResponse
		MulticastEntryGetResponseMsg
		SecurityProfileSpec
		SecurityProfileRequestMsg
		SecurityProfileStatusEpd
		SecurityProfileStatusCpd
		SecurityProfileStatus
		SecurityProfileResponse
		SecurityProfileResponseMsg
		SecurityProfileDeleteRequest
		SecurityProfileDeleteRequestMsg
		SecurityProfileDeleteResponse
		SecurityProfileDeleteResponseMsg
		SecurityProfileGetRequest
		SecurityProfileGetRequestMsg
		SecurityProfileStats
		SecurityProfileGetResponse
		SecurityProfileGetResponseMsg
		Service
		FirewallRuleSpec
		NetworkSecurityPolicy
		SecurityGroupPolicySpec
		SecurityGroupPolicyRequestMsg
		SecurityGroupPolicyStatus
		SecurityGroupPolicyResponse
		SecurityGroupPolicyResponseMsg
		SecurityGroupPolicyDeleteRequest
		SecurityGroupPolicyDeleteRequestMsg
		SecurityGroupPolicyDeleteResponse
		SecurityGroupPolicyDeleteResponseMsg
		SecurityGroupPolicyGetRequest
		SecurityGroupPolicyGetRequestMsg
		SecurityGroupPolicyStats
		SecurityGroupPolicyGetResponse
		SecurityGroupPolicyGetResponseMsg
		SecurityGroupSpec
		SecurityGroupRequestMsg
		SecurityGroupStatus
		SecurityGroupResponse
		SecurityGroupResponseMsg
		SecurityGroupDeleteRequest
		SecurityGroupDeleteRequestMsg
		SecurityGroupDeleteResponseMsg
		SecurityGroupGetRequest
		SecurityGroupGetRequestMsg
		SecurityGroupStats
		SecurityGroupGetResponse
		SecurityGroupGetResponseMsg
		AppData
		SecurityRuleAction
		SecurityRule
		SecurityPolicySpec
		SecurityPolicyRequestMsg
		SecurityRuleStatus
		SecurityPolicyStatus
		SecurityPolicyResponse
		SecurityPolicyResponseMsg
		SecurityPolicyDeleteRequest
		SecurityPolicyDeleteRequestMsg
		SecurityPolicyDeleteResponse
		SecurityPolicyDeleteResponseMsg
		SecurityPolicyGetRequest
		SecurityPolicyGetRequestMsg
		SecurityRuleStats
		SecurityPolicyStats
		SecurityPolicyGetResponse
		SecurityPolicyGetResponseMsg
		SecurityFlowGateFilter
		SecurityFlowGateGetRequest
		SecurityFlowGateGetRequestMsg
		FlowGateKey
		SecurityFlowGateGetResponse
		SecurityFlowGateGetResponseMsg
		SecurityFlowGateDeleteRequest
		SecurityFlowGateDeleteRequestMsg
		SecurityFlowGateDeleteResponseMsg
		PortXcvrStatus
		PortSpec
		PortLinkStatus
		PortStatus
		PortRequestMsg
		PortResponse
		PortResponseMsg
		PortDeleteRequest
		PortDeleteRequestMsg
		PortDeleteResponse
		PortDeleteResponseMsg
		MgmtMacStats
		MacStats
		TimeDuration
		LinkTimingInfo
		PortStats
		PortGetRequest
		PortGetRequestMsg
		PortGetResponse
		PortGetResponseMsg
		PortInfoGetRequest
		PortInfoGetRequestMsg
		PortInfoSpec
		PortInfoGetResponse
		PortInfoGetResponseMsg
		PortEvent
		AacsRequestMsg
		PolicerPPSSpec
		PolicerBPSSpec
		PolicerSpec
		PolicerStats
		QosPause
		QosSched
		QosClassMap
		QosMarking
		QosClassSpec
		QosClassRequestMsg
		PacketBufferPort
		QosClassPortStatus
		QosClassStatusEpd
		QosClassStatusCpd
		QosClassStatus
		QosClassResponse
		QosClassResponseMsg
		QosClassDeleteRequest
		QosClassDeleteRequestMsg
		QosClassDeleteResponse
		QosClassDeleteResponseMsg
		QosClassInputOflowQueueStats
		QosClassInputQueueStats
		QosClassOutputQueueStats
		QosClassQueueStats
		QosClassPortStats
		QosClassStats
		QosClassGetRequest
		QosClassGetRequestMsg
		QosClassGetResponse
		OccupancyPerQueue
		PortOccupancy
		Thresholds
		QosClassThresholdsGetResponse
		QosClassThresholdsGetResponseMsg
		QosClassThresholdsGetRequest
		QosClassThresholdsGetRequestMsg
		QosClassGetResponseMsg
		QosClassSetGlobalPauseTypeRequest
		QosClassSetGlobalPauseTypeRequestMsg
		QosClassSetGlobalPauseTypeResponseMsg
		CoppSpec
		CoppRequestMsg
		CoppStatusEpd
		CoppStatusCpd
		CoppStatus
		CoppResponse
		CoppResponseMsg
		CoppDeleteRequest
		CoppDeleteRequestMsg
		CoppDeleteResponse
		CoppDeleteResponseMsg
		CoppStats
		CoppGetRequest
		CoppGetRequestMsg
		CoppGetResponse
		CoppGetResponseMsg
		ApiStatsEntry
		ApiStatsResponse
		DropStatsEntry
		EgressDropStatsEntry
		BufferDropStatsEntry
		BufferDropStats
		TableStatsEntry
		TableStats
		BufferStats
		OflowFifoDropStatsEntry
		OflowFifoDropStats
		OflowFifoStats
		PacketBufferPortStats
		PacketBufferStats
		Status
		SystemGetRequest
		SystemResponse
		Stats
		DropStats
		EgressDropStats
		FTEError
		FTEFeatureStats
		FTEStatsInfo
		FTEStats
		SessionSummaryStats
		QCtr
		QGlobalInfo
		QInfo
		FTEInfo
		PMDStats
		ForwardingModeResponse
		FeatureProfileResponse
		MicroSegEvent
		MicroSegSpec
		MicroSegRequestMsg
		MicroSegResponse
		MicroSegResponseMsg
		MicroSegUpdateRequest
		MicroSegUpdateRequestMsg
		MicroSegUpdateResponse
		MicroSegUpdateResponseMsg
		SysSpec
		SysSpecStatus
		SysSpecResponse
		CollectorSpec
		CollectorStatus
		CollectorResponse
		CollectorRequestMsg
		CollectorResponseMsg
		CollectorDeleteRequest
		CollectorDeleteResponse
		CollectorDeleteRequestMsg
		CollectorDeleteResponseMsg
		CollectorGetRequest
		CollectorGetRequestMsg
		CollectorGetResponse
		CollectorGetResponseMsg
		CollectorStats
		MonitorAction
		FlowMonitorRuleSpec
		FlowMonitorRuleStatus
		FlowMonitorRuleResponse
		FlowMonitorRuleRequestMsg
		FlowMonitorRuleResponseMsg
		FlowMonitorRuleDeleteRequest
		FlowMonitorRuleDeleteResponse
		FlowMonitorRuleDeleteRequestMsg
		FlowMonitorRuleDeleteResponseMsg
		FlowMonitorRuleGetRequest
		FlowMonitorRuleGetRequestMsg
		FlowMonitorRuleStats
		FlowMonitorRuleGetResponse
		FlowMonitorRuleGetResponseMsg
		DropMonitorRuleSpec
		DropMonitorRuleStatus
		DropMonitorRuleResponse
		DropMonitorRuleRequestMsg
		DropMonitorRuleResponseMsg
		DropMonitorRuleDeleteRequest
		DropMonitorRuleDeleteResponse
		DropMonitorRuleDeleteRequestMsg
		DropMonitorRuleDeleteResponseMsg
		DropMonitorRuleGetRequest
		DropMonitorRuleGetRequestMsg
		DropMonitorRuleStats
		DropMonitorRuleGetResponse
		DropMonitorRuleGetResponseMsg
		RSpanSpec
		ERSpanSpec
		MirrorSessionSpec
		MirrorSessionStatus
		MirrorSessionResponse
		MirrorSessionRequestMsg
		MirrorSessionResponseMsg
		MirrorSessionDeleteRequest
		MirrorSessionDeleteResponse
		MirrorSessionDeleteRequestMsg
		MirrorSessionDeleteResponseMsg
		MirrorSessionGetRequest
		MirrorSessionGetRequestMsg
		MirrorSessionStats
		MirrorSessionGetResponse
		MirrorSessionGetResponseMsg
		ObjectMeta
		MplsTag
		EncapInfo
		IPAddress
		IPRange
		IPPrefix
		IPSubnet
		AddressRange
		Address
		IPAddressObj
		L4PortRange
		Empty
		DropReasons
		EgressDropReasons
		RuleMatch
		VrfSpec
		VrfRequestMsg
		VrfStatusEpd
		VrfStatusCpd
		VrfStatus
		VrfResponse
		VrfResponseMsg
		VrfDeleteRequest
		VrfDeleteResponse
		VrfDeleteRequestMsg
		VrfDeleteResponseMsg
		VrfGetRequest
		VrfGetRequestMsg
		VrfStats
		VrfGetResponse
		VrfGetResponseMsg
*/
package halproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import delphi "github.com/pensando/sw/nic/delphi/proto/delphi"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EndpointVmotionState int32

const (
	EndpointVmotionState_VMOTION_STATE_NONE   EndpointVmotionState = 0
	EndpointVmotionState_VMOTION_STATE_START  EndpointVmotionState = 1
	EndpointVmotionState_VMOTION_STATE_FAILED EndpointVmotionState = 2
	EndpointVmotionState_VMOTION_STATE_DONE   EndpointVmotionState = 3
)

var EndpointVmotionState_name = map[int32]string{
	0: "VMOTION_STATE_NONE",
	1: "VMOTION_STATE_START",
	2: "VMOTION_STATE_FAILED",
	3: "VMOTION_STATE_DONE",
}
var EndpointVmotionState_value = map[string]int32{
	"VMOTION_STATE_NONE":   0,
	"VMOTION_STATE_START":  1,
	"VMOTION_STATE_FAILED": 2,
	"VMOTION_STATE_DONE":   3,
}

func (x EndpointVmotionState) String() string {
	return proto.EnumName(EndpointVmotionState_name, int32(x))
}
func (EndpointVmotionState) EnumDescriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{0} }

type EndpointVmotion struct {
	VmotionState      EndpointVmotionState `protobuf:"varint,1,opt,name=vmotion_state,json=vmotionState,proto3,enum=endpoint.EndpointVmotionState" json:"vmotion_state,omitempty"`
	SourceHostIp      *IPAddress           `protobuf:"bytes,2,opt,name=source_host_ip,json=sourceHostIp" json:"source_host_ip,omitempty"`
	DestinationHostIp *IPAddress           `protobuf:"bytes,3,opt,name=destination_host_ip,json=destinationHostIp" json:"destination_host_ip,omitempty"`
}

func (m *EndpointVmotion) Reset()                    { *m = EndpointVmotion{} }
func (m *EndpointVmotion) String() string            { return proto.CompactTextString(m) }
func (*EndpointVmotion) ProtoMessage()               {}
func (*EndpointVmotion) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{0} }

func (m *EndpointVmotion) GetVmotionState() EndpointVmotionState {
	if m != nil {
		return m.VmotionState
	}
	return EndpointVmotionState_VMOTION_STATE_NONE
}

func (m *EndpointVmotion) GetSourceHostIp() *IPAddress {
	if m != nil {
		return m.SourceHostIp
	}
	return nil
}

func (m *EndpointVmotion) GetDestinationHostIp() *IPAddress {
	if m != nil {
		return m.DestinationHostIp
	}
	return nil
}

type EndpointAttributes struct {
	InterfaceKeyHandle *InterfaceKeyHandle       `protobuf:"bytes,1,opt,name=interface_key_handle,json=interfaceKeyHandle" json:"interface_key_handle,omitempty" venice:ref`
	UsegVlan           uint32                    `protobuf:"varint,2,opt,name=useg_vlan,json=usegVlan,proto3" json:"useg_vlan,omitempty"`
	IpAddress          []*IPAddress              `protobuf:"bytes,3,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	SgKeyHandle        []*SecurityGroupKeyHandle `protobuf:"bytes,4,rep,name=sg_key_handle,json=sgKeyHandle" json:"sg_key_handle,omitempty" venice:ref`
	HomingHostIp       *IPAddress                `protobuf:"bytes,5,opt,name=homing_host_ip,json=homingHostIp" json:"homing_host_ip,omitempty"`
	VmotionAttrs       *EndpointVmotion          `protobuf:"bytes,6,opt,name=vmotion_attrs,json=vmotionAttrs" json:"vmotion_attrs,omitempty"`
}

func (m *EndpointAttributes) Reset()                    { *m = EndpointAttributes{} }
func (m *EndpointAttributes) String() string            { return proto.CompactTextString(m) }
func (*EndpointAttributes) ProtoMessage()               {}
func (*EndpointAttributes) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{1} }

func (m *EndpointAttributes) GetInterfaceKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.InterfaceKeyHandle
	}
	return nil
}

func (m *EndpointAttributes) GetUsegVlan() uint32 {
	if m != nil {
		return m.UsegVlan
	}
	return 0
}

func (m *EndpointAttributes) GetIpAddress() []*IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointAttributes) GetSgKeyHandle() []*SecurityGroupKeyHandle {
	if m != nil {
		return m.SgKeyHandle
	}
	return nil
}

func (m *EndpointAttributes) GetHomingHostIp() *IPAddress {
	if m != nil {
		return m.HomingHostIp
	}
	return nil
}

func (m *EndpointAttributes) GetVmotionAttrs() *EndpointVmotion {
	if m != nil {
		return m.VmotionAttrs
	}
	return nil
}

// EndpointSpec is used to add or update an endpoint
type EndpointSpec struct {
	Meta          *delphi.ObjectMeta  `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle   *EndpointKeyHandle  `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle  *VrfKeyHandle       `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	EndpointAttrs *EndpointAttributes `protobuf:"bytes,4,opt,name=endpoint_attrs,json=endpointAttrs" json:"endpoint_attrs,omitempty"`
}

func (m *EndpointSpec) Reset()                    { *m = EndpointSpec{} }
func (m *EndpointSpec) String() string            { return proto.CompactTextString(m) }
func (*EndpointSpec) ProtoMessage()               {}
func (*EndpointSpec) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{2} }

func (m *EndpointSpec) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointSpec) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointSpec) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointSpec) GetEndpointAttrs() *EndpointAttributes {
	if m != nil {
		return m.EndpointAttrs
	}
	return nil
}

// EndpointRequestMsg is batched add or modify endpoint request
type EndpointRequestMsg struct {
	Request []*EndpointSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointRequestMsg) Reset()                    { *m = EndpointRequestMsg{} }
func (m *EndpointRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointRequestMsg) ProtoMessage()               {}
func (*EndpointRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{3} }

func (m *EndpointRequestMsg) GetRequest() []*EndpointSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// Endpoint IP address information.
type EndpointIpAddress struct {
	IpAddress         *IPAddress     `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	LearnSourceDhcp   bool           `protobuf:"varint,2,opt,name=learn_source_dhcp,json=learnSourceDhcp,proto3" json:"learn_source_dhcp,omitempty"`
	LearnSourceArp    bool           `protobuf:"varint,3,opt,name=learn_source_arp,json=learnSourceArp,proto3" json:"learn_source_arp,omitempty"`
	LearnSourceRarp   bool           `protobuf:"varint,4,opt,name=learn_source_rarp,json=learnSourceRarp,proto3" json:"learn_source_rarp,omitempty"`
	LearnSourceConfig bool           `protobuf:"varint,5,opt,name=learn_source_config,json=learnSourceConfig,proto3" json:"learn_source_config,omitempty"`
	LearnStatus       *EplearnStatus `protobuf:"bytes,6,opt,name=learn_status,json=learnStatus" json:"learn_status,omitempty"`
	IpsgTblIdx        uint32         `protobuf:"varint,7,opt,name=ipsg_tbl_idx,json=ipsgTblIdx,proto3" json:"ipsg_tbl_idx,omitempty"`
}

func (m *EndpointIpAddress) Reset()                    { *m = EndpointIpAddress{} }
func (m *EndpointIpAddress) String() string            { return proto.CompactTextString(m) }
func (*EndpointIpAddress) ProtoMessage()               {}
func (*EndpointIpAddress) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{4} }

func (m *EndpointIpAddress) GetIpAddress() *IPAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointIpAddress) GetLearnSourceDhcp() bool {
	if m != nil {
		return m.LearnSourceDhcp
	}
	return false
}

func (m *EndpointIpAddress) GetLearnSourceArp() bool {
	if m != nil {
		return m.LearnSourceArp
	}
	return false
}

func (m *EndpointIpAddress) GetLearnSourceRarp() bool {
	if m != nil {
		return m.LearnSourceRarp
	}
	return false
}

func (m *EndpointIpAddress) GetLearnSourceConfig() bool {
	if m != nil {
		return m.LearnSourceConfig
	}
	return false
}

func (m *EndpointIpAddress) GetLearnStatus() *EplearnStatus {
	if m != nil {
		return m.LearnStatus
	}
	return nil
}

func (m *EndpointIpAddress) GetIpsgTblIdx() uint32 {
	if m != nil {
		return m.IpsgTblIdx
	}
	return 0
}

type EndpointStatusEpd struct {
	RegMacTblIdx uint32   `protobuf:"varint,1,opt,name=reg_mac_tbl_idx,json=regMacTblIdx,proto3" json:"reg_mac_tbl_idx,omitempty"`
	RwTblIdx     []uint32 `protobuf:"varint,2,rep,packed,name=rw_tbl_idx,json=rwTblIdx" json:"rw_tbl_idx,omitempty"`
}

func (m *EndpointStatusEpd) Reset()                    { *m = EndpointStatusEpd{} }
func (m *EndpointStatusEpd) String() string            { return proto.CompactTextString(m) }
func (*EndpointStatusEpd) ProtoMessage()               {}
func (*EndpointStatusEpd) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{5} }

func (m *EndpointStatusEpd) GetRegMacTblIdx() uint32 {
	if m != nil {
		return m.RegMacTblIdx
	}
	return 0
}

func (m *EndpointStatusEpd) GetRwTblIdx() []uint32 {
	if m != nil {
		return m.RwTblIdx
	}
	return nil
}

type EndpointStatusCpd struct {
}

func (m *EndpointStatusCpd) Reset()                    { *m = EndpointStatusCpd{} }
func (m *EndpointStatusCpd) String() string            { return proto.CompactTextString(m) }
func (*EndpointStatusCpd) ProtoMessage()               {}
func (*EndpointStatusCpd) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{6} }

// EndpointStatus has the current status of an endpoint
// TODO: capturing aging information, if any
type EndpointStatus struct {
	Meta                        *delphi.ObjectMeta   `protobuf:"bytes,1,opt,name=Meta" json:"Meta,omitempty"`
	KeyOrHandle                 *EndpointKeyHandle   `protobuf:"bytes,2,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	EnicPinnedUplinkIfKeyHandle *InterfaceKeyHandle  `protobuf:"bytes,3,opt,name=enic_pinned_uplink_if_key_handle,json=enicPinnedUplinkIfKeyHandle" json:"enic_pinned_uplink_if_key_handle,omitempty" venice:ref`
	IpAddress                   []*EndpointIpAddress `protobuf:"bytes,4,rep,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	IsEndpointLocal             bool                 `protobuf:"varint,5,opt,name=is_endpoint_local,json=isEndpointLocal,proto3" json:"is_endpoint_local,omitempty"`
	LearnSourceConfig           bool                 `protobuf:"varint,6,opt,name=learn_source_config,json=learnSourceConfig,proto3" json:"learn_source_config,omitempty"`
	// Types that are valid to be assigned to EpPdStatus:
	//	*EndpointStatus_EpdStatus
	//	*EndpointStatus_CpdStatus
	EpPdStatus isEndpointStatus_EpPdStatus `protobuf_oneof:"ep_pd_status"`
}

func (m *EndpointStatus) Reset()                    { *m = EndpointStatus{} }
func (m *EndpointStatus) String() string            { return proto.CompactTextString(m) }
func (*EndpointStatus) ProtoMessage()               {}
func (*EndpointStatus) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{7} }

type isEndpointStatus_EpPdStatus interface {
	isEndpointStatus_EpPdStatus()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EndpointStatus_EpdStatus struct {
	EpdStatus *EndpointStatusEpd `protobuf:"bytes,7,opt,name=epd_status,json=epdStatus,oneof"`
}
type EndpointStatus_CpdStatus struct {
	CpdStatus *EndpointStatusCpd `protobuf:"bytes,8,opt,name=cpd_status,json=cpdStatus,oneof"`
}

func (*EndpointStatus_EpdStatus) isEndpointStatus_EpPdStatus() {}
func (*EndpointStatus_CpdStatus) isEndpointStatus_EpPdStatus() {}

func (m *EndpointStatus) GetEpPdStatus() isEndpointStatus_EpPdStatus {
	if m != nil {
		return m.EpPdStatus
	}
	return nil
}

func (m *EndpointStatus) GetMeta() *delphi.ObjectMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *EndpointStatus) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointStatus) GetEnicPinnedUplinkIfKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.EnicPinnedUplinkIfKeyHandle
	}
	return nil
}

func (m *EndpointStatus) GetIpAddress() []*EndpointIpAddress {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *EndpointStatus) GetIsEndpointLocal() bool {
	if m != nil {
		return m.IsEndpointLocal
	}
	return false
}

func (m *EndpointStatus) GetLearnSourceConfig() bool {
	if m != nil {
		return m.LearnSourceConfig
	}
	return false
}

func (m *EndpointStatus) GetEpdStatus() *EndpointStatusEpd {
	if x, ok := m.GetEpPdStatus().(*EndpointStatus_EpdStatus); ok {
		return x.EpdStatus
	}
	return nil
}

func (m *EndpointStatus) GetCpdStatus() *EndpointStatusCpd {
	if x, ok := m.GetEpPdStatus().(*EndpointStatus_CpdStatus); ok {
		return x.CpdStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointStatus_OneofMarshaler, _EndpointStatus_OneofUnmarshaler, _EndpointStatus_OneofSizer, []interface{}{
		(*EndpointStatus_EpdStatus)(nil),
		(*EndpointStatus_CpdStatus)(nil),
	}
}

func _EndpointStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointStatus)
	// ep_pd_status
	switch x := m.EpPdStatus.(type) {
	case *EndpointStatus_EpdStatus:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EpdStatus); err != nil {
			return err
		}
	case *EndpointStatus_CpdStatus:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CpdStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndpointStatus.EpPdStatus has unexpected type %T", x)
	}
	return nil
}

func _EndpointStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointStatus)
	switch tag {
	case 7: // ep_pd_status.epd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointStatusEpd)
		err := b.DecodeMessage(msg)
		m.EpPdStatus = &EndpointStatus_EpdStatus{msg}
		return true, err
	case 8: // ep_pd_status.cpd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointStatusCpd)
		err := b.DecodeMessage(msg)
		m.EpPdStatus = &EndpointStatus_CpdStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointStatus)
	// ep_pd_status
	switch x := m.EpPdStatus.(type) {
	case *EndpointStatus_EpdStatus:
		s := proto.Size(x.EpdStatus)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointStatus_CpdStatus:
		s := proto.Size(x.CpdStatus)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EndpointResponse is response to EndpointSpec
type EndpointResponse struct {
	ApiStatus      ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	EndpointStatus *EndpointStatus `protobuf:"bytes,2,opt,name=endpoint_status,json=endpointStatus" json:"endpoint_status,omitempty"`
}

func (m *EndpointResponse) Reset()                    { *m = EndpointResponse{} }
func (m *EndpointResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointResponse) ProtoMessage()               {}
func (*EndpointResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{8} }

func (m *EndpointResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EndpointResponse) GetEndpointStatus() *EndpointStatus {
	if m != nil {
		return m.EndpointStatus
	}
	return nil
}

// EndpointResponseMsg is batched response to EndpointRequestMsg
type EndpointResponseMsg struct {
	Response []*EndpointResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointResponseMsg) Reset()                    { *m = EndpointResponseMsg{} }
func (m *EndpointResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointResponseMsg) ProtoMessage()               {}
func (*EndpointResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{9} }

func (m *EndpointResponseMsg) GetResponse() []*EndpointResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Endpoint Update message
type EndpointUpdateRequest struct {
	// key_or_handle is used to identify an endpoint uniquely
	KeyOrHandle   *EndpointKeyHandle  `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle  *VrfKeyHandle       `protobuf:"bytes,2,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	EndpointAttrs *EndpointAttributes `protobuf:"bytes,3,opt,name=endpoint_attrs,json=endpointAttrs" json:"endpoint_attrs,omitempty"`
}

func (m *EndpointUpdateRequest) Reset()                    { *m = EndpointUpdateRequest{} }
func (m *EndpointUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointUpdateRequest) ProtoMessage()               {}
func (*EndpointUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{10} }

func (m *EndpointUpdateRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointUpdateRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointUpdateRequest) GetEndpointAttrs() *EndpointAttributes {
	if m != nil {
		return m.EndpointAttrs
	}
	return nil
}

// EndpointUpdateRequestMsg is batched endpoint update request
type EndpointUpdateRequestMsg struct {
	Request []*EndpointUpdateRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointUpdateRequestMsg) Reset()         { *m = EndpointUpdateRequestMsg{} }
func (m *EndpointUpdateRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointUpdateRequestMsg) ProtoMessage()    {}
func (*EndpointUpdateRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{11}
}

func (m *EndpointUpdateRequestMsg) GetRequest() []*EndpointUpdateRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// EndpointUpdateResponseMsg is used to update a batch of Endpoints
type EndpointUpdateResponseMsg struct {
	Response []*EndpointResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointUpdateResponseMsg) Reset()         { *m = EndpointUpdateResponseMsg{} }
func (m *EndpointUpdateResponseMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointUpdateResponseMsg) ProtoMessage()    {}
func (*EndpointUpdateResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{12}
}

func (m *EndpointUpdateResponseMsg) GetResponse() []*EndpointResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// EndpointFilter is attributes by which endpoints can be manipulated
// or queried. As the endpoint database can be huge, this is provided
// so that agent and HAL are less chatty when doing bulk deletes (e.g.
// when a L2 segment is deleted or interfae goes down etc.)
type EndpointFilter struct {
	VrfKeyHandle       *VrfKeyHandle       `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	InterfaceKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=interface_key_handle,json=interfaceKeyHandle" json:"interface_key_handle,omitempty" venice:ref`
	L2SegmentKeyHandle *L2SegmentKeyHandle `protobuf:"bytes,3,opt,name=l2Segment_key_handle,json=l2SegmentKeyHandle" json:"l2Segment_key_handle,omitempty" venice:ref`
}

func (m *EndpointFilter) Reset()                    { *m = EndpointFilter{} }
func (m *EndpointFilter) String() string            { return proto.CompactTextString(m) }
func (*EndpointFilter) ProtoMessage()               {}
func (*EndpointFilter) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{13} }

func (m *EndpointFilter) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointFilter) GetInterfaceKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.InterfaceKeyHandle
	}
	return nil
}

func (m *EndpointFilter) GetL2SegmentKeyHandle() *L2SegmentKeyHandle {
	if m != nil {
		return m.L2SegmentKeyHandle
	}
	return nil
}

// EndpointDeleteRequest is used to delete an endpoint
type EndpointDeleteRequest struct {
	// Types that are valid to be assigned to DeleteBy:
	//	*EndpointDeleteRequest_KeyOrHandle
	//	*EndpointDeleteRequest_Filter
	DeleteBy     isEndpointDeleteRequest_DeleteBy `protobuf_oneof:"delete_by"`
	VrfKeyHandle *VrfKeyHandle                    `protobuf:"bytes,3,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
}

func (m *EndpointDeleteRequest) Reset()                    { *m = EndpointDeleteRequest{} }
func (m *EndpointDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointDeleteRequest) ProtoMessage()               {}
func (*EndpointDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{14} }

type isEndpointDeleteRequest_DeleteBy interface {
	isEndpointDeleteRequest_DeleteBy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EndpointDeleteRequest_KeyOrHandle struct {
	KeyOrHandle *EndpointKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle,oneof"`
}
type EndpointDeleteRequest_Filter struct {
	Filter *EndpointFilter `protobuf:"bytes,2,opt,name=filter,oneof"`
}

func (*EndpointDeleteRequest_KeyOrHandle) isEndpointDeleteRequest_DeleteBy() {}
func (*EndpointDeleteRequest_Filter) isEndpointDeleteRequest_DeleteBy()      {}

func (m *EndpointDeleteRequest) GetDeleteBy() isEndpointDeleteRequest_DeleteBy {
	if m != nil {
		return m.DeleteBy
	}
	return nil
}

func (m *EndpointDeleteRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if x, ok := m.GetDeleteBy().(*EndpointDeleteRequest_KeyOrHandle); ok {
		return x.KeyOrHandle
	}
	return nil
}

func (m *EndpointDeleteRequest) GetFilter() *EndpointFilter {
	if x, ok := m.GetDeleteBy().(*EndpointDeleteRequest_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *EndpointDeleteRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EndpointDeleteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EndpointDeleteRequest_OneofMarshaler, _EndpointDeleteRequest_OneofUnmarshaler, _EndpointDeleteRequest_OneofSizer, []interface{}{
		(*EndpointDeleteRequest_KeyOrHandle)(nil),
		(*EndpointDeleteRequest_Filter)(nil),
	}
}

func _EndpointDeleteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EndpointDeleteRequest)
	// delete_by
	switch x := m.DeleteBy.(type) {
	case *EndpointDeleteRequest_KeyOrHandle:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KeyOrHandle); err != nil {
			return err
		}
	case *EndpointDeleteRequest_Filter:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Filter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EndpointDeleteRequest.DeleteBy has unexpected type %T", x)
	}
	return nil
}

func _EndpointDeleteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EndpointDeleteRequest)
	switch tag {
	case 1: // delete_by.key_or_handle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointKeyHandle)
		err := b.DecodeMessage(msg)
		m.DeleteBy = &EndpointDeleteRequest_KeyOrHandle{msg}
		return true, err
	case 2: // delete_by.filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndpointFilter)
		err := b.DecodeMessage(msg)
		m.DeleteBy = &EndpointDeleteRequest_Filter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EndpointDeleteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EndpointDeleteRequest)
	// delete_by
	switch x := m.DeleteBy.(type) {
	case *EndpointDeleteRequest_KeyOrHandle:
		s := proto.Size(x.KeyOrHandle)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EndpointDeleteRequest_Filter:
		s := proto.Size(x.Filter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// EndpointDeleteRequestMsg is batched endpoint delete request
type EndpointDeleteRequestMsg struct {
	Request []*EndpointDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointDeleteRequestMsg) Reset()         { *m = EndpointDeleteRequestMsg{} }
func (m *EndpointDeleteRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointDeleteRequestMsg) ProtoMessage()    {}
func (*EndpointDeleteRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{15}
}

func (m *EndpointDeleteRequestMsg) GetRequest() []*EndpointDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type EndpointDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *EndpointDeleteResponse) Reset()                    { *m = EndpointDeleteResponse{} }
func (m *EndpointDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointDeleteResponse) ProtoMessage()               {}
func (*EndpointDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{16} }

func (m *EndpointDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// EndpointDeleteResponseMsg is used to delete a batch of Endpoints
type EndpointDeleteResponseMsg struct {
	Response []*EndpointDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointDeleteResponseMsg) Reset()         { *m = EndpointDeleteResponseMsg{} }
func (m *EndpointDeleteResponseMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointDeleteResponseMsg) ProtoMessage()    {}
func (*EndpointDeleteResponseMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{17}
}

func (m *EndpointDeleteResponseMsg) GetResponse() []*EndpointDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// EndpointGetRequest is used to get information about an endpoint
type EndpointGetRequest struct {
	// key_or_handle is the endpoint's identifier for retrieval
	KeyOrHandle  *EndpointKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
	VrfKeyHandle *VrfKeyHandle      `protobuf:"bytes,2,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
}

func (m *EndpointGetRequest) Reset()                    { *m = EndpointGetRequest{} }
func (m *EndpointGetRequest) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetRequest) ProtoMessage()               {}
func (*EndpointGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{18} }

func (m *EndpointGetRequest) GetKeyOrHandle() *EndpointKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

func (m *EndpointGetRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

// EndpointGetRequestMsg is batched GET request for endpoints
type EndpointGetRequestMsg struct {
	Request []*EndpointGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointGetRequestMsg) Reset()                    { *m = EndpointGetRequestMsg{} }
func (m *EndpointGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetRequestMsg) ProtoMessage()               {}
func (*EndpointGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{19} }

func (m *EndpointGetRequestMsg) GetRequest() []*EndpointGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type EndpointGetByInterfaceRequest struct {
	VrfKeyHandle       *VrfKeyHandle       `protobuf:"bytes,1,opt,name=vrf_key_handle,json=vrfKeyHandle" json:"vrf_key_handle,omitempty" venice:ref`
	InterfaceKeyHandle *InterfaceKeyHandle `protobuf:"bytes,2,opt,name=interface_key_handle,json=interfaceKeyHandle" json:"interface_key_handle,omitempty" venice:ref`
}

func (m *EndpointGetByInterfaceRequest) Reset()         { *m = EndpointGetByInterfaceRequest{} }
func (m *EndpointGetByInterfaceRequest) String() string { return proto.CompactTextString(m) }
func (*EndpointGetByInterfaceRequest) ProtoMessage()    {}
func (*EndpointGetByInterfaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{20}
}

func (m *EndpointGetByInterfaceRequest) GetVrfKeyHandle() *VrfKeyHandle {
	if m != nil {
		return m.VrfKeyHandle
	}
	return nil
}

func (m *EndpointGetByInterfaceRequest) GetInterfaceKeyHandle() *InterfaceKeyHandle {
	if m != nil {
		return m.InterfaceKeyHandle
	}
	return nil
}

// EndpointGetByInterfaceRequestMsg is used to GET endpoints by interface
type EndpointGetByInterfaceRequestMsg struct {
	Request []*EndpointGetByInterfaceRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *EndpointGetByInterfaceRequestMsg) Reset()         { *m = EndpointGetByInterfaceRequestMsg{} }
func (m *EndpointGetByInterfaceRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointGetByInterfaceRequestMsg) ProtoMessage()    {}
func (*EndpointGetByInterfaceRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{21}
}

func (m *EndpointGetByInterfaceRequestMsg) GetRequest() []*EndpointGetByInterfaceRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// EndpointGetAllRequestMsg is used to GET all the endpoints
type EndpointGetAllRequestMsg struct {
}

func (m *EndpointGetAllRequestMsg) Reset()         { *m = EndpointGetAllRequestMsg{} }
func (m *EndpointGetAllRequestMsg) String() string { return proto.CompactTextString(m) }
func (*EndpointGetAllRequestMsg) ProtoMessage()    {}
func (*EndpointGetAllRequestMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorEndpoint, []int{22}
}

// EndpointStats is the statistics object for each Endpoint
type EndpointStats struct {
	EpLearnStats *EplearnStats `protobuf:"bytes,1,opt,name=ep_learn_stats,json=epLearnStats" json:"ep_learn_stats,omitempty"`
}

func (m *EndpointStats) Reset()                    { *m = EndpointStats{} }
func (m *EndpointStats) String() string            { return proto.CompactTextString(m) }
func (*EndpointStats) ProtoMessage()               {}
func (*EndpointStats) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{23} }

func (m *EndpointStats) GetEpLearnStats() *EplearnStats {
	if m != nil {
		return m.EpLearnStats
	}
	return nil
}

// EndpointGetResponse captures all the information about one Endpoint
type EndpointGetResponse struct {
	ApiStatus ApiStatus       `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *EndpointSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *EndpointStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Stats     *EndpointStats  `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *EndpointGetResponse) Reset()                    { *m = EndpointGetResponse{} }
func (m *EndpointGetResponse) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetResponse) ProtoMessage()               {}
func (*EndpointGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{24} }

func (m *EndpointGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EndpointGetResponse) GetSpec() *EndpointSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *EndpointGetResponse) GetStatus() *EndpointStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *EndpointGetResponse) GetStats() *EndpointStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// EndpointGetResponseMsg is batched response to EndpointGetRequestMsg
type EndpointGetResponseMsg struct {
	ApiStatus ApiStatus              `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Response  []*EndpointGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *EndpointGetResponseMsg) Reset()                    { *m = EndpointGetResponseMsg{} }
func (m *EndpointGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*EndpointGetResponseMsg) ProtoMessage()               {}
func (*EndpointGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{25} }

func (m *EndpointGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *EndpointGetResponseMsg) GetResponse() []*EndpointGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// Filter Spec
type FilterSpec struct {
	KeyOrHandle *FilterKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *FilterSpec) Reset()                    { *m = FilterSpec{} }
func (m *FilterSpec) String() string            { return proto.CompactTextString(m) }
func (*FilterSpec) ProtoMessage()               {}
func (*FilterSpec) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{26} }

func (m *FilterSpec) GetKeyOrHandle() *FilterKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// Filter Request Message
type FilterRequestMsg struct {
	Request []*FilterSpec `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FilterRequestMsg) Reset()                    { *m = FilterRequestMsg{} }
func (m *FilterRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterRequestMsg) ProtoMessage()               {}
func (*FilterRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{27} }

func (m *FilterRequestMsg) GetRequest() []*FilterSpec {
	if m != nil {
		return m.Request
	}
	return nil
}

// FilterStatus has the current status of an endpoint
type FilterStatus struct {
	FilterHandle uint64 `protobuf:"fixed64,1,opt,name=filter_handle,json=filterHandle,proto3" json:"filter_handle,omitempty"`
}

func (m *FilterStatus) Reset()                    { *m = FilterStatus{} }
func (m *FilterStatus) String() string            { return proto.CompactTextString(m) }
func (*FilterStatus) ProtoMessage()               {}
func (*FilterStatus) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{28} }

func (m *FilterStatus) GetFilterHandle() uint64 {
	if m != nil {
		return m.FilterHandle
	}
	return 0
}

// FilterResponse is response to FilterSpec
type FilterResponse struct {
	ApiStatus    ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	FilterStatus *FilterStatus `protobuf:"bytes,2,opt,name=filter_status,json=filterStatus" json:"filter_status,omitempty"`
}

func (m *FilterResponse) Reset()                    { *m = FilterResponse{} }
func (m *FilterResponse) String() string            { return proto.CompactTextString(m) }
func (*FilterResponse) ProtoMessage()               {}
func (*FilterResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{29} }

func (m *FilterResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FilterResponse) GetFilterStatus() *FilterStatus {
	if m != nil {
		return m.FilterStatus
	}
	return nil
}

// FilterResponseMsg is batched response to FilterRequestMsg
type FilterResponseMsg struct {
	Response []*FilterResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *FilterResponseMsg) Reset()                    { *m = FilterResponseMsg{} }
func (m *FilterResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterResponseMsg) ProtoMessage()               {}
func (*FilterResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{30} }

func (m *FilterResponseMsg) GetResponse() []*FilterResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// FilterDeleteRequest is used to delete an filter
type FilterDeleteRequest struct {
	KeyOrHandle *FilterKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *FilterDeleteRequest) Reset()                    { *m = FilterDeleteRequest{} }
func (m *FilterDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteRequest) ProtoMessage()               {}
func (*FilterDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{31} }

func (m *FilterDeleteRequest) GetKeyOrHandle() *FilterKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// FilterDeleteRequestMsg is batched filter delete request
type FilterDeleteRequestMsg struct {
	Request []*FilterDeleteRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FilterDeleteRequestMsg) Reset()                    { *m = FilterDeleteRequestMsg{} }
func (m *FilterDeleteRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteRequestMsg) ProtoMessage()               {}
func (*FilterDeleteRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{32} }

func (m *FilterDeleteRequestMsg) GetRequest() []*FilterDeleteRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

type FilterDeleteResponse struct {
	ApiStatus ApiStatus `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
}

func (m *FilterDeleteResponse) Reset()                    { *m = FilterDeleteResponse{} }
func (m *FilterDeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteResponse) ProtoMessage()               {}
func (*FilterDeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{33} }

func (m *FilterDeleteResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

// FilterDeleteResponseMsg is used to delete a batch of Filters
type FilterDeleteResponseMsg struct {
	Response []*FilterDeleteResponse `protobuf:"bytes,1,rep,name=response" json:"response,omitempty"`
}

func (m *FilterDeleteResponseMsg) Reset()                    { *m = FilterDeleteResponseMsg{} }
func (m *FilterDeleteResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterDeleteResponseMsg) ProtoMessage()               {}
func (*FilterDeleteResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{34} }

func (m *FilterDeleteResponseMsg) GetResponse() []*FilterDeleteResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// FilterGetRequest is used to get information about an filter
type FilterGetRequest struct {
	// key_or_handle is the filter's identifier for retrieval
	KeyOrHandle *FilterKeyHandle `protobuf:"bytes,1,opt,name=key_or_handle,json=keyOrHandle" json:"key_or_handle,omitempty" venice:key`
}

func (m *FilterGetRequest) Reset()                    { *m = FilterGetRequest{} }
func (m *FilterGetRequest) String() string            { return proto.CompactTextString(m) }
func (*FilterGetRequest) ProtoMessage()               {}
func (*FilterGetRequest) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{35} }

func (m *FilterGetRequest) GetKeyOrHandle() *FilterKeyHandle {
	if m != nil {
		return m.KeyOrHandle
	}
	return nil
}

// FilterGetRequestMsg is batched GET request for filters
type FilterGetRequestMsg struct {
	Request []*FilterGetRequest `protobuf:"bytes,1,rep,name=request" json:"request,omitempty"`
}

func (m *FilterGetRequestMsg) Reset()                    { *m = FilterGetRequestMsg{} }
func (m *FilterGetRequestMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterGetRequestMsg) ProtoMessage()               {}
func (*FilterGetRequestMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{36} }

func (m *FilterGetRequestMsg) GetRequest() []*FilterGetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

// FilterGetResponse captures all the information about one Filter
type FilterGetResponse struct {
	ApiStatus ApiStatus     `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Spec      *FilterSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status    *FilterStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *FilterGetResponse) Reset()                    { *m = FilterGetResponse{} }
func (m *FilterGetResponse) String() string            { return proto.CompactTextString(m) }
func (*FilterGetResponse) ProtoMessage()               {}
func (*FilterGetResponse) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{37} }

func (m *FilterGetResponse) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FilterGetResponse) GetSpec() *FilterSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *FilterGetResponse) GetStatus() *FilterStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// FilterGetResponseMsg is batched response to FilterGetRequestMsg
type FilterGetResponseMsg struct {
	ApiStatus ApiStatus            `protobuf:"varint,1,opt,name=api_status,json=apiStatus,proto3,enum=types.ApiStatus" json:"api_status,omitempty" venice:api_status`
	Response  []*FilterGetResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *FilterGetResponseMsg) Reset()                    { *m = FilterGetResponseMsg{} }
func (m *FilterGetResponseMsg) String() string            { return proto.CompactTextString(m) }
func (*FilterGetResponseMsg) ProtoMessage()               {}
func (*FilterGetResponseMsg) Descriptor() ([]byte, []int) { return fileDescriptorEndpoint, []int{38} }

func (m *FilterGetResponseMsg) GetApiStatus() ApiStatus {
	if m != nil {
		return m.ApiStatus
	}
	return ApiStatus_API_STATUS_OK
}

func (m *FilterGetResponseMsg) GetResponse() []*FilterGetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func init() {
	proto.RegisterType((*EndpointVmotion)(nil), "endpoint.EndpointVmotion")
	proto.RegisterType((*EndpointAttributes)(nil), "endpoint.EndpointAttributes")
	proto.RegisterType((*EndpointSpec)(nil), "endpoint.EndpointSpec")
	proto.RegisterType((*EndpointRequestMsg)(nil), "endpoint.EndpointRequestMsg")
	proto.RegisterType((*EndpointIpAddress)(nil), "endpoint.EndpointIpAddress")
	proto.RegisterType((*EndpointStatusEpd)(nil), "endpoint.EndpointStatusEpd")
	proto.RegisterType((*EndpointStatusCpd)(nil), "endpoint.EndpointStatusCpd")
	proto.RegisterType((*EndpointStatus)(nil), "endpoint.EndpointStatus")
	proto.RegisterType((*EndpointResponse)(nil), "endpoint.EndpointResponse")
	proto.RegisterType((*EndpointResponseMsg)(nil), "endpoint.EndpointResponseMsg")
	proto.RegisterType((*EndpointUpdateRequest)(nil), "endpoint.EndpointUpdateRequest")
	proto.RegisterType((*EndpointUpdateRequestMsg)(nil), "endpoint.EndpointUpdateRequestMsg")
	proto.RegisterType((*EndpointUpdateResponseMsg)(nil), "endpoint.EndpointUpdateResponseMsg")
	proto.RegisterType((*EndpointFilter)(nil), "endpoint.EndpointFilter")
	proto.RegisterType((*EndpointDeleteRequest)(nil), "endpoint.EndpointDeleteRequest")
	proto.RegisterType((*EndpointDeleteRequestMsg)(nil), "endpoint.EndpointDeleteRequestMsg")
	proto.RegisterType((*EndpointDeleteResponse)(nil), "endpoint.EndpointDeleteResponse")
	proto.RegisterType((*EndpointDeleteResponseMsg)(nil), "endpoint.EndpointDeleteResponseMsg")
	proto.RegisterType((*EndpointGetRequest)(nil), "endpoint.EndpointGetRequest")
	proto.RegisterType((*EndpointGetRequestMsg)(nil), "endpoint.EndpointGetRequestMsg")
	proto.RegisterType((*EndpointGetByInterfaceRequest)(nil), "endpoint.EndpointGetByInterfaceRequest")
	proto.RegisterType((*EndpointGetByInterfaceRequestMsg)(nil), "endpoint.EndpointGetByInterfaceRequestMsg")
	proto.RegisterType((*EndpointGetAllRequestMsg)(nil), "endpoint.EndpointGetAllRequestMsg")
	proto.RegisterType((*EndpointStats)(nil), "endpoint.EndpointStats")
	proto.RegisterType((*EndpointGetResponse)(nil), "endpoint.EndpointGetResponse")
	proto.RegisterType((*EndpointGetResponseMsg)(nil), "endpoint.EndpointGetResponseMsg")
	proto.RegisterType((*FilterSpec)(nil), "endpoint.FilterSpec")
	proto.RegisterType((*FilterRequestMsg)(nil), "endpoint.FilterRequestMsg")
	proto.RegisterType((*FilterStatus)(nil), "endpoint.FilterStatus")
	proto.RegisterType((*FilterResponse)(nil), "endpoint.FilterResponse")
	proto.RegisterType((*FilterResponseMsg)(nil), "endpoint.FilterResponseMsg")
	proto.RegisterType((*FilterDeleteRequest)(nil), "endpoint.FilterDeleteRequest")
	proto.RegisterType((*FilterDeleteRequestMsg)(nil), "endpoint.FilterDeleteRequestMsg")
	proto.RegisterType((*FilterDeleteResponse)(nil), "endpoint.FilterDeleteResponse")
	proto.RegisterType((*FilterDeleteResponseMsg)(nil), "endpoint.FilterDeleteResponseMsg")
	proto.RegisterType((*FilterGetRequest)(nil), "endpoint.FilterGetRequest")
	proto.RegisterType((*FilterGetRequestMsg)(nil), "endpoint.FilterGetRequestMsg")
	proto.RegisterType((*FilterGetResponse)(nil), "endpoint.FilterGetResponse")
	proto.RegisterType((*FilterGetResponseMsg)(nil), "endpoint.FilterGetResponseMsg")
	proto.RegisterEnum("endpoint.EndpointVmotionState", EndpointVmotionState_name, EndpointVmotionState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Endpoint service

type EndpointClient interface {
	EndpointCreate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error)
	EndpointUpdate(ctx context.Context, in *EndpointUpdateRequestMsg, opts ...grpc.CallOption) (*EndpointUpdateResponseMsg, error)
	EndpointDelete(ctx context.Context, in *EndpointDeleteRequestMsg, opts ...grpc.CallOption) (*EndpointDeleteResponseMsg, error)
	EndpointGet(ctx context.Context, in *EndpointGetRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error)
	// Filter
	FilterCreate(ctx context.Context, in *FilterRequestMsg, opts ...grpc.CallOption) (*FilterResponseMsg, error)
	// rpc FilterUpdate (FilterRequestMsg) returns (FilterResponseMsg) {}
	FilterDelete(ctx context.Context, in *FilterDeleteRequestMsg, opts ...grpc.CallOption) (*FilterDeleteResponseMsg, error)
	FilterGet(ctx context.Context, in *FilterGetRequestMsg, opts ...grpc.CallOption) (*FilterGetResponseMsg, error)
}

type endpointClient struct {
	cc *grpc.ClientConn
}

func NewEndpointClient(cc *grpc.ClientConn) EndpointClient {
	return &endpointClient{cc}
}

func (c *endpointClient) EndpointCreate(ctx context.Context, in *EndpointRequestMsg, opts ...grpc.CallOption) (*EndpointResponseMsg, error) {
	out := new(EndpointResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointUpdate(ctx context.Context, in *EndpointUpdateRequestMsg, opts ...grpc.CallOption) (*EndpointUpdateResponseMsg, error) {
	out := new(EndpointUpdateResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointDelete(ctx context.Context, in *EndpointDeleteRequestMsg, opts ...grpc.CallOption) (*EndpointDeleteResponseMsg, error) {
	out := new(EndpointDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) EndpointGet(ctx context.Context, in *EndpointGetRequestMsg, opts ...grpc.CallOption) (*EndpointGetResponseMsg, error) {
	out := new(EndpointGetResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/EndpointGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) FilterCreate(ctx context.Context, in *FilterRequestMsg, opts ...grpc.CallOption) (*FilterResponseMsg, error) {
	out := new(FilterResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/FilterCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) FilterDelete(ctx context.Context, in *FilterDeleteRequestMsg, opts ...grpc.CallOption) (*FilterDeleteResponseMsg, error) {
	out := new(FilterDeleteResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/FilterDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endpointClient) FilterGet(ctx context.Context, in *FilterGetRequestMsg, opts ...grpc.CallOption) (*FilterGetResponseMsg, error) {
	out := new(FilterGetResponseMsg)
	err := grpc.Invoke(ctx, "/endpoint.Endpoint/FilterGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Endpoint service

type EndpointServer interface {
	EndpointCreate(context.Context, *EndpointRequestMsg) (*EndpointResponseMsg, error)
	EndpointUpdate(context.Context, *EndpointUpdateRequestMsg) (*EndpointUpdateResponseMsg, error)
	EndpointDelete(context.Context, *EndpointDeleteRequestMsg) (*EndpointDeleteResponseMsg, error)
	EndpointGet(context.Context, *EndpointGetRequestMsg) (*EndpointGetResponseMsg, error)
	// Filter
	FilterCreate(context.Context, *FilterRequestMsg) (*FilterResponseMsg, error)
	// rpc FilterUpdate (FilterRequestMsg) returns (FilterResponseMsg) {}
	FilterDelete(context.Context, *FilterDeleteRequestMsg) (*FilterDeleteResponseMsg, error)
	FilterGet(context.Context, *FilterGetRequestMsg) (*FilterGetResponseMsg, error)
}

func RegisterEndpointServer(s *grpc.Server, srv EndpointServer) {
	s.RegisterService(&_Endpoint_serviceDesc, srv)
}

func _Endpoint_EndpointCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointCreate(ctx, req.(*EndpointRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointUpdateRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointUpdate(ctx, req.(*EndpointUpdateRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointDelete(ctx, req.(*EndpointDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_EndpointGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndpointGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).EndpointGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/EndpointGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).EndpointGet(ctx, req.(*EndpointGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_FilterCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).FilterCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/FilterCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).FilterCreate(ctx, req.(*FilterRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_FilterDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterDeleteRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).FilterDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/FilterDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).FilterDelete(ctx, req.(*FilterDeleteRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Endpoint_FilterGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterGetRequestMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndpointServer).FilterGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/endpoint.Endpoint/FilterGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndpointServer).FilterGet(ctx, req.(*FilterGetRequestMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Endpoint_serviceDesc = grpc.ServiceDesc{
	ServiceName: "endpoint.Endpoint",
	HandlerType: (*EndpointServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EndpointCreate",
			Handler:    _Endpoint_EndpointCreate_Handler,
		},
		{
			MethodName: "EndpointUpdate",
			Handler:    _Endpoint_EndpointUpdate_Handler,
		},
		{
			MethodName: "EndpointDelete",
			Handler:    _Endpoint_EndpointDelete_Handler,
		},
		{
			MethodName: "EndpointGet",
			Handler:    _Endpoint_EndpointGet_Handler,
		},
		{
			MethodName: "FilterCreate",
			Handler:    _Endpoint_FilterCreate_Handler,
		},
		{
			MethodName: "FilterDelete",
			Handler:    _Endpoint_FilterDelete_Handler,
		},
		{
			MethodName: "FilterGet",
			Handler:    _Endpoint_FilterGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "endpoint.proto",
}

func (m *EndpointVmotion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointVmotion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VmotionState != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VmotionState))
	}
	if m.SourceHostIp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.SourceHostIp.Size()))
		n1, err := m.SourceHostIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DestinationHostIp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.DestinationHostIp.Size()))
		n2, err := m.DestinationHostIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *EndpointAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InterfaceKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.InterfaceKeyHandle.Size()))
		n3, err := m.InterfaceKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.UsegVlan != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.UsegVlan))
	}
	if len(m.IpAddress) > 0 {
		for _, msg := range m.IpAddress {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SgKeyHandle) > 0 {
		for _, msg := range m.SgKeyHandle {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HomingHostIp != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.HomingHostIp.Size()))
		n4, err := m.HomingHostIp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.VmotionAttrs != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VmotionAttrs.Size()))
		n5, err := m.VmotionAttrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *EndpointSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Meta.Size()))
		n6, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n7, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n8, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.EndpointAttrs != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EndpointAttrs.Size()))
		n9, err := m.EndpointAttrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *EndpointRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointIpAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointIpAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpAddress != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.IpAddress.Size()))
		n10, err := m.IpAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.LearnSourceDhcp {
		dAtA[i] = 0x10
		i++
		if m.LearnSourceDhcp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceArp {
		dAtA[i] = 0x18
		i++
		if m.LearnSourceArp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceRarp {
		dAtA[i] = 0x20
		i++
		if m.LearnSourceRarp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceConfig {
		dAtA[i] = 0x28
		i++
		if m.LearnSourceConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnStatus != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.LearnStatus.Size()))
		n11, err := m.LearnStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.IpsgTblIdx != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.IpsgTblIdx))
	}
	return i, nil
}

func (m *EndpointStatusEpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStatusEpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegMacTblIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.RegMacTblIdx))
	}
	if len(m.RwTblIdx) > 0 {
		dAtA13 := make([]byte, len(m.RwTblIdx)*10)
		var j12 int
		for _, num := range m.RwTblIdx {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	return i, nil
}

func (m *EndpointStatusCpd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStatusCpd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EndpointStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Meta.Size()))
		n14, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.KeyOrHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n15, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.EnicPinnedUplinkIfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EnicPinnedUplinkIfKeyHandle.Size()))
		n16, err := m.EnicPinnedUplinkIfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.IpAddress) > 0 {
		for _, msg := range m.IpAddress {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsEndpointLocal {
		dAtA[i] = 0x28
		i++
		if m.IsEndpointLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LearnSourceConfig {
		dAtA[i] = 0x30
		i++
		if m.LearnSourceConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EpPdStatus != nil {
		nn17, err := m.EpPdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn17
	}
	return i, nil
}

func (m *EndpointStatus_EpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EpdStatus != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EpdStatus.Size()))
		n18, err := m.EpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *EndpointStatus_CpdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CpdStatus != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.CpdStatus.Size()))
		n19, err := m.CpdStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *EndpointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.EndpointStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EndpointStatus.Size()))
		n20, err := m.EndpointStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *EndpointResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointUpdateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointUpdateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n21, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n22, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.EndpointAttrs != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EndpointAttrs.Size()))
		n23, err := m.EndpointAttrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *EndpointUpdateRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointUpdateRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointUpdateResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointUpdateResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n24, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.InterfaceKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.InterfaceKeyHandle.Size()))
		n25, err := m.InterfaceKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.L2SegmentKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.L2SegmentKeyHandle.Size()))
		n26, err := m.L2SegmentKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *EndpointDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeleteBy != nil {
		nn27, err := m.DeleteBy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn27
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n28, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *EndpointDeleteRequest_KeyOrHandle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n29, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *EndpointDeleteRequest_Filter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Filter != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Filter.Size()))
		n30, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *EndpointDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *EndpointDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n31, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n32, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *EndpointGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointGetByInterfaceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetByInterfaceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.VrfKeyHandle.Size()))
		n33, err := m.VrfKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.InterfaceKeyHandle != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.InterfaceKeyHandle.Size()))
		n34, err := m.InterfaceKeyHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *EndpointGetByInterfaceRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetByInterfaceRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndpointGetAllRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetAllRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EndpointStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EpLearnStats != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.EpLearnStats.Size()))
		n35, err := m.EpLearnStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *EndpointGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Spec.Size()))
		n36, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Status.Size()))
		n37, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Stats != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Stats.Size()))
		n38, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *EndpointGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndpointGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n39, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *FilterRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FilterHandle != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(m.FilterHandle))
		i += 8
	}
	return i, nil
}

func (m *FilterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.FilterStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.FilterStatus.Size()))
		n40, err := m.FilterStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *FilterResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n41, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *FilterDeleteRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	return i, nil
}

func (m *FilterDeleteResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterDeleteResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.KeyOrHandle.Size()))
		n42, err := m.KeyOrHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *FilterGetRequestMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetRequestMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, msg := range m.Request {
			dAtA[i] = 0xa
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Spec.Size()))
		n43, err := m.Spec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Status != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.Status.Size()))
		n44, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *FilterGetResponseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterGetResponseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiStatus != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEndpoint(dAtA, i, uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, msg := range m.Response {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEndpoint(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintEndpoint(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EndpointVmotion) Size() (n int) {
	var l int
	_ = l
	if m.VmotionState != 0 {
		n += 1 + sovEndpoint(uint64(m.VmotionState))
	}
	if m.SourceHostIp != nil {
		l = m.SourceHostIp.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.DestinationHostIp != nil {
		l = m.DestinationHostIp.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointAttributes) Size() (n int) {
	var l int
	_ = l
	if m.InterfaceKeyHandle != nil {
		l = m.InterfaceKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.UsegVlan != 0 {
		n += 1 + sovEndpoint(uint64(m.UsegVlan))
	}
	if len(m.IpAddress) > 0 {
		for _, e := range m.IpAddress {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	if len(m.SgKeyHandle) > 0 {
		for _, e := range m.SgKeyHandle {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	if m.HomingHostIp != nil {
		l = m.HomingHostIp.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VmotionAttrs != nil {
		l = m.VmotionAttrs.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointSpec) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.EndpointAttrs != nil {
		l = m.EndpointAttrs.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointIpAddress) Size() (n int) {
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.LearnSourceDhcp {
		n += 2
	}
	if m.LearnSourceArp {
		n += 2
	}
	if m.LearnSourceRarp {
		n += 2
	}
	if m.LearnSourceConfig {
		n += 2
	}
	if m.LearnStatus != nil {
		l = m.LearnStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.IpsgTblIdx != 0 {
		n += 1 + sovEndpoint(uint64(m.IpsgTblIdx))
	}
	return n
}

func (m *EndpointStatusEpd) Size() (n int) {
	var l int
	_ = l
	if m.RegMacTblIdx != 0 {
		n += 1 + sovEndpoint(uint64(m.RegMacTblIdx))
	}
	if len(m.RwTblIdx) > 0 {
		l = 0
		for _, e := range m.RwTblIdx {
			l += sovEndpoint(uint64(e))
		}
		n += 1 + sovEndpoint(uint64(l)) + l
	}
	return n
}

func (m *EndpointStatusCpd) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EndpointStatus) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.EnicPinnedUplinkIfKeyHandle != nil {
		l = m.EnicPinnedUplinkIfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if len(m.IpAddress) > 0 {
		for _, e := range m.IpAddress {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	if m.IsEndpointLocal {
		n += 2
	}
	if m.LearnSourceConfig {
		n += 2
	}
	if m.EpPdStatus != nil {
		n += m.EpPdStatus.Size()
	}
	return n
}

func (m *EndpointStatus_EpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.EpdStatus != nil {
		l = m.EpdStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointStatus_CpdStatus) Size() (n int) {
	var l int
	_ = l
	if m.CpdStatus != nil {
		l = m.CpdStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.EndpointStatus != nil {
		l = m.EndpointStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointUpdateRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.EndpointAttrs != nil {
		l = m.EndpointAttrs.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointUpdateRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointUpdateResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointFilter) Size() (n int) {
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.InterfaceKeyHandle != nil {
		l = m.InterfaceKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.L2SegmentKeyHandle != nil {
		l = m.L2SegmentKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.DeleteBy != nil {
		n += m.DeleteBy.Size()
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointDeleteRequest_KeyOrHandle) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointDeleteRequest_Filter) Size() (n int) {
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}
func (m *EndpointDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	return n
}

func (m *EndpointDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointGetByInterfaceRequest) Size() (n int) {
	var l int
	_ = l
	if m.VrfKeyHandle != nil {
		l = m.VrfKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.InterfaceKeyHandle != nil {
		l = m.InterfaceKeyHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetByInterfaceRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *EndpointGetAllRequestMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EndpointStats) Size() (n int) {
	var l int
	_ = l
	if m.EpLearnStats != nil {
		l = m.EpLearnStats.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *EndpointGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterSpec) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterStatus) Size() (n int) {
	var l int
	_ = l
	if m.FilterHandle != 0 {
		n += 9
	}
	return n
}

func (m *FilterResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.FilterStatus != nil {
		l = m.FilterStatus.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterDeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterDeleteRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterDeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	return n
}

func (m *FilterDeleteResponseMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterGetRequest) Size() (n int) {
	var l int
	_ = l
	if m.KeyOrHandle != nil {
		l = m.KeyOrHandle.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterGetRequestMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Request) > 0 {
		for _, e := range m.Request {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func (m *FilterGetResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovEndpoint(uint64(l))
	}
	return n
}

func (m *FilterGetResponseMsg) Size() (n int) {
	var l int
	_ = l
	if m.ApiStatus != 0 {
		n += 1 + sovEndpoint(uint64(m.ApiStatus))
	}
	if len(m.Response) > 0 {
		for _, e := range m.Response {
			l = e.Size()
			n += 1 + l + sovEndpoint(uint64(l))
		}
	}
	return n
}

func sovEndpoint(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEndpoint(x uint64) (n int) {
	return sovEndpoint(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EndpointVmotion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointVmotion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointVmotion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmotionState", wireType)
			}
			m.VmotionState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VmotionState |= (EndpointVmotionState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceHostIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceHostIp == nil {
				m.SourceHostIp = &IPAddress{}
			}
			if err := m.SourceHostIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationHostIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestinationHostIp == nil {
				m.DestinationHostIp = &IPAddress{}
			}
			if err := m.DestinationHostIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceKeyHandle == nil {
				m.InterfaceKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.InterfaceKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsegVlan", wireType)
			}
			m.UsegVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsegVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = append(m.IpAddress, &IPAddress{})
			if err := m.IpAddress[len(m.IpAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SgKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SgKeyHandle = append(m.SgKeyHandle, &SecurityGroupKeyHandle{})
			if err := m.SgKeyHandle[len(m.SgKeyHandle)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomingHostIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HomingHostIp == nil {
				m.HomingHostIp = &IPAddress{}
			}
			if err := m.HomingHostIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmotionAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VmotionAttrs == nil {
				m.VmotionAttrs = &EndpointVmotion{}
			}
			if err := m.VmotionAttrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointAttrs == nil {
				m.EndpointAttrs = &EndpointAttributes{}
			}
			if err := m.EndpointAttrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointIpAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointIpAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointIpAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpAddress == nil {
				m.IpAddress = &IPAddress{}
			}
			if err := m.IpAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceDhcp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceDhcp = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceArp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceArp = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceRarp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceRarp = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceConfig = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LearnStatus == nil {
				m.LearnStatus = &EplearnStatus{}
			}
			if err := m.LearnStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsgTblIdx", wireType)
			}
			m.IpsgTblIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpsgTblIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStatusEpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStatusEpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStatusEpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegMacTblIdx", wireType)
			}
			m.RegMacTblIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegMacTblIdx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEndpoint
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RwTblIdx = append(m.RwTblIdx, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEndpoint
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthEndpoint
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEndpoint
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RwTblIdx = append(m.RwTblIdx, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RwTblIdx", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStatusCpd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStatusCpd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStatusCpd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &delphi.ObjectMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnicPinnedUplinkIfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnicPinnedUplinkIfKeyHandle == nil {
				m.EnicPinnedUplinkIfKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.EnicPinnedUplinkIfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = append(m.IpAddress, &EndpointIpAddress{})
			if err := m.IpAddress[len(m.IpAddress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEndpointLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEndpointLocal = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LearnSourceConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LearnSourceConfig = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointStatusEpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EpPdStatus = &EndpointStatus_EpdStatus{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointStatusCpd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EpPdStatus = &EndpointStatus_CpdStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointStatus == nil {
				m.EndpointStatus = &EndpointStatus{}
			}
			if err := m.EndpointStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointUpdateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointUpdateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointUpdateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointAttrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndpointAttrs == nil {
				m.EndpointAttrs = &EndpointAttributes{}
			}
			if err := m.EndpointAttrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointUpdateRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointUpdateRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointUpdateRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointUpdateRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointUpdateResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointUpdateResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointUpdateResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceKeyHandle == nil {
				m.InterfaceKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.InterfaceKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SegmentKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.L2SegmentKeyHandle == nil {
				m.L2SegmentKeyHandle = &L2SegmentKeyHandle{}
			}
			if err := m.L2SegmentKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointKeyHandle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeleteBy = &EndpointDeleteRequest_KeyOrHandle{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EndpointFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DeleteBy = &EndpointDeleteRequest_Filter{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &EndpointKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetByInterfaceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VrfKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VrfKeyHandle == nil {
				m.VrfKeyHandle = &VrfKeyHandle{}
			}
			if err := m.VrfKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceKeyHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceKeyHandle == nil {
				m.InterfaceKeyHandle = &InterfaceKeyHandle{}
			}
			if err := m.InterfaceKeyHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetByInterfaceRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetByInterfaceRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &EndpointGetByInterfaceRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetAllRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetAllRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetAllRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpLearnStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EpLearnStats == nil {
				m.EpLearnStats = &EplearnStats{}
			}
			if err := m.EpLearnStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &EndpointSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &EndpointStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &EndpointStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndpointGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndpointGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndpointGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &EndpointGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FilterKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FilterSpec{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterHandle", wireType)
			}
			m.FilterHandle = 0
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterHandle = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FilterStatus == nil {
				m.FilterStatus = &FilterStatus{}
			}
			if err := m.FilterStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FilterResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FilterKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FilterDeleteRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterDeleteResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterDeleteResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterDeleteResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FilterDeleteResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOrHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyOrHandle == nil {
				m.KeyOrHandle = &FilterKeyHandle{}
			}
			if err := m.KeyOrHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetRequestMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetRequestMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetRequestMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request, &FilterGetRequest{})
			if err := m.Request[len(m.Request)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &FilterSpec{}
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &FilterStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterGetResponseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterGetResponseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterGetResponseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiStatus", wireType)
			}
			m.ApiStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiStatus |= (ApiStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEndpoint
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response, &FilterGetResponse{})
			if err := m.Response[len(m.Response)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEndpoint(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEndpoint
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEndpoint(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEndpoint
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEndpoint
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEndpoint
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEndpoint
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEndpoint(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEndpoint = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEndpoint   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("endpoint.proto", fileDescriptorEndpoint) }

var fileDescriptorEndpoint = []byte{
	// 1708 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x4b, 0x6f, 0xdb, 0x56,
	0x16, 0x36, 0x25, 0xc5, 0x91, 0x8f, 0x1e, 0xb6, 0xaf, 0x1d, 0x45, 0x91, 0x63, 0x5b, 0xc3, 0x60,
	0x66, 0x8c, 0x00, 0xa3, 0x09, 0x9c, 0x20, 0x41, 0x9c, 0x60, 0x30, 0xf2, 0x5b, 0x88, 0x1f, 0x19,
	0xca, 0x36, 0x32, 0x13, 0x20, 0x1c, 0x9a, 0xbc, 0x96, 0x58, 0xd3, 0x14, 0x4b, 0x52, 0x4e, 0xb4,
	0xeb, 0xa2, 0xcb, 0x2e, 0x5b, 0x64, 0xd1, 0x76, 0xdd, 0x5f, 0xd0, 0x1f, 0xd0, 0x5d, 0x97, 0x01,
	0xba, 0xea, 0x26, 0x28, 0xb2, 0x2c, 0x50, 0x14, 0xc8, 0x2f, 0x28, 0x2e, 0x2f, 0x2f, 0xdf, 0x54,
	0xd2, 0x46, 0x41, 0xb3, 0xb2, 0x78, 0xef, 0x39, 0x1f, 0xcf, 0x3d, 0xe7, 0x3b, 0xdf, 0xb9, 0x4c,
	0xa0, 0x8c, 0x75, 0xc5, 0xe8, 0xa9, 0xba, 0xdd, 0x30, 0xcc, 0x9e, 0xdd, 0x43, 0x79, 0xf6, 0x5c,
	0x2b, 0xd8, 0x03, 0x03, 0x5b, 0x74, 0xb9, 0x96, 0x3f, 0xed, 0xba, 0xbf, 0x4a, 0xd8, 0xd0, 0xb0,
	0x64, 0xea, 0xee, 0x63, 0x51, 0xc1, 0x9a, 0xd1, 0x55, 0xe9, 0x13, 0xff, 0x82, 0x83, 0xc9, 0x0d,
	0x17, 0xe0, 0xe8, 0xac, 0x67, 0xab, 0x3d, 0x1d, 0xad, 0x41, 0xe9, 0x9c, 0xfe, 0x14, 0x2d, 0x5b,
	0xb2, 0x71, 0x95, 0xab, 0x73, 0x4b, 0xe5, 0xe5, 0x85, 0x86, 0xf7, 0xe6, 0x88, 0x47, 0x9b, 0x58,
	0x09, 0xc5, 0xf3, 0xc0, 0x13, 0xba, 0x0d, 0x65, 0xab, 0xd7, 0x37, 0x65, 0x2c, 0x76, 0x7b, 0x96,
	0x2d, 0xaa, 0x46, 0x35, 0x53, 0xe7, 0x96, 0x0a, 0xcb, 0x53, 0x0d, 0x1a, 0x65, 0xeb, 0x61, 0x53,
	0x51, 0x4c, 0x6c, 0x59, 0x42, 0x91, 0xda, 0x6d, 0xf7, 0x2c, 0xbb, 0x65, 0xa0, 0x7f, 0xc3, 0x8c,
	0x82, 0x2d, 0x5b, 0xd5, 0x25, 0x27, 0x00, 0xe6, 0x9c, 0x4d, 0x71, 0x9e, 0x0e, 0x18, 0x53, 0x04,
	0xfe, 0xd3, 0x2c, 0x20, 0x16, 0x60, 0xd3, 0xb6, 0x4d, 0xf5, 0xb8, 0x6f, 0x63, 0x0b, 0x3d, 0x82,
	0x59, 0x55, 0xb7, 0xb1, 0x79, 0x22, 0xc9, 0x58, 0x3c, 0xc5, 0x03, 0xb1, 0x2b, 0xe9, 0x8a, 0x46,
	0x0f, 0x57, 0x58, 0xae, 0x34, 0x4e, 0xbb, 0x8d, 0x16, 0xdb, 0x7f, 0x80, 0x07, 0xdb, 0xce, 0xee,
	0x6a, 0xf9, 0xf5, 0xcb, 0x45, 0x38, 0xc7, 0xba, 0x2a, 0xe3, 0x15, 0x13, 0x9f, 0x08, 0x48, 0x8d,
	0xd9, 0xa0, 0x39, 0x98, 0xe8, 0x5b, 0xb8, 0x23, 0x9e, 0x6b, 0x92, 0xee, 0x9c, 0xb2, 0x24, 0xe4,
	0xc9, 0xc2, 0x91, 0x26, 0xe9, 0xe8, 0x9f, 0x00, 0xaa, 0x21, 0x4a, 0x34, 0xdc, 0x6a, 0xb6, 0x9e,
	0x4d, 0x3c, 0xc6, 0x84, 0x6a, 0xb8, 0x3f, 0xd1, 0x1e, 0x94, 0xac, 0x4e, 0x30, 0xc0, 0x9c, 0xe3,
	0x53, 0x23, 0x01, 0xb6, 0xb1, 0xdc, 0x37, 0x55, 0x7b, 0xb0, 0x65, 0xf6, 0xfa, 0x46, 0x7a, 0x90,
	0x05, 0xab, 0xe3, 0x47, 0x77, 0x1b, 0xca, 0xdd, 0xde, 0x99, 0xaa, 0x77, 0xbc, 0x5c, 0x5e, 0x48,
	0x2b, 0x04, 0xb5, 0x73, 0x0b, 0xf1, 0x2f, 0x9f, 0x05, 0x92, 0x6d, 0x9b, 0x56, 0x75, 0xdc, 0x71,
	0xbb, 0x92, 0xca, 0x02, 0x8f, 0x00, 0x24, 0xe9, 0x16, 0xff, 0x79, 0x06, 0x8a, 0xcc, 0xa2, 0x6d,
	0x60, 0x19, 0xfd, 0x0d, 0x72, 0xbb, 0xd8, 0x96, 0xdc, 0x84, 0xa3, 0x86, 0xcb, 0xc3, 0xfd, 0xe3,
	0x8f, 0xb0, 0x6c, 0x93, 0x1d, 0xc1, 0xd9, 0x47, 0x2d, 0x28, 0x91, 0xd3, 0xf7, 0x4c, 0x96, 0x00,
	0x4a, 0x9c, 0x4b, 0x24, 0x01, 0x0c, 0x30, 0xf9, 0xec, 0xa7, 0x78, 0x20, 0x14, 0x4e, 0xf1, 0x60,
	0xdf, 0x74, 0xcf, 0xbe, 0x09, 0xe5, 0x73, 0xf3, 0x24, 0x98, 0x4c, 0xc6, 0xa3, 0xd3, 0x6e, 0xe3,
	0xc8, 0x3c, 0x49, 0x4f, 0x61, 0xf1, 0x3c, 0xb0, 0x8b, 0xd6, 0xfc, 0xae, 0x73, 0x93, 0x91, 0x73,
	0x70, 0xae, 0xc6, 0x93, 0xe1, 0x33, 0x4e, 0x28, 0xe1, 0xc0, 0x9a, 0xb5, 0x92, 0xfb, 0xe4, 0x39,
	0xcf, 0xf1, 0x9b, 0x3e, 0x39, 0x05, 0xfc, 0x71, 0x1f, 0x5b, 0xf6, 0xae, 0xd5, 0x41, 0x37, 0xe0,
	0xa2, 0x49, 0x9f, 0xaa, 0x9c, 0x53, 0xee, 0x4a, 0x1c, 0x99, 0x24, 0x51, 0x60, 0x66, 0xfc, 0x0f,
	0x19, 0x98, 0x66, 0x3b, 0x2d, 0x8f, 0x3c, 0x61, 0xb6, 0x71, 0x29, 0x85, 0x0e, 0xb0, 0xed, 0x3a,
	0x4c, 0x3b, 0xe2, 0x20, 0xba, 0xcd, 0xaa, 0x74, 0x65, 0xda, 0xa9, 0x79, 0x61, 0xd2, 0xd9, 0x68,
	0x3b, 0xeb, 0xeb, 0x5d, 0xd9, 0x40, 0x4b, 0x30, 0x15, 0xb2, 0x95, 0x4c, 0xda, 0x97, 0x79, 0xa1,
	0x1c, 0x30, 0x6d, 0x9a, 0x46, 0x0c, 0xd5, 0x24, 0xa6, 0xb9, 0x18, 0xaa, 0x20, 0x99, 0x06, 0x6a,
	0xc0, 0x4c, 0xc8, 0x56, 0xee, 0xe9, 0x27, 0x6a, 0xc7, 0x21, 0x69, 0x5e, 0x98, 0x0e, 0x58, 0xaf,
	0x39, 0x1b, 0xe8, 0x2e, 0x14, 0x5d, 0x7b, 0x5b, 0xb2, 0xfb, 0x8c, 0x96, 0x95, 0x06, 0x53, 0xb9,
	0x0d, 0xfa, 0xb7, 0xed, 0xec, 0x0a, 0x85, 0xc0, 0x03, 0xaa, 0x43, 0x51, 0x35, 0xac, 0x8e, 0x68,
	0x1f, 0x6b, 0xa2, 0xaa, 0x3c, 0xab, 0x5e, 0x74, 0x7a, 0x15, 0xc8, 0xda, 0xc1, 0xb1, 0xd6, 0x52,
	0x9e, 0xf1, 0x8f, 0xfc, 0xa4, 0x52, 0x9f, 0x0d, 0x43, 0x41, 0x7f, 0x85, 0x49, 0x13, 0x77, 0xc4,
	0x33, 0x49, 0xf6, 0x3c, 0x39, 0xc7, 0xb3, 0x68, 0xe2, 0xce, 0xae, 0x24, 0x53, 0x5f, 0x74, 0x15,
	0xc0, 0x7c, 0xea, 0x59, 0x64, 0xea, 0x59, 0xa2, 0x03, 0xe6, 0x53, 0x17, 0x79, 0x26, 0x8a, 0xbc,
	0x66, 0x28, 0xfc, 0x57, 0x39, 0x28, 0x87, 0x57, 0xff, 0x8c, 0x2e, 0x39, 0x83, 0x3a, 0xd9, 0x11,
	0x0d, 0x55, 0xd7, 0xb1, 0x22, 0xf6, 0x0d, 0x4d, 0xd5, 0x4f, 0x45, 0x35, 0xa1, 0x6f, 0xde, 0x56,
	0x25, 0xe7, 0xc8, 0xcf, 0x87, 0x0e, 0xdc, 0xa1, 0x83, 0xd6, 0x0a, 0x34, 0xd3, 0x4a, 0x88, 0xa3,
	0x54, 0xdd, 0xe6, 0xe2, 0x74, 0xf7, 0x48, 0x1d, 0xa1, 0xab, 0x6a, 0x89, 0x5e, 0x2f, 0x6a, 0x3d,
	0x59, 0xd2, 0x5c, 0xaa, 0x4c, 0xaa, 0x16, 0x73, 0xdd, 0x21, 0xcb, 0x69, 0xc4, 0x1a, 0x4f, 0x23,
	0xd6, 0x7d, 0x00, 0x6c, 0x28, 0x8c, 0x56, 0x17, 0x9d, 0x03, 0x27, 0xc4, 0xe5, 0xf1, 0x62, 0x7b,
	0x4c, 0x98, 0xc0, 0x86, 0xe2, 0xd6, 0xed, 0x3e, 0x80, 0xec, 0x7b, 0xe7, 0x87, 0x7b, 0xaf, 0x51,
	0x6f, 0x99, 0x79, 0x53, 0x6d, 0x58, 0x2d, 0x43, 0x11, 0x1b, 0xa2, 0x87, 0xc2, 0x7f, 0xcd, 0xc1,
	0x94, 0x2f, 0x16, 0x96, 0xd1, 0xd3, 0x2d, 0xa2, 0x69, 0x20, 0x19, 0x2a, 0x7b, 0x11, 0x1d, 0xcd,
	0xac, 0xc5, 0x9b, 0x86, 0x4a, 0x01, 0x57, 0x2f, 0xbd, 0x7e, 0xb9, 0x38, 0xed, 0x56, 0xc4, 0x37,
	0x17, 0x26, 0x24, 0x66, 0x81, 0x9a, 0x30, 0xe9, 0xe5, 0xd1, 0x05, 0xa3, 0x14, 0xaa, 0xa6, 0x45,
	0x2d, 0x78, 0x22, 0x48, 0x9f, 0xf9, 0x5d, 0x98, 0x89, 0x86, 0x47, 0xc4, 0xec, 0x36, 0xe4, 0x4d,
	0xf7, 0xd1, 0x55, 0xb3, 0x5a, 0x1c, 0x92, 0x39, 0x08, 0x9e, 0x2d, 0xff, 0x2b, 0x07, 0x97, 0xd8,
	0xf6, 0xa1, 0xa1, 0x90, 0x3b, 0x05, 0x15, 0xbb, 0x38, 0xd9, 0xb9, 0x11, 0x8e, 0x84, 0xcc, 0x88,
	0x46, 0x42, 0xf6, 0x77, 0x8f, 0x04, 0xfe, 0x10, 0xaa, 0x89, 0x07, 0x26, 0x59, 0xbc, 0x1b, 0x1d,
	0x09, 0x8b, 0x71, 0xe4, 0x90, 0x93, 0x3f, 0x1b, 0xda, 0x70, 0x25, 0x6a, 0xf1, 0xee, 0xd5, 0xf9,
	0x2c, 0xe3, 0x6b, 0xd5, 0xa6, 0xaa, 0xd9, 0xd8, 0x4c, 0xc8, 0x25, 0xf7, 0x87, 0x72, 0x99, 0x76,
	0x35, 0xcb, 0xbc, 0xf3, 0xd5, 0xec, 0x11, 0xcc, 0x6a, 0xcb, 0x6d, 0xdc, 0x39, 0xc3, 0xba, 0x9d,
	0x22, 0x67, 0x3b, 0x6c, 0x7f, 0x08, 0xb2, 0x16, 0xb3, 0xe1, 0x7f, 0x09, 0x90, 0x75, 0x1d, 0x6b,
	0xd8, 0x27, 0xeb, 0x83, 0x77, 0x21, 0xeb, 0xf6, 0x58, 0x98, 0xae, 0xcb, 0x30, 0x7e, 0xe2, 0x24,
	0x3b, 0xbd, 0x39, 0x69, 0x31, 0xb6, 0xc7, 0x04, 0xd7, 0x72, 0x54, 0xb7, 0x9e, 0xd5, 0x02, 0x4c,
	0x28, 0xce, 0xc9, 0xc4, 0xe3, 0x41, 0x90, 0xaa, 0xa1, 0xe3, 0xbe, 0x2d, 0x55, 0x43, 0x4e, 0x3e,
	0x55, 0xff, 0x0f, 0x95, 0xa8, 0xc5, 0x68, 0x75, 0x8e, 0xff, 0xaf, 0xdf, 0x0c, 0xe1, 0x37, 0x90,
	0xc8, 0xef, 0xc7, 0x9a, 0xa1, 0x9e, 0x1e, 0x7a, 0xac, 0x25, 0xbe, 0xe1, 0xfc, 0xcb, 0xdc, 0x16,
	0xb6, 0x3f, 0x5c, 0xb5, 0xe2, 0xf7, 0x7d, 0xb2, 0xfa, 0x81, 0x52, 0x35, 0x88, 0x94, 0x2e, 0x41,
	0xbf, 0x7c, 0x0f, 0xbf, 0x6e, 0xdf, 0x71, 0x30, 0x1f, 0xd8, 0x5f, 0x1d, 0x78, 0x0d, 0xca, 0xb2,
	0xf0, 0xc1, 0x8b, 0x03, 0x8f, 0xa1, 0x3e, 0xf4, 0x08, 0x24, 0x3f, 0xcd, 0x68, 0x7e, 0xfe, 0x9e,
	0x98, 0x9f, 0xb8, 0xb3, 0x9f, 0xaa, 0x9a, 0xdf, 0x39, 0x5b, 0xd8, 0x6e, 0x6a, 0x9a, 0x0f, 0xcf,
	0xef, 0x40, 0x29, 0x38, 0x63, 0x2d, 0x74, 0x0f, 0xca, 0xd8, 0x10, 0xfd, 0x0b, 0xae, 0xe5, 0x91,
	0x27, 0xe1, 0x7e, 0x6b, 0x09, 0x45, 0x6c, 0xec, 0x78, 0x4f, 0xfc, 0xcf, 0x9c, 0x3f, 0x90, 0x9d,
	0xa2, 0x8d, 0xf8, 0xca, 0x70, 0x1d, 0x72, 0x96, 0x81, 0x65, 0x2f, 0xf5, 0xc9, 0x9f, 0x28, 0x8e,
	0x0d, 0xba, 0x01, 0xe3, 0xee, 0xfb, 0xb2, 0x6f, 0xb8, 0x55, 0xb8, 0x76, 0xe8, 0x1f, 0x70, 0x81,
	0x9e, 0x98, 0x7e, 0x5b, 0x5d, 0x4e, 0x76, 0xb0, 0x04, 0x6a, 0xc5, 0x7f, 0xc9, 0xf9, 0xd2, 0x11,
	0x38, 0x2c, 0x29, 0xda, 0xa8, 0xce, 0x7b, 0x37, 0xa0, 0x0e, 0x19, 0xa7, 0xfa, 0xf3, 0x29, 0xdd,
	0x11, 0x93, 0x86, 0x43, 0x00, 0xaa, 0xcb, 0xce, 0xa7, 0xef, 0x56, 0xb2, 0x22, 0xcc, 0x10, 0xf2,
	0x52, 0xb3, 0xb7, 0xd3, 0x03, 0x7e, 0x15, 0xa6, 0xa8, 0x7d, 0x80, 0xa2, 0x8d, 0x28, 0x45, 0x67,
	0xfd, 0x20, 0xfd, 0x18, 0x7c, 0x3e, 0xde, 0x84, 0xa2, 0xbb, 0x4c, 0x4f, 0x79, 0x0d, 0x4a, 0x74,
	0x70, 0x04, 0x83, 0x1b, 0x17, 0x8a, 0x74, 0xd1, 0x7d, 0xf1, 0x17, 0x1c, 0x94, 0xd9, 0x9b, 0x47,
	0xcc, 0xaa, 0x7b, 0xde, 0xfb, 0x43, 0xd7, 0xd0, 0x4a, 0xec, 0x14, 0xd4, 0xd3, 0x8d, 0xcb, 0x55,
	0xf7, 0x16, 0x4c, 0x87, 0xc3, 0x22, 0x19, 0xb9, 0x15, 0x53, 0xf5, 0x6a, 0x14, 0x2c, 0xa1, 0x64,
	0x4f, 0x60, 0x86, 0xee, 0x85, 0xc7, 0xf9, 0xc8, 0x6a, 0xf7, 0x1f, 0xa8, 0x24, 0xe0, 0x93, 0x78,
	0xef, 0x44, 0x2b, 0x38, 0x1f, 0x0d, 0x37, 0x65, 0x7a, 0x3e, 0x81, 0xd9, 0xf0, 0xfe, 0x88, 0x67,
	0xe7, 0x21, 0x5c, 0x4e, 0xc2, 0x27, 0x31, 0xaf, 0xc4, 0x72, 0xbc, 0x90, 0x16, 0x74, 0x2c, 0xd3,
	0x8f, 0x19, 0x8b, 0x03, 0x43, 0x73, 0x64, 0x69, 0x7e, 0xc0, 0xca, 0x18, 0x1e, 0x74, 0xb7, 0xa2,
	0x39, 0xae, 0x45, 0xc3, 0x4d, 0x1a, 0x73, 0xdf, 0x72, 0x8c, 0x5f, 0xef, 0x43, 0x4f, 0x97, 0x42,
	0x7a, 0x9a, 0xdc, 0xb6, 0x54, 0x4d, 0x1b, 0x11, 0x35, 0x4d, 0x6b, 0x0e, 0xd7, 0x8a, 0x7f, 0xce,
	0x31, 0x66, 0xbc, 0x27, 0x69, 0xbc, 0x13, 0x93, 0xc6, 0xb9, 0xc4, 0x7c, 0x46, 0x6b, 0x7f, 0x7d,
	0x00, 0xb3, 0x49, 0xff, 0x7a, 0x8c, 0x2a, 0x80, 0x8e, 0x76, 0xf7, 0x0f, 0x5a, 0xfb, 0x7b, 0x62,
	0xfb, 0xa0, 0x79, 0xb0, 0x21, 0xee, 0xed, 0xef, 0x6d, 0x4c, 0x8d, 0xa1, 0xcb, 0x30, 0x13, 0x5e,
	0x6f, 0x1f, 0x34, 0x85, 0x83, 0x29, 0x0e, 0x55, 0x61, 0x36, 0xbc, 0xb1, 0xd9, 0x6c, 0xed, 0x6c,
	0xac, 0x4f, 0x65, 0xe2, 0x50, 0xeb, 0x04, 0x2a, 0xbb, 0xfc, 0x63, 0x0e, 0xf2, 0xec, 0xdd, 0x68,
	0xdf, 0xff, 0x9a, 0x59, 0x33, 0x31, 0x89, 0xe0, 0x6a, 0xd2, 0x67, 0x10, 0xe3, 0x4f, 0x6d, 0x3e,
	0xfd, 0x23, 0x89, 0x0c, 0xf2, 0x31, 0xf4, 0xd8, 0x07, 0xa4, 0x1f, 0x5d, 0x88, 0x7f, 0xc3, 0x07,
	0x1b, 0x81, 0xbd, 0x96, 0x6e, 0x93, 0x02, 0x4e, 0xbb, 0x2a, 0x09, 0x3c, 0xaa, 0x2b, 0x49, 0xe0,
	0xb1, 0x46, 0xe6, 0xc7, 0x90, 0x00, 0x85, 0xc0, 0x30, 0x43, 0x8b, 0xc3, 0x6e, 0x80, 0x04, 0xb6,
	0x3e, 0x74, 0x08, 0x52, 0xcc, 0x16, 0x1b, 0x32, 0x6e, 0x72, 0x6b, 0x71, 0x01, 0xf6, 0xf0, 0xe6,
	0xd2, 0xc4, 0x99, 0x42, 0x1d, 0x32, 0x28, 0xf7, 0xe4, 0xf5, 0xa1, 0xe2, 0x48, 0x00, 0xff, 0x32,
	0x5c, 0x89, 0x28, 0xec, 0x0e, 0x4c, 0x78, 0x3c, 0x45, 0xf3, 0xe9, 0x62, 0x40, 0x00, 0x17, 0x86,
	0x70, 0xdb, 0x41, 0x5b, 0xad, 0x7c, 0xff, 0x6a, 0x81, 0x7b, 0xf1, 0x6a, 0x81, 0xfb, 0xe9, 0xd5,
	0x02, 0xf7, 0xbf, 0x7c, 0x57, 0xd2, 0x9c, 0xff, 0x5f, 0x39, 0x1e, 0x77, 0xfe, 0xdc, 0xfc, 0x2d,
	0x00, 0x00, 0xff, 0xff, 0xb4, 0x35, 0x29, 0x04, 0xb6, 0x19, 0x00, 0x00,
}
