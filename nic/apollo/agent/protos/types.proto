//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for common types
//------------------------------------------------------------------------------

syntax = "proto3";

import public "gogo.proto";
import "google/protobuf/any.proto";

package types;
option go_package="pds";

// Empty message
message Empty {}

// API return codes (more descriptive than protobuf enums)
enum ApiStatus {
  API_STATUS_OK                    = 0; // success
  API_STATUS_ERR                   = 1; // catch-all error
  API_STATUS_INVALID_ARG           = 2; // invalid argument
  API_STATUS_EXISTS_ALREADY        = 3; // object already exists
  API_STATUS_OUT_OF_MEM            = 4; // out of memory
  API_STATUS_NOT_FOUND             = 5; // object not found
  API_STATUS_OUT_OF_RESOURCE       = 6; // out of resource
  API_STATUS_RETRY                 = 7; // if operation can be retried
  API_STATUS_OPERATION_NOT_ALLOWED = 8; // if operation is not allowed on
                                        // specific type of object
}

// IP address families
enum IPAF {
  IP_AF_NONE  = 0;
  IP_AF_INET  = 1; // IPv4
  IP_AF_INET6 = 2; // IPv6
}

enum WildcardMatch {
  MATCH_NONE  = 0;
  MATCH_ANY   = 256;
}

// IP Address object
message IPAddress {
  IPAF      Af     = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // IP address family
  oneof v4_or_v6 {
    // IPv4 address
    fixed32 V4Addr = 2;
    // IPv6 address
    bytes   V6Addr = 3;
  }
}

// IP Range
message IPRange {
  // starting IP address
  IPAddress Low  = 1;
  // ending IP address
  IPAddress High = 2;
}

// IPv4 Prefix
message IPv4Prefix {
  // IPv4 address portion
  fixed32 Addr = 1;
  // prefix length
  uint32  Len  = 2 [(gogoproto.moretags) = "meta:range=0-32"];
}

// IPv6 Prefix
message IPv6Prefix {
  // IPv6 address bytes
  bytes  Addr = 1;
  // prefix length
  uint32 Len  = 2 [(gogoproto.moretags) = "meta:range=0-128"];
}

// IP Prefix object
message IPPrefix {
  // IP prefix address
  IPAddress Addr = 1;
  // IP Prefix length
  uint32    Len  = 2 [(gogoproto.moretags) = "meta:range=0-128"];
}

// IPSubnet represents an IPv4 or IPv6 subnet
message IPSubnet {
  oneof subnet {
    // IPv4 subnet
    IPPrefix IPv4Subnet = 1;
    // IPv6 subnet
    IPPrefix IPv6Subnet = 2;
  }
}

// AddressRange represents an IPv4 or IPv6 address range
message AddressRange {
  oneof range {
    // IPv4 address range
    IPRange IPv4Range = 1;
    // IPv6 address range
    IPRange IPv6Range = 2;
  }
}

// Address object is the prefix or range
message Address {
  oneof address {
    // IPv4 or IPv6 prefix
    IPSubnet     Prefix = 1;
    // IPv4 or IPv6 address range
    AddressRange Range  = 2;
  }
}

// PortRange object has low and high end of the port ranges
message PortRange {
  uint32 PortLow  = 1 [(gogoproto.moretags) = "meta:range:0-65535"];
  uint32 PortHigh = 2 [(gogoproto.moretags) = "meta:range:0-65535"];
}

// direction in which policy is enforced
// INGRESS/EGRESS is w.r.t vnic (i.e., traffic leaving vnic is marked as
// EGRESS and traffic going to vnic is marked as INGRESS
enum RuleDir {
  RULE_DIR_NONE    = 0;
  RULE_DIR_INGRESS = 1;
  RULE_DIR_EGRESS  = 2;
}

// L3 rule match criteria
message RuleL3Match {
  // IP Protocol
  oneof protomatch {
    uint32              ProtoNum       = 1;
    types.WildcardMatch ProtoWildcard  = 2; // Match ANY protocol
  }
  oneof srcmatch {
    types.IPPrefix      SrcPrefix = 3; // Src IP Prefix
    types.AddressRange  SrcRange  = 4; // Src IP Range
    uint32              SrcTag    = 5; // Src Tag
  }
  oneof dstmatch {
    types.IPPrefix      DstPrefix = 6; // Dst IP Prefix
    types.AddressRange  DstRange  = 7; // Dst IP Range
    uint32              DstTag    = 8; // Dst Tag
  }
}

// TCP/UDP rule match criteria
message PortMatch {
  // source port range
  types.PortRange SrcPortRange = 1;
  // destination port range
  types.PortRange DstPortRange = 2;
}

// ICMPv4/ICMPv6 rule match criteria
message ICMPMatch {
  // ICMP type
  oneof typematch {
    uint32              TypeNum       = 1 ;
    types.WildcardMatch TypeWildcard  = 2; // Match ANY type
  }
  // ICMP code
  oneof codematch {
    uint32              CodeNum       = 3 ;
    types.WildcardMatch CodeWildcard  = 4; // Match ANY code
  }
}

// L4 rule match criteria
message RuleL4Match {
  oneof l4info {
    // port match criteria
    PortMatch Ports    = 1;
    // ICMP match criteria
    ICMPMatch TypeCode = 2;
  }
}

// rule match criteria
message RuleMatch {
  // Layer 3 match criteria
  RuleL3Match L3Match = 1;
  // Layer 4 match criteria
  RuleL4Match L4Match = 2;
}

// QinQ vlan tag
message QinQTag {
  // Customer VLAN tag
  uint32 cTag = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // Service VLAN tag
  uint32 sTag = 2 [(gogoproto.moretags) = "meta:mandatory"];
}

// encap types in the network
enum EncapType {
  ENCAP_TYPE_NONE     = 0;
  ENCAP_TYPE_DOT1Q    = 1;
  ENCAP_TYPE_QINQ     = 2;
  ENCAP_TYPE_MPLSoUDP = 3;
  ENCAP_TYPE_VXLAN    = 4;
}

// based on the encap type in the fabric, one can carry per vnic information
// for example, in case of MPLSoUDP, MPLS tag (along with source tunnel IP)
// can uniquely identify the vnic from where the packet is originating and
// another MPLS tag (along with the destination tunnel IP) can identify the
// destination VNIC
message EncapVal {
  oneof val {
    // MPLS tag corresponding to the VNIC or mapping
    uint32  VlanId   = 1;    // VLAN tag
    uint32  MPLSTag  = 2;    // MPLS tag/slot
    uint32  Vnid     = 3;    // VxLAN vnid
    QinQTag QinQTag  = 4;    // QinQ tag
  }
}

// fabric encap
message Encap {
  EncapType type  = 1;    // encap type
  EncapVal  value = 2;    // encap value
}

// Types of lif
enum LifType {
  LIF_TYPE_NONE          = 0;
  LIF_TYPE_HOST          = 1;
  LIF_TYPE_HOST_MGMT     = 2;
  LIF_TYPE_OOB_MGMT      = 3;
  LIF_TYPE_INBAND_MGMT   = 4;
  LIF_TYPE_INTERNAL_MGMT = 5;
  LIF_TYPE_DATAPATH      = 6;
  LIF_TYPE_LEARN         = 7;
  LIF_TYPE_CONTROL       = 8;
}

// Security rule action is one of the below
enum SecurityRuleAction {
  SECURITY_RULE_ACTION_NONE  = 0;
  SECURITY_RULE_ACTION_ALLOW = 1;
  SECURITY_RULE_ACTION_DENY  = 2;
}

// types of NAT actions supported
enum NatAction {
  NAT_ACTION_NONE        = 0;
  // Address only static NAT
  NAT_ACTION_STATIC      = 1;
  // address and port translation to the public (aka. Internet) address space
  NAT_ACTION_NAPT_PUBLIC = 2;
  // address and port translation to internal service address space
  NAT_ACTION_NAPT_SVC    = 3;
}

// BatchCtxt is opaque to application(s) and is expected to be passed
// back (to identify the batch) in every API call of this batch until
// BatchCommit() or BatchAbort()
message BatchCtxt {
  // opaque cookie
  uint64 BatchCookie = 1;
}

// Public/Internet or Service/Infra address
enum AddressType {
  ADDR_TYPE_NONE        = 0;
  ADDR_TYPE_PUBLIC      = 1;
  ADDR_TYPE_SERVICE     = 2;
}

// flow key for non-IP flows
message MACFlowKey {
  // subnet identifier
  bytes  Subnet    = 1;
  // source MAC address
  uint64 SrcMAC    = 2;
  // destination MAC address
  uint64 DstMAC    = 3;
  // 16 bits of Ethertype in the Ethernet header
  uint32 EtherType = 4;
}

// L4 portion of flow key tuple
message FlowL4Info {
  // key fields for TCP/UDP flows
  message TCPUDPInfo {
    uint32 SrcPort  = 1;
    uint32 DstPort  = 2;
  }
  // key fields for ICMP flows
  message ICMPInfo {
    uint32 Type = 1;
    uint32 Code = 2;
    uint32 Id   = 3;
  }
  oneof l4_info {
    TCPUDPInfo TcpUdpInfo = 1;
    ICMPInfo   IcmpInfo   = 2;
  }
}

// flow key for IP flows
message IPFlowKey {
  // VPC identifier
  bytes           VPCId      = 1;
  // source IP seen in the packet
  types.IPAddress SrcIP      = 2;
  // destination IP seen in the packet
  types.IPAddress DstIP      = 3;
  // IP protocol
  uint32          IPProtocol = 4;
  // L4 information of the flow key
  FlowL4Info      L4Info     = 5;
}

// flow key is either IP flow key or non-IP flow key
message FlowKey {
  oneof key {
    // flow key for the IPv4 and IPv6 flows
    IPFlowKey  IPFlowKey  = 1;
    // flow key for the non-IP flows
    MACFlowKey MACFlowKey = 2;
  }
}

// admin state of control plane objects
enum AdminState {
  ADMIN_STATE_NONE    = 0;
  ADMIN_STATE_ENABLE  = 1;
  ADMIN_STATE_DISABLE = 2;
}

// PortSpeed specifies the speed of the port
enum PortSpeed {
  PORT_SPEED_NONE  = 0; // port speed not configured
  PORT_SPEED_10M   = 1; // port speed is 10Mbps
  PORT_SPEED_100M  = 2; // port speed is 100Mbps
  PORT_SPEED_1G    = 3; // port speed is 1Gbps
  PORT_SPEED_10G   = 4; // port speed is 10Gbps
  PORT_SPEED_25G   = 5; // port speed is 25Gbps
  PORT_SPEED_40G   = 6; // port speed is 40Gbps
  PORT_SPEED_50G   = 7; // port speed is 50Gbps
  PORT_SPEED_100G  = 8; // port speed is 100Gbps
  PORT_SPEED_RESVD = 9;
}

enum Command {
  CMD_NONE                  = 0;
  CMD_MAPPING_DUMP          = 1;
  CMD_INTR_DUMP             = 2;
  CMD_INTR_CLEAR            = 3;
  CMD_API_ENGINE_STATS_DUMP = 4;
  CMD_FLOW_DUMP             = 5;
  CMD_STORE_STATS_DUMP      = 6;
  CMD_NAT_PB_DUMP           = 7;
  CMD_NACL_DUMP             = 8;
  CMD_PORT_FSM_DUMP         = 9;
}

message CommandMessage {
  Command             Command    = 1;
  google.protobuf.Any CommandMsg = 2;
}

enum ServiceRequestOp {
  SERVICE_OP_NONE    = 0;
  SERVICE_OP_CREATE  = 1;
  SERVICE_OP_DELETE  = 2;
  SERVICE_OP_UPDATE  = 3;
  SERVICE_OP_READ    = 4;
}

message ConfigMessage {
  ServiceRequestOp    ConfigOp  = 1;
  google.protobuf.Any ConfigMsg = 2;
}

message ServiceRequestMessage {
  int64   Version          = 1;
  oneof request {
    CommandMessage Command = 2;
    ConfigMessage  Config  = 3;
  }
}

message ServiceResponseMessage {
  ApiStatus           ApiStatus = 1;
  google.protobuf.Any Response  = 2;
}
