//------------------------------------------------------------------------------
// {C} Copyright 2019 Pensando Systems Inc. All rights reserved
//
// protobuf specification for common types
//------------------------------------------------------------------------------

syntax = "proto3";

import public "gogo.proto";

package types;
option go_package="pds";

// Empty message
message Empty {}

// API return codes (more descriptive than protobuf enums)
enum ApiStatus {
  API_STATUS_OK                    = 0; // success
  API_STATUS_ERR                   = 1; // catch-all error
  API_STATUS_INVALID_ARG           = 2; // invalid argument
  API_STATUS_EXISTS_ALREADY        = 3; // object already exists
  API_STATUS_OUT_OF_MEM            = 4; // out of memory
  API_STATUS_NOT_FOUND             = 5; // object not found
  API_STATUS_OUT_OF_RESOURCE       = 6; // out of resource
  API_STATUS_RETRY                 = 7; // if operation can be retried
  API_STATUS_OPERATION_NOT_ALLOWED = 8; // if operation is not allowed on
                                        // specific type of object
}

// IP address families
enum IPAF {
  IP_AF_NONE  = 0;
  IP_AF_INET  = 1; // IPv4
  IP_AF_INET6 = 2; // IPv6
}

// IP Address object
message IPAddress {
  IPAF      Af     = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // IP address family
  oneof v4_or_v6 {
    // IPv4 address
    fixed32 V4Addr = 2;
    // IPv6 address
    bytes   V6Addr = 3;
  }
}

// IP Range
message IPRange {
  // starting IP address
  IPAddress Low  = 1;
  // ending IP address
  IPAddress High = 2;
}

// IPv4 Prefix
message IPv4Prefix {
  // IPv4 address portion
  fixed32 Addr = 1;
  // prefix length
  uint32  Len  = 2 [(gogoproto.moretags) = "meta:range=0-32"];
}

// IPv6 Prefix
message IPv6Prefix {
  // IPv6 address bytes
  bytes  Addr = 1;
  // prefix length
  uint32 Len  = 2 [(gogoproto.moretags) = "meta:range=0-128"];
}

// IP Prefix object
message IPPrefix {
  // IP prefix address
  IPAddress Addr = 1;
  // IP Prefix length
  uint32    Len  = 2 [(gogoproto.moretags) = "meta:range=0-128"];
}

// IPSubnet represents an IPv4 or IPv6 subnet
message IPSubnet {
  oneof subnet {
    // IPv4 subnet
    IPPrefix IPv4Subnet = 1;
    // IPv6 subnet
    IPPrefix IPv6Subnet = 2;
  }
}

// AddressRange represents an IPv4 or IPv6 address range
message AddressRange {
  oneof range {
    // IPv4 address range
    IPRange IPv4Range = 1;
    // IPv6 address range
    IPRange IPv6Range = 2;
  }
}

// Address object is the prefix or range
message Address {
  oneof   Address {
    // IPv4 or IPv6 prefix
    IPSubnet     Prefix = 1;
    // IPv4 or IPv6 address range
    AddressRange Range  = 2;
  }
}

// PortRange object has low and high end of the port ranges
message PortRange {
  uint32 PortLow  = 1 [(gogoproto.moretags) = "meta:range:0-65535"];
  uint32 PortHigh = 2 [(gogoproto.moretags) = "meta:range:0-65535"];
}

// direction in which policy is enforced
// INGRESS/EGRESS is w.r.t vnic (i.e., traffic leaving vnic is marked as
// EGRESS and traffic going to vnic is marked as INGRESS
enum RuleDir {
  RULE_DIR_NONE    = 0;
  RULE_DIR_INGRESS = 1;
  RULE_DIR_EGRESS  = 2;
}

// L3 rule match criteria
message RuleL3Match {
  // IP Protocol
  uint32               Protocol  = 1 [(gogoproto.moretags) = "meta:range:0-255"];
  oneof SrcMatch {
    types.IPPrefix     SrcPrefix = 2; // Src IP Prefix
    types.AddressRange SrcRange  = 3; // Src IP Range
    uint32             SrcTag    = 4; // Src Tag
  }
  oneof DstMatch {
    types.IPPrefix     DstPrefix = 5; // Dst IP Prefix
    types.AddressRange DstRange  = 6; // Dst IP Range
    uint32             DstTag    = 7; // Dst Tag
  }
}

// TCP/UDP rule match criteria
message PortMatch {
  // source port range
  types.PortRange SrcPortRange = 1;
  // destination port range
  types.PortRange DstPortRange = 2;
}

// ICMPv4/ICMPv6 rule match criteria
message ICMPMatch {
  // ICMP type
  uint32 type = 1;
  // ICMP code
  uint32 code = 2;
}

// L4 rule match criteria
message RuleL4Match {
  oneof L4Info {
    // port match criteria
    PortMatch Ports    = 1;
    // ICMP match criteria
    ICMPMatch TypeCode = 2;
  }
}

// rule match criteria
message RuleMatch {
  // Layer 3 match criteria
  RuleL3Match L3Match = 1;
  // Layer 4 match criteria
  RuleL4Match L4Match = 2;
}

// QinQ vlan tag
message QinQTag {
  // Customer VLAN tag
  uint32 cTag = 1 [(gogoproto.moretags) = "meta:mandatory"];
  // Service VLAN tag
  uint32 sTag = 2 [(gogoproto.moretags) = "meta:mandatory"];
}

// encap types in the network
enum EncapType {
  ENCAP_TYPE_NONE     = 0;
  ENCAP_TYPE_DOT1Q    = 1;
  ENCAP_TYPE_QINQ     = 2;
  ENCAP_TYPE_MPLSoUDP = 3;
  ENCAP_TYPE_VXLAN    = 4;
}

// based on the encap type in the fabric, one can carry per vnic information
// for example, in case of MPLSoUDP, MPLS tag (along with source tunnel IP)
// can uniquely identify the vnic from where the packet is originating and
// another MPLS tag (along with the destination tunnel IP) can identify the
// destination VNIC
message EncapVal {
  oneof Val {
    // MPLS tag corresponding to the VNIC or mapping
    uint32  VlanId   = 1;    // VLAN tag
    uint32  MPLSTag  = 2;    // MPLS tag/slot
    uint32  Vnid     = 3;    // VxLAN vnid
    QinQTag QinQTag  = 4;    // QinQ tag
  }
}

// fabric encap
message Encap {
  EncapType type  = 1;    // encap type
  EncapVal  value = 2;    // encap value
}

// Types of lif
enum LifType {
  LIF_TYPE_NONE                     = 0;
  LIF_TYPE_HOST                     = 1;
  LIF_TYPE_HOST_MANAGEMENT          = 2;
  LIF_TYPE_MNIC_OOB_MANAGEMENT      = 3;
  LIF_TYPE_MNIC_INTERNAL_MANAGEMENT = 4;
  LIF_TYPE_MNIC_INBAND_MANAGEMENT   = 5;
  LIF_TYPE_MNIC_CPU                 = 6;
  LIF_TYPE_SWM                      = 7;
  LIF_TYPE_LEARN                    = 8;
}

// types of NAT actions supported
enum NatAction {
  NAT_ACTION_NONE        = 0;
  // Address only static NAT
  NAT_ACTION_STATIC      = 1;
  // address and port translation to public (aka. Internet) address space
  NAT_ACTION_NAPT_PUBLIC = 2;
  // address and port translation to internal service address space
  NAT_ACTION_NAPT_SVC    = 3;
}

// BatchCtxt is opaque to application(s) and is expected to be passed
// back (to identify the batch) in every API call of this batch until
// BatchCommit() or BatchAbort()
message BatchCtxt {
  // opaque cookie
  uint64 BatchCookie = 1;
}

// Public/Internet or Service/Infra address
enum AddressType {
  ADDR_TYPE_NONE        = 0;
  ADDR_TYPE_PUBLIC      = 1;
  ADDR_TYPE_SERVICE     = 2;
}

