// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package {{.GoPkg.Name}} is a auto generated package.
Input file: {{.Name}} {{$file := .}}
*/
package {{.GoPkg.Name}}{{$validators := getValidatorManifest .}}{{$defaults := getDefaulterManifest .}}{{$storageTransformers := getStorageTransformersManifest .}}{{$requirements := getRequirementsManifest .}}

import (
	"context"
	fmt "fmt"
	"errors"

	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/ref"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"

    "github.com/pensando/sw/events/generated/eventattrs"
	"github.com/pensando/sw/api/generated/events"
	{{if $validators.Fmap}}
	validators "github.com/pensando/sw/venice/utils/apigen/validators"{{end}}
	{{if $storageTransformers.Fmap}}"github.com/pensando/sw/venice/utils/transformers/storage"{{end}}
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/api/interfaces"
)

// Dummy definitions to suppress nonused warnings
var _ kvstore.Interface
var _ log.Logger
var _ listerwatcher.WatcherClient

{{range .Enums}} {{ $name := getNormalizedEnumName .}}{{ $values := getNormalizedEnum .}}
// {{$name}} is a map of normalized values for the enum
var {{$name}} = map[string]string {
	{{$values}}
}

var {{getEnumVNameName .}} = map[int32]string {
	{{getEnumVNameValues .}}
}

var {{getEnumVValueName .}} = map[string]int32 {
	{{getEnumVValueValues .}}
}

func (x {{getEnumName .}}) String() string {
	return {{getEnumVNameName .}}[int32(x)]
}
{{end}}
{{if $validators.Fmap}}
var _ validators.DummyVar
var validatorMap{{getFileName .Name}} = make(map[string]map[string][]func(string, interface{})error)
{{end}}
{{if $storageTransformers.Fmap}}
var storageTransformersMap{{getFileName .Name}} = make(map[string][]func(ctx context.Context, i interface{}, toStorage bool) error)
var eraseSecretsMap{{getFileName .Name}} = make(map[string] func(i interface{}))
{{end}}
{{range .Messages}}{{if (len (getDbKey .)) ne 0}}{{$sep := ", "}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}}) MakeKey(prefix string) string {
	return fmt.Sprint(globals.ConfigRootPrefix, "/", prefix, "/", {{range $index, $value := (getDbKey .)}}{{if ($index) ne 0}}{{$sep}}{{end}}{{if strEq $value.Type "prefix"}}"{{$value.Val}}"{{else}}m.{{$value.Val}}{{end}}{{$sep := ", "}}{{end}})
}

func (m *{{.Name}})  MakeURI(cat, ver, prefix string) string { {{$uri := getMsgURIKey . ""}}{{if $uri.Ref}}
  in := m{{end}}
	return fmt.Sprint("/", cat, "/", prefix, "/", ver, {{$uri.Str}})
}{{end}}{{end}}

{{range .Messages}}{{if isListHelper .}}{{$type := getListType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
}

func (m *{{.Name}})  MakeURI(ver, prefix string) string { {{$uri := getMsgURIKey . ""}}{{if $uri.Ref}}
  in := m{{end}}
	return fmt.Sprint("/", globals.ConfigURIPrefix, "/", prefix, "/", ver, {{$uri.Str}})
}{{end}} {{end}}
{{range .Messages}}{{if isWatchHelper .}}{{$type := getWatchType . false}}
// MakeKey generates a KV store key for the object
func (m *{{.Name}})  MakeKey(prefix string) string {
	obj := {{$type}}{}
	return obj.MakeKey(prefix)
} {{end}} {{end}}
{{range .Messages}}{{if isMapEntry .}}{{else}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}
// Clone clones the object into into or creates one of into is nil
func (m *{{getStr 0}}) Clone(into interface{}) (interface{}, error) {
	var out *{{getStr 0}}
	var ok bool
	if into == nil {
		out = &{{getStr 0}}{}
	} else {
		out, ok = into.(*{{getStr 0}})
		if !ok {
			return nil, fmt.Errorf("mismatched object types")
		}
	}
	*out = *(ref.DeepCopy(m).(*{{getStr 0}}))
	return out, nil
}

// Default sets up the defaults for the object
func (m *{{getStr 0}}) Defaults(ver string) bool { {{$msg := .}}{{if isSpecStatusMessage .}}
	var ret bool
	m.Kind = "{{.Name}}" {{if isTenanted .}}
	ret = m.Tenant != "default" || m.Namespace != "default"
	if ret {
		m.Tenant, m.Namespace = "default", "default"
	}{{else}}
    ret = m.Tenant != "" || m.Namespace != ""
    if ret {
	m.Tenant, m.Namespace = "", ""
	}{{end}}{{end}}{{with index $defaults.Map (getStr 0)}}{{if eq (len .Fields) 0}}
	{{if isSpecStatusMessage $msg}}return ret {{else}}return false {{end}}{{else}}{{if isSpecStatusMessage $msg}}{{else}}
	var ret bool {{end}}{{range $fldk, $defval := .Fields}}{{if $defval.Nested}}{{if $defval.Repeated}}
	for k := range m.{{$fldk}} { {{if $defval.Pointer}}
		if m.{{$fldk}}[k] != nil {
			i := m.{{$fldk}}[k]
			ret = i.Defaults(ver) || ret
		}{{else}}
		i := m.{{$fldk}}[k]
		ret = i.Defaults(ver) || ret {{end}}
	}{{else}}{{if $defval.Pointer}}
	if m.{{$fldk}} != nil {
		ret = m.{{$fldk}}.Defaults(ver) || ret
	}{{else}}
	ret = m.{{$fldk}}.Defaults(ver) || ret{{end}}{{end}}{{end}}{{end}}{{if eq (len .Versions) 0}}{{else}}
	ret = true
	switch ver { {{range $ver, $verdef := .Versions}}{{if eq $ver "all"}}
	default: {{else}}
	case "{{$ver}}": {{end}}{{range $fldk, $def := $verdef}}{{/*<0>*/}}{{if $def.Repeated}}{{/*<1>*/}}
	for k := range m.{{$fldk}} { {{if $def.Pointer}}{{/*<2>*/}}
		if m.{{$fldk}}[k] != nil {
			*m.{{$fldk}}[k] = {{$def.Val}}
		} {{else}}
		m.{{$fldk}}[k] = {{$def.Val}}{{end}}{{/*<2>*/}}
	}{{else}}{{if $def.Pointer}}{{/*<3>*/}}
	if m.{{$fldk}} != nil {
		m.{{$fldk}} = {{$def.Val}}
	}{{else}}
	m.{{$fldk}} = {{$def.Val}}{{end}}{{/*<3>*/}}{{end}}{{/*<1>*/}}{{end}}{{/*<0>*/}}
	{{end}} }{{/*<lenVer!=0>*/}}{{end}}{{/*<rangeVersion>*/}}
	return ret{{end}}
} {{end}}{{end}}
{{end}}


// Validators and Requirements
{{range .Messages}}{{/*<0-1>*/}}{{if isMapEntry .}}{{/*<0>*/}}{{else}}{{/*<0>*/}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{/*<x>*/}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}{{/*<x>*/}}{{$msg := .}}{{$msgname := (getStr 0)}}
func (m *{{$msgname}}) References(tenant string, path string, resp map[string]apiintf.ReferenceObj) {
    {{if isSpecStatusMessage .}}{{if isTenanted .}}
    tenant = m.Tenant{{end}}{{end}}{{with (index $requirements.Map $msgname)}}
        {{range $fldk, $fldv := .Fields}}
        {
            {{if $fldv.OverrideTenant}}tenant = m.{{$fldv.TenantFld}}{{end}}
            dlmtr := "."
            if path == "" {
                dlmtr = ""
            }
            tag := path + dlmtr + "{{getJSONTagByName $msg $fldk}}"{{if $fldv.Scalar}}
			uref, ok := resp[tag]
			if !ok {
				uref = apiintf.ReferenceObj{
					RefType: apiintf.ReferenceType("{{$fldv.RefType}}"),
					RefKind: "{{$fldv.Kind}}",
				}
			}
        {{if $fldv.Repeated}}
        for _, v := range m.{{$fldk}} {
            {{if $fldv.Pointer}} if v != nil { {{end}}
            uref.Refs = append(uref.Refs, {{getRequirementPath $file $fldv "tenant" "v"}})
            {{if $fldv.Pointer}} } {{end}}
        } {{else}}
           {{if $fldv.Pointer}} if m.{{$fldk}} != nil {
            if *m.{{$fldk}} != ""  { {{else}}
            if m.{{$fldk}} != "" { {{end}}
            uref.Refs = append(uref.Refs, {{getRequirementPath $file $fldv "tenant" (joinFields "." "m" $fldk)}})
           }
           {{if $fldv.Pointer}} } {{end}}
        {{end}}
        if len(uref.Refs) > 0 {
            resp[tag] = uref
        }{{else}}
        {{if $fldv.Repeated}}
        for _, v := range m.{{$fldk}} {
          {{if $fldv.Pointer}} if v != nil { {{end}}
            v.References(tenant, tag, resp)
            {{if $fldv.Pointer}} } {{end}}
          } {{else}}
            {{if $fldv.Pointer}} if m.{{$fldk}} != nil { {{end}}
            m.{{$fldk}}.References(tenant, tag, resp)
            {{if $fldv.Pointer}} } {{end}}
        {{end}}{{end}}
        }{{end}}{{end}}
}

func (m *{{$msgname}}) Validate(ver, path string, ignoreStatus bool, ignoreSpec bool) []error {
	var ret []error {{if isSpecStatusMessage $msg}}
	{{if isTenanted $msg}}{{if isNamespaced $msg}}{{else}}
	if m.Namespace != "default" {
    	ret = append(ret, errors.New("Only Namespace default is allowed for {{$msgname}}"))
	}{{end}}{{else}}
	if m.Tenant != "" {
		ret = append(ret, errors.New("Tenant not allowed for {{$msgname}}"))
	}{{if isNamespaced $msg}}{{else}}
	if m.Namespace != "" {
			ret = append(ret, errors.New("Namespace not allowed for {{$msgname}}"))
	}{{end}}{{end}}{{end}}{{with (index $validators.Map $msgname)}}{{/*<1>*/}}{{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{/*<2>*/}}{{if eq 0 (len $fldv.Validators)}}{{/*<3>*/}}{{if $fldv.Repeated}}{{/*<4>*/}}
	for k, v := range m.{{$fldk}} {
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := fmt.Sprintf("%s%s{{$fldk}}[%v]", path, dlmtr, k)
		 if errs := v.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			 ret = append(ret, errs...)
		 }
	} {{else}}{{/*<4>*/}}
	{{if isSpecStatusMessage $msg}}{{/*<+5>*/}}
		{{if strEq $fldk "Status"}}{{/*<+6>*/}}
	if !ignoreStatus {
			{{if $fldv.Pointer}}{{/*<+7>*/}}
			if  m.{{$fldk}} != nil {
				{{end}}{{/*<-7>*/}}
				dlmtr := "."
				if path == "" {
					dlmtr = ""
				}
				npath := path + dlmtr + "{{$fldk}}"
				if errs := m.{{$fldk}}.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
				ret = append(ret, errs...)
			}{{if $fldv.Pointer}}{{/*<+7>*/}}
		}{{end}}{{/*<-7>*/}}
	}{{else}}{{/*<-6>*/}} {{if strEq $fldk "Spec"}}{{/*<+6>*/}}
	if !ignoreSpec {
		{{if $fldv.Pointer}}{{/*<+7>*/}}
        if  m.{{$fldk}} != nil {
		{{end}}{{/*<-7>*/}}
        	dlmtr := "."
        	if path == "" {
        		dlmtr = ""
        	}
        	npath := path + dlmtr + "{{$fldk}}"
        	if errs := m.{{$fldk}}.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
        		ret = append(ret, errs...)
        	}{{if $fldv.Pointer}}{{/*<+7>*/}}
        }{{end}}{{/*<-7>*/}}
        } {{end}}
	{{if $fldv.Pointer}}{{/*<9>*/}}if m.{{$fldk}} != nil { {{end}}{{/*<9>*/}}
	{
		dlmtr := "."
		if path == "" {
			dlmtr = ""
		}
		npath := path + dlmtr + "{{$fldk}}"
		if errs := m.{{$fldk}}.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}{{if $fldv.Pointer}}{{/*<+6>*/}}
	}{{end}}{{/*<-6>*/}}{{end}}{{/*<-5>*/}}{{else}}{{if strEq $fldk "ObjectMeta"}}{{else}}{{/*<5>*/}}
	{{if $fldv.Pointer}}{{/*<11>*/}}if  m.{{$fldk}} != nil { {{end}}{{/*<11>*/}}
	{
			dlmtr := "."
			if path == "" {
				dlmtr = ""
			}
			npath := path + dlmtr + "{{$fldk}}"
			if errs := m.{{$fldk}}.Validate(ver, npath, ignoreStatus, ignoreSpec); errs != nil {
			ret = append(ret, errs...)
		}
	}{{if $fldv.Pointer}}{{/*<12>*/}}
	}{{end}}{{/*<12>*/}}{{end}}{{end}}{{/*<5>*/}}{{end}}{{/*<4>*/}}{{else}}{{/*<3>*/}}{{$_:= (saveBool true 0)}}{{end}}{{/*<3>*/}}{{end}}{{/*<2>*/}}{{if getBool 0}}{{/*<13>*/}}
	if vs, ok := validatorMap{{getFileName $file.Name}}["{{$msgname}}"][ver]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} else if vs, ok := validatorMap{{getFileName $file.Name}}["{{$msgname}}"]["all"]; ok {
		for _, v := range vs {
			if err := v(path, m); err != nil {
				ret = append(ret, err)
			}
		}
	} {{end}}{{/*<13>*/}}{{end}}{{/*<1>*/}}
	return ret
}

func (m *{{$msgname}}) Normalize() {
{{with (index $validators.Map $msgname)}}{{/*<1>*/}}{{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{/*<2>*/}}{{if eq 0 (len $fldv.Validators)}}{{/* this is a vector with validators */}}{{/*<3>*/}}{{if $fldv.Repeated}}{{/*<4>*/}}
	for k, v := range m.{{$fldk}} { {{if $fldv.Pointer}}
		if v != nil { {{end}}
			v.Normalize()
			m.{{$fldk}}[k] = v
		{{if $fldv.Pointer}} } {{end}}
	} {{else}}{{/*<4>*/}} {{if $fldv.Pointer}}
	if m.{{$fldk}} != nil { {{end}}
		m.{{$fldk}}.Normalize()
	{{if $fldv.Pointer}}  } {{end}}
	{{end}}{{/*<4>*/}}
	{{else}}{{/* <3> this is a field in this object with a validator */}}{{range $fldv.Validators}}{{if (strEq .Fn "StrEnum")}}{{/*<4>*/}}
	{{if $fldv.Repeated}}{{/*<5>*/}}
	for k, v := range  m.{{$fldk}} {
		m.{{$fldk}}[k] = {{getEnumStrNormalMap $file .Args}}[strings.ToLower(v)]
 	}{{else}}
		m.{{$fldk}} = {{getEnumStrNormalMap $file .Args}}[strings.ToLower(m.{{$fldk}})]
	{{end}}{{end}}{{/*<4>*/}}{{end}}
	{{end}}{{end}}{{end}}
}
{{end}}{{/*<0>*/}}{{end}}{{/*<0-1>*/}}

// Transformers
{{range .Messages}}{{if isMapEntry .}}{{else}}{{$x := saveStr (derefStr .Name) 0}}{{if isNestedMessage .}}{{$x := saveStr (getNestedMsgName .) 0}}{{end}}{{$msg := .}}{{$msgname := (getStr 0)}}{{with (index $storageTransformers.Map $msgname)}}{{if .HasTransformers}}
func (m *{{$msgname}}) ApplyStorageTransformer(ctx context.Context, toStorage bool) error { {{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Transformers)}}{{if $fldv.Repeated}}
	for i, v := range m.{{$fldk}} { {{if $fldv.Pointer}}
		 c := *v {{else}}
		 c := v {{end}}
		 if err := c.ApplyStorageTransformer(ctx, toStorage); err != nil {
			 return err
		 } {{if $fldv.Pointer}}
		 m.{{$fldk}}[i] = &c {{else}}
		 m.{{$fldk}}[i] = c {{end}}
	} {{else}}{{if isSpecStatusMessage $msg}}
	if err := m.{{$fldk}}.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}{{else}}
	{{if $fldv.Pointer}}
	if m.{{$fldk}} == nil {
		return nil
	}{{end}}
	if err := m.{{$fldk}}.ApplyStorageTransformer(ctx, toStorage); err != nil {
		return err
	}{{end}}{{end}}{{else}}{{$_:= (saveBool true 0)}}{{end}}{{end}}{{if getBool 0}}
	if vs, ok := storageTransformersMap{{getFileName $file.Name}}["{{$msgname}}"]; ok {
		for _, v := range vs {
			if err := v(ctx, m, toStorage); err != nil {
				return err
			}
		}
	} {{end}}
	return nil
}

func (m *{{$msgname}}) EraseSecrets() { {{$_ := (saveBool false 0)}}{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Transformers)}}{{if $fldv.Repeated}}
	for _, v := range m.{{$fldk}} {
		 v.EraseSecrets()
	} {{else}}{{if isSpecStatusMessage $msg}}
	m.{{$fldk}}.EraseSecrets()
	{{else}}
	{{if $fldv.Pointer}}
	if m.{{$fldk}} == nil {
		return
	}{{end}}
	m.{{$fldk}}.EraseSecrets()
	{{end}}{{end}}{{else}}{{$_:= (saveBool true 0)}}{{end}}{{end}}{{if getBool 0}}
	if v, ok := eraseSecretsMap{{getFileName $file.Name}}["{{$msgname}}"]; ok {
		v(m)
	} {{end}}
	return
}

{{if isSpecStatusMessage $msg}}
type storage{{$msgname}}Transformer struct {}
var Storage{{$msgname}}Transformer storage{{$msgname}}Transformer

func (st *storage{{$msgname}}Transformer) TransformFromStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.({{$msgname}})
	err := r.ApplyStorageTransformer(ctx, false)
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (st *storage{{$msgname}}Transformer) TransformToStorage(ctx context.Context, i interface{}) (interface{}, error) {
	r := i.({{$msgname}})
	err := r.ApplyStorageTransformer(ctx, true)
	if err != nil {
		return nil, err
	}
	return r, nil
}
{{end}}{{end}}{{end}}{{end}}{{end}}

func init() {
	scheme := runtime.GetDefaultScheme()
	scheme.AddKnownTypes({{range  .Messages}}{{if (len (getDbKey .)) ne 0}}
		&{{.Name}}{},{{end}}{{end}}
	)
{{if $validators.Fmap}}{{/*<1>*/}}
	validatorMap{{getFileName .Name}} = make(map[string]map[string][]func(string, interface{})error){{range .Messages}}{{/*<2>*/}}{{$msgName := getMsgName .}}{{with (index $validators.Map (derefStr .Name))}}{{/*<3>*/}}
	{{$_ := saveBool true 1}}{{range $fldk, $fldv := .Fields}}{{/*<4>*/}}{{if eq 0 (len $fldv.Validators)}}{{/*<5>*/}}{{else}}{{/*<5>*/}}{{if getBool 1}}{{/*<6>*/}}
	validatorMap{{getFileName $file.Name}}["{{$msgName}}"] = make(map[string][]func(string, interface{})error){{$_ := saveBool false 1}}{{end}}{{/*<6>*/}}{{end}}{{/*<5>*/}}{{end}}{{/*<4>*/}}{{range $fldk, $fldv := .Fields}}{{/*<7>*/}}{{if eq 0 (len $fldv.Validators)}}{{/*<8>*/}}{{else}}{{/*<8>*/}}
	{{range $fldv.Validators}}{{/*<9>*/}}{{if eq 0 (len .Args)}}{{/*<10>*/}}{{$fnname := .Fn}}
	validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(path string, i interface{}) error {
		m := i.(*{{$msgName}}){{if $fldv.Repeated}}{{/*<9.1>*/}}
		for k, v := range m.{{$fldk}} {
			if err := {{if .AllowEmpty}}validators.EmptyOr(validators.{{.Fn}}, v, nil){{else}}validators.{{$fnname}}(v){{end}}; err != nil {
				return fmt.Errorf("%v[%v] failed validation: %s", path + "." + "{{$fldk}}", k, err.Error())
			}
		}
		{{else}}{{/*<9.1>*/}}
		if err := {{if .AllowEmpty}}validators.EmptyOr(validators.{{.Fn}}, m.{{$fldk}}, nil){{else}}validators.{{.Fn}}(m.{{$fldk}}){{end}}; err != nil {
			return fmt.Errorf("%v failed validation: %s", path + "." + "{{$fldk}}", err.Error())
		}{{end}}{{/*<9.1>*/}}
		return nil
	})
		{{else}}{{/*<10>*/}} validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"] = append(validatorMap{{getFileName $file.Name}}["{{$msgName}}"]["{{.Ver}}"], func(path string, i interface{}) error {
		m := i.(*{{$msgName}})
		{{if (strEq .Fn "StrEnum")}}{{/*<11>*/}}{{$enummap := (getEnumStrMap $file .Args)}}{{if $fldv.Repeated}}{{/*<12>*/}}
        for k, v := range m.{{$fldk}} { {{if .AllowEmpty}}
            if len(v) == 0 {
                continue
            }
            {{end}}
			if _, ok := {{$enummap}}[v]; !ok {
				vals := []string{}
				for k1, _ := range  {{$enummap}} {
					vals = append(vals, k1)
				}
				return fmt.Errorf("%v[%v] did not match allowed strings %v", path + "." + "{{$fldk}}", k, vals)
			}
		}{{else}}{{/*<12>*/}}
        if _, ok := {{$enummap}}[m.{{$fldk}}]; !ok {{if .AllowEmpty}} && len(m.{{$fldk}}) != 0 {{end}}{
        	vals := []string{}
        	for k1, _ := range  {{$enummap}} {
        		vals = append(vals, k1)
        	}
			return fmt.Errorf("%v did not match allowed strings %v", path + "." + "{{$fldk}}", vals)
		}{{end}}{{/*<12>*/}}{{else}}{{/*<11>*/}}args := make([]string, 0) {{$fnname := .Fn}}
		{{range .Args}}{{/*<13>*/}}args = append(args, "{{.}}")
		{{end}}{{/*<13>*/}}{{if $fldv.Repeated}}{{/*<14>*/}}
		for _, v := range m.{{$fldk}} {
			if err := {{if .AllowEmpty}}validators.EmptyOr(validators.{{$fnname}}, v, args){{else}}validators.{{$fnname}}(v, args){{end}}; err != nil {
				return fmt.Errorf("%v failed validation: %s", path + "." + "{{$fldk}}", err.Error())
			}
		}{{else}}{{/*<14>*/}}
		if err := {{if .AllowEmpty}}validators.EmptyOr(validators.{{$fnname}}, m.{{$fldk}}, args){{else}}validators.{{$fnname}}(m.{{$fldk}}, args){{end}}; err != nil {
			return fmt.Errorf("%v failed validation: %s", path + "." + "{{$fldk}}", err.Error())
		}{{end}}{{/*<14>*/}}{{end}}{{/*<11>*/}}
		return nil
	})
	{{end}}{{/*<10>*/}}{{end}}{{/*<9>*/}}{{end}}{{/*<8>*/}}{{end}}{{/*<7>*/}}{{end}}{{/*<3>*/}}{{end}}{{/*<2>*/}}
{{end}}{{/*<1>*/}}

{{if $storageTransformers.Fmap}}
	{{range .Messages}}{{$msgName := .Name}}{{with (index $storageTransformers.Map (derefStr .Name))}}
	{{range $fldk, $fldv := .Fields}}{{if eq 0 (len $fldv.Transformers)}}{{else}}
	{{range $fldv.Transformers}}{{if eq 0 (len .Args)}}
	{
	{{$msgName}}{{$fldk}}Tx, err := storage.New{{.Fn}}ValueTransformer()
	if err != nil {
		log.Fatalf("Error instantiating {{.Fn}}StorageTransformer: %v", err)
	}
	storageTransformersMap{{getFileName $file.Name}}["{{$msgName}}"] = append(storageTransformersMap{{getFileName $file.Name}}["{{$msgName}}"],
	func(ctx context.Context, i interface{}, toStorage bool) error {
		var data []byte
		var err error
		m := i.(*{{$msgName}})
		{{if $fldv.Repeated}}
		slice := make([]{{$fldv.TypeCast}}, 0)
		for _, v := range m.{{$fldk}} {
			if toStorage {
				data, err = {{$msgName}}{{$fldk}}Tx.TransformToStorage(ctx, []byte(v))
			} else {
				data, err = {{$msgName}}{{$fldk}}Tx.TransformFromStorage(ctx, []byte(v))
			}
			if err != nil {
				return err
			}
			if data != nil {
				slice = append(slice, {{$fldv.TypeCast}}(data))
			}
		}
		m.{{$fldk}} = slice
		{{else}}
		if toStorage {
			data, err = {{$msgName}}{{$fldk}}Tx.TransformToStorage(ctx, []byte(m.{{$fldk}}))
		} else {
			data, err = {{$msgName}}{{$fldk}}Tx.TransformFromStorage(ctx, []byte(m.{{$fldk}}))
		}
		m.{{$fldk}} = {{$fldv.TypeCast}}(data)
		{{end}}
		return err
	})
	{{ if eq "Secret" .Fn}}
	eraseSecretsMap{{getFileName $file.Name}}["{{$msgName}}"] = func (i interface{}) {
    		m := i.(*{{$msgName}})
    		{{if $fldv.Repeated}}
    		m.{{$fldk}} = nil
    		{{else}}
    		var data []byte
    		m.{{$fldk}} = {{$fldv.TypeCast}}(data)
    		{{end}}
    		return
	}
	{{end}}
	}
	{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}
{{end}}
}
