// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"
	"github.com/gorilla/websocket"

	{{.GoPkg.Name}} "{{getRelPath .}}/generated/{{.GoPkg.Name}}"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/globals"
	api "github.com/pensando/sw/api"
	"github.com/pensando/sw/api/interfaces"
	apiserver "github.com/pensando/sw/venice/apiserver"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
)


// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface


{{$pkgname := .GoPkg.Name}}{{range .Services}}{{$srvname := .Name}}
// New{{$srvname}} sets up a new client for {{$srvname}}
func New{{$srvname}}(conn *grpc.ClientConn, logger log.Logger) {{$pkgname}}.Service{{$srvname}}Client {
 {{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{else}}
	var l{{.Name}}Endpoint endpoint.Endpoint
	{
		l{{.Name}}Endpoint = grpctransport.NewClient(
			conn,
			"{{$pkgname}}.{{$srvname}}",
			"{{.Name}}",
			{{$pkgname}}.EncodeGrpcReq{{.RequestType.Name}},
			{{$pkgname}}.DecodeGrpcResp{{.ResponseType.Name}},
			&{{getOutputType $pkgname . true}}{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
        l{{.Name}}Endpoint = trace.ClientEndPoint("{{$srvname}}:{{.Name}}")(l{{.Name}}Endpoint)
	} {{end}}{{end}}
	return {{$pkgname}}.Endpoints{{$srvname}}Client{
		Client: {{$pkgname}}.New{{$srvname}}Client(conn),
	{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{else}}
		{{.Name}}Endpoint:  l{{.Name}}Endpoint,{{end}} {{end}}
	}
}

// New{{$srvname}}Backend creates an instrumented client with middleware
func New{{$srvname}}Backend(conn *grpc.ClientConn, logger log.Logger) {{$pkgname}}.Service{{$srvname}}Client {
	cl := New{{$srvname}}(conn, logger)
	cl = {{$pkgname}}.Logging{{$srvname}}MiddlewareClient(logger)(cl)
	return cl
}
{{end}}

{{range .Services}}{{$svc := .}}{{$srvname := .Name}}{{$version := getExtension "venice.apiVersion" .}}{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}{{$crudop := .}}
type grpcObj{{$srvname}}{{.}} struct {
	logger log.Logger
	client {{$pkgname}}.Service{{$srvname}}Client
}

func (a *grpcObj{{$srvname}}{{.}}) Create(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoAdd{{.}}(nctx, in)
}

func (a *grpcObj{{$srvname}}{{.}}) Update(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoUpdate{{.}}(nctx, in)
}

func (a *grpcObj{{$srvname}}{{.}}) UpdateStatus(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdate{{.}}(nctx, in)
}

func (a *grpcObj{{$srvname}}{{.}}) Label(ctx context.Context, in *api.Label) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoLabel{{.}}(nctx, in)
}

func (a *grpcObj{{$srvname}}{{.}}) Get(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoGet{{.}}(nctx, &in)
}

func (a *grpcObj{{$srvname}}{{.}}) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.AutoDelete{{.}}(nctx, &in)
}

func (a *grpcObj{{$srvname}}{{.}}) List(ctx context.Context, options *api.ListWatchOptions) ([]*{{$pkgname}}.{{.}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	r, err := a.client.AutoList{{.}}(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObj{{$srvname}}{{.}}) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "WatchOper")
	nctx := addVersion(ctx, "{{$version}}")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatch{{.}}(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.({{$pkgname}}.{{$srvname}}_AutoWatch{{.}}Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}
{{$actions := getSvcActionEndpoints $svc .}}{{range $actions}}
func (a *grpcObj{{$srvname}}{{$crudop}}) {{.Name}}(ctx context.Context, in *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.}}", "oper", "{{.Name}}")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "{{$version}}")
	return a.client.{{.Name}}(nctx, in)
}
{{end}}

func (a *grpcObj{{$srvname}}{{.}}) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObj{{$srvname}}{{.}} struct {
	endpoints {{$pkgname}}.Endpoints{{$srvname}}RestClient
	instance string
}

func (a *restObj{{$srvname}}{{.}}) Create(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAdd{{.}}(ctx, in)
}

func (a *restObj{{$srvname}}{{.}}) Update(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdate{{.}}(ctx, in)
}

func (a *restObj{{$srvname}}{{.}}) UpdateStatus(ctx context.Context, in *{{$pkgname}}.{{.}}) (*{{$pkgname}}.{{.}}, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObj{{$srvname}}{{.}}) Label(ctx context.Context, in *api.Label) (*{{$pkgname}}.{{.}}, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabel{{.}}(ctx, in)
}

func (a *restObj{{$srvname}}{{.}}) Get(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGet{{.}}(ctx, &in)
}

func (a *restObj{{$srvname}}{{.}}) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*{{$pkgname}}.{{.}}, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := {{$pkgname}}.{{.}}{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDelete{{.}}(ctx, &in)
}

func (a *restObj{{$srvname}}{{.}}) List(ctx context.Context, options *api.ListWatchOptions) ([]*{{$pkgname}}.{{.}}, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	{{if (isObjTenanted $svc.File  .)}}
	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}{{end}}
	r, err := a.endpoints.AutoList{{.}}(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObj{{$srvname}}{{.}}) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatch{{.}}(ctx, options)
}

func (a *restObj{{$srvname}}{{.}}) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
		case apiintf.CreateOper:
		{{if isRestMethod $svc "AutoAdd" .}} return true {{else}} return false {{end}}
		case apiintf.UpdateOper:
		{{if isRestMethod $svc "AutoUpdate" .}} return true {{else}} return false {{end}}
		case apiintf.GetOper:
		{{if isRestMethod $svc "AutoGet" .}} return true {{else}} return false {{end}}
		case apiintf.DeleteOper:
		{{if isRestMethod $svc "AutoDelete" .}} return true {{else}} return false {{end}}
		case apiintf.ListOper:
		{{if isRestMethod $svc "AutoList" .}} return true {{else}} return false {{end}}
		case apiintf.WatchOper:
		{{if isRestMethod $svc "AutoWatch" .}} return true {{else}} return false {{end}}
		default:
		return false
	}
}
{{$actions := getSvcActionEndpoints $svc .}}{{range $actions}}
func (a *restObj{{$srvname}}{{$crudop}}) {{.Name}}(ctx context.Context, in *{{$pkgname}}.{{.Request}}) (*{{$pkgname}}.{{.Response}}, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.{{.Name}}{{$crudop}}(ctx, in)
}{{end}}
{{end}}{{end}}{{end}}

{{range .Services}}{{$srvname := .Name}}{{if (hasExtension "venice.apiGrpcCrudService" .)}}
type crudClient{{$srvname}} struct {
	logger log.Logger
	client {{$pkgname}}.Service{{$srvname}}Client
	{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
	grpc{{.}} {{$pkgname}}.{{$srvname}}{{.}}Interface{{end}}
}

// NewGrpcCrudClient{{$srvname}} creates a GRPC client for the service
func NewGrpcCrudClient{{$srvname}}(conn *grpc.ClientConn, logger log.Logger) {{$pkgname}}.{{$srvname}}Interface {
	client := New{{$srvname}}Backend(conn, logger)
	return &crudClient{{$srvname}}{
		logger: logger,
		client: client,
		{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
		grpc{{.}}: &grpcObj{{$srvname}}{{.}}{ client: client, logger: logger },{{end}}
	}
}
{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
func (a *crudClient{{$srvname}}) {{title .}}() {{$pkgname}}.{{$srvname}}{{.}}Interface {
	return a.grpc{{.}}
}
{{end}}{{$version := getExtension "venice.apiVersion" .}}

func (a *crudClient{{$srvname}}) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "{{.Name}}", "oper", "WatchOper")
	nctx := addVersion(ctx, "{{$version}}")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvc{{.Name}}(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.({{$pkgname}}.{{$srvname}}_AutoWatchSvc{{.Name}}Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type:   kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
	 				close(lw.OutCh)
	 				return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClient{{$srvname}} struct {
	{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
	rest{{.}} {{$pkgname}}.{{$srvname}}{{.}}Interface{{end}}
}

// NewRestCrudClient{{$srvname}} creates a REST client for the service.
func NewRestCrudClient{{$srvname}}(url string, httpClient *http.Client) {{$pkgname}}.{{$srvname}}Interface {
	endpoints, err := {{$pkgname}}.Make{{$srvname}}RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClient{{$srvname}}{
		{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
		rest{{.}}: &restObj{{$srvname}}{{.}}{ endpoints: endpoints, instance: url},{{end}}
	}
}

// NewStagedRestCrudClient{{$srvname}} creates a REST client for the service.
func NewStagedRestCrudClient{{$srvname}}(url string, id string, httpClient *http.Client) {{$pkgname}}.{{$srvname}}Interface {
	endpoints, err := {{$pkgname}}.Make{{$srvname}}StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClient{{$srvname}}{
		{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
		rest{{.}}: &restObj{{$srvname}}{{.}}{ endpoints: endpoints, instance: url},{{end}}
	}
}

{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
func (a *crudRestClient{{$srvname}}) {{title .}}() {{$pkgname}}.{{$srvname}}{{.}}Interface {
	return a.rest{{.}}
}
{{end}}

func (a *crudRestClient{{$srvname}}) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
{{end}}{{end}}
