// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: {{.Name}}
*/
package ctkit {{$pkgname := .GoPkg.Name}}

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/{{$pkgname}}"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/resolver"
	"github.com/pensando/sw/venice/utils/rpckit"
)

{{range .Services}}{{$svc := . }}{{$srvname := .Name}}{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}
{{$crudobjs := getSvcCrudObjects .}}{{range $crudobjs}}


// {{.}} is a wrapper object that implements additional functionality
type {{.}} struct {
	sync.Mutex
	{{$pkgname}}.{{.}}
	HandlerCtx interface{}   // additional state handlers can store
	ctrler     *ctrlerCtx    // reference back to the controller instance
}

func (obj *{{.}}) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		log.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		nobj := *obj
		// FIXME: clear the resource version till we figure out CAS semantics
		nobj.ObjectMeta.ResourceVersion = ""

		// update it
		_, err = apicl.{{$srvname}}().{{.}}().Update(context.Background(), &nobj.{{.}})
	} else {
		//  create
		_, err = apicl.{{$srvname}}().{{.}}().Create(context.Background(), &obj.{{.}})
	}

	return nil
}

// {{.}}Handler is the event handler for {{.}} object
type {{.}}Handler interface {
	On{{.}}Create(obj *{{.}}) error
	On{{.}}Update(obj *{{.}}) error
	On{{.}}Delete(obj *{{.}}) error
}

// handle{{.}}Event handles {{.}} events from watcher
func (ct *ctrlerCtx) handle{{.}}Event(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *{{$pkgname}}.{{.}}:
		eobj := evt.Object.(*{{$pkgname}}.{{.}})
		kind := "{{.}}"

		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		handler, ok := ct.handlers[kind]
		if !ok {
			log.Fatalf("Cant find the handler for %s", kind)
		}
		{{ToLower .}}Handler := handler.({{.}}Handler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &{{.}}{
					{{.}}:   *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				// call the event handler
				obj.Lock()
				err = {{ToLower .}}Handler.On{{.}}Create(obj)
				obj.Unlock()
				if err != nil {
					log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*{{.}})
				obj.ObjectMeta = eobj.ObjectMeta

				// see if it changed
				if _, ok := ref.ObjDiff(obj.Spec, eobj.Spec); ok {
					obj.Spec = eobj.Spec
					// call the event handler
					obj.Lock()
					err = {{ToLower .}}Handler.On{{.}}Update(obj)
					obj.Unlock()
					if err != nil {
						log.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						return err
					}
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				log.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}
			
			obj := fobj.(*{{.}})

			// Call the event reactor
			obj.Lock()
			err = {{ToLower .}}Handler.On{{.}}Delete(obj)
			obj.Unlock()
			if err != nil {
				log.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				return err
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		log.Fatalf("API watcher Found object of invalid type: %v on {{.}} watch channel", tp)
	}

	return nil
}


// diff{{.}} does a diff of {{.}} objects between local cache and API server
func (ct *ctrlerCtx) diff{{.}}(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.{{$srvname}}().{{.}}().List(context.Background(), &opts)
	if err != nil {
		log.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	// build an object map
	objmap := make(map[string]*{{$pkgname}}.{{.}})
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range ct.{{.}}().List() {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.{{.}},
			}
			ct.handle{{.}}Event(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handle{{.}}Event(&evt)
	}
}

func (ct *ctrlerCtx) run{{.}}Watcher() {
	kind := "{{.}}"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}

	// setup wait group
	ct.waitGrp.Add(1)
	defer ct.waitGrp.Done()

	// loop forever
	for {
		// create a grpc client
		apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, ct.logger, rpckit.WithBalancer(ct.balancer))
		if err != nil {
			log.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
		} else {
			log.Infof("API client connected {%+v}", apicl)

			// {{.}} object watcher
			wt, werr := apicl.{{$srvname}}().{{.}}().Watch(ctx, &opts)
			if werr != nil {
				log.Errorf("Failed to start %s watch (%s)\n", kind, werr)
				return
			}
			ct.Lock()
			ct.watchers[kind] = wt
			ct.Unlock()

			// perform a diff with API server and local cache
			time.Sleep(time.Millisecond * 100)
			ct.diff{{.}}(apicl)

			// handle api server watch events
		innerLoop:
			for {
				// wait for events
				select {
				case evt, ok := <-wt.EventChan():
					if !ok {
						log.Error("Error receiving from apisrv watcher")
						break innerLoop
					}

					// handle event
					ct.handle{{.}}Event(evt)
				}
			}
			apicl.Close()
		}

		// if stop flag is set, we are done
		if ct.stoped {
			log.Infof("Exiting API server watcher")
			return
		}

		// wait for a second and retry connecting to api server
		time.Sleep(time.Second)
	}
}

// Watch{{.}} starts watch on {{.}} object
func (ct *ctrlerCtx) Watch{{.}}(handler {{.}}Handler) error {
	kind := "{{.}}"

	ct.Lock()
	defer ct.Unlock()

	// see if we already have a watcher
	_, ok := ct.watchers[kind]
	if ok {
		return fmt.Errorf("{{.}} watcher already exists")
	}

	// save handler
	ct.handlers[kind] = handler

	// run {{.}} watcher in a go routine
	go ct.run{{.}}Watcher()

	return nil
}


// {{.}}API returns
type {{.}}API interface {
	Create(obj *{{$pkgname}}.{{.}}) error
	Update(obj *{{$pkgname}}.{{.}}) error
	Delete(obj *{{$pkgname}}.{{.}}) error
	List() []*{{.}}
	Watch(handler {{.}}Handler) error
}

// dummy struct that implements {{.}}API
type {{ToLower .}}API struct {
	ct *ctrlerCtx
}

// Create creates {{.}} object
func (api *{{ToLower .}}API) Create(obj *{{$pkgname}}.{{.}}) error {
	return api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on {{.}} object
func (api *{{ToLower .}}API) Update(obj *{{$pkgname}}.{{.}}) error {
	return api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes {{.}} object
func (api *{{ToLower .}}API) Delete(obj *{{$pkgname}}.{{.}}) error {
	return api.ct.handle{{.}}Event(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// List returns a list of all {{.}} objects
func (api *{{ToLower .}}API) List() []*{{.}} {
	var objlist []*{{.}}

	objs := api.ct.ListObjects("{{.}}")
	for _, obj := range objs {
		switch tp := obj.(type) {
		case *{{.}}:
			eobj := obj.(*{{.}})
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for {{.}}", tp)
		}
	}

	return objlist
}

// Watch sets up a event handlers for {{.}} object
func (api *{{ToLower .}}API) Watch(handler {{.}}Handler) error {
	return api.ct.Watch{{.}}(handler)
}

// {{.}} returns {{.}}API
func (ct *ctrlerCtx) {{.}}() {{.}}API {
	return &{{ToLower .}}API{ct: ct}
}

{{end}}{{end}}{{end}}
