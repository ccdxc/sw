// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package {{.GoPkg.Name}} is a auto generated package.
Input file: {{.Name}}
*/
package {{.GoPkg.Name}}{{$pkgname := .GoPkg.Name}}

import (
	"net/url"
	"net/http"
	"strings"
	"context"
	"time"
	"fmt"
	"errors"
	"crypto/tls"

	"github.com/go-kit/kit/endpoint"
	"google.golang.org/grpc"
	"github.com/gorilla/websocket"

	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/api/utils"
	loginctx "github.com/pensando/sw/api/login/context"
)

// Dummy definitions to suppress nonused warnings
var _ api.ObjectMeta
var _ grpc.ServerStream
var _ fmt.Formatter
var _ *listerwatcher.WatcherClient

{{range .Services}}{{$svcname := .Name}}
// Middleware{{$svcname}}Client add middleware to the client
type Middleware{{$svcname}}Client func(Service{{$svcname}}Client) Service{{$svcname}}Client
// Endpoints{{$svcname}}Client is the endpoints for the client
type Endpoints{{$svcname}}Client struct {
	Client {{$svcname}}Client
	AutoWatchSvc{{$svcname}}Endpoint endpoint.Endpoint
	{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}} {{else}}
	{{.Name}}Endpoint endpoint.Endpoint{{end}}{{end}}
}

// Endpoints{{$svcname}}RestClient is the REST client
type Endpoints{{$svcname}}RestClient struct {
	logger log.Logger
	client *http.Client
	instance string
	bufferId string

	{{range .Methods}}{{$params := (getMethodParams .)}}
	{{.Name}}Endpoint endpoint.Endpoint{{end}}
}

// Middleware{{$svcname}}Server adds middle ware to the server
type Middleware{{$svcname}}Server func(Service{{$svcname}}Server) Service{{$svcname}}Server
// Endpoints{{$svcname}}Server is the server endpoints{{/*<ServerEndpoints>*/}}
type Endpoints{{$svcname}}Server struct {
	svcWatchHandler{{$svcname}} func(options *api.ListWatchOptions, stream grpc.ServerStream) error
	{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{else}}{{/*<NonStreamingEndpoints>*/}}
	{{.Name}}Endpoint endpoint.Endpoint{{end}}{{end}}
	{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{range $cruds}}
	watchHandler{{.}} func(options *api.ListWatchOptions, stream grpc.ServerStream) error{{end}}{{end}}
}

{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}} {{else}}
// {{.Name}} is endpoint for {{.Name}}
func (e Endpoints{{$svcname}}Client) {{.Name}}(ctx context.Context, in *{{getInputType $pkgname . false}}) (*{{getOutputType $pkgname . false}}, error) {
	resp, err := e.{{.Name}}Endpoint(ctx, in)
	if err != nil {
		return &{{getOutputType $pkgname . false}}{}, err
	}
	return resp.(*{{getOutputType $pkgname . false}}), nil
}

type resp{{$svcname}}{{.Name}} struct {
	V   {{getOutputType $pkgname . false}}
	Err error
}{{end}}{{end}}{{/*<end><NonStreamingEndpoints>*/}}
{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}
func (e Endpoints{{$svcname}}Client) AutoWatchSvc{{$svcname}}(ctx context.Context, in *api.ListWatchOptions) ({{$svcname}}_AutoWatchSvc{{$svcname}}Client, error) {
	return e.Client.AutoWatchSvc{{$svcname}}(ctx, in)
}
{{range $cruds}}
// AutoWatch{{.}} performs Watch for {{.}}
func (e Endpoints{{$svcname}}Client) AutoWatch{{.}}(ctx context.Context, in *api.ListWatchOptions) ({{$svcname}}_AutoWatch{{.}}Client, error) {
	return e.Client.AutoWatch{{.}}(ctx, in)
}{{end}}{{else}}
func (e Endpoints{{$svcname}}Client) AutoWatchSvc{{$svcname}}(ctx context.Context, in *api.ListWatchOptions) ({{$svcname}}_AutoWatchSvc{{$svcname}}Client, error) {
	return nil, errors.New("not implemented")
}
{{end}}

{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{if (strEq $params.Oper "WatchOper")}} {{else}}{{if isClientStreaming .}}
func (e Endpoints{{$svcname}}Client) {{.Name}}(ctx context.Context) ({{$svcname}}_{{.Name}}Client, error) {
	return e.Client.{{.Name}}(ctx)
} {{else}}
func (e Endpoints{{$svcname}}Client) {{.Name}}(ctx context.Context, in *{{getInputType $pkgname . false}}) ({{$svcname}}_{{.Name}}Client, error) {
	return e.Client.{{.Name}}(ctx, in)
}{{end}}{{end}}{{end}}{{end}}

{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{else}}
// {{.Name}} implementation on server Endpoint
func (e Endpoints{{$svcname}}Server) {{.Name}}(ctx context.Context, in {{getInputType $pkgname . false}}) ({{getOutputType $pkgname . false}}, error) {
	resp, err := e.{{.Name}}Endpoint(ctx, in)
	if err != nil {
		return {{getOutputType $pkgname . false}}{}, err
	}
	return *resp.(*{{getOutputType $pkgname . false}}), nil
}

// Make{{$svcname}}{{.Name}}Endpoint creates  {{.Name}} endpoints for the service
func Make{{$svcname}}{{.Name}}Endpoint(s Service{{$svcname}}Server, logger log.Logger ) endpoint.Endpoint {
	f := func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*{{getInputType $pkgname . false}})
		v, err := s.{{.Name}}(ctx, *req)
		return resp{{$svcname}}{{.Name}} {
			V:   v,
			Err: err,
		}, nil
	}
    return trace.ServerEndpoint("{{$svcname}}:{{.Name}}")(f)
}{{end}}{{end}}
{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{$prefix := (getExtension "venice.apiPrefix" .)}}
func (e Endpoints{{$svcname}}Server) AutoWatchSvc{{$svcname}}(in *api.ListWatchOptions, stream {{$svcname}}_AutoWatchSvc{{$svcname}}Server) error {
	return e.svcWatchHandler{{$svcname}}(in, stream)
}
// MakeAutoWatchSvc{{$svcname}}Endpoint creates the Watch endpoint for the service
func MakeAutoWatchSvc{{$svcname}}Endpoint(s Service{{$svcname}}Server, logger log.Logger) (func(options *api.ListWatchOptions, stream grpc.ServerStream) error) {
	return func(options *api.ListWatchOptions, stream grpc.ServerStream) error {
		wstream := stream.({{$svcname}}_AutoWatchSvc{{$svcname}}Server)
		return s.AutoWatchSvc{{$svcname}}(options, wstream)
	}
}
{{range $cruds}}
// AutoWatch{{.}} is the watch handler for {{.}} on the server side.
func (e Endpoints{{$svcname}}Server) AutoWatch{{.}}(in *api.ListWatchOptions, stream {{$svcname}}_AutoWatch{{.}}Server) error {
	return e.watchHandler{{.}}(in, stream)
}

// MakeAutoWatch{{.}}Endpoint creates the Watch endpoint
func MakeAutoWatch{{.}}Endpoint(s Service{{$svcname}}Server, logger log.Logger) (func(options *api.ListWatchOptions, stream grpc.ServerStream) error) {
	return func(options *api.ListWatchOptions, stream grpc.ServerStream) error {
		wstream := stream.({{$svcname}}_AutoWatch{{.}}Server)
		return s.AutoWatch{{.}}(options, wstream)
	}
}
{{end}}{{else}}
// MakeAutoWatchSvc{{$svcname}}Endpoint creates the Watch endpoint for the service
func MakeAutoWatchSvc{{$svcname}}Endpoint(s Service{{$svcname}}Server, logger log.Logger) (func(options *api.ListWatchOptions, stream grpc.ServerStream) error) {
	return func(options *api.ListWatchOptions, stream grpc.ServerStream) error {
		return errors.New("not implemented")
	}
}
{{end}}

{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{if (strEq $params.Oper "WatchOper")}} {{else}}{{if isClientStreaming .}}
func (e Endpoints{{$svcname}}Server) {{.Name}}(in {{$svcname}}_{{.Name}}Server) error {
	return errors.New("not implemented")
} {{else}}
func (e Endpoints{{$svcname}}Server) {{.Name}}(in *{{getInputType $pkgname . false}}, stream {{$svcname}}_{{.Name}}Server) error {
	return errors.New("not implemented")
}{{end}}{{end}}{{end}}{{end}}

// Make{{$svcname}}ServerEndpoints creates server endpoints
func Make{{$svcname}}ServerEndpoints(s Service{{$svcname}}Server, logger log.Logger) Endpoints{{$svcname}}Server {
	return Endpoints{{$svcname}}Server{
		svcWatchHandler{{$svcname}}: MakeAutoWatchSvc{{$svcname}}Endpoint(s, logger),
		{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}} {{else}}
		{{.Name}}Endpoint: Make{{$svcname}}{{.Name}}Endpoint(s, logger),{{end}}{{end}}
		{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{$prefix := (getExtension "venice.apiPrefix" .)}}{{range $cruds}}
		watchHandler{{.}} : MakeAutoWatch{{.}}Endpoint(s, logger),{{end}}{{end}}
	}
}

// Logging{{$svcname}}MiddlewareClient adds middleware for the client
func Logging{{$svcname}}MiddlewareClient(logger log.Logger) Middleware{{$svcname}}Client {
	return func(next Service{{$svcname}}Client) Service{{$svcname}}Client {
		return logging{{$svcname}}MiddlewareClient{
			logger: logger,
			next: next,
		}
	}
}

type logging{{$svcname}}MiddlewareClient struct {
	logger log.Logger
	next   Service{{$svcname}}Client
}

// Logging{{$svcname}}MiddlewareServer adds middleware for the client
func Logging{{$svcname}}MiddlewareServer(logger log.Logger) Middleware{{$svcname}}Server {
	return func(next Service{{$svcname}}Server) Service{{$svcname}}Server {
		return logging{{$svcname}}MiddlewareServer{
			logger: logger,
			next: next,
		}
	}
}

type logging{{$svcname}}MiddlewareServer struct {
	logger log.Logger
	next   Service{{$svcname}}Server
}

{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}} {{else}}
func (m logging{{$svcname}}MiddlewareClient) {{.Name}}(ctx context.Context, in *{{getInputType $pkgname . false}}) (resp *{{getOutputType $pkgname . false}}, err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(ctx, "service", "{{$svcname}}", "method", "{{.Name}}", "result", rslt, "duration", time.Since(begin), "error", err)
	}(time.Now())
	resp, err = m.next.{{.Name}}(ctx, in)
	return
}{{end}}{{end}}
{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{$prefix := (getExtension "venice.apiPrefix" .)}}
func (m logging{{$svcname}}MiddlewareClient) AutoWatchSvc{{$svcname}}(ctx context.Context, in *api.ListWatchOptions) (resp {{$svcname}}_AutoWatchSvc{{$svcname}}Client, err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(ctx, "service", "{{$svcname}}", "method", "AutoWatchSvc{{$svcname}}", "result", rslt, "duration", time.Since(begin), "error", err)
	}(time.Now())
	resp, err = m.next.AutoWatchSvc{{$svcname}}(ctx, in)
	return
}
{{range $cruds}}
func (m logging{{$svcname}}MiddlewareClient) AutoWatch{{.}}(ctx context.Context, in *api.ListWatchOptions) (resp {{$svcname}}_AutoWatch{{.}}Client, err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(ctx, "service", "{{$svcname}}", "method", "AutoWatch{{.}}", "result", rslt, "duration", time.Since(begin), "error", err)
	}(time.Now())
	resp, err = m.next.AutoWatch{{.}}(ctx, in)
	return
}{{end}}
{{else}}
func (m logging{{$svcname}}MiddlewareClient) AutoWatchSvc{{$svcname}}(ctx context.Context, in *api.ListWatchOptions) ({{$svcname}}_AutoWatchSvc{{$svcname}}Client, error) {
	return nil, errors.New("not implemented")
}{{end}}
{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{if (strEq $params.Oper "WatchOper")}} {{else}}{{if isClientStreaming .}}
func (m logging{{$svcname}}MiddlewareClient) {{.Name}}(ctx context.Context) (resp {{$svcname}}_{{.Name}}Client, err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(ctx, "service", "{{$svcname}}", "method", "{{.Name}}", "result", rslt, "duration", time.Since(begin), "error", err)
	}(time.Now())
	resp, err = m.next.{{.Name}}(ctx)
	return
} {{else}}
func (m logging{{$svcname}}MiddlewareClient) {{.Name}}(ctx context.Context, in *{{getInputType $pkgname . false}}) (resp {{$svcname}}_{{.Name}}Client, err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(ctx, "service", "{{$svcname}}", "method", "{{.Name}}", "result", rslt, "duration", time.Since(begin), "error", err)
	}(time.Now())
	resp, err = m.next.{{.Name}}(ctx, in)
	return
}{{end}}{{end}}{{end}}{{end}}

{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}} {{else}}
func (m logging{{$svcname}}MiddlewareServer) {{.Name}}(ctx context.Context, in {{getInputType $pkgname . false}}) (resp {{getOutputType $pkgname . false}}, err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(ctx, "service", "{{$svcname}}", "method", "{{.Name}}", "result", rslt, "duration", time.Since(begin))
	}(time.Now())
	resp, err = m.next.{{.Name}}(ctx, in)
	return
}{{end}}{{end}}
{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{$prefix := (getExtension "venice.apiPrefix" .)}}
func (m logging{{$svcname}}MiddlewareServer) AutoWatchSvc{{$svcname}}(in *api.ListWatchOptions, stream {{$svcname}}_AutoWatchSvc{{$svcname}}Server) (err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(stream.Context(), "service", "{{$svcname}}", "method", "AutoWatchSvc{{$svcname}}", "result", rslt, "duration", time.Since(begin))
	}(time.Now())
	err = m.next.AutoWatchSvc{{$svcname}}(in, stream)
	return
}
{{range $cruds}}
func (m logging{{$svcname}}MiddlewareServer) AutoWatch{{.}}(in *api.ListWatchOptions, stream {{$svcname}}_AutoWatch{{.}}Server) (err error) {
	defer func(begin time.Time) {
		var rslt string
		if err == nil {
			rslt = "Success"
		} else {
			rslt = err.Error()
		}
		m.logger.Audit(stream.Context(), "service", "{{$svcname}}", "method", "AutoWatch{{.}}", "result", rslt, "duration", time.Since(begin))
	}(time.Now())
	err = m.next.AutoWatch{{.}}(in, stream)
	return
}{{end}}{{else}}
func (m logging{{$svcname}}MiddlewareServer) AutoWatchSvc{{$svcname}}(in *api.ListWatchOptions, stream {{$svcname}}_AutoWatchSvc{{$svcname}}Server) (error) {
	return errors.New("Not implemented")
}
{{end}}

{{range .Methods}}{{$params := (getMethodParams .)}}{{if isStreaming .}}{{if (strEq $params.Oper "WatchOper")}} {{else}}{{if isClientStreaming .}}
func (m logging{{$svcname}}MiddlewareServer) {{.Name}}(in {{$svcname}}_{{.Name}}Server) error {
	return errors.New("not implemented")
} {{else}}
func (m logging{{$svcname}}MiddlewareServer) {{.Name}}(in *{{getInputType $pkgname . false}}, stream {{$svcname}}_{{.Name}}Server)  error {
	return errors.New("not implemented")
}{{end}}{{end}}{{end}}{{end}}

func (r *Endpoints{{$svcname}}RestClient) updateHTTPHeader(ctx context.Context, header *http.Header) {
	val, ok := loginctx.AuthzHeaderFromContext(ctx)
	if ok {
		header.Add("Authorization", val)
	}
	val, ok = loginctx.ExtRequestIDHeaderFromContext(ctx)
	if ok {
		header.Add("Pensando-Psm-External-Request-Id", val)
	}
}
func (r *Endpoints{{$svcname}}RestClient) getHTTPRequest(ctx context.Context, in interface{}, method, path string) (*http.Request, error) {
	target, err := url.Parse(r.instance)
	if err != nil {
		return nil, fmt.Errorf("invalid instance %s", r.instance)
	}
	target.Path = path
	req, err := http.NewRequest(method, target.String(), nil)
	if err != nil {
		return nil, fmt.Errorf("could not create request (%s)", err)
	}
    r.updateHTTPHeader(ctx, &req.Header)
	if err = encodeHTTPRequest(ctx, req, in); err != nil {
		return nil, fmt.Errorf("could not encode request (%s)", err)
	}
	return req, nil
}
{{$svcparams := getSvcParams .}}{{range .Methods}}{{$methparams := getMethodParams .}}{{ if isAutoGenMethod .}}
//
func makeURI{{$svcname}}{{.Name}}{{$methparams.Oper}}(in *{{getInputType $pkgname . false}}) string { {{if isRestExposed .}}{{$uri := getURIKey . $svcparams.Version true}}
	return fmt.Sprint("{{$svcparams.URIPath}}", {{$uri.Str}}) {{else}}
	return ""
	{{end}}
}
{{end}}{{end}}

{{if (hasExtension "venice.apiGrpcCrudService" .)}}{{$cruds := (getExtension "venice.apiGrpcCrudService" .)}}{{$svc := . }}{{range $cruds}}{{$crudop := .}}
// AutoAdd{{.}} CRUD method for {{.}}
func (r *Endpoints{{$svcname}}RestClient) AutoAdd{{.}}(ctx context.Context, in *{{.}}) (*{{.}}, error) { {{if isRestMethod $svc "AutoAdd" .}}
	path := makeURI{{$svcname}}AutoAdd{{.}}CreateOper(in)
	if r.bufferId != "" {
		path = strings.Replace(path, "/configs", "/staging/" + r.bufferId, 1)
	}
	req, err := r.getHTTPRequest(ctx, in, "POST", path)
	if err != nil {
		return nil, err
	}
	httpresp, err := r.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("request failed (%s)", err)
	}
    defer httpresp.Body.Close()
	ret, err := decodeHTTPresp{{$svcname}}AutoAdd{{.}}(ctx, httpresp)
	if err != nil {
		return nil, err
	}
	return ret.(*{{.}}), nil
}{{else}}
	return nil, errors.New("not allowed")
}{{end}}

// AutoUpdate{{.}} CRUD method for {{.}}
func (r *Endpoints{{$svcname}}RestClient) AutoUpdate{{.}}(ctx context.Context, in *{{.}}) (*{{.}}, error) { {{if isRestMethod $svc "AutoUpdate" .}}
	path := makeURI{{$svcname}}AutoUpdate{{.}}UpdateOper(in)
	if r.bufferId != "" {
		path = strings.Replace(path, "/configs", "/staging/" + r.bufferId, 1)
	}
	req, err := r.getHTTPRequest(ctx, in, "PUT", path)
	if err != nil {
		return nil, err
	}
	resp, err := r.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("request failed (%s)", err)
	}
    defer resp.Body.Close()
	ret, err := decodeHTTPresp{{$svcname}}AutoUpdate{{.}}(ctx, resp)
	if err != nil {
		return nil, err
	}
	return ret.(*{{.}}), err
}{{else}}
	return nil, errors.New("not allowed")
}{{end}}

// AutoLabel{{.}} label method for {{.}}
func (r *Endpoints{{$svcname}}RestClient) AutoLabel{{.}}(ctx context.Context, in *api.Label) (*{{.}}, error) { {{if isRestMethod $svc "AutoLabel" .}}
	path := makeURI{{$svcname}}AutoLabel{{.}}LabelOper(in)
	if r.bufferId != "" {
		path = strings.Replace(path, "/configs", "/staging/" + r.bufferId, 1)
	}
	req, err := r.getHTTPRequest(ctx, in, "POST", path)
	if err != nil {
		return nil, err
	}
	resp, err := r.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("request failed (%s)", err)
	}
    defer resp.Body.Close()
	ret, err := decodeHTTPresp{{$svcname}}AutoLabel{{.}}(ctx, resp)
	if err != nil {
		return nil, err
	}
	return ret.(*{{.}}), err
}{{else}}
	return nil, errors.New("not allowed")
}{{end}}

// AutoGet{{.}} CRUD method for {{.}}
func (r *Endpoints{{$svcname}}RestClient) AutoGet{{.}}(ctx context.Context, in *{{.}}) (*{{.}}, error) { {{if isRestMethod $svc "AutoGet" .}}
	path := makeURI{{$svcname}}AutoGet{{.}}GetOper(in)
	if r.bufferId != "" {
		path = strings.Replace(path, "/configs", "/staging/" + r.bufferId, 1)
	}
	req, err := r.getHTTPRequest(ctx, in, "GET", path)
	if err != nil {
		return nil, err
	}
	resp, err := r.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("request failed (%s)", err)
	}
    defer resp.Body.Close()
	ret, err := decodeHTTPresp{{$svcname}}AutoGet{{.}}(ctx, resp)
	if err != nil {
		return nil, err
	}
	return ret.(*{{.}}), err
}{{else}}
	return nil, errors.New("not allowed")
}{{end}}

// AutoDelete{{.}} CRUD method for {{.}}
func (r *Endpoints{{$svcname}}RestClient) AutoDelete{{.}}(ctx context.Context, in *{{.}}) (*{{.}}, error) { {{if isRestMethod $svc "AutoDelete" .}}
	path := makeURI{{$svcname}}AutoDelete{{.}}DeleteOper(in)
	if r.bufferId != "" {
		path = strings.Replace(path, "/configs", "/staging/" + r.bufferId, 1)
	}
	req, err := r.getHTTPRequest(ctx, in, "DELETE", path)
	if err != nil {
		return nil, err
	}
	resp, err := r.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("request failed (%s)", err)
	}
    defer resp.Body.Close()
	ret, err := decodeHTTPresp{{$svcname}}AutoDelete{{.}}(ctx, resp)
	if err != nil {
		return nil, err
	}
	return ret.(*{{.}}), err
}{{else}}
	return nil, errors.New("not allowed")
}{{end}}

// AutoList{{.}} CRUD method for {{.}}
func (r *Endpoints{{$svcname}}RestClient) AutoList{{.}}(ctx context.Context, options *api.ListWatchOptions) (*{{.}}List, error) { {{if isRestMethod $svc "AutoList" .}}
	path := makeURI{{$svcname}}AutoList{{.}}ListOper(options)
	if r.bufferId != "" {
		path = strings.Replace(path, "/configs", "/staging/" + r.bufferId, 1)
	}
	req, err := r.getHTTPRequest(ctx, options, "GET", path)
	if err != nil {
		return nil, err
	}
	resp, err := r.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("request failed (%s)", err)
	}
    defer resp.Body.Close()
	ret, err := decodeHTTPresp{{$svcname}}AutoList{{.}}(ctx, resp)
	if err != nil {
		return nil, err
	}
	return ret.(*{{.}}List), err
}{{else}}
	return nil, errors.New("not allowed")
}{{end}}

// AutoWatch{{.}} CRUD method for {{.}}
func (r *Endpoints{{$svcname}}RestClient) AutoWatch{{.}}(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	path := r.instance + makeURI{{$svcname}}AutoWatch{{.}}WatchOper(options)
	path = strings.Replace(path, "http://", "ws://", 1)
	path = strings.Replace(path, "https://", "wss://", 1)
	params := apiutils.GetQueryStringFromListWatchOptions(options)
	if params != "" {
	    path = path + "?" + params
	}
	header := http.Header{}
	r.updateHTTPHeader(ctx, &header)
	dialer := websocket.DefaultDialer
	dialer.TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	conn, hresp, err := dialer.Dial(path, header)
	if err != nil {
		return nil, fmt.Errorf("failed to connect web socket to [%s](%s)[%+v]", path, err, hresp)
	}
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			in := &AutoMsg{{.}}WatchHelper{}
			err := conn.ReadJSON(in)
			if err != nil {
				return
			}
			for _, e := range in.Events {
			    ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
			    }
			    select {
			    case lw.OutCh <- &ev:
			    case <-ctx.Done():
					close(lw.OutCh)
					conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, "client closing"), time.Now().Add(3 * time.Second))
					return
			    }
			}
		}
	}
    lw := listerwatcher.NewWatcherClient(nil, bridgefn)
    lw.Run()
	go func() {
		<-ctx.Done()
		conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, "client closing"), time.Now().Add(3 * time.Second))
	}()
    return lw, nil
}
{{$actions := getSvcActionEndpoints $svc .}}{{range $actions}}
func (r *Endpoints{{$svcname}}RestClient) {{.Name}}{{$crudop}}(ctx context.Context, in *{{.Request}}) (*{{.Response}}, error) {
	if r.bufferId != "" {
		return nil, errors.New("staging not allowed")
	}
	path := makeURI{{$svcname}}{{.Name}}CreateOper(in)
	req, err := r.getHTTPRequest(ctx, in, "POST", path)
	if err != nil {
		return nil, err
	}
	resp, err := r.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, fmt.Errorf("request failed (%s)", err)
	}
    defer resp.Body.Close()
	ret, err := decodeHTTPresp{{$svcname}}{{.Name}}(ctx, resp)
	if err != nil {
		return nil, err
	}
	return ret.(*{{.Response}}), err
}
{{end}}{{end}}{{end}}
{{range .Methods}}{{$params := (getMethodParams .)}}{{if isAutoGenMethod .}}{{else}}
func (r *Endpoints{{$svcname}}RestClient) {{$svcname}}{{.Name}}Endpoint(ctx context.Context, in *{{getInputType $pkgname . false}}) (*{{getOutputType $pkgname . false}}, error) {
	return nil, errors.New("not allowed")
}
{{end}}{{end}}

// Make{{$svcname}}RestClientEndpoints make REST client endpoints
func Make{{$svcname}}RestClientEndpoints(instance string, httpClient *http.Client) (Endpoints{{$svcname}}RestClient, error) {
	if !strings.HasPrefix(instance, "https") {
		instance = "https://" + instance
	}

	return Endpoints{{$svcname}}RestClient {
		instance: instance,
		client: httpClient,
	}, nil

}

// Make{{$svcname}}StagedRestClientEndpoints makes staged REST client endpoints
func Make{{$svcname}}StagedRestClientEndpoints(instance string, bufferId string, httpClient *http.Client) (Endpoints{{$svcname}}RestClient, error) {
	if !strings.HasPrefix(instance, "https") {
		instance = "https://" + instance
	}

	return Endpoints{{$svcname}}RestClient {
		instance: instance,
		bufferId: bufferId,
		client: httpClient,
	}, nil
}
{{end}}
