// Code generated by protoc-gen-go. DO NOT EDIT.
// source: citadel.proto

/*
Package tproto is a generated protocol buffer package.

It is generated from these files:
	citadel.proto

It has these top-level messages:
	PointsWriteReq
	StatusResp
	ReplicaInfo
	ShardReq
	DatabaseReq
	QueryReq
	Result
	QueryResp
	SyncShardMsg
	ChunkInfo
	SyncShardInfoMsg
	SyncDataMsg
	Key
	KeyValue
	KeyMsg
	KeyValueMsg
	TableMsg
*/
package tproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Points write request
type PointsWriteReq struct {
	ClusterType string `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ReplicaID   uint64 `protobuf:"varint,2,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	ShardID     uint64 `protobuf:"varint,3,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	Database    string `protobuf:"bytes,4,opt,name=Database,json=database" json:"Database,omitempty"`
	Points      string `protobuf:"bytes,5,opt,name=Points,json=points" json:"Points,omitempty"`
}

func (m *PointsWriteReq) Reset()                    { *m = PointsWriteReq{} }
func (m *PointsWriteReq) String() string            { return proto.CompactTextString(m) }
func (*PointsWriteReq) ProtoMessage()               {}
func (*PointsWriteReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PointsWriteReq) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *PointsWriteReq) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *PointsWriteReq) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *PointsWriteReq) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *PointsWriteReq) GetPoints() string {
	if m != nil {
		return m.Points
	}
	return ""
}

// status resp
type StatusResp struct {
	Status string `protobuf:"bytes,1,opt,name=Status,json=status" json:"Status,omitempty"`
}

func (m *StatusResp) Reset()                    { *m = StatusResp{} }
func (m *StatusResp) String() string            { return proto.CompactTextString(m) }
func (*StatusResp) ProtoMessage()               {}
func (*StatusResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StatusResp) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// replica information
type ReplicaInfo struct {
	ClusterType string `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ReplicaID   uint64 `protobuf:"varint,2,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	ShardID     uint64 `protobuf:"varint,3,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	IsPrimary   bool   `protobuf:"varint,4,opt,name=IsPrimary,json=isPrimary" json:"IsPrimary,omitempty"`
	NodeUUID    string `protobuf:"bytes,5,opt,name=NodeUUID,json=nodeUUID" json:"NodeUUID,omitempty"`
	NodeURL     string `protobuf:"bytes,6,opt,name=NodeURL,json=nodeURL" json:"NodeURL,omitempty"`
}

func (m *ReplicaInfo) Reset()                    { *m = ReplicaInfo{} }
func (m *ReplicaInfo) String() string            { return proto.CompactTextString(m) }
func (*ReplicaInfo) ProtoMessage()               {}
func (*ReplicaInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ReplicaInfo) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *ReplicaInfo) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *ReplicaInfo) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ReplicaInfo) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *ReplicaInfo) GetNodeUUID() string {
	if m != nil {
		return m.NodeUUID
	}
	return ""
}

func (m *ReplicaInfo) GetNodeURL() string {
	if m != nil {
		return m.NodeURL
	}
	return ""
}

// create/Update shard request
type ShardReq struct {
	ClusterType string         `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ReplicaID   uint64         `protobuf:"varint,2,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	ShardID     uint64         `protobuf:"varint,3,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	IsPrimary   bool           `protobuf:"varint,4,opt,name=IsPrimary,json=isPrimary" json:"IsPrimary,omitempty"`
	Replicas    []*ReplicaInfo `protobuf:"bytes,5,rep,name=Replicas,json=replicas" json:"Replicas,omitempty"`
}

func (m *ShardReq) Reset()                    { *m = ShardReq{} }
func (m *ShardReq) String() string            { return proto.CompactTextString(m) }
func (*ShardReq) ProtoMessage()               {}
func (*ShardReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ShardReq) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *ShardReq) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *ShardReq) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardReq) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *ShardReq) GetReplicas() []*ReplicaInfo {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type DatabaseReq struct {
	ClusterType     string `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ReplicaID       uint64 `protobuf:"varint,2,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	ShardID         uint64 `protobuf:"varint,3,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	Database        string `protobuf:"bytes,4,opt,name=Database,json=database" json:"Database,omitempty"`
	RetentionPeriod uint64 `protobuf:"varint,5,opt,name=RetentionPeriod,json=retentionPeriod" json:"RetentionPeriod,omitempty"`
}

func (m *DatabaseReq) Reset()                    { *m = DatabaseReq{} }
func (m *DatabaseReq) String() string            { return proto.CompactTextString(m) }
func (*DatabaseReq) ProtoMessage()               {}
func (*DatabaseReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *DatabaseReq) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *DatabaseReq) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *DatabaseReq) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *DatabaseReq) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *DatabaseReq) GetRetentionPeriod() uint64 {
	if m != nil {
		return m.RetentionPeriod
	}
	return 0
}

// execute query req
type QueryReq struct {
	ClusterType string `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ReplicaID   uint64 `protobuf:"varint,2,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	ShardID     uint64 `protobuf:"varint,3,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	Database    string `protobuf:"bytes,4,opt,name=Database,json=database" json:"Database,omitempty"`
	TxnID       uint64 `protobuf:"varint,5,opt,name=TxnID,json=txnID" json:"TxnID,omitempty"`
	Query       string `protobuf:"bytes,6,opt,name=Query,json=query" json:"Query,omitempty"`
}

func (m *QueryReq) Reset()                    { *m = QueryReq{} }
func (m *QueryReq) String() string            { return proto.CompactTextString(m) }
func (*QueryReq) ProtoMessage()               {}
func (*QueryReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *QueryReq) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *QueryReq) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *QueryReq) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *QueryReq) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *QueryReq) GetTxnID() uint64 {
	if m != nil {
		return m.TxnID
	}
	return 0
}

func (m *QueryReq) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// single result
type Result struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Result) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// query result
type QueryResp struct {
	ClusterType string    `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ReplicaID   uint64    `protobuf:"varint,2,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	ShardID     uint64    `protobuf:"varint,3,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	Database    string    `protobuf:"bytes,4,opt,name=Database,json=database" json:"Database,omitempty"`
	TxnID       uint64    `protobuf:"varint,5,opt,name=TxnID,json=txnID" json:"TxnID,omitempty"`
	Result      []*Result `protobuf:"bytes,6,rep,name=Result,json=result" json:"Result,omitempty"`
}

func (m *QueryResp) Reset()                    { *m = QueryResp{} }
func (m *QueryResp) String() string            { return proto.CompactTextString(m) }
func (*QueryResp) ProtoMessage()               {}
func (*QueryResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *QueryResp) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *QueryResp) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *QueryResp) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *QueryResp) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

func (m *QueryResp) GetTxnID() uint64 {
	if m != nil {
		return m.TxnID
	}
	return 0
}

func (m *QueryResp) GetResult() []*Result {
	if m != nil {
		return m.Result
	}
	return nil
}

// sync shard req message from metadata server to primary
type SyncShardMsg struct {
	ClusterType   string         `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	SrcReplicaID  uint64         `protobuf:"varint,2,opt,name=SrcReplicaID,json=srcReplicaID" json:"SrcReplicaID,omitempty"`
	DestReplicaID uint64         `protobuf:"varint,3,opt,name=DestReplicaID,json=destReplicaID" json:"DestReplicaID,omitempty"`
	ShardID       uint64         `protobuf:"varint,4,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	DestNodeUUID  string         `protobuf:"bytes,5,opt,name=DestNodeUUID,json=destNodeUUID" json:"DestNodeUUID,omitempty"`
	DestNodeURL   string         `protobuf:"bytes,6,opt,name=DestNodeURL,json=destNodeURL" json:"DestNodeURL,omitempty"`
	SrcIsPrimary  bool           `protobuf:"varint,7,opt,name=SrcIsPrimary,json=srcIsPrimary" json:"SrcIsPrimary,omitempty"`
	Replicas      []*ReplicaInfo `protobuf:"bytes,8,rep,name=Replicas,json=replicas" json:"Replicas,omitempty"`
}

func (m *SyncShardMsg) Reset()                    { *m = SyncShardMsg{} }
func (m *SyncShardMsg) String() string            { return proto.CompactTextString(m) }
func (*SyncShardMsg) ProtoMessage()               {}
func (*SyncShardMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *SyncShardMsg) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *SyncShardMsg) GetSrcReplicaID() uint64 {
	if m != nil {
		return m.SrcReplicaID
	}
	return 0
}

func (m *SyncShardMsg) GetDestReplicaID() uint64 {
	if m != nil {
		return m.DestReplicaID
	}
	return 0
}

func (m *SyncShardMsg) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *SyncShardMsg) GetDestNodeUUID() string {
	if m != nil {
		return m.DestNodeUUID
	}
	return ""
}

func (m *SyncShardMsg) GetDestNodeURL() string {
	if m != nil {
		return m.DestNodeURL
	}
	return ""
}

func (m *SyncShardMsg) GetSrcIsPrimary() bool {
	if m != nil {
		return m.SrcIsPrimary
	}
	return false
}

func (m *SyncShardMsg) GetReplicas() []*ReplicaInfo {
	if m != nil {
		return m.Replicas
	}
	return nil
}

// information about the chunk we are syncing
type ChunkInfo struct {
	ChunkID  uint64 `protobuf:"varint,1,opt,name=ChunkID,json=chunkID" json:"ChunkID,omitempty"`
	Database string `protobuf:"bytes,2,opt,name=Database,json=database" json:"Database,omitempty"`
}

func (m *ChunkInfo) Reset()                    { *m = ChunkInfo{} }
func (m *ChunkInfo) String() string            { return proto.CompactTextString(m) }
func (*ChunkInfo) ProtoMessage()               {}
func (*ChunkInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ChunkInfo) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *ChunkInfo) GetDatabase() string {
	if m != nil {
		return m.Database
	}
	return ""
}

// information about the shard we are syncing
type SyncShardInfoMsg struct {
	ClusterType   string       `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	SrcReplicaID  uint64       `protobuf:"varint,2,opt,name=SrcReplicaID,json=srcReplicaID" json:"SrcReplicaID,omitempty"`
	DestReplicaID uint64       `protobuf:"varint,3,opt,name=DestReplicaID,json=destReplicaID" json:"DestReplicaID,omitempty"`
	ShardID       uint64       `protobuf:"varint,4,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	ChunkMeta     []byte       `protobuf:"bytes,5,opt,name=ChunkMeta,json=chunkMeta,proto3" json:"ChunkMeta,omitempty"`
	Chunks        []*ChunkInfo `protobuf:"bytes,6,rep,name=Chunks,json=chunks" json:"Chunks,omitempty"`
}

func (m *SyncShardInfoMsg) Reset()                    { *m = SyncShardInfoMsg{} }
func (m *SyncShardInfoMsg) String() string            { return proto.CompactTextString(m) }
func (*SyncShardInfoMsg) ProtoMessage()               {}
func (*SyncShardInfoMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SyncShardInfoMsg) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *SyncShardInfoMsg) GetSrcReplicaID() uint64 {
	if m != nil {
		return m.SrcReplicaID
	}
	return 0
}

func (m *SyncShardInfoMsg) GetDestReplicaID() uint64 {
	if m != nil {
		return m.DestReplicaID
	}
	return 0
}

func (m *SyncShardInfoMsg) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *SyncShardInfoMsg) GetChunkMeta() []byte {
	if m != nil {
		return m.ChunkMeta
	}
	return nil
}

func (m *SyncShardInfoMsg) GetChunks() []*ChunkInfo {
	if m != nil {
		return m.Chunks
	}
	return nil
}

// SyncDataMsg streaming data sync message
type SyncDataMsg struct {
	ClusterType   string `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	SrcReplicaID  uint64 `protobuf:"varint,2,opt,name=SrcReplicaID,json=srcReplicaID" json:"SrcReplicaID,omitempty"`
	DestReplicaID uint64 `protobuf:"varint,3,opt,name=DestReplicaID,json=destReplicaID" json:"DestReplicaID,omitempty"`
	ShardID       uint64 `protobuf:"varint,4,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	ChunkID       uint64 `protobuf:"varint,5,opt,name=ChunkID,json=chunkID" json:"ChunkID,omitempty"`
	Data          []byte `protobuf:"bytes,6,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *SyncDataMsg) Reset()                    { *m = SyncDataMsg{} }
func (m *SyncDataMsg) String() string            { return proto.CompactTextString(m) }
func (*SyncDataMsg) ProtoMessage()               {}
func (*SyncDataMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *SyncDataMsg) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *SyncDataMsg) GetSrcReplicaID() uint64 {
	if m != nil {
		return m.SrcReplicaID
	}
	return 0
}

func (m *SyncDataMsg) GetDestReplicaID() uint64 {
	if m != nil {
		return m.DestReplicaID
	}
	return 0
}

func (m *SyncDataMsg) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *SyncDataMsg) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *SyncDataMsg) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// key
type Key struct {
	Key []byte `protobuf:"bytes,1,opt,name=Key,json=key,proto3" json:"Key,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Key) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// kv-pair
type KeyValue struct {
	Key   []byte `protobuf:"bytes,1,opt,name=Key,json=key,proto3" json:"Key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=Value,json=value,proto3" json:"Value,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *KeyValue) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KeyValue) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// key message to be used by read and delete requests.
type KeyMsg struct {
	ClusterType string `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ShardID     uint64 `protobuf:"varint,2,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	ReplicaID   uint64 `protobuf:"varint,3,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	Table       string `protobuf:"bytes,4,opt,name=Table,json=table" json:"Table,omitempty"`
	Keys        []*Key `protobuf:"bytes,5,rep,name=Keys,json=keys" json:"Keys,omitempty"`
}

func (m *KeyMsg) Reset()                    { *m = KeyMsg{} }
func (m *KeyMsg) String() string            { return proto.CompactTextString(m) }
func (*KeyMsg) ProtoMessage()               {}
func (*KeyMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *KeyMsg) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *KeyMsg) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *KeyMsg) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *KeyMsg) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *KeyMsg) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

// key-value message to be used by read/list resp and write req
type KeyValueMsg struct {
	ClusterType string      `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ShardID     uint64      `protobuf:"varint,2,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	ReplicaID   uint64      `protobuf:"varint,3,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	Table       string      `protobuf:"bytes,4,opt,name=Table,json=table" json:"Table,omitempty"`
	Kvs         []*KeyValue `protobuf:"bytes,5,rep,name=Kvs,json=kvs" json:"Kvs,omitempty"`
}

func (m *KeyValueMsg) Reset()                    { *m = KeyValueMsg{} }
func (m *KeyValueMsg) String() string            { return proto.CompactTextString(m) }
func (*KeyValueMsg) ProtoMessage()               {}
func (*KeyValueMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *KeyValueMsg) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *KeyValueMsg) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *KeyValueMsg) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *KeyValueMsg) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func (m *KeyValueMsg) GetKvs() []*KeyValue {
	if m != nil {
		return m.Kvs
	}
	return nil
}

// table name message to be used by list req
type TableMsg struct {
	ClusterType string `protobuf:"bytes,1,opt,name=ClusterType,json=clusterType" json:"ClusterType,omitempty"`
	ShardID     uint64 `protobuf:"varint,2,opt,name=ShardID,json=shardID" json:"ShardID,omitempty"`
	ReplicaID   uint64 `protobuf:"varint,3,opt,name=ReplicaID,json=replicaID" json:"ReplicaID,omitempty"`
	Table       string `protobuf:"bytes,4,opt,name=Table,json=table" json:"Table,omitempty"`
}

func (m *TableMsg) Reset()                    { *m = TableMsg{} }
func (m *TableMsg) String() string            { return proto.CompactTextString(m) }
func (*TableMsg) ProtoMessage()               {}
func (*TableMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *TableMsg) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *TableMsg) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *TableMsg) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *TableMsg) GetTable() string {
	if m != nil {
		return m.Table
	}
	return ""
}

func init() {
	proto.RegisterType((*PointsWriteReq)(nil), "tproto.PointsWriteReq")
	proto.RegisterType((*StatusResp)(nil), "tproto.StatusResp")
	proto.RegisterType((*ReplicaInfo)(nil), "tproto.ReplicaInfo")
	proto.RegisterType((*ShardReq)(nil), "tproto.ShardReq")
	proto.RegisterType((*DatabaseReq)(nil), "tproto.DatabaseReq")
	proto.RegisterType((*QueryReq)(nil), "tproto.QueryReq")
	proto.RegisterType((*Result)(nil), "tproto.Result")
	proto.RegisterType((*QueryResp)(nil), "tproto.QueryResp")
	proto.RegisterType((*SyncShardMsg)(nil), "tproto.SyncShardMsg")
	proto.RegisterType((*ChunkInfo)(nil), "tproto.ChunkInfo")
	proto.RegisterType((*SyncShardInfoMsg)(nil), "tproto.SyncShardInfoMsg")
	proto.RegisterType((*SyncDataMsg)(nil), "tproto.SyncDataMsg")
	proto.RegisterType((*Key)(nil), "tproto.Key")
	proto.RegisterType((*KeyValue)(nil), "tproto.KeyValue")
	proto.RegisterType((*KeyMsg)(nil), "tproto.KeyMsg")
	proto.RegisterType((*KeyValueMsg)(nil), "tproto.KeyValueMsg")
	proto.RegisterType((*TableMsg)(nil), "tproto.TableMsg")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DataNode service

type DataNodeClient interface {
	// shard management APIs
	CreateShard(ctx context.Context, in *ShardReq, opts ...grpc.CallOption) (*StatusResp, error)
	UpdateShard(ctx context.Context, in *ShardReq, opts ...grpc.CallOption) (*StatusResp, error)
	DeleteShard(ctx context.Context, in *ShardReq, opts ...grpc.CallOption) (*StatusResp, error)
	// Sync messages
	SyncShardReq(ctx context.Context, in *SyncShardMsg, opts ...grpc.CallOption) (*StatusResp, error)
	SyncShardInfo(ctx context.Context, in *SyncShardInfoMsg, opts ...grpc.CallOption) (*StatusResp, error)
	SyncData(ctx context.Context, opts ...grpc.CallOption) (DataNode_SyncDataClient, error)
	// TSDB messages
	CreateDatabase(ctx context.Context, in *DatabaseReq, opts ...grpc.CallOption) (*StatusResp, error)
	DeleteDatabase(ctx context.Context, in *DatabaseReq, opts ...grpc.CallOption) (*StatusResp, error)
	ReadDatabases(ctx context.Context, in *DatabaseReq, opts ...grpc.CallOption) (*StatusResp, error)
	PointsReplicate(ctx context.Context, in *PointsWriteReq, opts ...grpc.CallOption) (*StatusResp, error)
	PointsWrite(ctx context.Context, in *PointsWriteReq, opts ...grpc.CallOption) (*StatusResp, error)
	ExecuteQuery(ctx context.Context, in *QueryReq, opts ...grpc.CallOption) (*QueryResp, error)
	// key-value messages
	ReadReq(ctx context.Context, in *KeyMsg, opts ...grpc.CallOption) (*KeyValueMsg, error)
	ListReq(ctx context.Context, in *TableMsg, opts ...grpc.CallOption) (*KeyValueMsg, error)
	WriteReq(ctx context.Context, in *KeyValueMsg, opts ...grpc.CallOption) (*StatusResp, error)
	DelReq(ctx context.Context, in *KeyMsg, opts ...grpc.CallOption) (*StatusResp, error)
	WriteReplicate(ctx context.Context, in *KeyValueMsg, opts ...grpc.CallOption) (*StatusResp, error)
	DelReplicate(ctx context.Context, in *KeyMsg, opts ...grpc.CallOption) (*StatusResp, error)
}

type dataNodeClient struct {
	cc *grpc.ClientConn
}

func NewDataNodeClient(cc *grpc.ClientConn) DataNodeClient {
	return &dataNodeClient{cc}
}

func (c *dataNodeClient) CreateShard(ctx context.Context, in *ShardReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/CreateShard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) UpdateShard(ctx context.Context, in *ShardReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/UpdateShard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) DeleteShard(ctx context.Context, in *ShardReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/DeleteShard", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) SyncShardReq(ctx context.Context, in *SyncShardMsg, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/SyncShardReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) SyncShardInfo(ctx context.Context, in *SyncShardInfoMsg, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/SyncShardInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) SyncData(ctx context.Context, opts ...grpc.CallOption) (DataNode_SyncDataClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DataNode_serviceDesc.Streams[0], c.cc, "/tproto.DataNode/SyncData", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNodeSyncDataClient{stream}
	return x, nil
}

type DataNode_SyncDataClient interface {
	Send(*SyncDataMsg) error
	CloseAndRecv() (*StatusResp, error)
	grpc.ClientStream
}

type dataNodeSyncDataClient struct {
	grpc.ClientStream
}

func (x *dataNodeSyncDataClient) Send(m *SyncDataMsg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataNodeSyncDataClient) CloseAndRecv() (*StatusResp, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StatusResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNodeClient) CreateDatabase(ctx context.Context, in *DatabaseReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/CreateDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) DeleteDatabase(ctx context.Context, in *DatabaseReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/DeleteDatabase", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) ReadDatabases(ctx context.Context, in *DatabaseReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/ReadDatabases", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) PointsReplicate(ctx context.Context, in *PointsWriteReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/PointsReplicate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) PointsWrite(ctx context.Context, in *PointsWriteReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/PointsWrite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) ExecuteQuery(ctx context.Context, in *QueryReq, opts ...grpc.CallOption) (*QueryResp, error) {
	out := new(QueryResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/ExecuteQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) ReadReq(ctx context.Context, in *KeyMsg, opts ...grpc.CallOption) (*KeyValueMsg, error) {
	out := new(KeyValueMsg)
	err := grpc.Invoke(ctx, "/tproto.DataNode/ReadReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) ListReq(ctx context.Context, in *TableMsg, opts ...grpc.CallOption) (*KeyValueMsg, error) {
	out := new(KeyValueMsg)
	err := grpc.Invoke(ctx, "/tproto.DataNode/ListReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) WriteReq(ctx context.Context, in *KeyValueMsg, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/WriteReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) DelReq(ctx context.Context, in *KeyMsg, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/DelReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) WriteReplicate(ctx context.Context, in *KeyValueMsg, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/WriteReplicate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataNodeClient) DelReplicate(ctx context.Context, in *KeyMsg, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.DataNode/DelReplicate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DataNode service

type DataNodeServer interface {
	// shard management APIs
	CreateShard(context.Context, *ShardReq) (*StatusResp, error)
	UpdateShard(context.Context, *ShardReq) (*StatusResp, error)
	DeleteShard(context.Context, *ShardReq) (*StatusResp, error)
	// Sync messages
	SyncShardReq(context.Context, *SyncShardMsg) (*StatusResp, error)
	SyncShardInfo(context.Context, *SyncShardInfoMsg) (*StatusResp, error)
	SyncData(DataNode_SyncDataServer) error
	// TSDB messages
	CreateDatabase(context.Context, *DatabaseReq) (*StatusResp, error)
	DeleteDatabase(context.Context, *DatabaseReq) (*StatusResp, error)
	ReadDatabases(context.Context, *DatabaseReq) (*StatusResp, error)
	PointsReplicate(context.Context, *PointsWriteReq) (*StatusResp, error)
	PointsWrite(context.Context, *PointsWriteReq) (*StatusResp, error)
	ExecuteQuery(context.Context, *QueryReq) (*QueryResp, error)
	// key-value messages
	ReadReq(context.Context, *KeyMsg) (*KeyValueMsg, error)
	ListReq(context.Context, *TableMsg) (*KeyValueMsg, error)
	WriteReq(context.Context, *KeyValueMsg) (*StatusResp, error)
	DelReq(context.Context, *KeyMsg) (*StatusResp, error)
	WriteReplicate(context.Context, *KeyValueMsg) (*StatusResp, error)
	DelReplicate(context.Context, *KeyMsg) (*StatusResp, error)
}

func RegisterDataNodeServer(s *grpc.Server, srv DataNodeServer) {
	s.RegisterService(&_DataNode_serviceDesc, srv)
}

func _DataNode_CreateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).CreateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/CreateShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).CreateShard(ctx, req.(*ShardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_UpdateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).UpdateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/UpdateShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).UpdateShard(ctx, req.(*ShardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_DeleteShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).DeleteShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/DeleteShard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).DeleteShard(ctx, req.(*ShardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_SyncShardReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncShardMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).SyncShardReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/SyncShardReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).SyncShardReq(ctx, req.(*SyncShardMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_SyncShardInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncShardInfoMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).SyncShardInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/SyncShardInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).SyncShardInfo(ctx, req.(*SyncShardInfoMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_SyncData_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataNodeServer).SyncData(&dataNodeSyncDataServer{stream})
}

type DataNode_SyncDataServer interface {
	SendAndClose(*StatusResp) error
	Recv() (*SyncDataMsg, error)
	grpc.ServerStream
}

type dataNodeSyncDataServer struct {
	grpc.ServerStream
}

func (x *dataNodeSyncDataServer) SendAndClose(m *StatusResp) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataNodeSyncDataServer) Recv() (*SyncDataMsg, error) {
	m := new(SyncDataMsg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataNode_CreateDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).CreateDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/CreateDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).CreateDatabase(ctx, req.(*DatabaseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_DeleteDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).DeleteDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/DeleteDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).DeleteDatabase(ctx, req.(*DatabaseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_ReadDatabases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatabaseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).ReadDatabases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/ReadDatabases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).ReadDatabases(ctx, req.(*DatabaseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_PointsReplicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointsWriteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).PointsReplicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/PointsReplicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).PointsReplicate(ctx, req.(*PointsWriteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_PointsWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointsWriteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).PointsWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/PointsWrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).PointsWrite(ctx, req.(*PointsWriteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_ExecuteQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).ExecuteQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/ExecuteQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).ExecuteQuery(ctx, req.(*QueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_ReadReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).ReadReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/ReadReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).ReadReq(ctx, req.(*KeyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_ListReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).ListReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/ListReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).ListReq(ctx, req.(*TableMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_WriteReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValueMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).WriteReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/WriteReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).WriteReq(ctx, req.(*KeyValueMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_DelReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).DelReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/DelReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).DelReq(ctx, req.(*KeyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_WriteReplicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyValueMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).WriteReplicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/WriteReplicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).WriteReplicate(ctx, req.(*KeyValueMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataNode_DelReplicate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataNodeServer).DelReplicate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.DataNode/DelReplicate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataNodeServer).DelReplicate(ctx, req.(*KeyMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataNode_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tproto.DataNode",
	HandlerType: (*DataNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateShard",
			Handler:    _DataNode_CreateShard_Handler,
		},
		{
			MethodName: "UpdateShard",
			Handler:    _DataNode_UpdateShard_Handler,
		},
		{
			MethodName: "DeleteShard",
			Handler:    _DataNode_DeleteShard_Handler,
		},
		{
			MethodName: "SyncShardReq",
			Handler:    _DataNode_SyncShardReq_Handler,
		},
		{
			MethodName: "SyncShardInfo",
			Handler:    _DataNode_SyncShardInfo_Handler,
		},
		{
			MethodName: "CreateDatabase",
			Handler:    _DataNode_CreateDatabase_Handler,
		},
		{
			MethodName: "DeleteDatabase",
			Handler:    _DataNode_DeleteDatabase_Handler,
		},
		{
			MethodName: "ReadDatabases",
			Handler:    _DataNode_ReadDatabases_Handler,
		},
		{
			MethodName: "PointsReplicate",
			Handler:    _DataNode_PointsReplicate_Handler,
		},
		{
			MethodName: "PointsWrite",
			Handler:    _DataNode_PointsWrite_Handler,
		},
		{
			MethodName: "ExecuteQuery",
			Handler:    _DataNode_ExecuteQuery_Handler,
		},
		{
			MethodName: "ReadReq",
			Handler:    _DataNode_ReadReq_Handler,
		},
		{
			MethodName: "ListReq",
			Handler:    _DataNode_ListReq_Handler,
		},
		{
			MethodName: "WriteReq",
			Handler:    _DataNode_WriteReq_Handler,
		},
		{
			MethodName: "DelReq",
			Handler:    _DataNode_DelReq_Handler,
		},
		{
			MethodName: "WriteReplicate",
			Handler:    _DataNode_WriteReplicate_Handler,
		},
		{
			MethodName: "DelReplicate",
			Handler:    _DataNode_DelReplicate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SyncData",
			Handler:       _DataNode_SyncData_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "citadel.proto",
}

// Client API for Broker service

type BrokerClient interface {
	PointsWrite(ctx context.Context, in *PointsWriteReq, opts ...grpc.CallOption) (*StatusResp, error)
	ExecuteQuery(ctx context.Context, in *QueryReq, opts ...grpc.CallOption) (*QueryResp, error)
}

type brokerClient struct {
	cc *grpc.ClientConn
}

func NewBrokerClient(cc *grpc.ClientConn) BrokerClient {
	return &brokerClient{cc}
}

func (c *brokerClient) PointsWrite(ctx context.Context, in *PointsWriteReq, opts ...grpc.CallOption) (*StatusResp, error) {
	out := new(StatusResp)
	err := grpc.Invoke(ctx, "/tproto.Broker/PointsWrite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *brokerClient) ExecuteQuery(ctx context.Context, in *QueryReq, opts ...grpc.CallOption) (*QueryResp, error) {
	out := new(QueryResp)
	err := grpc.Invoke(ctx, "/tproto.Broker/ExecuteQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Broker service

type BrokerServer interface {
	PointsWrite(context.Context, *PointsWriteReq) (*StatusResp, error)
	ExecuteQuery(context.Context, *QueryReq) (*QueryResp, error)
}

func RegisterBrokerServer(s *grpc.Server, srv BrokerServer) {
	s.RegisterService(&_Broker_serviceDesc, srv)
}

func _Broker_PointsWrite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointsWriteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServer).PointsWrite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.Broker/PointsWrite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServer).PointsWrite(ctx, req.(*PointsWriteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Broker_ExecuteQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BrokerServer).ExecuteQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tproto.Broker/ExecuteQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BrokerServer).ExecuteQuery(ctx, req.(*QueryReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Broker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tproto.Broker",
	HandlerType: (*BrokerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PointsWrite",
			Handler:    _Broker_PointsWrite_Handler,
		},
		{
			MethodName: "ExecuteQuery",
			Handler:    _Broker_ExecuteQuery_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "citadel.proto",
}

func init() { proto.RegisterFile("citadel.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 935 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x5f, 0x37, 0x8e, 0xe3, 0x3c, 0x3b, 0x69, 0x77, 0xba, 0x5a, 0xac, 0xaa, 0x12, 0xd5, 0x68,
	0x85, 0xc2, 0xa5, 0xa0, 0x40, 0x85, 0xb4, 0x7b, 0x58, 0x41, 0xc3, 0x21, 0xca, 0x16, 0x95, 0xe9,
	0x16, 0xce, 0x6e, 0xfc, 0xd8, 0xb5, 0x62, 0xec, 0xd4, 0x33, 0xa9, 0xd6, 0x88, 0x0f, 0xc1, 0x95,
	0x0b, 0x12, 0x77, 0x10, 0x07, 0x8e, 0x1c, 0x10, 0x1f, 0x85, 0x6f, 0x82, 0x66, 0x3c, 0x63, 0x3b,
	0x69, 0x83, 0xda, 0x95, 0x56, 0xe9, 0xc9, 0x7a, 0x6f, 0xde, 0x9b, 0xf7, 0xfb, 0xbd, 0x7f, 0x99,
	0x40, 0x6f, 0x1a, 0x8b, 0x30, 0xc2, 0xe4, 0x70, 0x9e, 0x67, 0x22, 0x23, 0x8e, 0x50, 0x5f, 0xfa,
	0x8b, 0x05, 0xfd, 0xd3, 0x2c, 0x4e, 0x05, 0xff, 0x36, 0x8f, 0x05, 0x32, 0xbc, 0x24, 0x07, 0xe0,
	0x1d, 0x27, 0x0b, 0x2e, 0x30, 0x7f, 0x59, 0xcc, 0x31, 0xb0, 0x0e, 0xac, 0x41, 0x97, 0x79, 0xd3,
	0x5a, 0x45, 0xf6, 0xa1, 0xcb, 0x70, 0x9e, 0xc4, 0xd3, 0x70, 0x3c, 0x0a, 0xb6, 0x0e, 0xac, 0x81,
	0xcd, 0xba, 0xb9, 0x51, 0x90, 0x00, 0x3a, 0x67, 0xaf, 0xc3, 0x3c, 0x1a, 0x8f, 0x82, 0x96, 0x3a,
	0xeb, 0xf0, 0x52, 0x24, 0x7b, 0xe0, 0x8e, 0x42, 0x11, 0x5e, 0x84, 0x1c, 0x03, 0x5b, 0x5d, 0xeb,
	0x46, 0x5a, 0x26, 0x8f, 0xc1, 0x29, 0x71, 0x04, 0x6d, 0x75, 0xe2, 0xcc, 0x95, 0x44, 0x9f, 0x00,
	0x9c, 0x89, 0x50, 0x2c, 0x38, 0x43, 0x3e, 0x97, 0x56, 0xa5, 0xa4, 0x61, 0x39, 0x5c, 0x49, 0xf4,
	0x2f, 0x0b, 0x3c, 0x03, 0x29, 0xfd, 0x2e, 0x7b, 0x87, 0x1c, 0xf6, 0xa1, 0x3b, 0xe6, 0xa7, 0x79,
	0xfc, 0x7d, 0x98, 0x17, 0x8a, 0x84, 0xcb, 0xba, 0xb1, 0x51, 0x48, 0x86, 0x5f, 0x65, 0x11, 0x9e,
	0x9f, 0x8f, 0x47, 0x9a, 0x87, 0x9b, 0x6a, 0x59, 0xde, 0xa9, 0xce, 0xd8, 0x8b, 0xc0, 0x51, 0x47,
	0x9d, 0xb4, 0x14, 0xe9, 0x9f, 0x16, 0xb8, 0x2a, 0xdc, 0xbb, 0x4d, 0xff, 0xff, 0x43, 0xff, 0x08,
	0x5c, 0x7d, 0xab, 0x2c, 0x41, 0x6b, 0xe0, 0x0d, 0x77, 0x0f, 0xcb, 0x26, 0x39, 0x6c, 0x64, 0x96,
	0xb9, 0x3a, 0x12, 0xa7, 0xbf, 0x5b, 0xe0, 0x99, 0x72, 0x6e, 0xae, 0x6f, 0x06, 0xb0, 0xcd, 0x50,
	0x60, 0x2a, 0xe2, 0x2c, 0x3d, 0xc5, 0x3c, 0xce, 0x22, 0x95, 0x78, 0x9b, 0x6d, 0xe7, 0xcb, 0x6a,
	0xfa, 0x9b, 0x05, 0xee, 0xd7, 0x0b, 0xcc, 0x8b, 0xcd, 0x81, 0x7d, 0x04, 0xed, 0x97, 0x6f, 0x52,
	0xdd, 0x1b, 0x36, 0x6b, 0x0b, 0x29, 0x48, 0xad, 0xc2, 0xa5, 0xdb, 0xa2, 0x7d, 0x29, 0x05, 0xba,
	0x0f, 0x0e, 0x43, 0xbe, 0x48, 0x04, 0x21, 0x60, 0xcb, 0x1b, 0x15, 0x48, 0x9f, 0xd9, 0xf2, 0x36,
	0xfa, 0xb7, 0x05, 0x5d, 0x4d, 0x86, 0xcf, 0xef, 0x15, 0x9b, 0x0f, 0x0c, 0xee, 0xc0, 0x51, 0x5d,
	0xd4, 0xaf, 0xbb, 0x48, 0x6a, 0x99, 0x93, 0xab, 0x2f, 0xfd, 0x63, 0x0b, 0xfc, 0xb3, 0x22, 0x9d,
	0xaa, 0xc0, 0x27, 0xfc, 0xd5, 0x2d, 0x48, 0x50, 0xf0, 0xcf, 0xf2, 0xe9, 0x2a, 0x0f, 0x9f, 0x37,
	0x74, 0xe4, 0x09, 0xf4, 0x46, 0xc8, 0x45, 0x6d, 0x54, 0x12, 0xea, 0x45, 0x4d, 0x65, 0x93, 0xb0,
	0xbd, 0x4c, 0x98, 0x82, 0x2f, 0xfd, 0x57, 0xa6, 0xd8, 0x8f, 0x1a, 0x3a, 0x89, 0xb4, 0xb2, 0xa9,
	0xa6, 0xd9, 0x8b, 0x6a, 0x95, 0x46, 0x5a, 0x4f, 0x5b, 0x47, 0x4d, 0x9b, 0x44, 0x3a, 0xbe, 0x71,
	0xe0, 0xdc, 0xdb, 0x0c, 0xdc, 0xe7, 0xd0, 0x3d, 0x7e, 0xbd, 0x48, 0x67, 0x6a, 0xc3, 0x05, 0xd0,
	0x29, 0x85, 0x91, 0xca, 0x94, 0xcd, 0x3a, 0xd3, 0x52, 0x5c, 0x2a, 0xd9, 0xd6, 0x72, 0xc9, 0xe8,
	0xbf, 0x16, 0xec, 0x54, 0x49, 0x97, 0xf7, 0xdc, 0x9f, 0xc4, 0xef, 0x6b, 0x76, 0x27, 0x28, 0x42,
	0x95, 0x75, 0x9f, 0x75, 0xa7, 0x46, 0x41, 0x3e, 0x04, 0x47, 0x9d, 0x72, 0xdd, 0x55, 0x0f, 0x4d,
	0xaa, 0xaa, 0x8c, 0x30, 0x47, 0x59, 0x73, 0xfa, 0x8f, 0x05, 0x9e, 0xe4, 0x28, 0x93, 0x70, 0x7f,
	0xe8, 0x35, 0xea, 0xd5, 0x5e, 0xae, 0x97, 0x19, 0x6f, 0xa7, 0x31, 0xde, 0xef, 0x41, 0x6b, 0x82,
	0x05, 0xd9, 0x51, 0x1f, 0x3d, 0xf8, 0xad, 0x19, 0x16, 0x74, 0x08, 0xee, 0x04, 0x8b, 0x6f, 0xc2,
	0x64, 0x81, 0xd7, 0x4f, 0xe5, 0x44, 0xaa, 0x23, 0xc5, 0xc0, 0x67, 0xed, 0x2b, 0x29, 0xd0, 0x9f,
	0x2d, 0x70, 0x26, 0x58, 0xdc, 0x2e, 0x17, 0x0d, 0x06, 0x5b, 0xd7, 0x0a, 0xb4, 0xca, 0xbe, 0xb1,
	0x42, 0xe4, 0x32, 0x08, 0x2f, 0x12, 0xb3, 0x25, 0xda, 0x42, 0x0a, 0xe4, 0x7d, 0xb0, 0x27, 0x58,
	0x98, 0x1f, 0x14, 0xcf, 0x14, 0x6d, 0x82, 0x05, 0xb3, 0x67, 0x58, 0x70, 0xfa, 0xab, 0x05, 0x9e,
	0x21, 0xb4, 0x09, 0x80, 0x14, 0x5a, 0x93, 0x2b, 0x83, 0x6f, 0xa7, 0x81, 0x4f, 0x21, 0x62, 0xad,
	0xd9, 0x15, 0xa7, 0x3f, 0x80, 0xab, 0x3c, 0x37, 0x80, 0x6f, 0xf8, 0x93, 0x5b, 0x4e, 0xb3, 0x5c,
	0x2c, 0xe4, 0x08, 0xbc, 0xe3, 0x1c, 0x43, 0x81, 0x2a, 0x00, 0xa9, 0xe0, 0x9a, 0xb7, 0xc3, 0x1e,
	0xa9, 0x34, 0xd5, 0x93, 0x89, 0x3e, 0x90, 0x6e, 0xe7, 0xf3, 0xe8, 0x6d, 0xdc, 0x46, 0x98, 0xe0,
	0x5d, 0xdd, 0x9e, 0x36, 0xd6, 0xba, 0xfc, 0xa5, 0x7d, 0x54, 0x59, 0x35, 0x96, 0xfd, 0x1a, 0xdf,
	0xe7, 0xd0, 0x5b, 0xda, 0x4e, 0x24, 0xb8, 0xe6, 0xac, 0x97, 0xd6, 0x9a, 0x0b, 0x3e, 0x03, 0xd7,
	0x8c, 0x3e, 0xd9, 0x6d, 0xfa, 0xea, 0x65, 0x70, 0xb3, 0xdb, 0xc0, 0x22, 0xcf, 0xa0, 0x5f, 0xa6,
	0xd6, 0xac, 0xce, 0xda, 0xbd, 0xf1, 0xc6, 0x59, 0x13, 0xf5, 0x19, 0xf4, 0xcb, 0x4c, 0xbd, 0x8d,
	0xf3, 0x53, 0xe8, 0x31, 0x0c, 0x23, 0x63, 0xc8, 0xef, 0xe2, 0xfb, 0x1c, 0xb6, 0xcb, 0x47, 0xb3,
	0xee, 0x2b, 0x81, 0xe4, 0xb1, 0x31, 0x5c, 0x7e, 0xd5, 0xaf, 0x45, 0xee, 0x35, 0xec, 0xee, 0xe8,
	0x7c, 0x04, 0xfe, 0x97, 0x6f, 0x70, 0xba, 0x10, 0xa8, 0x5e, 0x22, 0x75, 0x87, 0x98, 0x57, 0xd6,
	0xde, 0xc3, 0x15, 0x8d, 0x72, 0xfb, 0x18, 0x3a, 0x92, 0xb0, 0xec, 0x8d, 0x7e, 0x63, 0xe0, 0x64,
	0x75, 0x76, 0x57, 0x07, 0xf0, 0x84, 0xbf, 0xa2, 0x0f, 0xc8, 0x10, 0x3a, 0x2f, 0x62, 0xb9, 0x66,
	0x2f, 0xeb, 0x18, 0x66, 0x22, 0xd7, 0xf9, 0x1c, 0x81, 0x5b, 0xfd, 0xa3, 0xb9, 0xc9, 0x64, 0x0d,
	0xa7, 0x43, 0x70, 0x46, 0x98, 0xdc, 0x84, 0x6d, 0x6d, 0xe9, 0x75, 0x18, 0x53, 0x80, 0x3b, 0x04,
	0xfb, 0x54, 0xbe, 0x35, 0x92, 0xda, 0xf5, 0x56, 0x21, 0x87, 0x3f, 0x82, 0xf3, 0x45, 0x9e, 0xcd,
	0x30, 0xdf, 0x44, 0xf5, 0x2e, 0x1c, 0xa5, 0xfa, 0xe4, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x40,
	0xa5, 0x03, 0x0d, 0x50, 0x0e, 0x00, 0x00,
}
