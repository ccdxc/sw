// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: orch.proto

/*
	Package orch is a generated protocol buffer package.

	It is generated from these files:
		orch.proto

	It has these top-level messages:
		Spec
		Filter
		WatchSpec
		WatchEvent
		SmartNIC
		SmartNICList
		SmartNICEvent
		NwIF
		NwIFList
		NwIFEvent
		NwIFMigrationStart
		Empty
		Stats
*/
package orch

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import api "github.com/pensando/sw/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type WatchEvent_EventType int32

const (
	WatchEvent_List   WatchEvent_EventType = 0
	WatchEvent_Create WatchEvent_EventType = 1
	WatchEvent_Update WatchEvent_EventType = 2
	WatchEvent_Delete WatchEvent_EventType = 3
)

var WatchEvent_EventType_name = map[int32]string{
	0: "List",
	1: "Create",
	2: "Update",
	3: "Delete",
}
var WatchEvent_EventType_value = map[string]int32{
	"List":   0,
	"Create": 1,
	"Update": 2,
	"Delete": 3,
}

func (x WatchEvent_EventType) String() string {
	return proto.EnumName(WatchEvent_EventType_name, int32(x))
}
func (WatchEvent_EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptorOrch, []int{3, 0} }

// Elements of a filter spec
// TODO: migrate to common definition
type Spec struct {
	Key      string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Operator string   `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	Values   []string `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
}

func (m *Spec) Reset()                    { *m = Spec{} }
func (m *Spec) String() string            { return proto.CompactTextString(m) }
func (*Spec) ProtoMessage()               {}
func (*Spec) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{0} }

func (m *Spec) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Spec) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *Spec) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// The filter selecting a subset of objects to list
type Filter struct {
	Specs []*Spec `protobuf:"bytes,1,rep,name=specs" json:"specs,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{1} }

func (m *Filter) GetSpecs() []*Spec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// Specification for a watch
type WatchSpec struct {
	Refversion string  `protobuf:"bytes,1,opt,name=refversion,proto3" json:"refversion,omitempty"`
	Specs      []*Spec `protobuf:"bytes,2,rep,name=specs" json:"specs,omitempty"`
}

func (m *WatchSpec) Reset()                    { *m = WatchSpec{} }
func (m *WatchSpec) String() string            { return proto.CompactTextString(m) }
func (*WatchSpec) ProtoMessage()               {}
func (*WatchSpec) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{2} }

func (m *WatchSpec) GetRefversion() string {
	if m != nil {
		return m.Refversion
	}
	return ""
}

func (m *WatchSpec) GetSpecs() []*Spec {
	if m != nil {
		return m.Specs
	}
	return nil
}

// Response event types for watch
// If the specified resource version is outside the incremental sync window,
// watch will respond with a list.
type WatchEvent struct {
	Event WatchEvent_EventType `protobuf:"varint,1,opt,name=event,proto3,enum=orch.WatchEvent_EventType" json:"event,omitempty"`
}

func (m *WatchEvent) Reset()                    { *m = WatchEvent{} }
func (m *WatchEvent) String() string            { return proto.CompactTextString(m) }
func (*WatchEvent) ProtoMessage()               {}
func (*WatchEvent) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{3} }

func (m *WatchEvent) GetEvent() WatchEvent_EventType {
	if m != nil {
		return m.Event
	}
	return WatchEvent_List
}

// A HW NIC aka PNIC, VMNIC in vSphere terminology
type SmartNIC struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind,proto3" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string           `protobuf:"bytes,2,opt,name=ObjectAPIVersion,proto3" json:"ObjectAPIVersion,omitempty"`
	ObjectMeta       *api.ObjectMeta  `protobuf:"bytes,3,opt,name=ObjectMeta" json:"ObjectMeta,omitempty"`
	Status           *SmartNIC_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{4} }

func (m *SmartNIC) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *SmartNIC) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *SmartNIC) GetObjectMeta() *api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *SmartNIC) GetStatus() *SmartNIC_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type SmartNIC_Status struct {
	HostIP     string `protobuf:"bytes,1,opt,name=hostIP,proto3" json:"hostIP,omitempty"`
	MacAddress string `protobuf:"bytes,2,opt,name=macAddress,proto3" json:"macAddress,omitempty"`
	Switch     string `protobuf:"bytes,3,opt,name=switch,proto3" json:"switch,omitempty"`
}

func (m *SmartNIC_Status) Reset()                    { *m = SmartNIC_Status{} }
func (m *SmartNIC_Status) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC_Status) ProtoMessage()               {}
func (*SmartNIC_Status) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{4, 0} }

func (m *SmartNIC_Status) GetHostIP() string {
	if m != nil {
		return m.HostIP
	}
	return ""
}

func (m *SmartNIC_Status) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *SmartNIC_Status) GetSwitch() string {
	if m != nil {
		return m.Switch
	}
	return ""
}

// List of SmartNICs
type SmartNICList struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind,proto3" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string        `protobuf:"bytes,2,opt,name=ObjectAPIVersion,proto3" json:"ObjectAPIVersion,omitempty"`
	ListMeta         *api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta" json:"ListMeta,omitempty"`
	Items            []*SmartNIC   `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *SmartNICList) Reset()                    { *m = SmartNICList{} }
func (m *SmartNICList) String() string            { return proto.CompactTextString(m) }
func (*SmartNICList) ProtoMessage()               {}
func (*SmartNICList) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{5} }

func (m *SmartNICList) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *SmartNICList) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *SmartNICList) GetListMeta() *api.ListMeta {
	if m != nil {
		return m.ListMeta
	}
	return nil
}

func (m *SmartNICList) GetItems() []*SmartNIC {
	if m != nil {
		return m.Items
	}
	return nil
}

// Response to SmartNIC watch
type SmartNICEvent struct {
	E         *WatchEvent `protobuf:"bytes,1,opt,name=e" json:"e,omitempty"`
	Smartnics []*SmartNIC `protobuf:"bytes,2,rep,name=smartnics" json:"smartnics,omitempty"`
}

func (m *SmartNICEvent) Reset()                    { *m = SmartNICEvent{} }
func (m *SmartNICEvent) String() string            { return proto.CompactTextString(m) }
func (*SmartNICEvent) ProtoMessage()               {}
func (*SmartNICEvent) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{6} }

func (m *SmartNICEvent) GetE() *WatchEvent {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *SmartNICEvent) GetSmartnics() []*SmartNIC {
	if m != nil {
		return m.Smartnics
	}
	return nil
}

// A network interface (aka virtual NIC)
type NwIF struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind,proto3" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string            `protobuf:"bytes,2,opt,name=ObjectAPIVersion,proto3" json:"ObjectAPIVersion,omitempty"`
	ObjectMeta       *api.ObjectMeta   `protobuf:"bytes,3,opt,name=ObjectMeta" json:"ObjectMeta,omitempty"`
	Config           *NwIF_Config      `protobuf:"bytes,4,opt,name=config" json:"config,omitempty"`
	Status           *NwIF_Status      `protobuf:"bytes,5,opt,name=status" json:"status,omitempty"`
	Attributes       map[string]string `protobuf:"bytes,6,rep,name=attributes" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NwIF) Reset()                    { *m = NwIF{} }
func (m *NwIF) String() string            { return proto.CompactTextString(m) }
func (*NwIF) ProtoMessage()               {}
func (*NwIF) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{7} }

func (m *NwIF) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *NwIF) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *NwIF) GetObjectMeta() *api.ObjectMeta {
	if m != nil {
		return m.ObjectMeta
	}
	return nil
}

func (m *NwIF) GetConfig() *NwIF_Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *NwIF) GetStatus() *NwIF_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NwIF) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type NwIF_Config struct {
	LocalVLAN int32 `protobuf:"varint,1,opt,name=localVLAN,proto3" json:"localVLAN,omitempty"`
}

func (m *NwIF_Config) Reset()                    { *m = NwIF_Config{} }
func (m *NwIF_Config) String() string            { return proto.CompactTextString(m) }
func (*NwIF_Config) ProtoMessage()               {}
func (*NwIF_Config) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{7, 0} }

func (m *NwIF_Config) GetLocalVLAN() int32 {
	if m != nil {
		return m.LocalVLAN
	}
	return 0
}

type NwIF_Status struct {
	MacAddress  string `protobuf:"bytes,1,opt,name=macAddress,proto3" json:"macAddress,omitempty"`
	PortGroup   string `protobuf:"bytes,2,opt,name=portGroup,proto3" json:"portGroup,omitempty"`
	Switch      string `protobuf:"bytes,3,opt,name=switch,proto3" json:"switch,omitempty"`
	SmartNIC_ID string `protobuf:"bytes,4,opt,name=smartNIC_ID,json=smartNICID,proto3" json:"smartNIC_ID,omitempty"`
	IpAddress   string `protobuf:"bytes,5,opt,name=ipAddress,proto3" json:"ipAddress,omitempty"`
	Network     string `protobuf:"bytes,6,opt,name=network,proto3" json:"network,omitempty"`
	WlName      string `protobuf:"bytes,7,opt,name=wlName,proto3" json:"wlName,omitempty"`
	WlUUID      string `protobuf:"bytes,8,opt,name=wlUUID,proto3" json:"wlUUID,omitempty"`
}

func (m *NwIF_Status) Reset()                    { *m = NwIF_Status{} }
func (m *NwIF_Status) String() string            { return proto.CompactTextString(m) }
func (*NwIF_Status) ProtoMessage()               {}
func (*NwIF_Status) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{7, 1} }

func (m *NwIF_Status) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NwIF_Status) GetPortGroup() string {
	if m != nil {
		return m.PortGroup
	}
	return ""
}

func (m *NwIF_Status) GetSwitch() string {
	if m != nil {
		return m.Switch
	}
	return ""
}

func (m *NwIF_Status) GetSmartNIC_ID() string {
	if m != nil {
		return m.SmartNIC_ID
	}
	return ""
}

func (m *NwIF_Status) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *NwIF_Status) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *NwIF_Status) GetWlName() string {
	if m != nil {
		return m.WlName
	}
	return ""
}

func (m *NwIF_Status) GetWlUUID() string {
	if m != nil {
		return m.WlUUID
	}
	return ""
}

// List of NwIFs
type NwIFList struct {
	// Kind represents the type of the API object.
	ObjectKind string `protobuf:"bytes,1,opt,name=ObjectKind,proto3" json:"ObjectKind,omitempty"`
	// APIVersion defines the version of the API object.
	ObjectAPIVersion string        `protobuf:"bytes,2,opt,name=ObjectAPIVersion,proto3" json:"ObjectAPIVersion,omitempty"`
	ListMeta         *api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta" json:"ListMeta,omitempty"`
	Items            []*NwIF       `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *NwIFList) Reset()                    { *m = NwIFList{} }
func (m *NwIFList) String() string            { return proto.CompactTextString(m) }
func (*NwIFList) ProtoMessage()               {}
func (*NwIFList) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{8} }

func (m *NwIFList) GetObjectKind() string {
	if m != nil {
		return m.ObjectKind
	}
	return ""
}

func (m *NwIFList) GetObjectAPIVersion() string {
	if m != nil {
		return m.ObjectAPIVersion
	}
	return ""
}

func (m *NwIFList) GetListMeta() *api.ListMeta {
	if m != nil {
		return m.ListMeta
	}
	return nil
}

func (m *NwIFList) GetItems() []*NwIF {
	if m != nil {
		return m.Items
	}
	return nil
}

// Response to NwIF watch
type NwIFEvent struct {
	E     *WatchEvent `protobuf:"bytes,1,opt,name=e" json:"e,omitempty"`
	Nwifs []*NwIF     `protobuf:"bytes,2,rep,name=nwifs" json:"nwifs,omitempty"`
}

func (m *NwIFEvent) Reset()                    { *m = NwIFEvent{} }
func (m *NwIFEvent) String() string            { return proto.CompactTextString(m) }
func (*NwIFEvent) ProtoMessage()               {}
func (*NwIFEvent) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{9} }

func (m *NwIFEvent) GetE() *WatchEvent {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *NwIFEvent) GetNwifs() []*NwIF {
	if m != nil {
		return m.Nwifs
	}
	return nil
}

// Migration start for network interfaces belonging to a VM
type NwIFMigrationStart struct {
	Nwifs  []*NwIF   `protobuf:"bytes,1,rep,name=nwifs" json:"nwifs,omitempty"`
	Source *SmartNIC `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Dest   *SmartNIC `protobuf:"bytes,3,opt,name=dest" json:"dest,omitempty"`
}

func (m *NwIFMigrationStart) Reset()                    { *m = NwIFMigrationStart{} }
func (m *NwIFMigrationStart) String() string            { return proto.CompactTextString(m) }
func (*NwIFMigrationStart) ProtoMessage()               {}
func (*NwIFMigrationStart) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{10} }

func (m *NwIFMigrationStart) GetNwifs() []*NwIF {
	if m != nil {
		return m.Nwifs
	}
	return nil
}

func (m *NwIFMigrationStart) GetSource() *SmartNIC {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *NwIFMigrationStart) GetDest() *SmartNIC {
	if m != nil {
		return m.Dest
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{11} }

type Stats struct {
	StoreWatchFailCount     int64 `protobuf:"varint,1,opt,name=storeWatchFailCount,proto3" json:"storeWatchFailCount,omitempty"`
	StoreWatchErrCount      int64 `protobuf:"varint,2,opt,name=storeWatchErrCount,proto3" json:"storeWatchErrCount,omitempty"`
	StoreWatchBadEventCount int64 `protobuf:"varint,3,opt,name=storeWatchBadEventCount,proto3" json:"storeWatchBadEventCount,omitempty"`
	StoreWatchBadObjCount   int64 `protobuf:"varint,4,opt,name=storeWatchBadObjCount,proto3" json:"storeWatchBadObjCount,omitempty"`
	WatchCloseCount         int64 `protobuf:"varint,5,opt,name=watchCloseCount,proto3" json:"watchCloseCount,omitempty"`
	GrpcSendErrCount        int64 `protobuf:"varint,6,opt,name=grpcSendErrCount,proto3" json:"grpcSendErrCount,omitempty"`
}

func (m *Stats) Reset()                    { *m = Stats{} }
func (m *Stats) String() string            { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()               {}
func (*Stats) Descriptor() ([]byte, []int) { return fileDescriptorOrch, []int{12} }

func (m *Stats) GetStoreWatchFailCount() int64 {
	if m != nil {
		return m.StoreWatchFailCount
	}
	return 0
}

func (m *Stats) GetStoreWatchErrCount() int64 {
	if m != nil {
		return m.StoreWatchErrCount
	}
	return 0
}

func (m *Stats) GetStoreWatchBadEventCount() int64 {
	if m != nil {
		return m.StoreWatchBadEventCount
	}
	return 0
}

func (m *Stats) GetStoreWatchBadObjCount() int64 {
	if m != nil {
		return m.StoreWatchBadObjCount
	}
	return 0
}

func (m *Stats) GetWatchCloseCount() int64 {
	if m != nil {
		return m.WatchCloseCount
	}
	return 0
}

func (m *Stats) GetGrpcSendErrCount() int64 {
	if m != nil {
		return m.GrpcSendErrCount
	}
	return 0
}

func init() {
	proto.RegisterType((*Spec)(nil), "orch.Spec")
	proto.RegisterType((*Filter)(nil), "orch.Filter")
	proto.RegisterType((*WatchSpec)(nil), "orch.WatchSpec")
	proto.RegisterType((*WatchEvent)(nil), "orch.WatchEvent")
	proto.RegisterType((*SmartNIC)(nil), "orch.SmartNIC")
	proto.RegisterType((*SmartNIC_Status)(nil), "orch.SmartNIC.Status")
	proto.RegisterType((*SmartNICList)(nil), "orch.SmartNICList")
	proto.RegisterType((*SmartNICEvent)(nil), "orch.SmartNICEvent")
	proto.RegisterType((*NwIF)(nil), "orch.NwIF")
	proto.RegisterType((*NwIF_Config)(nil), "orch.NwIF.Config")
	proto.RegisterType((*NwIF_Status)(nil), "orch.NwIF.Status")
	proto.RegisterType((*NwIFList)(nil), "orch.NwIFList")
	proto.RegisterType((*NwIFEvent)(nil), "orch.NwIFEvent")
	proto.RegisterType((*NwIFMigrationStart)(nil), "orch.NwIFMigrationStart")
	proto.RegisterType((*Empty)(nil), "orch.Empty")
	proto.RegisterType((*Stats)(nil), "orch.Stats")
	proto.RegisterEnum("orch.WatchEvent_EventType", WatchEvent_EventType_name, WatchEvent_EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for OrchApi service

type OrchApiClient interface {
	// List all SmartNIC objects that match the filter spec
	ListSmartNICs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*SmartNICList, error)
	// Watch all Smart NIC objects from the reference version with matching filter spec
	WatchSmartNICs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchSmartNICsClient, error)
	// List all NwIF objects that match the filter spec
	ListNwIFs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*NwIFList, error)
	// Watch all NwIF objects from the reference version with matching filter spec
	WatchNwIFs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchNwIFsClient, error)
	// Watch migration events of network interfaces. Reference version does not apply
	// here as the events are not replayable.
	WatchNwIFMigration(ctx context.Context, in *Filter, opts ...grpc.CallOption) (OrchApi_WatchNwIFMigrationClient, error)
	// Get server statistics
	Inspect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Stats, error)
}

type orchApiClient struct {
	cc *grpc.ClientConn
}

func NewOrchApiClient(cc *grpc.ClientConn) OrchApiClient {
	return &orchApiClient{cc}
}

func (c *orchApiClient) ListSmartNICs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*SmartNICList, error) {
	out := new(SmartNICList)
	err := grpc.Invoke(ctx, "/orch.OrchApi/ListSmartNICs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchApiClient) WatchSmartNICs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchSmartNICsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchApi_serviceDesc.Streams[0], c.cc, "/orch.OrchApi/WatchSmartNICs", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchApiWatchSmartNICsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchApi_WatchSmartNICsClient interface {
	Recv() (*SmartNICEvent, error)
	grpc.ClientStream
}

type orchApiWatchSmartNICsClient struct {
	grpc.ClientStream
}

func (x *orchApiWatchSmartNICsClient) Recv() (*SmartNICEvent, error) {
	m := new(SmartNICEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orchApiClient) ListNwIFs(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*NwIFList, error) {
	out := new(NwIFList)
	err := grpc.Invoke(ctx, "/orch.OrchApi/ListNwIFs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchApiClient) WatchNwIFs(ctx context.Context, in *WatchSpec, opts ...grpc.CallOption) (OrchApi_WatchNwIFsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchApi_serviceDesc.Streams[1], c.cc, "/orch.OrchApi/WatchNwIFs", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchApiWatchNwIFsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchApi_WatchNwIFsClient interface {
	Recv() (*NwIFEvent, error)
	grpc.ClientStream
}

type orchApiWatchNwIFsClient struct {
	grpc.ClientStream
}

func (x *orchApiWatchNwIFsClient) Recv() (*NwIFEvent, error) {
	m := new(NwIFEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orchApiClient) WatchNwIFMigration(ctx context.Context, in *Filter, opts ...grpc.CallOption) (OrchApi_WatchNwIFMigrationClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OrchApi_serviceDesc.Streams[2], c.cc, "/orch.OrchApi/WatchNwIFMigration", opts...)
	if err != nil {
		return nil, err
	}
	x := &orchApiWatchNwIFMigrationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type OrchApi_WatchNwIFMigrationClient interface {
	Recv() (*NwIFMigrationStart, error)
	grpc.ClientStream
}

type orchApiWatchNwIFMigrationClient struct {
	grpc.ClientStream
}

func (x *orchApiWatchNwIFMigrationClient) Recv() (*NwIFMigrationStart, error) {
	m := new(NwIFMigrationStart)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *orchApiClient) Inspect(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Stats, error) {
	out := new(Stats)
	err := grpc.Invoke(ctx, "/orch.OrchApi/Inspect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for OrchApi service

type OrchApiServer interface {
	// List all SmartNIC objects that match the filter spec
	ListSmartNICs(context.Context, *Filter) (*SmartNICList, error)
	// Watch all Smart NIC objects from the reference version with matching filter spec
	WatchSmartNICs(*WatchSpec, OrchApi_WatchSmartNICsServer) error
	// List all NwIF objects that match the filter spec
	ListNwIFs(context.Context, *Filter) (*NwIFList, error)
	// Watch all NwIF objects from the reference version with matching filter spec
	WatchNwIFs(*WatchSpec, OrchApi_WatchNwIFsServer) error
	// Watch migration events of network interfaces. Reference version does not apply
	// here as the events are not replayable.
	WatchNwIFMigration(*Filter, OrchApi_WatchNwIFMigrationServer) error
	// Get server statistics
	Inspect(context.Context, *Empty) (*Stats, error)
}

func RegisterOrchApiServer(s *grpc.Server, srv OrchApiServer) {
	s.RegisterService(&_OrchApi_serviceDesc, srv)
}

func _OrchApi_ListSmartNICs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchApiServer).ListSmartNICs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orch.OrchApi/ListSmartNICs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchApiServer).ListSmartNICs(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchApi_WatchSmartNICs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSpec)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchApiServer).WatchSmartNICs(m, &orchApiWatchSmartNICsServer{stream})
}

type OrchApi_WatchSmartNICsServer interface {
	Send(*SmartNICEvent) error
	grpc.ServerStream
}

type orchApiWatchSmartNICsServer struct {
	grpc.ServerStream
}

func (x *orchApiWatchSmartNICsServer) Send(m *SmartNICEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _OrchApi_ListNwIFs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchApiServer).ListNwIFs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orch.OrchApi/ListNwIFs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchApiServer).ListNwIFs(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrchApi_WatchNwIFs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchSpec)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchApiServer).WatchNwIFs(m, &orchApiWatchNwIFsServer{stream})
}

type OrchApi_WatchNwIFsServer interface {
	Send(*NwIFEvent) error
	grpc.ServerStream
}

type orchApiWatchNwIFsServer struct {
	grpc.ServerStream
}

func (x *orchApiWatchNwIFsServer) Send(m *NwIFEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _OrchApi_WatchNwIFMigration_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(OrchApiServer).WatchNwIFMigration(m, &orchApiWatchNwIFMigrationServer{stream})
}

type OrchApi_WatchNwIFMigrationServer interface {
	Send(*NwIFMigrationStart) error
	grpc.ServerStream
}

type orchApiWatchNwIFMigrationServer struct {
	grpc.ServerStream
}

func (x *orchApiWatchNwIFMigrationServer) Send(m *NwIFMigrationStart) error {
	return x.ServerStream.SendMsg(m)
}

func _OrchApi_Inspect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchApiServer).Inspect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orch.OrchApi/Inspect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchApiServer).Inspect(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _OrchApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orch.OrchApi",
	HandlerType: (*OrchApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSmartNICs",
			Handler:    _OrchApi_ListSmartNICs_Handler,
		},
		{
			MethodName: "ListNwIFs",
			Handler:    _OrchApi_ListNwIFs_Handler,
		},
		{
			MethodName: "Inspect",
			Handler:    _OrchApi_Inspect_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchSmartNICs",
			Handler:       _OrchApi_WatchSmartNICs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchNwIFs",
			Handler:       _OrchApi_WatchNwIFs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchNwIFMigration",
			Handler:       _OrchApi_WatchNwIFMigration_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "orch.proto",
}

func (m *Spec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Operator) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.Operator)))
		i += copy(dAtA[i:], m.Operator)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Specs) > 0 {
		for _, msg := range m.Specs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOrch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WatchSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Refversion) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.Refversion)))
		i += copy(dAtA[i:], m.Refversion)
	}
	if len(m.Specs) > 0 {
		for _, msg := range m.Specs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOrch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WatchEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatchEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Event != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.Event))
	}
	return i, nil
}

func (m *SmartNIC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjectKind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectKind)))
		i += copy(dAtA[i:], m.ObjectKind)
	}
	if len(m.ObjectAPIVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectAPIVersion)))
		i += copy(dAtA[i:], m.ObjectAPIVersion)
	}
	if m.ObjectMeta != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.ObjectMeta.Size()))
		n1, err := m.ObjectMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Status != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *SmartNIC_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostIP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.HostIP)))
		i += copy(dAtA[i:], m.HostIP)
	}
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.Switch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.Switch)))
		i += copy(dAtA[i:], m.Switch)
	}
	return i, nil
}

func (m *SmartNICList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjectKind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectKind)))
		i += copy(dAtA[i:], m.ObjectKind)
	}
	if len(m.ObjectAPIVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectAPIVersion)))
		i += copy(dAtA[i:], m.ObjectAPIVersion)
	}
	if m.ListMeta != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.ListMeta.Size()))
		n3, err := m.ListMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOrch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SmartNICEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.E != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.E.Size()))
		n4, err := m.E.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Smartnics) > 0 {
		for _, msg := range m.Smartnics {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOrch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NwIF) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NwIF) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjectKind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectKind)))
		i += copy(dAtA[i:], m.ObjectKind)
	}
	if len(m.ObjectAPIVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectAPIVersion)))
		i += copy(dAtA[i:], m.ObjectAPIVersion)
	}
	if m.ObjectMeta != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.ObjectMeta.Size()))
		n5, err := m.ObjectMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Config != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.Config.Size()))
		n6, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Status != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.Status.Size()))
		n7, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Attributes) > 0 {
		for k, _ := range m.Attributes {
			dAtA[i] = 0x32
			i++
			v := m.Attributes[k]
			mapSize := 1 + len(k) + sovOrch(uint64(len(k))) + 1 + len(v) + sovOrch(uint64(len(v)))
			i = encodeVarintOrch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintOrch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintOrch(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *NwIF_Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NwIF_Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalVLAN != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.LocalVLAN))
	}
	return i, nil
}

func (m *NwIF_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NwIF_Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MacAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.MacAddress)))
		i += copy(dAtA[i:], m.MacAddress)
	}
	if len(m.PortGroup) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.PortGroup)))
		i += copy(dAtA[i:], m.PortGroup)
	}
	if len(m.Switch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.Switch)))
		i += copy(dAtA[i:], m.Switch)
	}
	if len(m.SmartNIC_ID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.SmartNIC_ID)))
		i += copy(dAtA[i:], m.SmartNIC_ID)
	}
	if len(m.IpAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.IpAddress)))
		i += copy(dAtA[i:], m.IpAddress)
	}
	if len(m.Network) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if len(m.WlName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.WlName)))
		i += copy(dAtA[i:], m.WlName)
	}
	if len(m.WlUUID) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.WlUUID)))
		i += copy(dAtA[i:], m.WlUUID)
	}
	return i, nil
}

func (m *NwIFList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NwIFList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ObjectKind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectKind)))
		i += copy(dAtA[i:], m.ObjectKind)
	}
	if len(m.ObjectAPIVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(len(m.ObjectAPIVersion)))
		i += copy(dAtA[i:], m.ObjectAPIVersion)
	}
	if m.ListMeta != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.ListMeta.Size()))
		n8, err := m.ListMeta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintOrch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NwIFEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NwIFEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.E != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.E.Size()))
		n9, err := m.E.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Nwifs) > 0 {
		for _, msg := range m.Nwifs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOrch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *NwIFMigrationStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NwIFMigrationStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nwifs) > 0 {
		for _, msg := range m.Nwifs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOrch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Source != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.Source.Size()))
		n10, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Dest != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.Dest.Size()))
		n11, err := m.Dest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Stats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreWatchFailCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.StoreWatchFailCount))
	}
	if m.StoreWatchErrCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.StoreWatchErrCount))
	}
	if m.StoreWatchBadEventCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.StoreWatchBadEventCount))
	}
	if m.StoreWatchBadObjCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.StoreWatchBadObjCount))
	}
	if m.WatchCloseCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.WatchCloseCount))
	}
	if m.GrpcSendErrCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOrch(dAtA, i, uint64(m.GrpcSendErrCount))
	}
	return i, nil
}

func encodeVarintOrch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Spec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	return n
}

func (m *Filter) Size() (n int) {
	var l int
	_ = l
	if len(m.Specs) > 0 {
		for _, e := range m.Specs {
			l = e.Size()
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	return n
}

func (m *WatchSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Refversion)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	if len(m.Specs) > 0 {
		for _, e := range m.Specs {
			l = e.Size()
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	return n
}

func (m *WatchEvent) Size() (n int) {
	var l int
	_ = l
	if m.Event != 0 {
		n += 1 + sovOrch(uint64(m.Event))
	}
	return n
}

func (m *SmartNIC) Size() (n int) {
	var l int
	_ = l
	l = len(m.ObjectKind)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.ObjectAPIVersion)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	return n
}

func (m *SmartNIC_Status) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostIP)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.Switch)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	return n
}

func (m *SmartNICList) Size() (n int) {
	var l int
	_ = l
	l = len(m.ObjectKind)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.ObjectAPIVersion)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.ListMeta != nil {
		l = m.ListMeta.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	return n
}

func (m *SmartNICEvent) Size() (n int) {
	var l int
	_ = l
	if m.E != nil {
		l = m.E.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if len(m.Smartnics) > 0 {
		for _, e := range m.Smartnics {
			l = e.Size()
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	return n
}

func (m *NwIF) Size() (n int) {
	var l int
	_ = l
	l = len(m.ObjectKind)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.ObjectAPIVersion)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.ObjectMeta != nil {
		l = m.ObjectMeta.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if len(m.Attributes) > 0 {
		for k, v := range m.Attributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovOrch(uint64(len(k))) + 1 + len(v) + sovOrch(uint64(len(v)))
			n += mapEntrySize + 1 + sovOrch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *NwIF_Config) Size() (n int) {
	var l int
	_ = l
	if m.LocalVLAN != 0 {
		n += 1 + sovOrch(uint64(m.LocalVLAN))
	}
	return n
}

func (m *NwIF_Status) Size() (n int) {
	var l int
	_ = l
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.PortGroup)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.Switch)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.SmartNIC_ID)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.WlName)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.WlUUID)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	return n
}

func (m *NwIFList) Size() (n int) {
	var l int
	_ = l
	l = len(m.ObjectKind)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	l = len(m.ObjectAPIVersion)
	if l > 0 {
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.ListMeta != nil {
		l = m.ListMeta.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	return n
}

func (m *NwIFEvent) Size() (n int) {
	var l int
	_ = l
	if m.E != nil {
		l = m.E.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if len(m.Nwifs) > 0 {
		for _, e := range m.Nwifs {
			l = e.Size()
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	return n
}

func (m *NwIFMigrationStart) Size() (n int) {
	var l int
	_ = l
	if len(m.Nwifs) > 0 {
		for _, e := range m.Nwifs {
			l = e.Size()
			n += 1 + l + sovOrch(uint64(l))
		}
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	if m.Dest != nil {
		l = m.Dest.Size()
		n += 1 + l + sovOrch(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Stats) Size() (n int) {
	var l int
	_ = l
	if m.StoreWatchFailCount != 0 {
		n += 1 + sovOrch(uint64(m.StoreWatchFailCount))
	}
	if m.StoreWatchErrCount != 0 {
		n += 1 + sovOrch(uint64(m.StoreWatchErrCount))
	}
	if m.StoreWatchBadEventCount != 0 {
		n += 1 + sovOrch(uint64(m.StoreWatchBadEventCount))
	}
	if m.StoreWatchBadObjCount != 0 {
		n += 1 + sovOrch(uint64(m.StoreWatchBadObjCount))
	}
	if m.WatchCloseCount != 0 {
		n += 1 + sovOrch(uint64(m.WatchCloseCount))
	}
	if m.GrpcSendErrCount != 0 {
		n += 1 + sovOrch(uint64(m.GrpcSendErrCount))
	}
	return n
}

func sovOrch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOrch(x uint64) (n int) {
	return sovOrch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Spec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Specs = append(m.Specs, &Spec{})
			if err := m.Specs[len(m.Specs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refversion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refversion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Specs = append(m.Specs, &Spec{})
			if err := m.Specs[len(m.Specs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatchEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatchEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatchEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			m.Event = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Event |= (WatchEvent_EventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNIC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNIC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectAPIVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectAPIVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &api.ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &SmartNIC_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Switch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectAPIVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectAPIVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ListMeta == nil {
				m.ListMeta = &api.ListMeta{}
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SmartNIC{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.E == nil {
				m.E = &WatchEvent{}
			}
			if err := m.E.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Smartnics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Smartnics = append(m.Smartnics, &SmartNIC{})
			if err := m.Smartnics[len(m.Smartnics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NwIF) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NwIF: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NwIF: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectAPIVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectAPIVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectMeta == nil {
				m.ObjectMeta = &api.ObjectMeta{}
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &NwIF_Config{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NwIF_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOrch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthOrch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOrch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthOrch
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipOrch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthOrch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Attributes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NwIF_Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalVLAN", wireType)
			}
			m.LocalVLAN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalVLAN |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NwIF_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Switch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Switch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartNIC_ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmartNIC_ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WlName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WlName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WlUUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WlUUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NwIFList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NwIFList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NwIFList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectAPIVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectAPIVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ListMeta == nil {
				m.ListMeta = &api.ListMeta{}
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &NwIF{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NwIFEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NwIFEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NwIFEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.E == nil {
				m.E = &WatchEvent{}
			}
			if err := m.E.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nwifs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nwifs = append(m.Nwifs, &NwIF{})
			if err := m.Nwifs[len(m.Nwifs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NwIFMigrationStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NwIFMigrationStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NwIFMigrationStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nwifs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nwifs = append(m.Nwifs, &NwIF{})
			if err := m.Nwifs[len(m.Nwifs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SmartNIC{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dest == nil {
				m.Dest = &SmartNIC{}
			}
			if err := m.Dest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreWatchFailCount", wireType)
			}
			m.StoreWatchFailCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreWatchFailCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreWatchErrCount", wireType)
			}
			m.StoreWatchErrCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreWatchErrCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreWatchBadEventCount", wireType)
			}
			m.StoreWatchBadEventCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreWatchBadEventCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreWatchBadObjCount", wireType)
			}
			m.StoreWatchBadObjCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreWatchBadObjCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatchCloseCount", wireType)
			}
			m.WatchCloseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WatchCloseCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcSendErrCount", wireType)
			}
			m.GrpcSendErrCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpcSendErrCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOrch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOrch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOrch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOrch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOrch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("orch.proto", fileDescriptorOrch) }

var fileDescriptorOrch = []byte{
	// 1015 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0x93, 0xd8, 0x89, 0x4f, 0xda, 0x26, 0xcc, 0xb2, 0x60, 0x59, 0xab, 0x10, 0x59, 0xec,
	0x2a, 0xbb, 0x40, 0x52, 0x65, 0xb9, 0x58, 0x2a, 0x21, 0x91, 0x4d, 0x5b, 0x14, 0xd1, 0x9f, 0x95,
	0x43, 0x17, 0x6e, 0x10, 0x72, 0x9c, 0x69, 0xe3, 0xdd, 0xc4, 0x63, 0xcd, 0x4c, 0x1a, 0xe5, 0x96,
	0x27, 0xe0, 0x1d, 0xb8, 0xe4, 0x82, 0x97, 0xe0, 0x82, 0x4b, 0x1e, 0x01, 0xf5, 0x02, 0x5e, 0x03,
	0xcd, 0x8f, 0xed, 0xfc, 0xb4, 0x12, 0x17, 0x48, 0x7b, 0x53, 0xcd, 0xf9, 0xce, 0x77, 0xce, 0x99,
	0xf9, 0xf2, 0x8d, 0x3b, 0x00, 0x84, 0x86, 0x93, 0x76, 0x42, 0x09, 0x27, 0xa8, 0x24, 0xd6, 0xee,
	0xe3, 0xeb, 0x88, 0x4f, 0xe6, 0xa3, 0x76, 0x48, 0x66, 0x9d, 0x04, 0xc7, 0x2c, 0x88, 0xc7, 0xa4,
	0xc3, 0x16, 0x9d, 0x20, 0x89, 0x3a, 0x33, 0xcc, 0x03, 0x45, 0xf6, 0x4e, 0xa1, 0x34, 0x4c, 0x70,
	0x88, 0xea, 0x50, 0x7c, 0x8b, 0x97, 0x8e, 0xd1, 0x34, 0x5a, 0xb6, 0x2f, 0x96, 0xc8, 0x85, 0x0a,
	0x49, 0x30, 0x0d, 0x38, 0xa1, 0x4e, 0x41, 0xc2, 0x59, 0x8c, 0x3e, 0x00, 0xeb, 0x26, 0x98, 0xce,
	0x31, 0x73, 0x8a, 0xcd, 0x62, 0xcb, 0xf6, 0x75, 0xe4, 0x3d, 0x03, 0xeb, 0x24, 0x9a, 0x72, 0x4c,
	0x51, 0x13, 0x4c, 0x96, 0xe0, 0x90, 0x39, 0x46, 0xb3, 0xd8, 0xaa, 0x76, 0xa1, 0x2d, 0x37, 0x28,
	0x46, 0xf9, 0x2a, 0xe1, 0x9d, 0x81, 0xfd, 0x5d, 0xc0, 0xc3, 0x89, 0x1c, 0xdf, 0x00, 0xa0, 0xf8,
	0xea, 0x06, 0x53, 0x16, 0x91, 0x58, 0xef, 0x62, 0x05, 0xc9, 0xdb, 0x15, 0xee, 0x6b, 0xb7, 0x04,
	0x90, 0xed, 0x8e, 0x6f, 0x70, 0xcc, 0xd1, 0x01, 0x98, 0x58, 0x2c, 0x64, 0xab, 0xfd, 0xae, 0xab,
	0xf8, 0x39, 0xa1, 0x2d, 0xff, 0x7e, 0xbb, 0x4c, 0xb0, 0xaf, 0x88, 0xde, 0x17, 0x60, 0x67, 0x18,
	0xaa, 0x40, 0xe9, 0x34, 0x62, 0xbc, 0xbe, 0x83, 0x00, 0xac, 0x3e, 0xc5, 0x01, 0xc7, 0x75, 0x43,
	0xac, 0x2f, 0x93, 0xb1, 0x58, 0x17, 0xc4, 0xfa, 0x08, 0x4f, 0x31, 0xc7, 0xf5, 0xa2, 0xf7, 0x73,
	0x01, 0x2a, 0xc3, 0x59, 0x40, 0xf9, 0xf9, 0xa0, 0x2f, 0x4e, 0x72, 0x31, 0x7a, 0x83, 0x43, 0xfe,
	0x4d, 0x14, 0x8f, 0xd3, 0x93, 0xe4, 0x08, 0x7a, 0x06, 0x75, 0x15, 0xf5, 0x5e, 0x0d, 0x5e, 0xeb,
	0xf3, 0x2a, 0x79, 0xb7, 0x70, 0xd4, 0x49, 0x7b, 0x9d, 0x61, 0x1e, 0x38, 0xc5, 0xa6, 0xd1, 0xaa,
	0x76, 0x6b, 0xed, 0x20, 0x89, 0xda, 0x39, 0xec, 0xaf, 0x50, 0xd0, 0x67, 0x60, 0x31, 0x1e, 0xf0,
	0x39, 0x73, 0x4a, 0x92, 0xfc, 0x50, 0xeb, 0xa4, 0x37, 0xd7, 0x1e, 0xca, 0xa4, 0xaf, 0x49, 0xee,
	0xf7, 0x60, 0x29, 0x44, 0xfc, 0xa0, 0x13, 0xc2, 0xf8, 0xe0, 0x95, 0xde, 0xb1, 0x8e, 0xc4, 0x69,
	0x66, 0x41, 0xd8, 0x1b, 0x8f, 0x29, 0x66, 0x4c, 0xef, 0x73, 0x05, 0x11, 0x75, 0x6c, 0x11, 0xf1,
	0x70, 0x22, 0x77, 0x67, 0xfb, 0x3a, 0xf2, 0x7e, 0x35, 0x60, 0x37, 0x9d, 0x2a, 0x94, 0xfc, 0x5f,
	0x65, 0x79, 0x0a, 0x15, 0xd1, 0x73, 0x45, 0x94, 0x3d, 0x29, 0x4a, 0x0a, 0xfa, 0x59, 0x1a, 0x7d,
	0x0c, 0x66, 0xc4, 0xf1, 0x4c, 0xe8, 0x21, 0x7c, 0xb3, 0xbf, 0xae, 0x87, 0xaf, 0x92, 0xde, 0x0f,
	0xb0, 0x97, 0x42, 0xca, 0x3e, 0x0d, 0x30, 0xb0, 0xdc, 0x64, 0xb5, 0x5b, 0xdf, 0xb4, 0x8e, 0x6f,
	0x60, 0xf4, 0x29, 0xd8, 0x4c, 0x14, 0xc4, 0x51, 0x66, 0xc9, 0xcd, 0xd6, 0x39, 0xc1, 0xfb, 0xbb,
	0x04, 0xa5, 0xf3, 0xc5, 0xe0, 0xe4, 0xdd, 0x7a, 0xe3, 0x29, 0x58, 0x21, 0x89, 0xaf, 0xa2, 0x6b,
	0xed, 0x8d, 0xf7, 0xd4, 0x86, 0xc5, 0xc6, 0xda, 0x7d, 0x99, 0xf0, 0x35, 0x41, 0x50, 0xb5, 0x8d,
	0xcc, 0x2d, 0xea, 0xba, 0x85, 0xd0, 0x21, 0x40, 0xc0, 0x39, 0x8d, 0x46, 0x73, 0x8e, 0x99, 0x63,
	0x49, 0x29, 0xdc, 0x15, 0x7a, 0x2f, 0x4b, 0x1e, 0xc7, 0x9c, 0x2e, 0xfd, 0x15, 0xb6, 0xfb, 0x04,
	0x2c, 0x35, 0x18, 0x3d, 0x02, 0x7b, 0x4a, 0xc2, 0x60, 0xfa, 0xfa, 0xb4, 0x77, 0x2e, 0x75, 0x31,
	0xfd, 0x1c, 0x70, 0xff, 0x31, 0x32, 0x9f, 0xae, 0xfb, 0xd1, 0xd8, 0xf2, 0xe3, 0x23, 0xb0, 0x13,
	0x42, 0xf9, 0xd7, 0x94, 0xcc, 0x13, 0x2d, 0x5d, 0x0e, 0xdc, 0xe7, 0x56, 0xf4, 0x11, 0x54, 0x99,
	0xfe, 0xdd, 0x7e, 0x1c, 0x1c, 0x49, 0x7d, 0x6c, 0x1f, 0x52, 0x68, 0x70, 0x24, 0xda, 0x46, 0x49,
	0x3a, 0xd5, 0x54, 0x6d, 0x33, 0x00, 0x39, 0x50, 0x8e, 0x31, 0x5f, 0x10, 0xfa, 0xd6, 0xb1, 0x64,
	0x2e, 0x0d, 0xc5, 0xc0, 0xc5, 0xf4, 0x3c, 0x98, 0x61, 0xa7, 0xac, 0x06, 0xaa, 0x48, 0xe1, 0x97,
	0x97, 0x83, 0x23, 0xa7, 0x92, 0xe2, 0x22, 0x72, 0xbf, 0x84, 0xda, 0x86, 0x60, 0x77, 0x7c, 0x98,
	0xdf, 0x07, 0x53, 0x7e, 0x6e, 0xf5, 0xf9, 0x54, 0x70, 0x58, 0x78, 0x61, 0x78, 0xbf, 0x18, 0x50,
	0x11, 0xaa, 0xbf, 0xcb, 0x1b, 0xd7, 0x5c, 0xbf, 0x71, 0x90, 0x7b, 0x21, 0xbd, 0x6d, 0x67, 0x60,
	0x8b, 0xf0, 0xbf, 0xdd, 0xb4, 0x26, 0x98, 0xf1, 0x22, 0xba, 0xda, 0xf8, 0xf0, 0xab, 0x76, 0x32,
	0xe1, 0xfd, 0x64, 0x00, 0x12, 0xf1, 0x59, 0x74, 0x4d, 0x03, 0x1e, 0x91, 0x78, 0xc8, 0x03, 0xca,
	0xf3, 0x42, 0xe3, 0x9e, 0x42, 0xf4, 0x04, 0x2c, 0x46, 0xe6, 0x34, 0x54, 0x42, 0x6e, 0xdf, 0x60,
	0x9d, 0x45, 0x1e, 0x94, 0xc6, 0x98, 0x71, 0x7d, 0xf0, 0x4d, 0x96, 0xcc, 0x79, 0x65, 0x30, 0x8f,
	0x67, 0x09, 0x5f, 0x7a, 0xbf, 0x15, 0xc0, 0x14, 0x5e, 0x65, 0xe8, 0x00, 0x1e, 0x30, 0x4e, 0x28,
	0x96, 0xe7, 0x39, 0x09, 0xa2, 0x69, 0x9f, 0xcc, 0xf5, 0x3f, 0xa4, 0xa2, 0x7f, 0x57, 0x0a, 0xb5,
	0x01, 0xe5, 0xf0, 0x31, 0xa5, 0xaa, 0xa0, 0x20, 0x0b, 0xee, 0xc8, 0xa0, 0x17, 0xf0, 0x61, 0x8e,
	0xbe, 0x0c, 0xc6, 0x52, 0x34, 0x55, 0x54, 0x94, 0x45, 0xf7, 0xa5, 0xd1, 0xe7, 0xf0, 0x70, 0x2d,
	0x75, 0x31, 0x7a, 0xa3, 0xea, 0x4a, 0xb2, 0xee, 0xee, 0x24, 0x6a, 0x41, 0x6d, 0x21, 0xb0, 0xfe,
	0x94, 0x30, 0xac, 0xf8, 0xa6, 0xe4, 0x6f, 0xc2, 0xc2, 0x5b, 0xd7, 0x34, 0x09, 0x87, 0x38, 0x1e,
	0x67, 0xe7, 0xb0, 0x24, 0x75, 0x0b, 0xef, 0xfe, 0x5e, 0x80, 0xf2, 0x05, 0x0d, 0x27, 0xbd, 0x24,
	0x42, 0xcf, 0x61, 0x4f, 0x18, 0x29, 0x15, 0x97, 0xa1, 0x5d, 0xa5, 0xb6, 0x7a, 0x54, 0xb8, 0x68,
	0x5d, 0x7b, 0x41, 0xf5, 0x76, 0xd0, 0x21, 0xec, 0xab, 0x87, 0x44, 0x56, 0x55, 0x5b, 0x71, 0x92,
	0x78, 0x23, 0xb8, 0x0f, 0xd6, 0x0b, 0xa5, 0x12, 0xde, 0xce, 0x81, 0x81, 0x3e, 0x01, 0x5b, 0x74,
	0x11, 0xb6, 0xd8, 0x1c, 0xb6, 0x9f, 0x3b, 0x46, 0x0f, 0xea, 0xea, 0x27, 0x86, 0x62, 0x6f, 0x0d,
	0xa9, 0xe5, 0x05, 0xf9, 0x80, 0xaf, 0x00, 0x65, 0x35, 0x99, 0x43, 0x37, 0x26, 0x39, 0x79, 0xe1,
	0xba, 0x89, 0x65, 0x87, 0xc7, 0x50, 0x1e, 0xc4, 0xe2, 0x8d, 0xc3, 0x51, 0x55, 0x11, 0xa5, 0xd3,
	0x5c, 0x1d, 0x48, 0xb3, 0x79, 0x3b, 0x2f, 0x77, 0xff, 0xb8, 0x6d, 0x18, 0x7f, 0xde, 0x36, 0x8c,
	0xbf, 0x6e, 0x1b, 0xc6, 0xc8, 0x92, 0xaf, 0xbb, 0xe7, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xd7,
	0x49, 0x98, 0xb0, 0x18, 0x0a, 0x00, 0x00,
}
