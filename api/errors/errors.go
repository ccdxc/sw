package apierrors

import (
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	gwruntime "github.com/pensando/grpc-gateway/runtime"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/runtime"
)

// FromError extracts a api.Status object from error. This is possible for errors generated by
//  the api server. The api server attaches auxillary data to grpc errors which this utiility
//  function extracts
func FromError(err error) api.Status {
	ret := api.Status{Code: int32(codes.Unknown), Message: []string{err.Error()}}
	grpcstatus, ok := status.FromError(err)
	if !ok {
		return ret
	}

	details := grpcstatus.Details()
	for _, d := range details {
		// we expect only one status object.
		if _, ok := d.(*api.Status); ok {
			ret = *d.(*api.Status)
			break
		}
	}
	ret.Code = int32(gwruntime.HTTPStatusFromCode(grpcstatus.Code()))
	return ret
}

// ToGrpcError generates an error to be used as return for gRPC errors on the server. This utility
//  function encodes an api.Status message to a grpc error which can then be extracted by the
//  grpc client
func ToGrpcError(err error, msg []string, code int32, uri string, obj runtime.Object) error {
	ref := &api.ObjectRef{}
	if obj != nil {
		ref.Kind = obj.GetObjectKind()
		if meta, ok := obj.(runtime.ObjectMetaAccessor); ok {
			objmeta := meta.GetObjectMeta()
			ref.Name = objmeta.Name
			ref.Tenant = objmeta.Tenant
			ref.Namespace = objmeta.Namespace
		}
	}
	ref.URI = uri
	apistatus := api.Status{
		TypeMeta: api.TypeMeta{Kind: ref.Kind},
		Code:     code,
		Result:   api.StatusResult{Str: err.Error()},
		Message:  msg,
		Ref:      ref,
	}
	grpcstatus := status.New(codes.Code(code), err.Error())
	grpcstatus, e := grpcstatus.WithDetails(&apistatus)
	if e != nil {
		log.Errorf("failed to create grpcStatus (%s)", e)
		return err
	}
	return grpcstatus.Err()
}
