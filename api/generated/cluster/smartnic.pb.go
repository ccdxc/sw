// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: smartnic.proto

package cluster

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// These are valid conditions of a SmartNIC
type SmartNICCondition_ConditionType int32

const (
	// ui-hint: Healthy
	SmartNICCondition_HEALTHY SmartNICCondition_ConditionType = 0
	// ui-hint: Not Reachable
	SmartNICCondition_UNREACHABLE SmartNICCondition_ConditionType = 1
)

var SmartNICCondition_ConditionType_name = map[int32]string{
	0: "HEALTHY",
	1: "UNREACHABLE",
}
var SmartNICCondition_ConditionType_value = map[string]int32{
	"HEALTHY":     0,
	"UNREACHABLE": 1,
}

func (x SmartNICCondition_ConditionType) String() string {
	return proto.EnumName(SmartNICCondition_ConditionType_name, int32(x))
}
func (SmartNICCondition_ConditionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{4, 0}
}

// MgmtModes defines the valid management modes
type SmartNICSpec_MgmtModes int32

const (
	// ui-hint: Host
	SmartNICSpec_HOST SmartNICSpec_MgmtModes = 0
	// ui-hint: Network
	SmartNICSpec_NETWORK SmartNICSpec_MgmtModes = 1
)

var SmartNICSpec_MgmtModes_name = map[int32]string{
	0: "HOST",
	1: "NETWORK",
}
var SmartNICSpec_MgmtModes_value = map[string]int32{
	"HOST":    0,
	"NETWORK": 1,
}

func (x SmartNICSpec_MgmtModes) String() string {
	return proto.EnumName(SmartNICSpec_MgmtModes_name, int32(x))
}
func (SmartNICSpec_MgmtModes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{6, 0}
}

// NetworkModes - is only applicable if the MgmtMode is NETWORK
type SmartNICSpec_NetworkModes int32

const (
	// ui-hint: Out of Band
	SmartNICSpec_OOB SmartNICSpec_NetworkModes = 0
	// ui-hint: Inband
	SmartNICSpec_INBAND SmartNICSpec_NetworkModes = 1
)

var SmartNICSpec_NetworkModes_name = map[int32]string{
	0: "OOB",
	1: "INBAND",
}
var SmartNICSpec_NetworkModes_value = map[string]int32{
	"OOB":    0,
	"INBAND": 1,
}

func (x SmartNICSpec_NetworkModes) String() string {
	return proto.EnumName(SmartNICSpec_NetworkModes_name, int32(x))
}
func (SmartNICSpec_NetworkModes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{6, 1}
}

// Various phases in lifecycle of a SmartNIC
type SmartNICStatus_Phase int32

const (
	// ui-hint: Unknown
	SmartNICStatus_UNKNOWN SmartNICStatus_Phase = 0
	// ui-hint: Registering
	SmartNICStatus_REGISTERING SmartNICStatus_Phase = 1
	// ui-hint: Rejected
	SmartNICStatus_REJECTED SmartNICStatus_Phase = 2
	// ui-hint: Pending
	SmartNICStatus_PENDING SmartNICStatus_Phase = 3
	// ui-hint: Admitted
	SmartNICStatus_ADMITTED SmartNICStatus_Phase = 4
)

var SmartNICStatus_Phase_name = map[int32]string{
	0: "UNKNOWN",
	1: "REGISTERING",
	2: "REJECTED",
	3: "PENDING",
	4: "ADMITTED",
}
var SmartNICStatus_Phase_value = map[string]int32{
	"UNKNOWN":     0,
	"REGISTERING": 1,
	"REJECTED":    2,
	"PENDING":     3,
	"ADMITTED":    4,
}

func (x SmartNICStatus_Phase) String() string {
	return proto.EnumName(SmartNICStatus_Phase_name, int32(x))
}
func (SmartNICStatus_Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSmartnic, []int{7, 0}
}

// BIOS information
type BiosInfo struct {
	// Vendor name
	Vendor string `protobuf:"bytes,1,opt,name=Vendor,json=vendor,omitempty,proto3" json:"vendor,omitempty"`
	// BIOS version
	Version string `protobuf:"bytes,2,opt,name=Version,json=version,omitempty,proto3" json:"version,omitempty"`
	// Firmware major release info
	FwMajorVersion string `protobuf:"bytes,3,opt,name=FwMajorVersion,json=fw-major-ver,omitempty,proto3" json:"fw-major-ver,omitempty"`
	// Firmware minor release info
	FwMinorVersion string `protobuf:"bytes,4,opt,name=FwMinorVersion,json=fw-minor-ver,omitempty,proto3" json:"fw-minor-ver,omitempty"`
}

func (m *BiosInfo) Reset()                    { *m = BiosInfo{} }
func (m *BiosInfo) String() string            { return proto.CompactTextString(m) }
func (*BiosInfo) ProtoMessage()               {}
func (*BiosInfo) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{0} }

func (m *BiosInfo) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *BiosInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *BiosInfo) GetFwMajorVersion() string {
	if m != nil {
		return m.FwMajorVersion
	}
	return ""
}

func (m *BiosInfo) GetFwMinorVersion() string {
	if m != nil {
		return m.FwMinorVersion
	}
	return ""
}

// IPConfig defines the static IP configuration for a SmartNIC
type IPConfig struct {
	// IPAddress contains the Management IP address of the SmartNIC in CIDR format
	IPAddress string `protobuf:"bytes,1,opt,name=IPAddress,json=ip-address,omitempty,proto3" json:"ip-address,omitempty"`
	// DefaultGW contains the default gateway's IP address
	DefaultGW string `protobuf:"bytes,2,opt,name=DefaultGW,json=default-gw,omitempty,proto3" json:"default-gw,omitempty"`
	// DNSServers contains a list of DNS Servers that can be used on SmartNIC
	DNSServers []string `protobuf:"bytes,3,rep,name=DNSServers,json=dns-servers,omitempty" json:"dns-servers,omitempty"`
}

func (m *IPConfig) Reset()                    { *m = IPConfig{} }
func (m *IPConfig) String() string            { return proto.CompactTextString(m) }
func (*IPConfig) ProtoMessage()               {}
func (*IPConfig) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{1} }

func (m *IPConfig) GetIPAddress() string {
	if m != nil {
		return m.IPAddress
	}
	return ""
}

func (m *IPConfig) GetDefaultGW() string {
	if m != nil {
		return m.DefaultGW
	}
	return ""
}

func (m *IPConfig) GetDNSServers() []string {
	if m != nil {
		return m.DNSServers
	}
	return nil
}

// MAC address Range
type MacRange struct {
	//
	Start string `protobuf:"bytes,1,opt,name=Start,json=mac-start,omitempty,proto3" json:"mac-start,omitempty"`
	//
	End string `protobuf:"bytes,2,opt,name=End,json=mac-end,omitempty,proto3" json:"mac-end,omitempty"`
}

func (m *MacRange) Reset()                    { *m = MacRange{} }
func (m *MacRange) String() string            { return proto.CompactTextString(m) }
func (*MacRange) ProtoMessage()               {}
func (*MacRange) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{2} }

func (m *MacRange) GetStart() string {
	if m != nil {
		return m.Start
	}
	return ""
}

func (m *MacRange) GetEnd() string {
	if m != nil {
		return m.End
	}
	return ""
}

// ------------------------------------ SMART NIC  -------------------------------------------
//
// SmartNIC represents the Naples I/O subsystem
//
// Entity responsible & scenarios involved in managing this object:
//
//      Create:
//          o CMD
//              - created as part of NIC registration, Admittance
//      Modify:
//          o CMD
//              - update spec attributes
//              - update status attributes
//      Delete:
//          o CMD
//              - aging out stale or rejected NICs (TBD)
//          o NetOps, SecOps
//              - Decomission a NIC (TBD)
//
type SmartNIC struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	// Object name is Serial-Number of the SmartNIC
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
	// SmartNICSpec contains the configuration of the network adapter.
	Spec SmartNICSpec `protobuf:"bytes,3,opt,name=Spec,json=spec,omitempty" json:"spec,omitempty"`
	// SmartNICStatus contains the current state of the network adapter.
	Status SmartNICStatus `protobuf:"bytes,4,opt,name=Status,json=status,omitempty" json:"status,omitempty"`
}

func (m *SmartNIC) Reset()                    { *m = SmartNIC{} }
func (m *SmartNIC) String() string            { return proto.CompactTextString(m) }
func (*SmartNIC) ProtoMessage()               {}
func (*SmartNIC) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{3} }

func (m *SmartNIC) GetSpec() SmartNICSpec {
	if m != nil {
		return m.Spec
	}
	return SmartNICSpec{}
}

func (m *SmartNIC) GetStatus() SmartNICStatus {
	if m != nil {
		return m.Status
	}
	return SmartNICStatus{}
}

// SmartNICCondition describes the state of a SmartNIC at a certain point.
type SmartNICCondition struct {
	// Type indicates a certain NIC condition
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Condition Status
	Status string `protobuf:"bytes,2,opt,name=Status,json=status,omitempty,proto3" json:"status,omitempty"`
	// The last time the condition transitioned
	LastTransitionTime string `protobuf:"bytes,3,opt,name=LastTransitionTime,json=last-transition-time,omitempty,proto3" json:"last-transition-time,omitempty"`
	// The reason for the condition's last transition
	Reason string `protobuf:"bytes,4,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
	// A detailed message indicating details about the transition.
	Message string `protobuf:"bytes,5,opt,name=Message,json=message,omitempty,proto3" json:"message,omitempty"`
}

func (m *SmartNICCondition) Reset()                    { *m = SmartNICCondition{} }
func (m *SmartNICCondition) String() string            { return proto.CompactTextString(m) }
func (*SmartNICCondition) ProtoMessage()               {}
func (*SmartNICCondition) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{4} }

func (m *SmartNICCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SmartNICCondition) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *SmartNICCondition) GetLastTransitionTime() string {
	if m != nil {
		return m.LastTransitionTime
	}
	return ""
}

func (m *SmartNICCondition) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SmartNICCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Naples I/O (SmartNIC) subsystem information
type SmartNICInfo struct {
	// BIOS details
	BiosInfo *BiosInfo `protobuf:"bytes,1,opt,name=BiosInfo,json=bios-info,omitempty" json:"bios-info,omitempty"`
	// OS details
	OsInfo *OsInfo `protobuf:"bytes,2,opt,name=OsInfo,json=os-info,omitempty" json:"os-info,omitempty"`
	// CPU details
	CpuInfo *CPUInfo `protobuf:"bytes,3,opt,name=CpuInfo,json=cpu-info,omitempty" json:"cpu-info,omitempty"`
	// RAM/Memory details
	MemoryInfo *MemInfo `protobuf:"bytes,4,opt,name=MemoryInfo,json=memory-info,omitempty" json:"memory-info,omitempty"`
	// Storage details
	StorageInfo *StorageInfo `protobuf:"bytes,5,opt,name=StorageInfo,json=storage-info,omitempty" json:"storage-info,omitempty"`
}

func (m *SmartNICInfo) Reset()                    { *m = SmartNICInfo{} }
func (m *SmartNICInfo) String() string            { return proto.CompactTextString(m) }
func (*SmartNICInfo) ProtoMessage()               {}
func (*SmartNICInfo) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{5} }

func (m *SmartNICInfo) GetBiosInfo() *BiosInfo {
	if m != nil {
		return m.BiosInfo
	}
	return nil
}

func (m *SmartNICInfo) GetOsInfo() *OsInfo {
	if m != nil {
		return m.OsInfo
	}
	return nil
}

func (m *SmartNICInfo) GetCpuInfo() *CPUInfo {
	if m != nil {
		return m.CpuInfo
	}
	return nil
}

func (m *SmartNICInfo) GetMemoryInfo() *MemInfo {
	if m != nil {
		return m.MemoryInfo
	}
	return nil
}

func (m *SmartNICInfo) GetStorageInfo() *StorageInfo {
	if m != nil {
		return m.StorageInfo
	}
	return nil
}

// SmartNICSpec contains configuration of the SmartNIC (Naples I/O subsystem)
type SmartNICSpec struct {
	// Admit allows a SmartNIC to join the cluster
	Admit bool `protobuf:"varint,1,opt,name=Admit,json=admit,omitempty,proto3" json:"admit,omitempty"`
	// Hostname is used as a user friendly identifier in logs/events
	Hostname string `protobuf:"bytes,2,opt,name=Hostname,json=hostname,omitempty,proto3" json:"hostname,omitempty"`
	// IPConfig defines the static IP configuration. If not specified, DHCP will be attempted
	IPConfig *IPConfig `protobuf:"bytes,3,opt,name=IPConfig,json=ip-config,omitempty" json:"ip-config,omitempty"`
	// MgmtMode defines the management mode of the SmartNIC
	MgmtMode string `protobuf:"bytes,4,opt,name=MgmtMode,json=mgmt-mode,omitempty,proto3" json:"mgmt-mode,omitempty"`
	// MgmtMode defines the management mode of the SmartNIC
	NetworkMode string `protobuf:"bytes,5,opt,name=NetworkMode,json=network-mode,omitempty,proto3" json:"network-mode,omitempty"`
	// MgmtVlan defines the vlan to be used in network managed mode. The default of 0
	// means we use untagged-vlan for doing inband management
	MgmtVlan uint32 `protobuf:"varint,6,opt,name=MgmtVlan,json=mgmt-vlan,omitempty,proto3" json:"mgmt-vlan,omitempty"`
	// Controllers contains the list of remote controllers IP addresses or hostnames
	Controllers []string `protobuf:"bytes,7,rep,name=Controllers,json=controllers,omitempty" json:"controllers,omitempty"`
}

func (m *SmartNICSpec) Reset()                    { *m = SmartNICSpec{} }
func (m *SmartNICSpec) String() string            { return proto.CompactTextString(m) }
func (*SmartNICSpec) ProtoMessage()               {}
func (*SmartNICSpec) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{6} }

func (m *SmartNICSpec) GetAdmit() bool {
	if m != nil {
		return m.Admit
	}
	return false
}

func (m *SmartNICSpec) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *SmartNICSpec) GetIPConfig() *IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *SmartNICSpec) GetMgmtMode() string {
	if m != nil {
		return m.MgmtMode
	}
	return ""
}

func (m *SmartNICSpec) GetNetworkMode() string {
	if m != nil {
		return m.NetworkMode
	}
	return ""
}

func (m *SmartNICSpec) GetMgmtVlan() uint32 {
	if m != nil {
		return m.MgmtVlan
	}
	return 0
}

func (m *SmartNICSpec) GetControllers() []string {
	if m != nil {
		return m.Controllers
	}
	return nil
}

// SmartNICStatus contains current status of a SmartNIC
type SmartNICStatus struct {
	// Current admission phase of the SmartNIC.
	// When auto-admission is enabled, AdmissionPhase will be set to NIC_ADMITTED
	// by CMD for validated NICs.
	// When auto-admission is not enabled, AdmissionPhase will be set to NIC_PENDING
	// by CMD for validated NICs since it requires manual approval.
	// To admit the NIC as a part of manual admission, user is expected to
	// set Spec.Admit to true for the NICs that are in NIC_PENDING
	// state. Note : Whitelist mode is not supported yet.
	AdmissionPhase string `protobuf:"bytes,1,opt,name=AdmissionPhase,json=admission-phase,omitempty,proto3" json:"admission-phase,omitempty"`
	// List of current NIC conditions
	Conditions []SmartNICCondition `protobuf:"bytes,2,rep,name=Conditions,json=conditions,omitempty" json:"conditions,omitempty"`
	// Serial number
	SerialNum string `protobuf:"bytes,3,opt,name=SerialNum,json=serial-num,omitempty,proto3" json:"serial-num,omitempty"`
	// PrimaryMAC is the MAC address of the primary PF exposed by SmartNIC
	PrimaryMAC string `protobuf:"bytes,4,opt,name=PrimaryMAC,json=primary-mac,omitempty,proto3" json:"primary-mac,omitempty"`
	// IPConfig is the ip address related configuration obtained from DHCP
	IPConfig *IPConfig `protobuf:"bytes,5,opt,name=IPConfig,json=ip-config,omitempty" json:"ip-config,omitempty"`
	// Naples I/O system info
	SystemInfo *SmartNICInfo `protobuf:"bytes,6,opt,name=SystemInfo,json=system-info,omitempty" json:"system-info,omitempty"`
	// Network Interfaces
	Interfaces []string `protobuf:"bytes,7,rep,name=Interfaces,json=interfaces,omitempty" json:"interfaces,omitempty"`
}

func (m *SmartNICStatus) Reset()                    { *m = SmartNICStatus{} }
func (m *SmartNICStatus) String() string            { return proto.CompactTextString(m) }
func (*SmartNICStatus) ProtoMessage()               {}
func (*SmartNICStatus) Descriptor() ([]byte, []int) { return fileDescriptorSmartnic, []int{7} }

func (m *SmartNICStatus) GetAdmissionPhase() string {
	if m != nil {
		return m.AdmissionPhase
	}
	return ""
}

func (m *SmartNICStatus) GetConditions() []SmartNICCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *SmartNICStatus) GetSerialNum() string {
	if m != nil {
		return m.SerialNum
	}
	return ""
}

func (m *SmartNICStatus) GetPrimaryMAC() string {
	if m != nil {
		return m.PrimaryMAC
	}
	return ""
}

func (m *SmartNICStatus) GetIPConfig() *IPConfig {
	if m != nil {
		return m.IPConfig
	}
	return nil
}

func (m *SmartNICStatus) GetSystemInfo() *SmartNICInfo {
	if m != nil {
		return m.SystemInfo
	}
	return nil
}

func (m *SmartNICStatus) GetInterfaces() []string {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

func init() {
	proto.RegisterType((*BiosInfo)(nil), "cluster.BiosInfo")
	proto.RegisterType((*IPConfig)(nil), "cluster.IPConfig")
	proto.RegisterType((*MacRange)(nil), "cluster.MacRange")
	proto.RegisterType((*SmartNIC)(nil), "cluster.SmartNIC")
	proto.RegisterType((*SmartNICCondition)(nil), "cluster.SmartNICCondition")
	proto.RegisterType((*SmartNICInfo)(nil), "cluster.SmartNICInfo")
	proto.RegisterType((*SmartNICSpec)(nil), "cluster.SmartNICSpec")
	proto.RegisterType((*SmartNICStatus)(nil), "cluster.SmartNICStatus")
	proto.RegisterEnum("cluster.SmartNICCondition_ConditionType", SmartNICCondition_ConditionType_name, SmartNICCondition_ConditionType_value)
	proto.RegisterEnum("cluster.SmartNICSpec_MgmtModes", SmartNICSpec_MgmtModes_name, SmartNICSpec_MgmtModes_value)
	proto.RegisterEnum("cluster.SmartNICSpec_NetworkModes", SmartNICSpec_NetworkModes_name, SmartNICSpec_NetworkModes_value)
	proto.RegisterEnum("cluster.SmartNICStatus_Phase", SmartNICStatus_Phase_name, SmartNICStatus_Phase_value)
}
func (m *BiosInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BiosInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vendor) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Vendor)))
		i += copy(dAtA[i:], m.Vendor)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.FwMajorVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.FwMajorVersion)))
		i += copy(dAtA[i:], m.FwMajorVersion)
	}
	if len(m.FwMinorVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.FwMinorVersion)))
		i += copy(dAtA[i:], m.FwMinorVersion)
	}
	return i, nil
}

func (m *IPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IPAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.IPAddress)))
		i += copy(dAtA[i:], m.IPAddress)
	}
	if len(m.DefaultGW) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.DefaultGW)))
		i += copy(dAtA[i:], m.DefaultGW)
	}
	if len(m.DNSServers) > 0 {
		for _, s := range m.DNSServers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MacRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MacRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	return i, nil
}

func (m *SmartNIC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNIC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintSmartnic(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *SmartNICCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.LastTransitionTime) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.LastTransitionTime)))
		i += copy(dAtA[i:], m.LastTransitionTime)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SmartNICInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BiosInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.BiosInfo.Size()))
		n5, err := m.BiosInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.OsInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.OsInfo.Size()))
		n6, err := m.OsInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.CpuInfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.CpuInfo.Size()))
		n7, err := m.CpuInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.MemoryInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.MemoryInfo.Size()))
		n8, err := m.MemoryInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.StorageInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.StorageInfo.Size()))
		n9, err := m.StorageInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *SmartNICSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Admit {
		dAtA[i] = 0x8
		i++
		if m.Admit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.IPConfig.Size()))
		n10, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.MgmtMode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.MgmtMode)))
		i += copy(dAtA[i:], m.MgmtMode)
	}
	if len(m.NetworkMode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.NetworkMode)))
		i += copy(dAtA[i:], m.NetworkMode)
	}
	if m.MgmtVlan != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *SmartNICStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartNICStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AdmissionPhase) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.AdmissionPhase)))
		i += copy(dAtA[i:], m.AdmissionPhase)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSmartnic(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SerialNum) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.SerialNum)))
		i += copy(dAtA[i:], m.SerialNum)
	}
	if len(m.PrimaryMAC) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(len(m.PrimaryMAC)))
		i += copy(dAtA[i:], m.PrimaryMAC)
	}
	if m.IPConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.IPConfig.Size()))
		n11, err := m.IPConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.SystemInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSmartnic(dAtA, i, uint64(m.SystemInfo.Size()))
		n12, err := m.SystemInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.Interfaces) > 0 {
		for _, s := range m.Interfaces {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintSmartnic(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *BiosInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.FwMajorVersion)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.FwMinorVersion)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *IPConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.IPAddress)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.DefaultGW)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if len(m.DNSServers) > 0 {
		for _, s := range m.DNSServers {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	return n
}

func (m *MacRange) Size() (n int) {
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *SmartNIC) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSmartnic(uint64(l))
	return n
}

func (m *SmartNICCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.LastTransitionTime)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *SmartNICInfo) Size() (n int) {
	var l int
	_ = l
	if m.BiosInfo != nil {
		l = m.BiosInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.OsInfo != nil {
		l = m.OsInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.CpuInfo != nil {
		l = m.CpuInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.MemoryInfo != nil {
		l = m.MemoryInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.StorageInfo != nil {
		l = m.StorageInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	return n
}

func (m *SmartNICSpec) Size() (n int) {
	var l int
	_ = l
	if m.Admit {
		n += 2
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.MgmtMode)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.NetworkMode)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.MgmtVlan != 0 {
		n += 1 + sovSmartnic(uint64(m.MgmtVlan))
	}
	if len(m.Controllers) > 0 {
		for _, s := range m.Controllers {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	return n
}

func (m *SmartNICStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.AdmissionPhase)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	l = len(m.SerialNum)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	l = len(m.PrimaryMAC)
	if l > 0 {
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.IPConfig != nil {
		l = m.IPConfig.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if m.SystemInfo != nil {
		l = m.SystemInfo.Size()
		n += 1 + l + sovSmartnic(uint64(l))
	}
	if len(m.Interfaces) > 0 {
		for _, s := range m.Interfaces {
			l = len(s)
			n += 1 + l + sovSmartnic(uint64(l))
		}
	}
	return n
}

func sovSmartnic(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSmartnic(x uint64) (n int) {
	return sovSmartnic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BiosInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BiosInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BiosInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwMajorVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwMajorVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwMinorVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwMinorVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IPAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGW", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGW = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DNSServers = append(m.DNSServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MacRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MacRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MacRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNIC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNIC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNIC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTransitionTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiosInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BiosInfo == nil {
				m.BiosInfo = &BiosInfo{}
			}
			if err := m.BiosInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OsInfo == nil {
				m.OsInfo = &OsInfo{}
			}
			if err := m.OsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CpuInfo == nil {
				m.CpuInfo = &CPUInfo{}
			}
			if err := m.CpuInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemoryInfo == nil {
				m.MemoryInfo = &MemInfo{}
			}
			if err := m.MemoryInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageInfo == nil {
				m.StorageInfo = &StorageInfo{}
			}
			if err := m.StorageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admit = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MgmtMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MgmtVlan", wireType)
			}
			m.MgmtVlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MgmtVlan |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controllers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Controllers = append(m.Controllers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartNICStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartNICStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartNICStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionPhase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmissionPhase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, SmartNICCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryMAC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryMAC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IPConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IPConfig == nil {
				m.IPConfig = &IPConfig{}
			}
			if err := m.IPConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SystemInfo == nil {
				m.SystemInfo = &SmartNICInfo{}
			}
			if err := m.SystemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interfaces", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSmartnic
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interfaces = append(m.Interfaces, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSmartnic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSmartnic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSmartnic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSmartnic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSmartnic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSmartnic
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSmartnic
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSmartnic(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSmartnic = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSmartnic   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("smartnic.proto", fileDescriptorSmartnic) }

var fileDescriptorSmartnic = []byte{
	// 1420 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x97, 0x4d, 0x6f, 0xdb, 0xb6,
	0x1f, 0xc7, 0xa3, 0x38, 0x4e, 0x1c, 0x3a, 0x0f, 0x0e, 0x9b, 0xa6, 0x76, 0xd0, 0x7f, 0x5c, 0xe8,
	0xbf, 0x01, 0x2e, 0x56, 0xd9, 0x45, 0xba, 0x15, 0x68, 0x31, 0x0c, 0xb3, 0x1c, 0xb7, 0x71, 0x5b,
	0xcb, 0x99, 0xed, 0xa6, 0x18, 0xf6, 0x00, 0x30, 0x32, 0xe3, 0xaa, 0xb3, 0x48, 0x4d, 0xa4, 0x13,
	0xe4, 0x05, 0x2c, 0x87, 0xdd, 0x07, 0xec, 0x35, 0xe4, 0x38, 0xec, 0xba, 0xf3, 0x7a, 0x2c, 0x76,
	0xd8, 0xd1, 0x18, 0x7a, 0xf4, 0xab, 0x18, 0x48, 0x49, 0x36, 0x6d, 0x29, 0xd8, 0x0e, 0xbb, 0x99,
	0x1f, 0xfe, 0xf8, 0x15, 0x7f, 0xe4, 0xef, 0x81, 0x06, 0x1b, 0xcc, 0x45, 0x3e, 0x27, 0x8e, 0x5d,
	0xf6, 0x7c, 0xca, 0x29, 0x5c, 0xb1, 0x07, 0x43, 0xc6, 0xb1, 0xbf, 0x7b, 0xbb, 0x4f, 0x69, 0x7f,
	0x80, 0x2b, 0xc8, 0x73, 0x2a, 0x88, 0x10, 0xca, 0x11, 0x77, 0x28, 0x61, 0x81, 0xd9, 0x6e, 0xbd,
	0xef, 0xf0, 0xd7, 0xc3, 0x93, 0xb2, 0x4d, 0xdd, 0x8a, 0x87, 0x09, 0x43, 0xa4, 0x47, 0x2b, 0xec,
	0xbc, 0x72, 0x86, 0x89, 0x63, 0xe3, 0xca, 0x90, 0x3b, 0x03, 0x26, 0x96, 0xf6, 0x31, 0x51, 0x57,
	0x57, 0x1c, 0x62, 0x0f, 0x86, 0x3d, 0x1c, 0xc9, 0x18, 0x8a, 0x4c, 0x9f, 0xf6, 0x69, 0x45, 0xe2,
	0x93, 0xe1, 0xa9, 0x1c, 0xc9, 0x81, 0xfc, 0x15, 0x9a, 0x7f, 0x78, 0xcd, 0x57, 0xc5, 0x1e, 0x5d,
	0xcc, 0x51, 0x68, 0xb6, 0x1e, 0xfa, 0x10, 0x0e, 0x77, 0x08, 0xe6, 0xe7, 0xd4, 0xff, 0xce, 0x21,
	0x1c, 0xfb, 0xa7, 0xc8, 0xc6, 0x01, 0xd7, 0x7f, 0x5a, 0x04, 0x19, 0xd3, 0xa1, 0xac, 0x41, 0x4e,
	0x29, 0x7c, 0x08, 0x96, 0x8f, 0x31, 0xe9, 0x51, 0x3f, 0xaf, 0xdd, 0xd1, 0x4a, 0xab, 0xe6, 0xf6,
	0x78, 0x54, 0xcc, 0x9d, 0x49, 0x72, 0x8f, 0xba, 0x0e, 0xc7, 0xae, 0xc7, 0x2f, 0xda, 0x31, 0x02,
	0x1f, 0x81, 0x95, 0x63, 0xec, 0x33, 0x87, 0x92, 0xfc, 0xa2, 0x5c, 0x78, 0x73, 0x3c, 0x2a, 0x6e,
	0x9d, 0x05, 0x48, 0x59, 0x19, 0x47, 0xf0, 0x19, 0xd8, 0x78, 0x72, 0xde, 0x44, 0x6f, 0xa8, 0x1f,
	0x29, 0xa4, 0xa4, 0xc2, 0xee, 0x78, 0x54, 0xdc, 0x39, 0x3d, 0x37, 0x5c, 0x31, 0x65, 0x9c, 0x61,
	0x75, 0x03, 0xd7, 0xf0, 0x50, 0xcb, 0x21, 0x53, 0xad, 0xa5, 0x59, 0x2d, 0x31, 0x95, 0xa4, 0x15,
	0xe7, 0xfa, 0x9f, 0x1a, 0xc8, 0x34, 0x8e, 0x6a, 0x94, 0x9c, 0x3a, 0x7d, 0x58, 0x05, 0xab, 0x8d,
	0xa3, 0x6a, 0xaf, 0xe7, 0x63, 0xc6, 0xc2, 0xa3, 0xc9, 0x8f, 0x47, 0xc5, 0x6d, 0xc7, 0x33, 0x50,
	0x40, 0x15, 0xc5, 0x44, 0x2a, 0x24, 0x0e, 0xf0, 0x29, 0x1a, 0x0e, 0xf8, 0xd3, 0x57, 0xe1, 0x21,
	0x49, 0x89, 0x5e, 0x00, 0x8d, 0xfe, 0xb9, 0x2a, 0x91, 0x44, 0xe1, 0x01, 0x00, 0x07, 0x56, 0xa7,
	0x83, 0x7d, 0x71, 0x8a, 0xf9, 0xd4, 0x9d, 0x54, 0x69, 0xd5, 0x2c, 0x8c, 0x47, 0xc5, 0x9b, 0x3d,
	0xc2, 0x0c, 0x16, 0x60, 0x45, 0x24, 0x19, 0xeb, 0x3f, 0x6b, 0x20, 0xd3, 0x44, 0x76, 0x1b, 0x91,
	0x3e, 0x86, 0x87, 0x20, 0xdd, 0xe1, 0xc8, 0xe7, 0xa1, 0x53, 0x1f, 0x5c, 0x5d, 0x16, 0x56, 0x9b,
	0xc8, 0x16, 0xae, 0x96, 0xee, 0x8e, 0x47, 0xc5, 0x1b, 0x2e, 0xb2, 0x0d, 0x26, 0x2c, 0x14, 0xe1,
	0x24, 0x08, 0x4d, 0x90, 0xaa, 0x93, 0x5e, 0xe8, 0x99, 0x3e, 0xaf, 0xb3, 0x25, 0x96, 0x60, 0xd2,
	0x53, 0x63, 0x21, 0x86, 0xf4, 0xdf, 0x16, 0x41, 0xa6, 0x23, 0x32, 0xd1, 0x6a, 0xd4, 0xe0, 0x43,
	0xa0, 0x75, 0xe5, 0xb6, 0xb2, 0xfb, 0xeb, 0x65, 0xe4, 0x39, 0xe5, 0xee, 0x85, 0x87, 0x9b, 0x98,
	0x23, 0xf3, 0xc6, 0xdb, 0x51, 0x71, 0xe1, 0xdd, 0xa8, 0xa8, 0x8d, 0x47, 0xc5, 0x95, 0x7b, 0x0e,
	0x19, 0x38, 0x04, 0xb7, 0xa3, 0x1f, 0xf0, 0x09, 0xd0, 0x5a, 0x72, 0x1b, 0xd9, 0xfd, 0x4d, 0xb9,
	0xae, 0x75, 0xf2, 0x06, 0xdb, 0x5c, 0xae, 0xdc, 0x55, 0x56, 0x6e, 0x88, 0x5c, 0x51, 0xf6, 0x33,
	0x37, 0x86, 0xcf, 0xc1, 0x52, 0xc7, 0xc3, 0xb6, 0x0c, 0xc7, 0xec, 0xfe, 0xcd, 0x72, 0x94, 0x4e,
	0xd1, 0x06, 0xc5, 0xa4, 0xb9, 0x23, 0x04, 0x85, 0x18, 0xf3, 0xb0, 0xad, 0x8a, 0xcd, 0x8e, 0x61,
	0x07, 0x2c, 0x77, 0x38, 0xe2, 0x43, 0x26, 0x23, 0x32, 0xbb, 0x7f, 0x2b, 0x2e, 0x27, 0xa7, 0xcd,
	0x7c, 0x28, 0x98, 0x63, 0x72, 0xac, 0x66, 0xdd, 0x3c, 0x79, 0xbc, 0xf9, 0xc7, 0x0f, 0x85, 0x2c,
	0x5c, 0x8d, 0x6a, 0x17, 0xd3, 0x7f, 0x4f, 0x81, 0xad, 0x48, 0xaf, 0x46, 0x49, 0xcf, 0x11, 0xe5,
	0x06, 0x7e, 0x0d, 0x96, 0xc4, 0xd1, 0x85, 0x57, 0xfc, 0xd9, 0xd5, 0x65, 0xa1, 0xd4, 0xe1, 0x7e,
	0x9d, 0x0c, 0xdd, 0x52, 0xcc, 0xb8, 0x3c, 0xf9, 0x25, 0x96, 0x88, 0x9b, 0xdb, 0xe0, 0x17, 0x1e,
	0x56, 0x3d, 0x9b, 0x1d, 0xc3, 0xf6, 0xc4, 0xb3, 0xe0, 0xea, 0xef, 0x5f, 0x5d, 0x16, 0xf2, 0x91,
	0xfe, 0x44, 0x2d, 0x30, 0xb9, 0xfb, 0xef, 0x1c, 0x83, 0xdf, 0x02, 0xf8, 0x02, 0x31, 0xde, 0xf5,
	0x11, 0x61, 0xc1, 0x66, 0x1c, 0x17, 0x87, 0x75, 0x41, 0x1f, 0x8f, 0x8a, 0x7b, 0x03, 0xc4, 0xb8,
	0xc1, 0x27, 0xd3, 0x06, 0x77, 0x5c, 0x75, 0x8f, 0xff, 0x30, 0x2f, 0xca, 0x5c, 0x1b, 0x23, 0x36,
	0xa9, 0x0f, 0xb2, 0xcc, 0xf9, 0x92, 0xa8, 0xfb, 0x9a, 0x27, 0xa2, 0xcc, 0x35, 0x31, 0x63, 0xa8,
	0x8f, 0xf3, 0xe9, 0x69, 0x99, 0x73, 0x03, 0x34, 0x13, 0xda, 0xf3, 0x48, 0x37, 0xc0, 0xfa, 0xcc,
	0xd1, 0xc2, 0x2c, 0x58, 0x39, 0xac, 0x57, 0x5f, 0x74, 0x0f, 0xbf, 0xcc, 0x2d, 0xc0, 0x4d, 0x90,
	0x7d, 0x69, 0xb5, 0xeb, 0xd5, 0xda, 0x61, 0xd5, 0x7c, 0x51, 0xcf, 0x69, 0xfa, 0x2f, 0x29, 0xb0,
	0x16, 0x5d, 0x8e, 0xac, 0xcc, 0x5f, 0x4c, 0xab, 0x74, 0x98, 0x14, 0x5b, 0x93, 0x10, 0x8a, 0x26,
	0xcc, 0x5b, 0x22, 0x63, 0x4f, 0x1c, 0xca, 0x0c, 0x87, 0x9c, 0x52, 0x35, 0x63, 0x13, 0x20, 0x6c,
	0x80, 0xe5, 0x56, 0x20, 0x18, 0x65, 0x4b, 0x24, 0x18, 0xe0, 0xc0, 0xbb, 0xb8, 0x58, 0x1c, 0xc1,
	0x26, 0x58, 0xa9, 0x79, 0x43, 0xa9, 0x15, 0xa4, 0x4b, 0x6e, 0xa2, 0x55, 0x3b, 0x7a, 0x29, 0xc5,
	0x76, 0xc6, 0xa3, 0x22, 0xb4, 0xbd, 0xe1, 0xbc, 0x5a, 0x02, 0x83, 0xc7, 0x00, 0x34, 0xb1, 0x4b,
	0xfd, 0x0b, 0xa9, 0xb8, 0x34, 0xa7, 0xd8, 0xc4, 0xae, 0x54, 0x94, 0xa5, 0xcf, 0x95, 0x76, 0xf3,
	0xa2, 0xc9, 0x18, 0x7e, 0x03, 0xb2, 0x1d, 0x4e, 0x7d, 0xd4, 0xc7, 0x52, 0x38, 0x2d, 0x85, 0xb7,
	0xa7, 0xa9, 0x38, 0x9d, 0x0b, 0x5a, 0x06, 0x0b, 0xc0, 0xbc, 0xfa, 0x35, 0x5c, 0xff, 0x31, 0x3d,
	0xbd, 0x34, 0x51, 0x1d, 0xe0, 0x03, 0x90, 0xae, 0xf6, 0x5c, 0x27, 0xa8, 0xae, 0x19, 0xf3, 0xc6,
	0x78, 0x54, 0xdc, 0x44, 0x02, 0x28, 0x62, 0xf3, 0x00, 0x7e, 0x0a, 0x32, 0x87, 0x94, 0x71, 0x82,
	0x5c, 0x1c, 0xa6, 0x94, 0x3c, 0xba, 0xd7, 0x21, 0x53, 0x8f, 0x2e, 0xce, 0x44, 0x9c, 0x44, 0x5d,
	0x2b, 0xbc, 0x8a, 0x69, 0x9c, 0x44, 0x13, 0x41, 0x9c, 0x38, 0x9e, 0x61, 0xcb, 0xa1, 0x1a, 0x27,
	0x09, 0x10, 0x22, 0x90, 0x69, 0xf6, 0x5d, 0xde, 0xa4, 0x3d, 0x1c, 0xe6, 0xcb, 0xe3, 0xab, 0xcb,
	0x42, 0x71, 0xbe, 0x86, 0x08, 0x8f, 0xcb, 0x91, 0x21, 0x0b, 0x9a, 0x47, 0xdf, 0xe5, 0x86, 0x4b,
	0x7b, 0x78, 0xa6, 0x79, 0xc4, 0x21, 0x74, 0x41, 0xd6, 0x0a, 0x9e, 0x27, 0xf2, 0x2b, 0x41, 0x72,
	0x7d, 0x7e, 0x75, 0x59, 0xd0, 0x13, 0xbf, 0xa2, 0xd8, 0xca, 0x0f, 0x45, 0x6f, 0x9b, 0xf9, 0x6f,
	0x5d, 0xc3, 0x61, 0x3b, 0xf0, 0xe8, 0x78, 0x80, 0x48, 0x7e, 0xf9, 0x8e, 0x56, 0x5a, 0x37, 0x3f,
	0xba, 0xba, 0x2c, 0xe4, 0x1a, 0x84, 0xcb, 0xae, 0x58, 0xba, 0x7f, 0xef, 0xe3, 0xfb, 0x8f, 0x3e,
	0x99, 0xba, 0x70, 0x36, 0x40, 0x24, 0xe6, 0xc2, 0x2c, 0x84, 0x75, 0x90, 0xad, 0x51, 0xc2, 0x7d,
	0x3a, 0x18, 0x88, 0xee, 0xbc, 0x32, 0xed, 0xce, 0xf6, 0x14, 0xab, 0x21, 0x9a, 0x88, 0x75, 0x1d,
	0xac, 0x4e, 0xce, 0x10, 0x66, 0xc0, 0xd2, 0x61, 0xab, 0xd3, 0xcd, 0x2d, 0x88, 0x6a, 0x61, 0xd5,
	0xbb, 0xaf, 0x5a, 0xed, 0xe7, 0x39, 0x4d, 0xff, 0x3f, 0x58, 0x53, 0x4f, 0x00, 0xae, 0x80, 0x54,
	0xab, 0x65, 0xe6, 0x16, 0x20, 0x00, 0xcb, 0x0d, 0xcb, 0xac, 0x5a, 0x07, 0x39, 0x4d, 0xff, 0x35,
	0x0d, 0x36, 0x66, 0x7b, 0x0b, 0xfc, 0x1e, 0x6c, 0x88, 0x70, 0x64, 0xe2, 0x65, 0x74, 0xf4, 0x1a,
	0x31, 0xb5, 0x25, 0xfc, 0x2f, 0x76, 0xd0, 0x72, 0x4d, 0x59, 0xda, 0x89, 0x93, 0x28, 0xa0, 0x68,
	0xa9, 0xe1, 0x09, 0xa6, 0xb8, 0x72, 0xfd, 0x14, 0x3c, 0x01, 0x60, 0x52, 0xf6, 0x44, 0x87, 0x48,
	0x95, 0xb2, 0xfb, 0xbb, 0xb1, 0xde, 0x37, 0x31, 0x31, 0x6f, 0x87, 0xed, 0x6f, 0xdb, 0x9e, 0xac,
	0x52, 0x9f, 0x45, 0x49, 0x54, 0xbc, 0xac, 0x3a, 0xd8, 0x77, 0xd0, 0xc0, 0x1a, 0xba, 0x61, 0x93,
	0x90, 0x2f, 0x2b, 0x26, 0xa1, 0x41, 0x86, 0xae, 0x2a, 0x91, 0x44, 0xc5, 0xcb, 0xea, 0xc8, 0x77,
	0x5c, 0xe4, 0x5f, 0x34, 0xab, 0xb5, 0x30, 0xc8, 0xe5, 0xdd, 0x79, 0x01, 0x35, 0x5c, 0xa4, 0x76,
	0xf7, 0x64, 0x3c, 0x93, 0x7b, 0xe9, 0xff, 0x26, 0xf7, 0xbe, 0x02, 0xa0, 0x73, 0xc1, 0x78, 0x50,
	0xf1, 0x64, 0xac, 0x26, 0x3d, 0x45, 0xa6, 0xe5, 0x90, 0x49, 0xe3, 0x58, 0x39, 0x4c, 0xc4, 0xd0,
	0x04, 0xa0, 0x11, 0xfd, 0x1b, 0x88, 0x22, 0x36, 0x78, 0xd6, 0x4e, 0xe8, 0xcc, 0xb3, 0x36, 0x81,
	0xea, 0x16, 0x48, 0xcb, 0x10, 0x11, 0x11, 0xfa, 0xd2, 0x7a, 0x6e, 0xb5, 0x5e, 0x59, 0x41, 0x3f,
	0x6b, 0xd7, 0x9f, 0x36, 0x3a, 0xdd, 0x7a, 0xbb, 0x61, 0x3d, 0xcd, 0x69, 0x70, 0x0d, 0x64, 0xda,
	0xf5, 0x67, 0xf5, 0x5a, 0xb7, 0x7e, 0x90, 0x5b, 0x14, 0xb6, 0x47, 0x75, 0xeb, 0x40, 0x4c, 0xa5,
	0xc4, 0x54, 0xf5, 0xa0, 0xd9, 0xe8, 0x8a, 0xa9, 0x25, 0x73, 0xed, 0xed, 0xfb, 0x3d, 0xed, 0xdd,
	0xfb, 0x3d, 0xed, 0xaf, 0xf7, 0x7b, 0xda, 0x91, 0x76, 0xb2, 0x2c, 0xff, 0xa5, 0x3c, 0xf8, 0x3b,
	0x00, 0x00, 0xff, 0xff, 0xb6, 0x8d, 0x29, 0x7a, 0xa2, 0x0d, 0x00, 0x00,
}
