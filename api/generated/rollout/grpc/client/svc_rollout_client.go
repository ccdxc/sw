// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	rollout "github.com/pensando/sw/api/generated/rollout"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewRolloutV1 sets up a new client for RolloutV1
func NewRolloutV1(conn *grpc.ClientConn, logger log.Logger) rollout.ServiceRolloutV1Client {

	var lAutoAddRolloutEndpoint endpoint.Endpoint
	{
		lAutoAddRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoAddRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddRolloutEndpoint = trace.ClientEndPoint("RolloutV1:AutoAddRollout")(lAutoAddRolloutEndpoint)
	}
	var lAutoAddRolloutActionEndpoint endpoint.Endpoint
	{
		lAutoAddRolloutActionEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoAddRolloutAction",
			rollout.EncodeGrpcReqRolloutAction,
			rollout.DecodeGrpcRespRolloutAction,
			&rollout.RolloutAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddRolloutActionEndpoint = trace.ClientEndPoint("RolloutV1:AutoAddRolloutAction")(lAutoAddRolloutActionEndpoint)
	}
	var lAutoDeleteRolloutEndpoint endpoint.Endpoint
	{
		lAutoDeleteRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoDeleteRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteRolloutEndpoint = trace.ClientEndPoint("RolloutV1:AutoDeleteRollout")(lAutoDeleteRolloutEndpoint)
	}
	var lAutoDeleteRolloutActionEndpoint endpoint.Endpoint
	{
		lAutoDeleteRolloutActionEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoDeleteRolloutAction",
			rollout.EncodeGrpcReqRolloutAction,
			rollout.DecodeGrpcRespRolloutAction,
			&rollout.RolloutAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteRolloutActionEndpoint = trace.ClientEndPoint("RolloutV1:AutoDeleteRolloutAction")(lAutoDeleteRolloutActionEndpoint)
	}
	var lAutoGetRolloutEndpoint endpoint.Endpoint
	{
		lAutoGetRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoGetRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetRolloutEndpoint = trace.ClientEndPoint("RolloutV1:AutoGetRollout")(lAutoGetRolloutEndpoint)
	}
	var lAutoGetRolloutActionEndpoint endpoint.Endpoint
	{
		lAutoGetRolloutActionEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoGetRolloutAction",
			rollout.EncodeGrpcReqRolloutAction,
			rollout.DecodeGrpcRespRolloutAction,
			&rollout.RolloutAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetRolloutActionEndpoint = trace.ClientEndPoint("RolloutV1:AutoGetRolloutAction")(lAutoGetRolloutActionEndpoint)
	}
	var lAutoLabelRolloutEndpoint endpoint.Endpoint
	{
		lAutoLabelRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoLabelRollout",
			rollout.EncodeGrpcReqLabel,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelRolloutEndpoint = trace.ClientEndPoint("RolloutV1:AutoLabelRollout")(lAutoLabelRolloutEndpoint)
	}
	var lAutoLabelRolloutActionEndpoint endpoint.Endpoint
	{
		lAutoLabelRolloutActionEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoLabelRolloutAction",
			rollout.EncodeGrpcReqLabel,
			rollout.DecodeGrpcRespRolloutAction,
			&rollout.RolloutAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelRolloutActionEndpoint = trace.ClientEndPoint("RolloutV1:AutoLabelRolloutAction")(lAutoLabelRolloutActionEndpoint)
	}
	var lAutoListRolloutEndpoint endpoint.Endpoint
	{
		lAutoListRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoListRollout",
			rollout.EncodeGrpcReqListWatchOptions,
			rollout.DecodeGrpcRespRolloutList,
			&rollout.RolloutList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListRolloutEndpoint = trace.ClientEndPoint("RolloutV1:AutoListRollout")(lAutoListRolloutEndpoint)
	}
	var lAutoListRolloutActionEndpoint endpoint.Endpoint
	{
		lAutoListRolloutActionEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoListRolloutAction",
			rollout.EncodeGrpcReqListWatchOptions,
			rollout.DecodeGrpcRespRolloutActionList,
			&rollout.RolloutActionList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListRolloutActionEndpoint = trace.ClientEndPoint("RolloutV1:AutoListRolloutAction")(lAutoListRolloutActionEndpoint)
	}
	var lAutoUpdateRolloutEndpoint endpoint.Endpoint
	{
		lAutoUpdateRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoUpdateRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateRolloutEndpoint = trace.ClientEndPoint("RolloutV1:AutoUpdateRollout")(lAutoUpdateRolloutEndpoint)
	}
	var lAutoUpdateRolloutActionEndpoint endpoint.Endpoint
	{
		lAutoUpdateRolloutActionEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"AutoUpdateRolloutAction",
			rollout.EncodeGrpcReqRolloutAction,
			rollout.DecodeGrpcRespRolloutAction,
			&rollout.RolloutAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateRolloutActionEndpoint = trace.ClientEndPoint("RolloutV1:AutoUpdateRolloutAction")(lAutoUpdateRolloutActionEndpoint)
	}
	var lCreateRolloutEndpoint endpoint.Endpoint
	{
		lCreateRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"CreateRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lCreateRolloutEndpoint = trace.ClientEndPoint("RolloutV1:CreateRollout")(lCreateRolloutEndpoint)
	}
	var lRemoveRolloutEndpoint endpoint.Endpoint
	{
		lRemoveRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"RemoveRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lRemoveRolloutEndpoint = trace.ClientEndPoint("RolloutV1:RemoveRollout")(lRemoveRolloutEndpoint)
	}
	var lStopRolloutEndpoint endpoint.Endpoint
	{
		lStopRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"StopRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lStopRolloutEndpoint = trace.ClientEndPoint("RolloutV1:StopRollout")(lStopRolloutEndpoint)
	}
	var lUpdateRolloutEndpoint endpoint.Endpoint
	{
		lUpdateRolloutEndpoint = grpctransport.NewClient(
			conn,
			"rollout.RolloutV1",
			"UpdateRollout",
			rollout.EncodeGrpcReqRollout,
			rollout.DecodeGrpcRespRollout,
			&rollout.Rollout{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lUpdateRolloutEndpoint = trace.ClientEndPoint("RolloutV1:UpdateRollout")(lUpdateRolloutEndpoint)
	}
	return rollout.EndpointsRolloutV1Client{
		Client: rollout.NewRolloutV1Client(conn),

		AutoAddRolloutEndpoint:          lAutoAddRolloutEndpoint,
		AutoAddRolloutActionEndpoint:    lAutoAddRolloutActionEndpoint,
		AutoDeleteRolloutEndpoint:       lAutoDeleteRolloutEndpoint,
		AutoDeleteRolloutActionEndpoint: lAutoDeleteRolloutActionEndpoint,
		AutoGetRolloutEndpoint:          lAutoGetRolloutEndpoint,
		AutoGetRolloutActionEndpoint:    lAutoGetRolloutActionEndpoint,
		AutoLabelRolloutEndpoint:        lAutoLabelRolloutEndpoint,
		AutoLabelRolloutActionEndpoint:  lAutoLabelRolloutActionEndpoint,
		AutoListRolloutEndpoint:         lAutoListRolloutEndpoint,
		AutoListRolloutActionEndpoint:   lAutoListRolloutActionEndpoint,
		AutoUpdateRolloutEndpoint:       lAutoUpdateRolloutEndpoint,
		AutoUpdateRolloutActionEndpoint: lAutoUpdateRolloutActionEndpoint,
		CreateRolloutEndpoint:           lCreateRolloutEndpoint,
		RemoveRolloutEndpoint:           lRemoveRolloutEndpoint,
		StopRolloutEndpoint:             lStopRolloutEndpoint,
		UpdateRolloutEndpoint:           lUpdateRolloutEndpoint,
	}
}

// NewRolloutV1Backend creates an instrumented client with middleware
func NewRolloutV1Backend(conn *grpc.ClientConn, logger log.Logger) rollout.ServiceRolloutV1Client {
	cl := NewRolloutV1(conn, logger)
	cl = rollout.LoggingRolloutV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjRolloutV1Rollout struct {
	logger log.Logger
	client rollout.ServiceRolloutV1Client
}

func (a *grpcObjRolloutV1Rollout) Create(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) Update(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) UpdateStatus(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) Label(ctx context.Context, in *api.Label) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) Get(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.Rollout{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetRollout(nctx, &in)
}

func (a *grpcObjRolloutV1Rollout) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.Rollout{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteRollout(nctx, &in)
}

func (a *grpcObjRolloutV1Rollout) List(ctx context.Context, options *api.ListWatchOptions) ([]*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListRollout(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjRolloutV1Rollout) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Rollout", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchRollout(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(rollout.RolloutV1_AutoWatchRolloutClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjRolloutV1Rollout) CreateRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "{CreateRollout Rollout Rollout}", "oper", "CreateRollout")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.CreateRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) UpdateRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "{UpdateRollout Rollout Rollout}", "oper", "UpdateRollout")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.UpdateRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) StopRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "{StopRollout Rollout Rollout}", "oper", "StopRollout")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.StopRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) RemoveRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	a.logger.DebugLog("msg", "received call", "object", "{RemoveRollout Rollout Rollout}", "oper", "RemoveRollout")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.RemoveRollout(nctx, in)
}

func (a *grpcObjRolloutV1Rollout) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjRolloutV1Rollout struct {
	endpoints rollout.EndpointsRolloutV1RestClient
	instance  string
}

func (a *restObjRolloutV1Rollout) Create(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddRollout(ctx, in)
}

func (a *restObjRolloutV1Rollout) Update(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateRollout(ctx, in)
}

func (a *restObjRolloutV1Rollout) UpdateStatus(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjRolloutV1Rollout) Label(ctx context.Context, in *api.Label) (*rollout.Rollout, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelRollout(ctx, in)
}

func (a *restObjRolloutV1Rollout) Get(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.Rollout, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.Rollout{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetRollout(ctx, &in)
}

func (a *restObjRolloutV1Rollout) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.Rollout, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.Rollout{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteRollout(ctx, &in)
}

func (a *restObjRolloutV1Rollout) List(ctx context.Context, options *api.ListWatchOptions) ([]*rollout.Rollout, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListRollout(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjRolloutV1Rollout) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchRollout(ctx, options)
}

func (a *restObjRolloutV1Rollout) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

func (a *restObjRolloutV1Rollout) CreateRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.CreateRolloutRollout(ctx, in)
}
func (a *restObjRolloutV1Rollout) UpdateRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.UpdateRolloutRollout(ctx, in)
}
func (a *restObjRolloutV1Rollout) StopRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.StopRolloutRollout(ctx, in)
}
func (a *restObjRolloutV1Rollout) RemoveRollout(ctx context.Context, in *rollout.Rollout) (*rollout.Rollout, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.RemoveRolloutRollout(ctx, in)
}

type grpcObjRolloutV1RolloutAction struct {
	logger log.Logger
	client rollout.ServiceRolloutV1Client
}

func (a *grpcObjRolloutV1RolloutAction) Create(ctx context.Context, in *rollout.RolloutAction) (*rollout.RolloutAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddRolloutAction(nctx, in)
}

func (a *grpcObjRolloutV1RolloutAction) Update(ctx context.Context, in *rollout.RolloutAction) (*rollout.RolloutAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateRolloutAction(nctx, in)
}

func (a *grpcObjRolloutV1RolloutAction) UpdateStatus(ctx context.Context, in *rollout.RolloutAction) (*rollout.RolloutAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateRolloutAction(nctx, in)
}

func (a *grpcObjRolloutV1RolloutAction) Label(ctx context.Context, in *api.Label) (*rollout.RolloutAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelRolloutAction(nctx, in)
}

func (a *grpcObjRolloutV1RolloutAction) Get(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.RolloutAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.RolloutAction{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetRolloutAction(nctx, &in)
}

func (a *grpcObjRolloutV1RolloutAction) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.RolloutAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.RolloutAction{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteRolloutAction(nctx, &in)
}

func (a *grpcObjRolloutV1RolloutAction) List(ctx context.Context, options *api.ListWatchOptions) ([]*rollout.RolloutAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListRolloutAction(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjRolloutV1RolloutAction) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutAction", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchRolloutAction(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(rollout.RolloutV1_AutoWatchRolloutActionClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjRolloutV1RolloutAction) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjRolloutV1RolloutAction struct {
	endpoints rollout.EndpointsRolloutV1RestClient
	instance  string
}

func (a *restObjRolloutV1RolloutAction) Create(ctx context.Context, in *rollout.RolloutAction) (*rollout.RolloutAction, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddRolloutAction(ctx, in)
}

func (a *restObjRolloutV1RolloutAction) Update(ctx context.Context, in *rollout.RolloutAction) (*rollout.RolloutAction, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateRolloutAction(ctx, in)
}

func (a *restObjRolloutV1RolloutAction) UpdateStatus(ctx context.Context, in *rollout.RolloutAction) (*rollout.RolloutAction, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjRolloutV1RolloutAction) Label(ctx context.Context, in *api.Label) (*rollout.RolloutAction, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelRolloutAction(ctx, in)
}

func (a *restObjRolloutV1RolloutAction) Get(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.RolloutAction, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.RolloutAction{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetRolloutAction(ctx, &in)
}

func (a *restObjRolloutV1RolloutAction) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*rollout.RolloutAction, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := rollout.RolloutAction{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteRolloutAction(ctx, &in)
}

func (a *restObjRolloutV1RolloutAction) List(ctx context.Context, options *api.ListWatchOptions) ([]*rollout.RolloutAction, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListRolloutAction(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjRolloutV1RolloutAction) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchRolloutAction(ctx, options)
}

func (a *restObjRolloutV1RolloutAction) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return false
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientRolloutV1 struct {
	logger log.Logger
	client rollout.ServiceRolloutV1Client

	grpcRollout       rollout.RolloutV1RolloutInterface
	grpcRolloutAction rollout.RolloutV1RolloutActionInterface
}

// NewGrpcCrudClientRolloutV1 creates a GRPC client for the service
func NewGrpcCrudClientRolloutV1(conn *grpc.ClientConn, logger log.Logger) rollout.RolloutV1Interface {
	client := NewRolloutV1Backend(conn, logger)
	return &crudClientRolloutV1{
		logger: logger,
		client: client,

		grpcRollout:       &grpcObjRolloutV1Rollout{client: client, logger: logger},
		grpcRolloutAction: &grpcObjRolloutV1RolloutAction{client: client, logger: logger},
	}
}

func (a *crudClientRolloutV1) Rollout() rollout.RolloutV1RolloutInterface {
	return a.grpcRollout
}

func (a *crudClientRolloutV1) RolloutAction() rollout.RolloutV1RolloutActionInterface {
	return a.grpcRolloutAction
}

func (a *crudClientRolloutV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "RolloutV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcRolloutV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(rollout.RolloutV1_AutoWatchSvcRolloutV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientRolloutV1 struct {
	restRollout       rollout.RolloutV1RolloutInterface
	restRolloutAction rollout.RolloutV1RolloutActionInterface
}

// NewRestCrudClientRolloutV1 creates a REST client for the service.
func NewRestCrudClientRolloutV1(url string, httpClient *http.Client) rollout.RolloutV1Interface {
	endpoints, err := rollout.MakeRolloutV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientRolloutV1{

		restRollout:       &restObjRolloutV1Rollout{endpoints: endpoints, instance: url},
		restRolloutAction: &restObjRolloutV1RolloutAction{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientRolloutV1 creates a REST client for the service.
func NewStagedRestCrudClientRolloutV1(url string, id string, httpClient *http.Client) rollout.RolloutV1Interface {
	endpoints, err := rollout.MakeRolloutV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientRolloutV1{

		restRollout:       &restObjRolloutV1Rollout{endpoints: endpoints, instance: url},
		restRolloutAction: &restObjRolloutV1RolloutAction{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientRolloutV1) Rollout() rollout.RolloutV1RolloutInterface {
	return a.restRollout
}

func (a *crudRestClientRolloutV1) RolloutAction() rollout.RolloutV1RolloutActionInterface {
	return a.restRolloutAction
}

func (a *crudRestClientRolloutV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
