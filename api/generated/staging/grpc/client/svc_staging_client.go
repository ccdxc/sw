// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	staging "github.com/pensando/sw/api/generated/staging"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewStagingV1 sets up a new client for StagingV1
func NewStagingV1(conn *grpc.ClientConn, logger log.Logger) staging.ServiceStagingV1Client {

	var lAutoAddBufferEndpoint endpoint.Endpoint
	{
		lAutoAddBufferEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"AutoAddBuffer",
			staging.EncodeGrpcReqBuffer,
			staging.DecodeGrpcRespBuffer,
			&staging.Buffer{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddBufferEndpoint = trace.ClientEndPoint("StagingV1:AutoAddBuffer")(lAutoAddBufferEndpoint)
	}
	var lAutoDeleteBufferEndpoint endpoint.Endpoint
	{
		lAutoDeleteBufferEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"AutoDeleteBuffer",
			staging.EncodeGrpcReqBuffer,
			staging.DecodeGrpcRespBuffer,
			&staging.Buffer{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteBufferEndpoint = trace.ClientEndPoint("StagingV1:AutoDeleteBuffer")(lAutoDeleteBufferEndpoint)
	}
	var lAutoGetBufferEndpoint endpoint.Endpoint
	{
		lAutoGetBufferEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"AutoGetBuffer",
			staging.EncodeGrpcReqBuffer,
			staging.DecodeGrpcRespBuffer,
			&staging.Buffer{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetBufferEndpoint = trace.ClientEndPoint("StagingV1:AutoGetBuffer")(lAutoGetBufferEndpoint)
	}
	var lAutoLabelBufferEndpoint endpoint.Endpoint
	{
		lAutoLabelBufferEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"AutoLabelBuffer",
			staging.EncodeGrpcReqLabel,
			staging.DecodeGrpcRespBuffer,
			&staging.Buffer{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelBufferEndpoint = trace.ClientEndPoint("StagingV1:AutoLabelBuffer")(lAutoLabelBufferEndpoint)
	}
	var lAutoListBufferEndpoint endpoint.Endpoint
	{
		lAutoListBufferEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"AutoListBuffer",
			staging.EncodeGrpcReqListWatchOptions,
			staging.DecodeGrpcRespBufferList,
			&staging.BufferList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListBufferEndpoint = trace.ClientEndPoint("StagingV1:AutoListBuffer")(lAutoListBufferEndpoint)
	}
	var lAutoUpdateBufferEndpoint endpoint.Endpoint
	{
		lAutoUpdateBufferEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"AutoUpdateBuffer",
			staging.EncodeGrpcReqBuffer,
			staging.DecodeGrpcRespBuffer,
			&staging.Buffer{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateBufferEndpoint = trace.ClientEndPoint("StagingV1:AutoUpdateBuffer")(lAutoUpdateBufferEndpoint)
	}
	var lBulkeditEndpoint endpoint.Endpoint
	{
		lBulkeditEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"Bulkedit",
			staging.EncodeGrpcReqBulkEditAction,
			staging.DecodeGrpcRespBulkEditAction,
			&staging.BulkEditAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lBulkeditEndpoint = trace.ClientEndPoint("StagingV1:Bulkedit")(lBulkeditEndpoint)
	}
	var lClearEndpoint endpoint.Endpoint
	{
		lClearEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"Clear",
			staging.EncodeGrpcReqClearAction,
			staging.DecodeGrpcRespClearAction,
			&staging.ClearAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lClearEndpoint = trace.ClientEndPoint("StagingV1:Clear")(lClearEndpoint)
	}
	var lCommitEndpoint endpoint.Endpoint
	{
		lCommitEndpoint = grpctransport.NewClient(
			conn,
			"staging.StagingV1",
			"Commit",
			staging.EncodeGrpcReqCommitAction,
			staging.DecodeGrpcRespCommitAction,
			&staging.CommitAction{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lCommitEndpoint = trace.ClientEndPoint("StagingV1:Commit")(lCommitEndpoint)
	}
	return staging.EndpointsStagingV1Client{
		Client: staging.NewStagingV1Client(conn),

		AutoAddBufferEndpoint:    lAutoAddBufferEndpoint,
		AutoDeleteBufferEndpoint: lAutoDeleteBufferEndpoint,
		AutoGetBufferEndpoint:    lAutoGetBufferEndpoint,
		AutoLabelBufferEndpoint:  lAutoLabelBufferEndpoint,
		AutoListBufferEndpoint:   lAutoListBufferEndpoint,
		AutoUpdateBufferEndpoint: lAutoUpdateBufferEndpoint,
		BulkeditEndpoint:         lBulkeditEndpoint,
		ClearEndpoint:            lClearEndpoint,
		CommitEndpoint:           lCommitEndpoint,
	}
}

// NewStagingV1Backend creates an instrumented client with middleware
func NewStagingV1Backend(conn *grpc.ClientConn, logger log.Logger) staging.ServiceStagingV1Client {
	cl := NewStagingV1(conn, logger)
	cl = staging.LoggingStagingV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjStagingV1Buffer struct {
	logger log.Logger
	client staging.ServiceStagingV1Client
}

func (a *grpcObjStagingV1Buffer) Create(ctx context.Context, in *staging.Buffer) (*staging.Buffer, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddBuffer(nctx, in)
}

func (a *grpcObjStagingV1Buffer) Update(ctx context.Context, in *staging.Buffer) (*staging.Buffer, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateBuffer(nctx, in)
}

func (a *grpcObjStagingV1Buffer) UpdateStatus(ctx context.Context, in *staging.Buffer) (*staging.Buffer, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateBuffer(nctx, in)
}

func (a *grpcObjStagingV1Buffer) Label(ctx context.Context, in *api.Label) (*staging.Buffer, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelBuffer(nctx, in)
}

func (a *grpcObjStagingV1Buffer) Get(ctx context.Context, objMeta *api.ObjectMeta) (*staging.Buffer, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := staging.Buffer{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetBuffer(nctx, &in)
}

func (a *grpcObjStagingV1Buffer) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*staging.Buffer, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := staging.Buffer{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteBuffer(nctx, &in)
}

func (a *grpcObjStagingV1Buffer) List(ctx context.Context, options *api.ListWatchOptions) ([]*staging.Buffer, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListBuffer(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjStagingV1Buffer) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Buffer", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchBuffer(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(staging.StagingV1_AutoWatchBufferClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjStagingV1Buffer) Commit(ctx context.Context, in *staging.CommitAction) (*staging.CommitAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "{Commit CommitAction CommitAction}", "oper", "Commit")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.Commit(nctx, in)
}

func (a *grpcObjStagingV1Buffer) Clear(ctx context.Context, in *staging.ClearAction) (*staging.ClearAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "{Clear ClearAction ClearAction}", "oper", "Clear")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.Clear(nctx, in)
}

func (a *grpcObjStagingV1Buffer) Bulkedit(ctx context.Context, in *staging.BulkEditAction) (*staging.BulkEditAction, error) {
	a.logger.DebugLog("msg", "received call", "object", "{Bulkedit BulkEditAction BulkEditAction}", "oper", "Bulkedit")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.Bulkedit(nctx, in)
}

func (a *grpcObjStagingV1Buffer) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjStagingV1Buffer struct {
	endpoints staging.EndpointsStagingV1RestClient
	instance  string
}

func (a *restObjStagingV1Buffer) Create(ctx context.Context, in *staging.Buffer) (*staging.Buffer, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddBuffer(ctx, in)
}

func (a *restObjStagingV1Buffer) Update(ctx context.Context, in *staging.Buffer) (*staging.Buffer, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateBuffer(ctx, in)
}

func (a *restObjStagingV1Buffer) UpdateStatus(ctx context.Context, in *staging.Buffer) (*staging.Buffer, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjStagingV1Buffer) Label(ctx context.Context, in *api.Label) (*staging.Buffer, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelBuffer(ctx, in)
}

func (a *restObjStagingV1Buffer) Get(ctx context.Context, objMeta *api.ObjectMeta) (*staging.Buffer, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := staging.Buffer{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetBuffer(ctx, &in)
}

func (a *restObjStagingV1Buffer) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*staging.Buffer, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := staging.Buffer{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteBuffer(ctx, &in)
}

func (a *restObjStagingV1Buffer) List(ctx context.Context, options *api.ListWatchOptions) ([]*staging.Buffer, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListBuffer(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjStagingV1Buffer) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchBuffer(ctx, options)
}

func (a *restObjStagingV1Buffer) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

func (a *restObjStagingV1Buffer) Commit(ctx context.Context, in *staging.CommitAction) (*staging.CommitAction, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.CommitBuffer(ctx, in)
}
func (a *restObjStagingV1Buffer) Clear(ctx context.Context, in *staging.ClearAction) (*staging.ClearAction, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.ClearBuffer(ctx, in)
}
func (a *restObjStagingV1Buffer) Bulkedit(ctx context.Context, in *staging.BulkEditAction) (*staging.BulkEditAction, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.BulkeditBuffer(ctx, in)
}

type crudClientStagingV1 struct {
	logger log.Logger
	client staging.ServiceStagingV1Client

	grpcBuffer staging.StagingV1BufferInterface
}

// NewGrpcCrudClientStagingV1 creates a GRPC client for the service
func NewGrpcCrudClientStagingV1(conn *grpc.ClientConn, logger log.Logger) staging.StagingV1Interface {
	client := NewStagingV1Backend(conn, logger)
	return &crudClientStagingV1{
		logger: logger,
		client: client,

		grpcBuffer: &grpcObjStagingV1Buffer{client: client, logger: logger},
	}
}

func (a *crudClientStagingV1) Buffer() staging.StagingV1BufferInterface {
	return a.grpcBuffer
}

func (a *crudClientStagingV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "StagingV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcStagingV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(staging.StagingV1_AutoWatchSvcStagingV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientStagingV1 struct {
	restBuffer staging.StagingV1BufferInterface
}

// NewRestCrudClientStagingV1 creates a REST client for the service.
func NewRestCrudClientStagingV1(url string, httpClient *http.Client) staging.StagingV1Interface {
	endpoints, err := staging.MakeStagingV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientStagingV1{

		restBuffer: &restObjStagingV1Buffer{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientStagingV1 creates a REST client for the service.
func NewStagedRestCrudClientStagingV1(url string, id string, httpClient *http.Client) staging.StagingV1Interface {
	endpoints, err := staging.MakeStagingV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientStagingV1{

		restBuffer: &restObjStagingV1Buffer{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientStagingV1) Buffer() staging.StagingV1BufferInterface {
	return a.restBuffer
}

func (a *crudRestClientStagingV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
