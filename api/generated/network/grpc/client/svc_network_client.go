// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	network "github.com/pensando/sw/api/generated/network"
	"github.com/pensando/sw/api/interfaces"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewNetworkV1 sets up a new client for NetworkV1
func NewNetworkV1(conn *grpc.ClientConn, logger log.Logger) network.ServiceNetworkV1Client {

	var lAutoAddIPAMPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddIPAMPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddIPAMPolicy",
			network.EncodeGrpcReqIPAMPolicy,
			network.DecodeGrpcRespIPAMPolicy,
			&network.IPAMPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddIPAMPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddIPAMPolicy")(lAutoAddIPAMPolicyEndpoint)
	}
	var lAutoAddLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddLbPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddLbPolicy")(lAutoAddLbPolicyEndpoint)
	}
	var lAutoAddNetworkEndpoint endpoint.Endpoint
	{
		lAutoAddNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNetworkEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddNetwork")(lAutoAddNetworkEndpoint)
	}
	var lAutoAddNetworkInterfaceEndpoint endpoint.Endpoint
	{
		lAutoAddNetworkInterfaceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddNetworkInterface",
			network.EncodeGrpcReqNetworkInterface,
			network.DecodeGrpcRespNetworkInterface,
			&network.NetworkInterface{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddNetworkInterfaceEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddNetworkInterface")(lAutoAddNetworkInterfaceEndpoint)
	}
	var lAutoAddRouteTableEndpoint endpoint.Endpoint
	{
		lAutoAddRouteTableEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddRouteTable",
			network.EncodeGrpcReqRouteTable,
			network.DecodeGrpcRespRouteTable,
			&network.RouteTable{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddRouteTableEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddRouteTable")(lAutoAddRouteTableEndpoint)
	}
	var lAutoAddRoutingConfigEndpoint endpoint.Endpoint
	{
		lAutoAddRoutingConfigEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddRoutingConfig",
			network.EncodeGrpcReqRoutingConfig,
			network.DecodeGrpcRespRoutingConfig,
			&network.RoutingConfig{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddRoutingConfigEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddRoutingConfig")(lAutoAddRoutingConfigEndpoint)
	}
	var lAutoAddServiceEndpoint endpoint.Endpoint
	{
		lAutoAddServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddServiceEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddService")(lAutoAddServiceEndpoint)
	}
	var lAutoAddVirtualRouterEndpoint endpoint.Endpoint
	{
		lAutoAddVirtualRouterEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoAddVirtualRouter",
			network.EncodeGrpcReqVirtualRouter,
			network.DecodeGrpcRespVirtualRouter,
			&network.VirtualRouter{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddVirtualRouterEndpoint = trace.ClientEndPoint("NetworkV1:AutoAddVirtualRouter")(lAutoAddVirtualRouterEndpoint)
	}
	var lAutoDeleteIPAMPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteIPAMPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteIPAMPolicy",
			network.EncodeGrpcReqIPAMPolicy,
			network.DecodeGrpcRespIPAMPolicy,
			&network.IPAMPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteIPAMPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteIPAMPolicy")(lAutoDeleteIPAMPolicyEndpoint)
	}
	var lAutoDeleteLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteLbPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteLbPolicy")(lAutoDeleteLbPolicyEndpoint)
	}
	var lAutoDeleteNetworkEndpoint endpoint.Endpoint
	{
		lAutoDeleteNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNetworkEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteNetwork")(lAutoDeleteNetworkEndpoint)
	}
	var lAutoDeleteNetworkInterfaceEndpoint endpoint.Endpoint
	{
		lAutoDeleteNetworkInterfaceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteNetworkInterface",
			network.EncodeGrpcReqNetworkInterface,
			network.DecodeGrpcRespNetworkInterface,
			&network.NetworkInterface{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteNetworkInterfaceEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteNetworkInterface")(lAutoDeleteNetworkInterfaceEndpoint)
	}
	var lAutoDeleteRouteTableEndpoint endpoint.Endpoint
	{
		lAutoDeleteRouteTableEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteRouteTable",
			network.EncodeGrpcReqRouteTable,
			network.DecodeGrpcRespRouteTable,
			&network.RouteTable{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteRouteTableEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteRouteTable")(lAutoDeleteRouteTableEndpoint)
	}
	var lAutoDeleteRoutingConfigEndpoint endpoint.Endpoint
	{
		lAutoDeleteRoutingConfigEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteRoutingConfig",
			network.EncodeGrpcReqRoutingConfig,
			network.DecodeGrpcRespRoutingConfig,
			&network.RoutingConfig{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteRoutingConfigEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteRoutingConfig")(lAutoDeleteRoutingConfigEndpoint)
	}
	var lAutoDeleteServiceEndpoint endpoint.Endpoint
	{
		lAutoDeleteServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteServiceEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteService")(lAutoDeleteServiceEndpoint)
	}
	var lAutoDeleteVirtualRouterEndpoint endpoint.Endpoint
	{
		lAutoDeleteVirtualRouterEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoDeleteVirtualRouter",
			network.EncodeGrpcReqVirtualRouter,
			network.DecodeGrpcRespVirtualRouter,
			&network.VirtualRouter{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteVirtualRouterEndpoint = trace.ClientEndPoint("NetworkV1:AutoDeleteVirtualRouter")(lAutoDeleteVirtualRouterEndpoint)
	}
	var lAutoGetIPAMPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetIPAMPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetIPAMPolicy",
			network.EncodeGrpcReqIPAMPolicy,
			network.DecodeGrpcRespIPAMPolicy,
			&network.IPAMPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetIPAMPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetIPAMPolicy")(lAutoGetIPAMPolicyEndpoint)
	}
	var lAutoGetLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetLbPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetLbPolicy")(lAutoGetLbPolicyEndpoint)
	}
	var lAutoGetNetworkEndpoint endpoint.Endpoint
	{
		lAutoGetNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNetworkEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetNetwork")(lAutoGetNetworkEndpoint)
	}
	var lAutoGetNetworkInterfaceEndpoint endpoint.Endpoint
	{
		lAutoGetNetworkInterfaceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetNetworkInterface",
			network.EncodeGrpcReqNetworkInterface,
			network.DecodeGrpcRespNetworkInterface,
			&network.NetworkInterface{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetNetworkInterfaceEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetNetworkInterface")(lAutoGetNetworkInterfaceEndpoint)
	}
	var lAutoGetRouteTableEndpoint endpoint.Endpoint
	{
		lAutoGetRouteTableEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetRouteTable",
			network.EncodeGrpcReqRouteTable,
			network.DecodeGrpcRespRouteTable,
			&network.RouteTable{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetRouteTableEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetRouteTable")(lAutoGetRouteTableEndpoint)
	}
	var lAutoGetRoutingConfigEndpoint endpoint.Endpoint
	{
		lAutoGetRoutingConfigEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetRoutingConfig",
			network.EncodeGrpcReqRoutingConfig,
			network.DecodeGrpcRespRoutingConfig,
			&network.RoutingConfig{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetRoutingConfigEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetRoutingConfig")(lAutoGetRoutingConfigEndpoint)
	}
	var lAutoGetServiceEndpoint endpoint.Endpoint
	{
		lAutoGetServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetServiceEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetService")(lAutoGetServiceEndpoint)
	}
	var lAutoGetVirtualRouterEndpoint endpoint.Endpoint
	{
		lAutoGetVirtualRouterEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoGetVirtualRouter",
			network.EncodeGrpcReqVirtualRouter,
			network.DecodeGrpcRespVirtualRouter,
			&network.VirtualRouter{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetVirtualRouterEndpoint = trace.ClientEndPoint("NetworkV1:AutoGetVirtualRouter")(lAutoGetVirtualRouterEndpoint)
	}
	var lAutoLabelIPAMPolicyEndpoint endpoint.Endpoint
	{
		lAutoLabelIPAMPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelIPAMPolicy",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespIPAMPolicy,
			&network.IPAMPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelIPAMPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelIPAMPolicy")(lAutoLabelIPAMPolicyEndpoint)
	}
	var lAutoLabelLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoLabelLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelLbPolicy",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelLbPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelLbPolicy")(lAutoLabelLbPolicyEndpoint)
	}
	var lAutoLabelNetworkEndpoint endpoint.Endpoint
	{
		lAutoLabelNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelNetwork",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelNetworkEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelNetwork")(lAutoLabelNetworkEndpoint)
	}
	var lAutoLabelNetworkInterfaceEndpoint endpoint.Endpoint
	{
		lAutoLabelNetworkInterfaceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelNetworkInterface",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespNetworkInterface,
			&network.NetworkInterface{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelNetworkInterfaceEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelNetworkInterface")(lAutoLabelNetworkInterfaceEndpoint)
	}
	var lAutoLabelRouteTableEndpoint endpoint.Endpoint
	{
		lAutoLabelRouteTableEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelRouteTable",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespRouteTable,
			&network.RouteTable{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelRouteTableEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelRouteTable")(lAutoLabelRouteTableEndpoint)
	}
	var lAutoLabelRoutingConfigEndpoint endpoint.Endpoint
	{
		lAutoLabelRoutingConfigEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelRoutingConfig",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespRoutingConfig,
			&network.RoutingConfig{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelRoutingConfigEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelRoutingConfig")(lAutoLabelRoutingConfigEndpoint)
	}
	var lAutoLabelServiceEndpoint endpoint.Endpoint
	{
		lAutoLabelServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelService",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelServiceEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelService")(lAutoLabelServiceEndpoint)
	}
	var lAutoLabelVirtualRouterEndpoint endpoint.Endpoint
	{
		lAutoLabelVirtualRouterEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoLabelVirtualRouter",
			network.EncodeGrpcReqLabel,
			network.DecodeGrpcRespVirtualRouter,
			&network.VirtualRouter{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoLabelVirtualRouterEndpoint = trace.ClientEndPoint("NetworkV1:AutoLabelVirtualRouter")(lAutoLabelVirtualRouterEndpoint)
	}
	var lAutoListIPAMPolicyEndpoint endpoint.Endpoint
	{
		lAutoListIPAMPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListIPAMPolicy",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespIPAMPolicyList,
			&network.IPAMPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListIPAMPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoListIPAMPolicy")(lAutoListIPAMPolicyEndpoint)
	}
	var lAutoListLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoListLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListLbPolicy",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespLbPolicyList,
			&network.LbPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListLbPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoListLbPolicy")(lAutoListLbPolicyEndpoint)
	}
	var lAutoListNetworkEndpoint endpoint.Endpoint
	{
		lAutoListNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListNetwork",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespNetworkList,
			&network.NetworkList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNetworkEndpoint = trace.ClientEndPoint("NetworkV1:AutoListNetwork")(lAutoListNetworkEndpoint)
	}
	var lAutoListNetworkInterfaceEndpoint endpoint.Endpoint
	{
		lAutoListNetworkInterfaceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListNetworkInterface",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespNetworkInterfaceList,
			&network.NetworkInterfaceList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListNetworkInterfaceEndpoint = trace.ClientEndPoint("NetworkV1:AutoListNetworkInterface")(lAutoListNetworkInterfaceEndpoint)
	}
	var lAutoListRouteTableEndpoint endpoint.Endpoint
	{
		lAutoListRouteTableEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListRouteTable",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespRouteTableList,
			&network.RouteTableList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListRouteTableEndpoint = trace.ClientEndPoint("NetworkV1:AutoListRouteTable")(lAutoListRouteTableEndpoint)
	}
	var lAutoListRoutingConfigEndpoint endpoint.Endpoint
	{
		lAutoListRoutingConfigEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListRoutingConfig",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespRoutingConfigList,
			&network.RoutingConfigList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListRoutingConfigEndpoint = trace.ClientEndPoint("NetworkV1:AutoListRoutingConfig")(lAutoListRoutingConfigEndpoint)
	}
	var lAutoListServiceEndpoint endpoint.Endpoint
	{
		lAutoListServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListService",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespServiceList,
			&network.ServiceList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListServiceEndpoint = trace.ClientEndPoint("NetworkV1:AutoListService")(lAutoListServiceEndpoint)
	}
	var lAutoListVirtualRouterEndpoint endpoint.Endpoint
	{
		lAutoListVirtualRouterEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoListVirtualRouter",
			network.EncodeGrpcReqListWatchOptions,
			network.DecodeGrpcRespVirtualRouterList,
			&network.VirtualRouterList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListVirtualRouterEndpoint = trace.ClientEndPoint("NetworkV1:AutoListVirtualRouter")(lAutoListVirtualRouterEndpoint)
	}
	var lAutoUpdateIPAMPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateIPAMPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateIPAMPolicy",
			network.EncodeGrpcReqIPAMPolicy,
			network.DecodeGrpcRespIPAMPolicy,
			&network.IPAMPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateIPAMPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateIPAMPolicy")(lAutoUpdateIPAMPolicyEndpoint)
	}
	var lAutoUpdateLbPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateLbPolicyEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateLbPolicy",
			network.EncodeGrpcReqLbPolicy,
			network.DecodeGrpcRespLbPolicy,
			&network.LbPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateLbPolicyEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateLbPolicy")(lAutoUpdateLbPolicyEndpoint)
	}
	var lAutoUpdateNetworkEndpoint endpoint.Endpoint
	{
		lAutoUpdateNetworkEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateNetwork",
			network.EncodeGrpcReqNetwork,
			network.DecodeGrpcRespNetwork,
			&network.Network{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNetworkEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateNetwork")(lAutoUpdateNetworkEndpoint)
	}
	var lAutoUpdateNetworkInterfaceEndpoint endpoint.Endpoint
	{
		lAutoUpdateNetworkInterfaceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateNetworkInterface",
			network.EncodeGrpcReqNetworkInterface,
			network.DecodeGrpcRespNetworkInterface,
			&network.NetworkInterface{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateNetworkInterfaceEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateNetworkInterface")(lAutoUpdateNetworkInterfaceEndpoint)
	}
	var lAutoUpdateRouteTableEndpoint endpoint.Endpoint
	{
		lAutoUpdateRouteTableEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateRouteTable",
			network.EncodeGrpcReqRouteTable,
			network.DecodeGrpcRespRouteTable,
			&network.RouteTable{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateRouteTableEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateRouteTable")(lAutoUpdateRouteTableEndpoint)
	}
	var lAutoUpdateRoutingConfigEndpoint endpoint.Endpoint
	{
		lAutoUpdateRoutingConfigEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateRoutingConfig",
			network.EncodeGrpcReqRoutingConfig,
			network.DecodeGrpcRespRoutingConfig,
			&network.RoutingConfig{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateRoutingConfigEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateRoutingConfig")(lAutoUpdateRoutingConfigEndpoint)
	}
	var lAutoUpdateServiceEndpoint endpoint.Endpoint
	{
		lAutoUpdateServiceEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateService",
			network.EncodeGrpcReqService,
			network.DecodeGrpcRespService,
			&network.Service{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateServiceEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateService")(lAutoUpdateServiceEndpoint)
	}
	var lAutoUpdateVirtualRouterEndpoint endpoint.Endpoint
	{
		lAutoUpdateVirtualRouterEndpoint = grpctransport.NewClient(
			conn,
			"network.NetworkV1",
			"AutoUpdateVirtualRouter",
			network.EncodeGrpcReqVirtualRouter,
			network.DecodeGrpcRespVirtualRouter,
			&network.VirtualRouter{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateVirtualRouterEndpoint = trace.ClientEndPoint("NetworkV1:AutoUpdateVirtualRouter")(lAutoUpdateVirtualRouterEndpoint)
	}
	return network.EndpointsNetworkV1Client{
		Client: network.NewNetworkV1Client(conn),

		AutoAddIPAMPolicyEndpoint:          lAutoAddIPAMPolicyEndpoint,
		AutoAddLbPolicyEndpoint:            lAutoAddLbPolicyEndpoint,
		AutoAddNetworkEndpoint:             lAutoAddNetworkEndpoint,
		AutoAddNetworkInterfaceEndpoint:    lAutoAddNetworkInterfaceEndpoint,
		AutoAddRouteTableEndpoint:          lAutoAddRouteTableEndpoint,
		AutoAddRoutingConfigEndpoint:       lAutoAddRoutingConfigEndpoint,
		AutoAddServiceEndpoint:             lAutoAddServiceEndpoint,
		AutoAddVirtualRouterEndpoint:       lAutoAddVirtualRouterEndpoint,
		AutoDeleteIPAMPolicyEndpoint:       lAutoDeleteIPAMPolicyEndpoint,
		AutoDeleteLbPolicyEndpoint:         lAutoDeleteLbPolicyEndpoint,
		AutoDeleteNetworkEndpoint:          lAutoDeleteNetworkEndpoint,
		AutoDeleteNetworkInterfaceEndpoint: lAutoDeleteNetworkInterfaceEndpoint,
		AutoDeleteRouteTableEndpoint:       lAutoDeleteRouteTableEndpoint,
		AutoDeleteRoutingConfigEndpoint:    lAutoDeleteRoutingConfigEndpoint,
		AutoDeleteServiceEndpoint:          lAutoDeleteServiceEndpoint,
		AutoDeleteVirtualRouterEndpoint:    lAutoDeleteVirtualRouterEndpoint,
		AutoGetIPAMPolicyEndpoint:          lAutoGetIPAMPolicyEndpoint,
		AutoGetLbPolicyEndpoint:            lAutoGetLbPolicyEndpoint,
		AutoGetNetworkEndpoint:             lAutoGetNetworkEndpoint,
		AutoGetNetworkInterfaceEndpoint:    lAutoGetNetworkInterfaceEndpoint,
		AutoGetRouteTableEndpoint:          lAutoGetRouteTableEndpoint,
		AutoGetRoutingConfigEndpoint:       lAutoGetRoutingConfigEndpoint,
		AutoGetServiceEndpoint:             lAutoGetServiceEndpoint,
		AutoGetVirtualRouterEndpoint:       lAutoGetVirtualRouterEndpoint,
		AutoLabelIPAMPolicyEndpoint:        lAutoLabelIPAMPolicyEndpoint,
		AutoLabelLbPolicyEndpoint:          lAutoLabelLbPolicyEndpoint,
		AutoLabelNetworkEndpoint:           lAutoLabelNetworkEndpoint,
		AutoLabelNetworkInterfaceEndpoint:  lAutoLabelNetworkInterfaceEndpoint,
		AutoLabelRouteTableEndpoint:        lAutoLabelRouteTableEndpoint,
		AutoLabelRoutingConfigEndpoint:     lAutoLabelRoutingConfigEndpoint,
		AutoLabelServiceEndpoint:           lAutoLabelServiceEndpoint,
		AutoLabelVirtualRouterEndpoint:     lAutoLabelVirtualRouterEndpoint,
		AutoListIPAMPolicyEndpoint:         lAutoListIPAMPolicyEndpoint,
		AutoListLbPolicyEndpoint:           lAutoListLbPolicyEndpoint,
		AutoListNetworkEndpoint:            lAutoListNetworkEndpoint,
		AutoListNetworkInterfaceEndpoint:   lAutoListNetworkInterfaceEndpoint,
		AutoListRouteTableEndpoint:         lAutoListRouteTableEndpoint,
		AutoListRoutingConfigEndpoint:      lAutoListRoutingConfigEndpoint,
		AutoListServiceEndpoint:            lAutoListServiceEndpoint,
		AutoListVirtualRouterEndpoint:      lAutoListVirtualRouterEndpoint,
		AutoUpdateIPAMPolicyEndpoint:       lAutoUpdateIPAMPolicyEndpoint,
		AutoUpdateLbPolicyEndpoint:         lAutoUpdateLbPolicyEndpoint,
		AutoUpdateNetworkEndpoint:          lAutoUpdateNetworkEndpoint,
		AutoUpdateNetworkInterfaceEndpoint: lAutoUpdateNetworkInterfaceEndpoint,
		AutoUpdateRouteTableEndpoint:       lAutoUpdateRouteTableEndpoint,
		AutoUpdateRoutingConfigEndpoint:    lAutoUpdateRoutingConfigEndpoint,
		AutoUpdateServiceEndpoint:          lAutoUpdateServiceEndpoint,
		AutoUpdateVirtualRouterEndpoint:    lAutoUpdateVirtualRouterEndpoint,
	}
}

// NewNetworkV1Backend creates an instrumented client with middleware
func NewNetworkV1Backend(conn *grpc.ClientConn, logger log.Logger) network.ServiceNetworkV1Client {
	cl := NewNetworkV1(conn, logger)
	cl = network.LoggingNetworkV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjNetworkV1Network struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1Network) Create(ctx context.Context, in *network.Network) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNetwork(nctx, in)
}

func (a *grpcObjNetworkV1Network) Update(ctx context.Context, in *network.Network) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNetwork(nctx, in)
}

func (a *grpcObjNetworkV1Network) UpdateStatus(ctx context.Context, in *network.Network) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateNetwork(nctx, in)
}

func (a *grpcObjNetworkV1Network) Label(ctx context.Context, in *api.Label) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelNetwork(nctx, in)
}

func (a *grpcObjNetworkV1Network) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNetwork(nctx, &in)
}

func (a *grpcObjNetworkV1Network) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNetwork(nctx, &in)
}

func (a *grpcObjNetworkV1Network) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Network, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNetwork(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1Network) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Network", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNetwork(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchNetworkClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1Network) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1Network struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1Network) Create(ctx context.Context, in *network.Network) (*network.Network, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNetwork(ctx, in)
}

func (a *restObjNetworkV1Network) Update(ctx context.Context, in *network.Network) (*network.Network, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNetwork(ctx, in)
}

func (a *restObjNetworkV1Network) UpdateStatus(ctx context.Context, in *network.Network) (*network.Network, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1Network) Label(ctx context.Context, in *api.Label) (*network.Network, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelNetwork(ctx, in)
}

func (a *restObjNetworkV1Network) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNetwork(ctx, &in)
}

func (a *restObjNetworkV1Network) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Network, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Network{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNetwork(ctx, &in)
}

func (a *restObjNetworkV1Network) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Network, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListNetwork(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1Network) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchNetwork(ctx, options)
}

func (a *restObjNetworkV1Network) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjNetworkV1Service struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1Service) Create(ctx context.Context, in *network.Service) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddService(nctx, in)
}

func (a *grpcObjNetworkV1Service) Update(ctx context.Context, in *network.Service) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateService(nctx, in)
}

func (a *grpcObjNetworkV1Service) UpdateStatus(ctx context.Context, in *network.Service) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateService(nctx, in)
}

func (a *grpcObjNetworkV1Service) Label(ctx context.Context, in *api.Label) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelService(nctx, in)
}

func (a *grpcObjNetworkV1Service) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetService(nctx, &in)
}

func (a *grpcObjNetworkV1Service) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteService(nctx, &in)
}

func (a *grpcObjNetworkV1Service) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Service, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListService(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1Service) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Service", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchService(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchServiceClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1Service) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1Service struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1Service) Create(ctx context.Context, in *network.Service) (*network.Service, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddService(ctx, in)
}

func (a *restObjNetworkV1Service) Update(ctx context.Context, in *network.Service) (*network.Service, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateService(ctx, in)
}

func (a *restObjNetworkV1Service) UpdateStatus(ctx context.Context, in *network.Service) (*network.Service, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1Service) Label(ctx context.Context, in *api.Label) (*network.Service, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelService(ctx, in)
}

func (a *restObjNetworkV1Service) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetService(ctx, &in)
}

func (a *restObjNetworkV1Service) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.Service, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.Service{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteService(ctx, &in)
}

func (a *restObjNetworkV1Service) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.Service, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListService(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1Service) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchService(ctx, options)
}

func (a *restObjNetworkV1Service) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return false
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjNetworkV1LbPolicy struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1LbPolicy) Create(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddLbPolicy(nctx, in)
}

func (a *grpcObjNetworkV1LbPolicy) Update(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateLbPolicy(nctx, in)
}

func (a *grpcObjNetworkV1LbPolicy) UpdateStatus(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateLbPolicy(nctx, in)
}

func (a *grpcObjNetworkV1LbPolicy) Label(ctx context.Context, in *api.Label) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelLbPolicy(nctx, in)
}

func (a *grpcObjNetworkV1LbPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetLbPolicy(nctx, &in)
}

func (a *grpcObjNetworkV1LbPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteLbPolicy(nctx, &in)
}

func (a *grpcObjNetworkV1LbPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.LbPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListLbPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1LbPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "LbPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchLbPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchLbPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1LbPolicy) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1LbPolicy struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1LbPolicy) Create(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddLbPolicy(ctx, in)
}

func (a *restObjNetworkV1LbPolicy) Update(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateLbPolicy(ctx, in)
}

func (a *restObjNetworkV1LbPolicy) UpdateStatus(ctx context.Context, in *network.LbPolicy) (*network.LbPolicy, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1LbPolicy) Label(ctx context.Context, in *api.Label) (*network.LbPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelLbPolicy(ctx, in)
}

func (a *restObjNetworkV1LbPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetLbPolicy(ctx, &in)
}

func (a *restObjNetworkV1LbPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.LbPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.LbPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteLbPolicy(ctx, &in)
}

func (a *restObjNetworkV1LbPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.LbPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListLbPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1LbPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchLbPolicy(ctx, options)
}

func (a *restObjNetworkV1LbPolicy) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return false
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return false
	case apiintf.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjNetworkV1VirtualRouter struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1VirtualRouter) Create(ctx context.Context, in *network.VirtualRouter) (*network.VirtualRouter, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddVirtualRouter(nctx, in)
}

func (a *grpcObjNetworkV1VirtualRouter) Update(ctx context.Context, in *network.VirtualRouter) (*network.VirtualRouter, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateVirtualRouter(nctx, in)
}

func (a *grpcObjNetworkV1VirtualRouter) UpdateStatus(ctx context.Context, in *network.VirtualRouter) (*network.VirtualRouter, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateVirtualRouter(nctx, in)
}

func (a *grpcObjNetworkV1VirtualRouter) Label(ctx context.Context, in *api.Label) (*network.VirtualRouter, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelVirtualRouter(nctx, in)
}

func (a *grpcObjNetworkV1VirtualRouter) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.VirtualRouter, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.VirtualRouter{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetVirtualRouter(nctx, &in)
}

func (a *grpcObjNetworkV1VirtualRouter) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.VirtualRouter, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.VirtualRouter{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteVirtualRouter(nctx, &in)
}

func (a *grpcObjNetworkV1VirtualRouter) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.VirtualRouter, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListVirtualRouter(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1VirtualRouter) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "VirtualRouter", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchVirtualRouter(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchVirtualRouterClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1VirtualRouter) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1VirtualRouter struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1VirtualRouter) Create(ctx context.Context, in *network.VirtualRouter) (*network.VirtualRouter, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddVirtualRouter(ctx, in)
}

func (a *restObjNetworkV1VirtualRouter) Update(ctx context.Context, in *network.VirtualRouter) (*network.VirtualRouter, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateVirtualRouter(ctx, in)
}

func (a *restObjNetworkV1VirtualRouter) UpdateStatus(ctx context.Context, in *network.VirtualRouter) (*network.VirtualRouter, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1VirtualRouter) Label(ctx context.Context, in *api.Label) (*network.VirtualRouter, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelVirtualRouter(ctx, in)
}

func (a *restObjNetworkV1VirtualRouter) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.VirtualRouter, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.VirtualRouter{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetVirtualRouter(ctx, &in)
}

func (a *restObjNetworkV1VirtualRouter) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.VirtualRouter, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.VirtualRouter{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteVirtualRouter(ctx, &in)
}

func (a *restObjNetworkV1VirtualRouter) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.VirtualRouter, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListVirtualRouter(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1VirtualRouter) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchVirtualRouter(ctx, options)
}

func (a *restObjNetworkV1VirtualRouter) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjNetworkV1NetworkInterface struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1NetworkInterface) Create(ctx context.Context, in *network.NetworkInterface) (*network.NetworkInterface, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddNetworkInterface(nctx, in)
}

func (a *grpcObjNetworkV1NetworkInterface) Update(ctx context.Context, in *network.NetworkInterface) (*network.NetworkInterface, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateNetworkInterface(nctx, in)
}

func (a *grpcObjNetworkV1NetworkInterface) UpdateStatus(ctx context.Context, in *network.NetworkInterface) (*network.NetworkInterface, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateNetworkInterface(nctx, in)
}

func (a *grpcObjNetworkV1NetworkInterface) Label(ctx context.Context, in *api.Label) (*network.NetworkInterface, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelNetworkInterface(nctx, in)
}

func (a *grpcObjNetworkV1NetworkInterface) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.NetworkInterface, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.NetworkInterface{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetNetworkInterface(nctx, &in)
}

func (a *grpcObjNetworkV1NetworkInterface) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.NetworkInterface, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.NetworkInterface{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteNetworkInterface(nctx, &in)
}

func (a *grpcObjNetworkV1NetworkInterface) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.NetworkInterface, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListNetworkInterface(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1NetworkInterface) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkInterface", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchNetworkInterface(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchNetworkInterfaceClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1NetworkInterface) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1NetworkInterface struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1NetworkInterface) Create(ctx context.Context, in *network.NetworkInterface) (*network.NetworkInterface, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddNetworkInterface(ctx, in)
}

func (a *restObjNetworkV1NetworkInterface) Update(ctx context.Context, in *network.NetworkInterface) (*network.NetworkInterface, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateNetworkInterface(ctx, in)
}

func (a *restObjNetworkV1NetworkInterface) UpdateStatus(ctx context.Context, in *network.NetworkInterface) (*network.NetworkInterface, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1NetworkInterface) Label(ctx context.Context, in *api.Label) (*network.NetworkInterface, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelNetworkInterface(ctx, in)
}

func (a *restObjNetworkV1NetworkInterface) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.NetworkInterface, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.NetworkInterface{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetNetworkInterface(ctx, &in)
}

func (a *restObjNetworkV1NetworkInterface) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.NetworkInterface, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.NetworkInterface{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteNetworkInterface(ctx, &in)
}

func (a *restObjNetworkV1NetworkInterface) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.NetworkInterface, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListNetworkInterface(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1NetworkInterface) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchNetworkInterface(ctx, options)
}

func (a *restObjNetworkV1NetworkInterface) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjNetworkV1IPAMPolicy struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1IPAMPolicy) Create(ctx context.Context, in *network.IPAMPolicy) (*network.IPAMPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddIPAMPolicy(nctx, in)
}

func (a *grpcObjNetworkV1IPAMPolicy) Update(ctx context.Context, in *network.IPAMPolicy) (*network.IPAMPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateIPAMPolicy(nctx, in)
}

func (a *grpcObjNetworkV1IPAMPolicy) UpdateStatus(ctx context.Context, in *network.IPAMPolicy) (*network.IPAMPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateIPAMPolicy(nctx, in)
}

func (a *grpcObjNetworkV1IPAMPolicy) Label(ctx context.Context, in *api.Label) (*network.IPAMPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelIPAMPolicy(nctx, in)
}

func (a *grpcObjNetworkV1IPAMPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.IPAMPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.IPAMPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetIPAMPolicy(nctx, &in)
}

func (a *grpcObjNetworkV1IPAMPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.IPAMPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.IPAMPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteIPAMPolicy(nctx, &in)
}

func (a *grpcObjNetworkV1IPAMPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.IPAMPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListIPAMPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1IPAMPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "IPAMPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchIPAMPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchIPAMPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1IPAMPolicy) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1IPAMPolicy struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1IPAMPolicy) Create(ctx context.Context, in *network.IPAMPolicy) (*network.IPAMPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddIPAMPolicy(ctx, in)
}

func (a *restObjNetworkV1IPAMPolicy) Update(ctx context.Context, in *network.IPAMPolicy) (*network.IPAMPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateIPAMPolicy(ctx, in)
}

func (a *restObjNetworkV1IPAMPolicy) UpdateStatus(ctx context.Context, in *network.IPAMPolicy) (*network.IPAMPolicy, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1IPAMPolicy) Label(ctx context.Context, in *api.Label) (*network.IPAMPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelIPAMPolicy(ctx, in)
}

func (a *restObjNetworkV1IPAMPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.IPAMPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.IPAMPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetIPAMPolicy(ctx, &in)
}

func (a *restObjNetworkV1IPAMPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.IPAMPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.IPAMPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteIPAMPolicy(ctx, &in)
}

func (a *restObjNetworkV1IPAMPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.IPAMPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListIPAMPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1IPAMPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchIPAMPolicy(ctx, options)
}

func (a *restObjNetworkV1IPAMPolicy) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjNetworkV1RoutingConfig struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1RoutingConfig) Create(ctx context.Context, in *network.RoutingConfig) (*network.RoutingConfig, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddRoutingConfig(nctx, in)
}

func (a *grpcObjNetworkV1RoutingConfig) Update(ctx context.Context, in *network.RoutingConfig) (*network.RoutingConfig, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateRoutingConfig(nctx, in)
}

func (a *grpcObjNetworkV1RoutingConfig) UpdateStatus(ctx context.Context, in *network.RoutingConfig) (*network.RoutingConfig, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateRoutingConfig(nctx, in)
}

func (a *grpcObjNetworkV1RoutingConfig) Label(ctx context.Context, in *api.Label) (*network.RoutingConfig, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelRoutingConfig(nctx, in)
}

func (a *grpcObjNetworkV1RoutingConfig) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.RoutingConfig, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RoutingConfig{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetRoutingConfig(nctx, &in)
}

func (a *grpcObjNetworkV1RoutingConfig) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.RoutingConfig, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RoutingConfig{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteRoutingConfig(nctx, &in)
}

func (a *grpcObjNetworkV1RoutingConfig) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.RoutingConfig, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListRoutingConfig(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1RoutingConfig) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "RoutingConfig", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchRoutingConfig(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchRoutingConfigClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1RoutingConfig) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1RoutingConfig struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1RoutingConfig) Create(ctx context.Context, in *network.RoutingConfig) (*network.RoutingConfig, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddRoutingConfig(ctx, in)
}

func (a *restObjNetworkV1RoutingConfig) Update(ctx context.Context, in *network.RoutingConfig) (*network.RoutingConfig, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateRoutingConfig(ctx, in)
}

func (a *restObjNetworkV1RoutingConfig) UpdateStatus(ctx context.Context, in *network.RoutingConfig) (*network.RoutingConfig, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1RoutingConfig) Label(ctx context.Context, in *api.Label) (*network.RoutingConfig, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelRoutingConfig(ctx, in)
}

func (a *restObjNetworkV1RoutingConfig) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.RoutingConfig, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RoutingConfig{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetRoutingConfig(ctx, &in)
}

func (a *restObjNetworkV1RoutingConfig) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.RoutingConfig, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RoutingConfig{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteRoutingConfig(ctx, &in)
}

func (a *restObjNetworkV1RoutingConfig) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.RoutingConfig, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	r, err := a.endpoints.AutoListRoutingConfig(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1RoutingConfig) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchRoutingConfig(ctx, options)
}

func (a *restObjNetworkV1RoutingConfig) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return true
	case apiintf.UpdateOper:
		return true
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return true
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjNetworkV1RouteTable struct {
	logger log.Logger
	client network.ServiceNetworkV1Client
}

func (a *grpcObjNetworkV1RouteTable) Create(ctx context.Context, in *network.RouteTable) (*network.RouteTable, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddRouteTable(nctx, in)
}

func (a *grpcObjNetworkV1RouteTable) Update(ctx context.Context, in *network.RouteTable) (*network.RouteTable, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateRouteTable(nctx, in)
}

func (a *grpcObjNetworkV1RouteTable) UpdateStatus(ctx context.Context, in *network.RouteTable) (*network.RouteTable, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	nctx = addStatusUpd(nctx)
	return a.client.AutoUpdateRouteTable(nctx, in)
}

func (a *grpcObjNetworkV1RouteTable) Label(ctx context.Context, in *api.Label) (*network.RouteTable, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "label")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoLabelRouteTable(nctx, in)
}

func (a *grpcObjNetworkV1RouteTable) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.RouteTable, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RouteTable{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetRouteTable(nctx, &in)
}

func (a *grpcObjNetworkV1RouteTable) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.RouteTable, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RouteTable{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteRouteTable(nctx, &in)
}

func (a *grpcObjNetworkV1RouteTable) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.RouteTable, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListRouteTable(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjNetworkV1RouteTable) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "RouteTable", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchRouteTable(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchRouteTableClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjNetworkV1RouteTable) Allowed(oper apiintf.APIOperType) bool {
	return true
}

type restObjNetworkV1RouteTable struct {
	endpoints network.EndpointsNetworkV1RestClient
	instance  string
}

func (a *restObjNetworkV1RouteTable) Create(ctx context.Context, in *network.RouteTable) (*network.RouteTable, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddRouteTable(ctx, in)
}

func (a *restObjNetworkV1RouteTable) Update(ctx context.Context, in *network.RouteTable) (*network.RouteTable, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateRouteTable(ctx, in)
}

func (a *restObjNetworkV1RouteTable) UpdateStatus(ctx context.Context, in *network.RouteTable) (*network.RouteTable, error) {
	return nil, errors.New("not supported for REST")
}

func (a *restObjNetworkV1RouteTable) Label(ctx context.Context, in *api.Label) (*network.RouteTable, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoLabelRouteTable(ctx, in)
}

func (a *restObjNetworkV1RouteTable) Get(ctx context.Context, objMeta *api.ObjectMeta) (*network.RouteTable, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RouteTable{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetRouteTable(ctx, &in)
}

func (a *restObjNetworkV1RouteTable) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*network.RouteTable, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := network.RouteTable{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteRouteTable(ctx, &in)
}

func (a *restObjNetworkV1RouteTable) List(ctx context.Context, options *api.ListWatchOptions) ([]*network.RouteTable, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListRouteTable(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjNetworkV1RouteTable) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchRouteTable(ctx, options)
}

func (a *restObjNetworkV1RouteTable) Allowed(oper apiintf.APIOperType) bool {
	switch oper {
	case apiintf.CreateOper:
		return false
	case apiintf.UpdateOper:
		return false
	case apiintf.GetOper:
		return true
	case apiintf.DeleteOper:
		return false
	case apiintf.ListOper:
		return true
	case apiintf.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientNetworkV1 struct {
	logger log.Logger
	client network.ServiceNetworkV1Client

	grpcNetwork          network.NetworkV1NetworkInterface
	grpcService          network.NetworkV1ServiceInterface
	grpcLbPolicy         network.NetworkV1LbPolicyInterface
	grpcVirtualRouter    network.NetworkV1VirtualRouterInterface
	grpcNetworkInterface network.NetworkV1NetworkInterfaceInterface
	grpcIPAMPolicy       network.NetworkV1IPAMPolicyInterface
	grpcRoutingConfig    network.NetworkV1RoutingConfigInterface
	grpcRouteTable       network.NetworkV1RouteTableInterface
}

// NewGrpcCrudClientNetworkV1 creates a GRPC client for the service
func NewGrpcCrudClientNetworkV1(conn *grpc.ClientConn, logger log.Logger) network.NetworkV1Interface {
	client := NewNetworkV1Backend(conn, logger)
	return &crudClientNetworkV1{
		logger: logger,
		client: client,

		grpcNetwork:          &grpcObjNetworkV1Network{client: client, logger: logger},
		grpcService:          &grpcObjNetworkV1Service{client: client, logger: logger},
		grpcLbPolicy:         &grpcObjNetworkV1LbPolicy{client: client, logger: logger},
		grpcVirtualRouter:    &grpcObjNetworkV1VirtualRouter{client: client, logger: logger},
		grpcNetworkInterface: &grpcObjNetworkV1NetworkInterface{client: client, logger: logger},
		grpcIPAMPolicy:       &grpcObjNetworkV1IPAMPolicy{client: client, logger: logger},
		grpcRoutingConfig:    &grpcObjNetworkV1RoutingConfig{client: client, logger: logger},
		grpcRouteTable:       &grpcObjNetworkV1RouteTable{client: client, logger: logger},
	}
}

func (a *crudClientNetworkV1) Network() network.NetworkV1NetworkInterface {
	return a.grpcNetwork
}

func (a *crudClientNetworkV1) Service() network.NetworkV1ServiceInterface {
	return a.grpcService
}

func (a *crudClientNetworkV1) LbPolicy() network.NetworkV1LbPolicyInterface {
	return a.grpcLbPolicy
}

func (a *crudClientNetworkV1) VirtualRouter() network.NetworkV1VirtualRouterInterface {
	return a.grpcVirtualRouter
}

func (a *crudClientNetworkV1) NetworkInterface() network.NetworkV1NetworkInterfaceInterface {
	return a.grpcNetworkInterface
}

func (a *crudClientNetworkV1) IPAMPolicy() network.NetworkV1IPAMPolicyInterface {
	return a.grpcIPAMPolicy
}

func (a *crudClientNetworkV1) RoutingConfig() network.NetworkV1RoutingConfigInterface {
	return a.grpcRoutingConfig
}

func (a *crudClientNetworkV1) RouteTable() network.NetworkV1RouteTableInterface {
	return a.grpcRouteTable
}

func (a *crudClientNetworkV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "NetworkV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcNetworkV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(network.NetworkV1_AutoWatchSvcNetworkV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "err", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "err", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientNetworkV1 struct {
	restNetwork          network.NetworkV1NetworkInterface
	restService          network.NetworkV1ServiceInterface
	restLbPolicy         network.NetworkV1LbPolicyInterface
	restVirtualRouter    network.NetworkV1VirtualRouterInterface
	restNetworkInterface network.NetworkV1NetworkInterfaceInterface
	restIPAMPolicy       network.NetworkV1IPAMPolicyInterface
	restRoutingConfig    network.NetworkV1RoutingConfigInterface
	restRouteTable       network.NetworkV1RouteTableInterface
}

// NewRestCrudClientNetworkV1 creates a REST client for the service.
func NewRestCrudClientNetworkV1(url string, httpClient *http.Client) network.NetworkV1Interface {
	endpoints, err := network.MakeNetworkV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientNetworkV1{

		restNetwork:          &restObjNetworkV1Network{endpoints: endpoints, instance: url},
		restService:          &restObjNetworkV1Service{endpoints: endpoints, instance: url},
		restLbPolicy:         &restObjNetworkV1LbPolicy{endpoints: endpoints, instance: url},
		restVirtualRouter:    &restObjNetworkV1VirtualRouter{endpoints: endpoints, instance: url},
		restNetworkInterface: &restObjNetworkV1NetworkInterface{endpoints: endpoints, instance: url},
		restIPAMPolicy:       &restObjNetworkV1IPAMPolicy{endpoints: endpoints, instance: url},
		restRoutingConfig:    &restObjNetworkV1RoutingConfig{endpoints: endpoints, instance: url},
		restRouteTable:       &restObjNetworkV1RouteTable{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientNetworkV1 creates a REST client for the service.
func NewStagedRestCrudClientNetworkV1(url string, id string, httpClient *http.Client) network.NetworkV1Interface {
	endpoints, err := network.MakeNetworkV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientNetworkV1{

		restNetwork:          &restObjNetworkV1Network{endpoints: endpoints, instance: url},
		restService:          &restObjNetworkV1Service{endpoints: endpoints, instance: url},
		restLbPolicy:         &restObjNetworkV1LbPolicy{endpoints: endpoints, instance: url},
		restVirtualRouter:    &restObjNetworkV1VirtualRouter{endpoints: endpoints, instance: url},
		restNetworkInterface: &restObjNetworkV1NetworkInterface{endpoints: endpoints, instance: url},
		restIPAMPolicy:       &restObjNetworkV1IPAMPolicy{endpoints: endpoints, instance: url},
		restRoutingConfig:    &restObjNetworkV1RoutingConfig{endpoints: endpoints, instance: url},
		restRouteTable:       &restObjNetworkV1RouteTable{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientNetworkV1) Network() network.NetworkV1NetworkInterface {
	return a.restNetwork
}

func (a *crudRestClientNetworkV1) Service() network.NetworkV1ServiceInterface {
	return a.restService
}

func (a *crudRestClientNetworkV1) LbPolicy() network.NetworkV1LbPolicyInterface {
	return a.restLbPolicy
}

func (a *crudRestClientNetworkV1) VirtualRouter() network.NetworkV1VirtualRouterInterface {
	return a.restVirtualRouter
}

func (a *crudRestClientNetworkV1) NetworkInterface() network.NetworkV1NetworkInterfaceInterface {
	return a.restNetworkInterface
}

func (a *crudRestClientNetworkV1) IPAMPolicy() network.NetworkV1IPAMPolicyInterface {
	return a.restIPAMPolicy
}

func (a *crudRestClientNetworkV1) RoutingConfig() network.NetworkV1RoutingConfigInterface {
	return a.restRoutingConfig
}

func (a *crudRestClientNetworkV1) RouteTable() network.NetworkV1RouteTableInterface {
	return a.restRouteTable
}

func (a *crudRestClientNetworkV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
