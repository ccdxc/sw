// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package authApiServer is a auto generated package.
Input file: svc_auth.proto
*/
package authApiServer

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/pkg/errors"
	"google.golang.org/grpc"

	"github.com/pensando/sw/api"
	auth "github.com/pensando/sw/api/generated/auth"
	fieldhooks "github.com/pensando/sw/api/hooks/apiserver/fields"
	"github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/api/listerwatcher"
	"github.com/pensando/sw/api/utils"
	"github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/apiserver/pkg"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/ctxutils"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
)

// dummy vars to suppress unused errors
var _ api.ObjectMeta
var _ listerwatcher.WatcherClient
var _ fmt.Stringer
var _ fieldhooks.Dummy

type sauthSvc_authBackend struct {
	Services map[string]apiserver.Service
	Messages map[string]apiserver.Message
	logger   log.Logger
	scheme   *runtime.Scheme

	endpointsAuthV1 *eAuthV1Endpoints
}

type eAuthV1Endpoints struct {
	Svc                  sauthSvc_authBackend
	fnAutoWatchSvcAuthV1 func(in *api.ListWatchOptions, stream grpc.ServerStream, svcprefix string) error

	fnAutoAddAuthenticationPolicy    func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoAddRole                    func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoAddRoleBinding             func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoAddUser                    func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoAddUserPreference          func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoDeleteAuthenticationPolicy func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoDeleteRole                 func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoDeleteRoleBinding          func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoDeleteUser                 func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoDeleteUserPreference       func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoGetAuthenticationPolicy    func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoGetRole                    func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoGetRoleBinding             func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoGetUser                    func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoGetUserPreference          func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoLabelAuthenticationPolicy  func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoLabelRole                  func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoLabelRoleBinding           func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoLabelUser                  func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoLabelUserPreference        func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoListAuthenticationPolicy   func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoListRole                   func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoListRoleBinding            func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoListUser                   func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoListUserPreference         func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoUpdateAuthenticationPolicy func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoUpdateRole                 func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoUpdateRoleBinding          func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoUpdateUser                 func(ctx context.Context, t interface{}) (interface{}, error)
	fnAutoUpdateUserPreference       func(ctx context.Context, t interface{}) (interface{}, error)
	fnIsAuthorized                   func(ctx context.Context, t interface{}) (interface{}, error)
	fnLdapBindCheck                  func(ctx context.Context, t interface{}) (interface{}, error)
	fnLdapConnectionCheck            func(ctx context.Context, t interface{}) (interface{}, error)
	fnPasswordChange                 func(ctx context.Context, t interface{}) (interface{}, error)
	fnPasswordReset                  func(ctx context.Context, t interface{}) (interface{}, error)
	fnTokenSecretGenerate            func(ctx context.Context, t interface{}) (interface{}, error)

	fnAutoWatchUser                 func(in *api.ListWatchOptions, stream grpc.ServerStream, svcprefix string) error
	fnAutoWatchAuthenticationPolicy func(in *api.ListWatchOptions, stream grpc.ServerStream, svcprefix string) error
	fnAutoWatchRole                 func(in *api.ListWatchOptions, stream grpc.ServerStream, svcprefix string) error
	fnAutoWatchRoleBinding          func(in *api.ListWatchOptions, stream grpc.ServerStream, svcprefix string) error
	fnAutoWatchUserPreference       func(in *api.ListWatchOptions, stream grpc.ServerStream, svcprefix string) error
}

func (s *sauthSvc_authBackend) regMsgsFunc(l log.Logger, scheme *runtime.Scheme) {
	l.Infof("registering message for sauthSvc_authBackend")
	s.Messages = map[string]apiserver.Message{

		"auth.AuthenticationPolicyList": apisrvpkg.NewMessage("auth.AuthenticationPolicyList").WithKvListFunc(func(ctx context.Context, kvs kvstore.Interface, options *api.ListWatchOptions, prefix string) (interface{}, error) {

			into := auth.AuthenticationPolicyList{}
			into.Kind = "AuthenticationPolicyList"
			r := auth.AuthenticationPolicy{}
			r.ObjectMeta = options.ObjectMeta
			key := r.MakeKey(prefix)

			ctx = apiutils.SetVar(ctx, "ObjKind", "auth.AuthenticationPolicy")
			err := kvs.ListFiltered(ctx, key, &into, *options)
			if err != nil {
				l.ErrorLog("msg", "Object ListFiltered failed", "key", key, "err", err)
				return nil, err
			}
			err = into.ApplyStorageTransformer(ctx, false)
			if err != nil {
				return nil, err
			}
			return into, nil
		}).WithSelfLinkWriter(func(path, ver, prefix string, i interface{}) (interface{}, error) {
			r := i.(auth.AuthenticationPolicyList)
			r.APIVersion = ver
			for i := range r.Items {
				r.Items[i].SelfLink = r.Items[i].MakeURI("configs", ver, prefix)
			}
			return r, nil
		}).WithGetRuntimeObject(func(i interface{}) runtime.Object {
			r := i.(auth.AuthenticationPolicyList)
			return &r
		}),
		"auth.AutoMsgAuthenticationPolicyWatchHelper": apisrvpkg.NewMessage("auth.AutoMsgAuthenticationPolicyWatchHelper"),
		"auth.AutoMsgRoleBindingWatchHelper":          apisrvpkg.NewMessage("auth.AutoMsgRoleBindingWatchHelper"),
		"auth.AutoMsgRoleWatchHelper":                 apisrvpkg.NewMessage("auth.AutoMsgRoleWatchHelper"),
		"auth.AutoMsgUserPreferenceWatchHelper":       apisrvpkg.NewMessage("auth.AutoMsgUserPreferenceWatchHelper"),
		"auth.AutoMsgUserWatchHelper":                 apisrvpkg.NewMessage("auth.AutoMsgUserWatchHelper"),
		"auth.RoleBindingList": apisrvpkg.NewMessage("auth.RoleBindingList").WithKvListFunc(func(ctx context.Context, kvs kvstore.Interface, options *api.ListWatchOptions, prefix string) (interface{}, error) {

			into := auth.RoleBindingList{}
			into.Kind = "RoleBindingList"
			r := auth.RoleBinding{}
			r.ObjectMeta = options.ObjectMeta
			key := r.MakeKey(prefix)

			if options.Tenant == "" {
				if strings.HasSuffix(key, "//") {
					key = key[:len(key)-1]
				}
			}

			ctx = apiutils.SetVar(ctx, "ObjKind", "auth.RoleBinding")
			err := kvs.ListFiltered(ctx, key, &into, *options)
			if err != nil {
				l.ErrorLog("msg", "Object ListFiltered failed", "key", key, "err", err)
				return nil, err
			}
			return into, nil
		}).WithSelfLinkWriter(func(path, ver, prefix string, i interface{}) (interface{}, error) {
			r := i.(auth.RoleBindingList)
			r.APIVersion = ver
			for i := range r.Items {
				r.Items[i].SelfLink = r.Items[i].MakeURI("configs", ver, prefix)
			}
			return r, nil
		}).WithGetRuntimeObject(func(i interface{}) runtime.Object {
			r := i.(auth.RoleBindingList)
			return &r
		}),
		"auth.RoleList": apisrvpkg.NewMessage("auth.RoleList").WithKvListFunc(func(ctx context.Context, kvs kvstore.Interface, options *api.ListWatchOptions, prefix string) (interface{}, error) {

			into := auth.RoleList{}
			into.Kind = "RoleList"
			r := auth.Role{}
			r.ObjectMeta = options.ObjectMeta
			key := r.MakeKey(prefix)

			if options.Tenant == "" {
				if strings.HasSuffix(key, "//") {
					key = key[:len(key)-1]
				}
			}

			ctx = apiutils.SetVar(ctx, "ObjKind", "auth.Role")
			err := kvs.ListFiltered(ctx, key, &into, *options)
			if err != nil {
				l.ErrorLog("msg", "Object ListFiltered failed", "key", key, "err", err)
				return nil, err
			}
			return into, nil
		}).WithSelfLinkWriter(func(path, ver, prefix string, i interface{}) (interface{}, error) {
			r := i.(auth.RoleList)
			r.APIVersion = ver
			for i := range r.Items {
				r.Items[i].SelfLink = r.Items[i].MakeURI("configs", ver, prefix)
			}
			return r, nil
		}).WithGetRuntimeObject(func(i interface{}) runtime.Object {
			r := i.(auth.RoleList)
			return &r
		}),
		"auth.UserList": apisrvpkg.NewMessage("auth.UserList").WithKvListFunc(func(ctx context.Context, kvs kvstore.Interface, options *api.ListWatchOptions, prefix string) (interface{}, error) {

			into := auth.UserList{}
			into.Kind = "UserList"
			r := auth.User{}
			r.ObjectMeta = options.ObjectMeta
			key := r.MakeKey(prefix)

			if options.Tenant == "" {
				if strings.HasSuffix(key, "//") {
					key = key[:len(key)-1]
				}
			}

			ctx = apiutils.SetVar(ctx, "ObjKind", "auth.User")
			err := kvs.ListFiltered(ctx, key, &into, *options)
			if err != nil {
				l.ErrorLog("msg", "Object ListFiltered failed", "key", key, "err", err)
				return nil, err
			}
			err = into.ApplyStorageTransformer(ctx, false)
			if err != nil {
				return nil, err
			}
			return into, nil
		}).WithSelfLinkWriter(func(path, ver, prefix string, i interface{}) (interface{}, error) {
			r := i.(auth.UserList)
			r.APIVersion = ver
			for i := range r.Items {
				r.Items[i].SelfLink = r.Items[i].MakeURI("configs", ver, prefix)
			}
			return r, nil
		}).WithGetRuntimeObject(func(i interface{}) runtime.Object {
			r := i.(auth.UserList)
			return &r
		}),
		"auth.UserPreferenceList": apisrvpkg.NewMessage("auth.UserPreferenceList").WithKvListFunc(func(ctx context.Context, kvs kvstore.Interface, options *api.ListWatchOptions, prefix string) (interface{}, error) {

			into := auth.UserPreferenceList{}
			into.Kind = "UserPreferenceList"
			r := auth.UserPreference{}
			r.ObjectMeta = options.ObjectMeta
			key := r.MakeKey(prefix)

			if options.Tenant == "" {
				if strings.HasSuffix(key, "//") {
					key = key[:len(key)-1]
				}
			}

			ctx = apiutils.SetVar(ctx, "ObjKind", "auth.UserPreference")
			err := kvs.ListFiltered(ctx, key, &into, *options)
			if err != nil {
				l.ErrorLog("msg", "Object ListFiltered failed", "key", key, "err", err)
				return nil, err
			}
			return into, nil
		}).WithSelfLinkWriter(func(path, ver, prefix string, i interface{}) (interface{}, error) {
			r := i.(auth.UserPreferenceList)
			r.APIVersion = ver
			for i := range r.Items {
				r.Items[i].SelfLink = r.Items[i].MakeURI("configs", ver, prefix)
			}
			return r, nil
		}).WithGetRuntimeObject(func(i interface{}) runtime.Object {
			r := i.(auth.UserPreferenceList)
			return &r
		}),
		// Add a message handler for ListWatch options
		"api.ListWatchOptions": apisrvpkg.NewMessage("api.ListWatchOptions"),
		// Add a message handler for Label options
		"api.Label": apisrvpkg.NewMessage("api.Label").WithGetRuntimeObject(func(i interface{}) runtime.Object {
			r := i.(api.Label)
			return &r
		}).WithObjectVersionWriter(func(i interface{}, version string) interface{} {
			r := i.(api.Label)
			r.APIVersion = version
			return r
		}),
	}

	apisrv.RegisterMessages("auth", s.Messages)
	// add messages to package.
	if pkgMessages == nil {
		pkgMessages = make(map[string]apiserver.Message)
	}
	for k, v := range s.Messages {
		pkgMessages[k] = v
	}
}

func (s *sauthSvc_authBackend) regSvcsFunc(ctx context.Context, logger log.Logger, grpcserver *rpckit.RPCServer, scheme *runtime.Scheme) {

	{
		srv := apisrvpkg.NewService("auth.AuthV1")
		s.endpointsAuthV1.fnAutoWatchSvcAuthV1 = srv.WatchFromKv

		s.endpointsAuthV1.fnAutoAddAuthenticationPolicy = srv.AddMethod("AutoAddAuthenticationPolicy",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.AuthenticationPolicy"], pkgMessages["auth.AuthenticationPolicy"], "auth", "AutoAddAuthenticationPolicy")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/authn-policy"), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoAddRole = srv.AddMethod("AutoAddRole",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.Role"], pkgMessages["auth.Role"], "auth", "AutoAddRole")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.Role)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/roles/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoAddRoleBinding = srv.AddMethod("AutoAddRoleBinding",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.RoleBinding"], pkgMessages["auth.RoleBinding"], "auth", "AutoAddRoleBinding")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.RoleBinding)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/role-bindings/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoAddUser = srv.AddMethod("AutoAddUser",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.User"], pkgMessages["auth.User"], "auth", "AutoAddUser")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.User)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoAddUserPreference = srv.AddMethod("AutoAddUserPreference",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.UserPreference"], pkgMessages["auth.UserPreference"], "auth", "AutoAddUserPreference")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return "", fmt.Errorf("not rest endpoint")
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoDeleteAuthenticationPolicy = srv.AddMethod("AutoDeleteAuthenticationPolicy",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.AuthenticationPolicy"], pkgMessages["auth.AuthenticationPolicy"], "auth", "AutoDeleteAuthenticationPolicy")).WithOper(apiintf.DeleteOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return "", fmt.Errorf("not rest endpoint")
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoDeleteRole = srv.AddMethod("AutoDeleteRole",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.Role"], pkgMessages["auth.Role"], "auth", "AutoDeleteRole")).WithOper(apiintf.DeleteOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.Role)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/roles/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoDeleteRoleBinding = srv.AddMethod("AutoDeleteRoleBinding",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.RoleBinding"], pkgMessages["auth.RoleBinding"], "auth", "AutoDeleteRoleBinding")).WithOper(apiintf.DeleteOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.RoleBinding)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/role-bindings/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoDeleteUser = srv.AddMethod("AutoDeleteUser",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.User"], pkgMessages["auth.User"], "auth", "AutoDeleteUser")).WithOper(apiintf.DeleteOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.User)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoDeleteUserPreference = srv.AddMethod("AutoDeleteUserPreference",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.UserPreference"], pkgMessages["auth.UserPreference"], "auth", "AutoDeleteUserPreference")).WithOper(apiintf.DeleteOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return "", fmt.Errorf("not rest endpoint")
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoGetAuthenticationPolicy = srv.AddMethod("AutoGetAuthenticationPolicy",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.AuthenticationPolicy"], pkgMessages["auth.AuthenticationPolicy"], "auth", "AutoGetAuthenticationPolicy")).WithOper(apiintf.GetOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/authn-policy"), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoGetRole = srv.AddMethod("AutoGetRole",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.Role"], pkgMessages["auth.Role"], "auth", "AutoGetRole")).WithOper(apiintf.GetOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.Role)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/roles/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoGetRoleBinding = srv.AddMethod("AutoGetRoleBinding",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.RoleBinding"], pkgMessages["auth.RoleBinding"], "auth", "AutoGetRoleBinding")).WithOper(apiintf.GetOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.RoleBinding)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/role-bindings/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoGetUser = srv.AddMethod("AutoGetUser",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.User"], pkgMessages["auth.User"], "auth", "AutoGetUser")).WithOper(apiintf.GetOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.User)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoGetUserPreference = srv.AddMethod("AutoGetUserPreference",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.UserPreference"], pkgMessages["auth.UserPreference"], "auth", "AutoGetUserPreference")).WithOper(apiintf.GetOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.UserPreference)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/user-preferences/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoLabelAuthenticationPolicy = srv.AddMethod("AutoLabelAuthenticationPolicy",
			apisrvpkg.NewMethod(srv, pkgMessages["api.Label"], pkgMessages["auth.AuthenticationPolicy"], "auth", "AutoLabelAuthenticationPolicy")).WithOper(apiintf.LabelOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/authn-policy"), nil
		}).WithMethDbKey(func(i interface{}, prefix string) (string, error) {
			new := auth.AuthenticationPolicy{}
			if i == nil {
				return new.MakeKey(prefix), nil
			}
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			new.ObjectMeta = in.ObjectMeta
			return new.MakeKey(prefix), nil
		}).WithResponseWriter(func(ctx context.Context, kvs kvstore.Interface, prefix string, in, old, resp interface{}, oper apiintf.APIOperType) (interface{}, error) {
			label, ok := resp.(api.Label)
			if !ok {
				return "", fmt.Errorf("Expected type to be api.Label")
			}
			cur := auth.AuthenticationPolicy{}
			cur.ObjectMeta = label.ObjectMeta
			key := cur.MakeKey(prefix)
			if err := kvs.Get(ctx, key, &cur); err != nil {
				return nil, err
			}
			return cur, nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoLabelRole = srv.AddMethod("AutoLabelRole",
			apisrvpkg.NewMethod(srv, pkgMessages["api.Label"], pkgMessages["auth.Role"], "auth", "AutoLabelRole")).WithOper(apiintf.LabelOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/roles/", in.Name), nil
		}).WithMethDbKey(func(i interface{}, prefix string) (string, error) {
			new := auth.Role{}
			if i == nil {
				return new.MakeKey(prefix), nil
			}
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			new.ObjectMeta = in.ObjectMeta
			return new.MakeKey(prefix), nil
		}).WithResponseWriter(func(ctx context.Context, kvs kvstore.Interface, prefix string, in, old, resp interface{}, oper apiintf.APIOperType) (interface{}, error) {
			label, ok := resp.(api.Label)
			if !ok {
				return "", fmt.Errorf("Expected type to be api.Label")
			}
			cur := auth.Role{}
			cur.ObjectMeta = label.ObjectMeta
			key := cur.MakeKey(prefix)
			if err := kvs.Get(ctx, key, &cur); err != nil {
				return nil, err
			}
			return cur, nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoLabelRoleBinding = srv.AddMethod("AutoLabelRoleBinding",
			apisrvpkg.NewMethod(srv, pkgMessages["api.Label"], pkgMessages["auth.RoleBinding"], "auth", "AutoLabelRoleBinding")).WithOper(apiintf.LabelOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/role-bindings/", in.Name), nil
		}).WithMethDbKey(func(i interface{}, prefix string) (string, error) {
			new := auth.RoleBinding{}
			if i == nil {
				return new.MakeKey(prefix), nil
			}
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			new.ObjectMeta = in.ObjectMeta
			return new.MakeKey(prefix), nil
		}).WithResponseWriter(func(ctx context.Context, kvs kvstore.Interface, prefix string, in, old, resp interface{}, oper apiintf.APIOperType) (interface{}, error) {
			label, ok := resp.(api.Label)
			if !ok {
				return "", fmt.Errorf("Expected type to be api.Label")
			}
			cur := auth.RoleBinding{}
			cur.ObjectMeta = label.ObjectMeta
			key := cur.MakeKey(prefix)
			if err := kvs.Get(ctx, key, &cur); err != nil {
				return nil, err
			}
			return cur, nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoLabelUser = srv.AddMethod("AutoLabelUser",
			apisrvpkg.NewMethod(srv, pkgMessages["api.Label"], pkgMessages["auth.User"], "auth", "AutoLabelUser")).WithOper(apiintf.LabelOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).WithMethDbKey(func(i interface{}, prefix string) (string, error) {
			new := auth.User{}
			if i == nil {
				return new.MakeKey(prefix), nil
			}
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			new.ObjectMeta = in.ObjectMeta
			return new.MakeKey(prefix), nil
		}).WithResponseWriter(func(ctx context.Context, kvs kvstore.Interface, prefix string, in, old, resp interface{}, oper apiintf.APIOperType) (interface{}, error) {
			label, ok := resp.(api.Label)
			if !ok {
				return "", fmt.Errorf("Expected type to be api.Label")
			}
			cur := auth.User{}
			cur.ObjectMeta = label.ObjectMeta
			key := cur.MakeKey(prefix)
			if err := kvs.Get(ctx, key, &cur); err != nil {
				return nil, err
			}
			return cur, nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoLabelUserPreference = srv.AddMethod("AutoLabelUserPreference",
			apisrvpkg.NewMethod(srv, pkgMessages["api.Label"], pkgMessages["auth.UserPreference"], "auth", "AutoLabelUserPreference")).WithOper(apiintf.LabelOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/user-preferences/", in.Name), nil
		}).WithMethDbKey(func(i interface{}, prefix string) (string, error) {
			new := auth.UserPreference{}
			if i == nil {
				return new.MakeKey(prefix), nil
			}
			in, ok := i.(api.Label)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			new.ObjectMeta = in.ObjectMeta
			return new.MakeKey(prefix), nil
		}).WithResponseWriter(func(ctx context.Context, kvs kvstore.Interface, prefix string, in, old, resp interface{}, oper apiintf.APIOperType) (interface{}, error) {
			label, ok := resp.(api.Label)
			if !ok {
				return "", fmt.Errorf("Expected type to be api.Label")
			}
			cur := auth.UserPreference{}
			cur.ObjectMeta = label.ObjectMeta
			key := cur.MakeKey(prefix)
			if err := kvs.Get(ctx, key, &cur); err != nil {
				return nil, err
			}
			return cur, nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoListAuthenticationPolicy = srv.AddMethod("AutoListAuthenticationPolicy",
			apisrvpkg.NewMethod(srv, pkgMessages["api.ListWatchOptions"], pkgMessages["auth.AuthenticationPolicyList"], "auth", "AutoListAuthenticationPolicy")).WithOper(apiintf.ListOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return "", fmt.Errorf("not rest endpoint")
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoListRole = srv.AddMethod("AutoListRole",
			apisrvpkg.NewMethod(srv, pkgMessages["api.ListWatchOptions"], pkgMessages["auth.RoleList"], "auth", "AutoListRole")).WithOper(apiintf.ListOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(api.ListWatchOptions)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/roles/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoListRoleBinding = srv.AddMethod("AutoListRoleBinding",
			apisrvpkg.NewMethod(srv, pkgMessages["api.ListWatchOptions"], pkgMessages["auth.RoleBindingList"], "auth", "AutoListRoleBinding")).WithOper(apiintf.ListOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(api.ListWatchOptions)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/role-bindings/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoListUser = srv.AddMethod("AutoListUser",
			apisrvpkg.NewMethod(srv, pkgMessages["api.ListWatchOptions"], pkgMessages["auth.UserList"], "auth", "AutoListUser")).WithOper(apiintf.ListOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(api.ListWatchOptions)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoListUserPreference = srv.AddMethod("AutoListUserPreference",
			apisrvpkg.NewMethod(srv, pkgMessages["api.ListWatchOptions"], pkgMessages["auth.UserPreferenceList"], "auth", "AutoListUserPreference")).WithOper(apiintf.ListOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return "", fmt.Errorf("not rest endpoint")
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoUpdateAuthenticationPolicy = srv.AddMethod("AutoUpdateAuthenticationPolicy",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.AuthenticationPolicy"], pkgMessages["auth.AuthenticationPolicy"], "auth", "AutoUpdateAuthenticationPolicy")).WithOper(apiintf.UpdateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/authn-policy"), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoUpdateRole = srv.AddMethod("AutoUpdateRole",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.Role"], pkgMessages["auth.Role"], "auth", "AutoUpdateRole")).WithOper(apiintf.UpdateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.Role)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/roles/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoUpdateRoleBinding = srv.AddMethod("AutoUpdateRoleBinding",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.RoleBinding"], pkgMessages["auth.RoleBinding"], "auth", "AutoUpdateRoleBinding")).WithOper(apiintf.UpdateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.RoleBinding)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/role-bindings/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoUpdateUser = srv.AddMethod("AutoUpdateUser",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.User"], pkgMessages["auth.User"], "auth", "AutoUpdateUser")).WithOper(apiintf.UpdateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.User)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoUpdateUserPreference = srv.AddMethod("AutoUpdateUserPreference",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.UserPreference"], pkgMessages["auth.UserPreference"], "auth", "AutoUpdateUserPreference")).WithOper(apiintf.UpdateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.UserPreference)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/user-preferences/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnIsAuthorized = srv.AddMethod("IsAuthorized",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.SubjectAccessReviewRequest"], pkgMessages["auth.User"], "auth", "IsAuthorized")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.SubjectAccessReviewRequest)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnLdapBindCheck = srv.AddMethod("LdapBindCheck",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.AuthenticationPolicy"], pkgMessages["auth.AuthenticationPolicy"], "auth", "LdapBindCheck")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/authn-policy"), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnLdapConnectionCheck = srv.AddMethod("LdapConnectionCheck",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.AuthenticationPolicy"], pkgMessages["auth.AuthenticationPolicy"], "auth", "LdapConnectionCheck")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/authn-policy"), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnPasswordChange = srv.AddMethod("PasswordChange",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.PasswordChangeRequest"], pkgMessages["auth.User"], "auth", "PasswordChange")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.PasswordChangeRequest)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnPasswordReset = srv.AddMethod("PasswordReset",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.PasswordResetRequest"], pkgMessages["auth.User"], "auth", "PasswordReset")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			in, ok := i.(auth.PasswordResetRequest)
			if !ok {
				return "", fmt.Errorf("wrong type")
			}
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/tenant/", in.Tenant, "/users/", in.Name), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnTokenSecretGenerate = srv.AddMethod("TokenSecretGenerate",
			apisrvpkg.NewMethod(srv, pkgMessages["auth.TokenSecretRequest"], pkgMessages["auth.AuthenticationPolicy"], "auth", "TokenSecretGenerate")).WithOper(apiintf.CreateOper).WithVersion("v1").WithMakeURI(func(i interface{}) (string, error) {
			return fmt.Sprint("/", globals.ConfigURIPrefix, "/", "auth/v1/authn-policy"), nil
		}).HandleInvocation

		s.endpointsAuthV1.fnAutoWatchUser = pkgMessages["auth.User"].WatchFromKv

		s.endpointsAuthV1.fnAutoWatchAuthenticationPolicy = pkgMessages["auth.AuthenticationPolicy"].WatchFromKv

		s.endpointsAuthV1.fnAutoWatchRole = pkgMessages["auth.Role"].WatchFromKv

		s.endpointsAuthV1.fnAutoWatchRoleBinding = pkgMessages["auth.RoleBinding"].WatchFromKv

		s.endpointsAuthV1.fnAutoWatchUserPreference = pkgMessages["auth.UserPreference"].WatchFromKv

		s.Services = map[string]apiserver.Service{
			"auth.AuthV1": srv,
		}
		apisrv.RegisterService("auth.AuthV1", srv)
		endpoints := auth.MakeAuthV1ServerEndpoints(s.endpointsAuthV1, logger)
		server := auth.MakeGRPCServerAuthV1(ctx, endpoints, logger)
		auth.RegisterAuthV1Server(grpcserver.GrpcServer, server)
		svcObjs := []string{"User", "AuthenticationPolicy", "Role", "RoleBinding", "UserPreference"}
		fieldhooks.RegisterImmutableFieldsServiceHooks("auth", "AuthV1", svcObjs)
	}
}

func (s *sauthSvc_authBackend) regWatchersFunc(ctx context.Context, logger log.Logger, grpcserver *rpckit.RPCServer, scheme *runtime.Scheme) {

	// Add Watchers
	{

		// Service watcher
		svc := s.Services["auth.AuthV1"]
		if svc != nil {
			svc.WithKvWatchFunc(func(l log.Logger, options *api.ListWatchOptions, kvs kvstore.Interface, stream interface{}, txfnMap map[string]func(from, to string, i interface{}) (interface{}, error), version, svcprefix string) error {
				key := globals.ConfigRootPrefix + "/auth"
				wstream := stream.(grpc.ServerStream)
				nctx, cancel := context.WithCancel(wstream.Context())
				defer cancel()
				watcher, err := kvs.WatchFiltered(nctx, key, *options)
				if err != nil {
					l.ErrorLog("msg", "error starting Watch for service", "err", err, "service", "AuthV1")
					return err
				}
				return listerwatcher.SvcWatch(nctx, watcher, wstream, txfnMap, version, l)
			})
		}

		pkgMessages["auth.User"].WithKvWatchFunc(func(l log.Logger, options *api.ListWatchOptions, kvs kvstore.Interface, stream interface{}, txfn func(from, to string, i interface{}) (interface{}, error), version, svcprefix string) error {
			o := auth.User{}
			key := o.MakeKey(svcprefix)
			if strings.HasSuffix(key, "//") {
				key = strings.TrimSuffix(key, "/")
			}
			if strings.HasSuffix(key, "//Singleton") {
				key = strings.TrimSuffix(key, "/Singleton")
			}
			wstream := stream.(auth.AuthV1_AutoWatchUserServer)
			nctx, cancel := context.WithCancel(wstream.Context())
			defer cancel()
			id := fmt.Sprintf("%s-%x", ctxutils.GetPeerID(nctx), &key)

			nctx = ctxutils.SetContextID(nctx, id)
			if kvs == nil {
				return fmt.Errorf("Nil KVS")
			}
			nctx = apiutils.SetVar(nctx, "ObjKind", "auth.User")
			l.InfoLog("msg", "KVWatcher starting watch", "WatcherID", id, "object", "auth.User")
			watcher, err := kvs.WatchFiltered(nctx, key, *options)
			if err != nil {
				l.ErrorLog("msg", "error starting Watch on KV", "err", err, "WatcherID", id, "bbject", "auth.User")
				return err
			}
			timer := time.NewTimer(apiserver.DefaultWatchHoldInterval)
			if !timer.Stop() {
				<-timer.C
			}
			running := false
			events := &auth.AutoMsgUserWatchHelper{}
			sendToStream := func() error {
				l.DebugLog("msg", "writing to stream", "len", len(events.Events))
				if err := wstream.Send(events); err != nil {
					l.ErrorLog("msg", "Stream send error'ed for Order", "err", err, "WatcherID", id, "bbject", "auth.User")
					return err
				}
				events = &auth.AutoMsgUserWatchHelper{}
				return nil
			}
			defer l.InfoLog("msg", "exiting watcher", "service", "auth.User")
			for {
				select {
				case ev, ok := <-watcher.EventChan():
					if !ok {
						l.ErrorLog("msg", "Channel closed for Watcher", "WatcherID", id, "bbject", "auth.User")
						return nil
					}
					evin, ok := ev.Object.(*auth.User)
					if !ok {
						status, ok := ev.Object.(*api.Status)
						if !ok {
							return errors.New("unknown error")
						}
						return fmt.Errorf("%v:(%s) %s", status.Code, status.Result, status.Message)
					}
					// XXX-TODO(sanjayt): Avoid a copy and update selflink at enqueue.
					cin, err := evin.Clone(nil)
					if err != nil {
						return fmt.Errorf("unable to clone object (%s)", err)
					}
					in := cin.(*auth.User)
					in.SelfLink = in.MakeURI(globals.ConfigURIPrefix, "v1", "auth")
					{
						txin, err := auth.StorageUserTransformer.TransformFromStorage(nctx, *in)
						if err != nil {
							return errors.Wrap(err, "Failed to apply storage transformer to User")
						}
						obj := txin.(auth.User)
						in = &obj
					}
					strEvent := &auth.AutoMsgUserWatchHelper_WatchEvent{
						Type:   string(ev.Type),
						Object: in,
					}
					l.DebugLog("msg", "received User watch event from KV", "type", ev.Type)
					if version != in.APIVersion {
						i, err := txfn(in.APIVersion, version, in)
						if err != nil {
							l.ErrorLog("msg", "Failed to transform message", "type", "User", "fromver", in.APIVersion, "tover", version, "WatcherID", id, "bbject", "auth.User")
							break
						}
						strEvent.Object = i.(*auth.User)
					}
					events.Events = append(events.Events, strEvent)
					if !running {
						running = true
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
					if len(events.Events) >= apiserver.DefaultWatchBatchSize {
						if err = sendToStream(); err != nil {
							return err
						}
						if !timer.Stop() {
							<-timer.C
						}
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
				case <-timer.C:
					running = false
					if err = sendToStream(); err != nil {
						return err
					}
				case <-nctx.Done():
					l.DebugLog("msg", "Context cancelled for Watcher", "WatcherID", id, "bbject", "auth.User")
					return wstream.Context().Err()
				}
			}
		})

		pkgMessages["auth.AuthenticationPolicy"].WithKvWatchFunc(func(l log.Logger, options *api.ListWatchOptions, kvs kvstore.Interface, stream interface{}, txfn func(from, to string, i interface{}) (interface{}, error), version, svcprefix string) error {
			o := auth.AuthenticationPolicy{}
			key := o.MakeKey(svcprefix)
			if strings.HasSuffix(key, "//") {
				key = strings.TrimSuffix(key, "/")
			}
			if strings.HasSuffix(key, "//Singleton") {
				key = strings.TrimSuffix(key, "/Singleton")
			}
			wstream := stream.(auth.AuthV1_AutoWatchAuthenticationPolicyServer)
			nctx, cancel := context.WithCancel(wstream.Context())
			defer cancel()
			id := fmt.Sprintf("%s-%x", ctxutils.GetPeerID(nctx), &key)

			nctx = ctxutils.SetContextID(nctx, id)
			if kvs == nil {
				return fmt.Errorf("Nil KVS")
			}
			nctx = apiutils.SetVar(nctx, "ObjKind", "auth.AuthenticationPolicy")
			l.InfoLog("msg", "KVWatcher starting watch", "WatcherID", id, "object", "auth.AuthenticationPolicy")
			watcher, err := kvs.WatchFiltered(nctx, key, *options)
			if err != nil {
				l.ErrorLog("msg", "error starting Watch on KV", "err", err, "WatcherID", id, "bbject", "auth.AuthenticationPolicy")
				return err
			}
			timer := time.NewTimer(apiserver.DefaultWatchHoldInterval)
			if !timer.Stop() {
				<-timer.C
			}
			running := false
			events := &auth.AutoMsgAuthenticationPolicyWatchHelper{}
			sendToStream := func() error {
				l.DebugLog("msg", "writing to stream", "len", len(events.Events))
				if err := wstream.Send(events); err != nil {
					l.ErrorLog("msg", "Stream send error'ed for Order", "err", err, "WatcherID", id, "bbject", "auth.AuthenticationPolicy")
					return err
				}
				events = &auth.AutoMsgAuthenticationPolicyWatchHelper{}
				return nil
			}
			defer l.InfoLog("msg", "exiting watcher", "service", "auth.AuthenticationPolicy")
			for {
				select {
				case ev, ok := <-watcher.EventChan():
					if !ok {
						l.ErrorLog("msg", "Channel closed for Watcher", "WatcherID", id, "bbject", "auth.AuthenticationPolicy")
						return nil
					}
					evin, ok := ev.Object.(*auth.AuthenticationPolicy)
					if !ok {
						status, ok := ev.Object.(*api.Status)
						if !ok {
							return errors.New("unknown error")
						}
						return fmt.Errorf("%v:(%s) %s", status.Code, status.Result, status.Message)
					}
					// XXX-TODO(sanjayt): Avoid a copy and update selflink at enqueue.
					cin, err := evin.Clone(nil)
					if err != nil {
						return fmt.Errorf("unable to clone object (%s)", err)
					}
					in := cin.(*auth.AuthenticationPolicy)
					in.SelfLink = in.MakeURI(globals.ConfigURIPrefix, "v1", "auth")
					{
						txin, err := auth.StorageAuthenticationPolicyTransformer.TransformFromStorage(nctx, *in)
						if err != nil {
							return errors.Wrap(err, "Failed to apply storage transformer to AuthenticationPolicy")
						}
						obj := txin.(auth.AuthenticationPolicy)
						in = &obj
					}
					strEvent := &auth.AutoMsgAuthenticationPolicyWatchHelper_WatchEvent{
						Type:   string(ev.Type),
						Object: in,
					}
					l.DebugLog("msg", "received AuthenticationPolicy watch event from KV", "type", ev.Type)
					if version != in.APIVersion {
						i, err := txfn(in.APIVersion, version, in)
						if err != nil {
							l.ErrorLog("msg", "Failed to transform message", "type", "AuthenticationPolicy", "fromver", in.APIVersion, "tover", version, "WatcherID", id, "bbject", "auth.AuthenticationPolicy")
							break
						}
						strEvent.Object = i.(*auth.AuthenticationPolicy)
					}
					events.Events = append(events.Events, strEvent)
					if !running {
						running = true
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
					if len(events.Events) >= apiserver.DefaultWatchBatchSize {
						if err = sendToStream(); err != nil {
							return err
						}
						if !timer.Stop() {
							<-timer.C
						}
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
				case <-timer.C:
					running = false
					if err = sendToStream(); err != nil {
						return err
					}
				case <-nctx.Done():
					l.DebugLog("msg", "Context cancelled for Watcher", "WatcherID", id, "bbject", "auth.AuthenticationPolicy")
					return wstream.Context().Err()
				}
			}
		})

		pkgMessages["auth.Role"].WithKvWatchFunc(func(l log.Logger, options *api.ListWatchOptions, kvs kvstore.Interface, stream interface{}, txfn func(from, to string, i interface{}) (interface{}, error), version, svcprefix string) error {
			o := auth.Role{}
			key := o.MakeKey(svcprefix)
			if strings.HasSuffix(key, "//") {
				key = strings.TrimSuffix(key, "/")
			}
			if strings.HasSuffix(key, "//Singleton") {
				key = strings.TrimSuffix(key, "/Singleton")
			}
			wstream := stream.(auth.AuthV1_AutoWatchRoleServer)
			nctx, cancel := context.WithCancel(wstream.Context())
			defer cancel()
			id := fmt.Sprintf("%s-%x", ctxutils.GetPeerID(nctx), &key)

			nctx = ctxutils.SetContextID(nctx, id)
			if kvs == nil {
				return fmt.Errorf("Nil KVS")
			}
			nctx = apiutils.SetVar(nctx, "ObjKind", "auth.Role")
			l.InfoLog("msg", "KVWatcher starting watch", "WatcherID", id, "object", "auth.Role")
			watcher, err := kvs.WatchFiltered(nctx, key, *options)
			if err != nil {
				l.ErrorLog("msg", "error starting Watch on KV", "err", err, "WatcherID", id, "bbject", "auth.Role")
				return err
			}
			timer := time.NewTimer(apiserver.DefaultWatchHoldInterval)
			if !timer.Stop() {
				<-timer.C
			}
			running := false
			events := &auth.AutoMsgRoleWatchHelper{}
			sendToStream := func() error {
				l.DebugLog("msg", "writing to stream", "len", len(events.Events))
				if err := wstream.Send(events); err != nil {
					l.ErrorLog("msg", "Stream send error'ed for Order", "err", err, "WatcherID", id, "bbject", "auth.Role")
					return err
				}
				events = &auth.AutoMsgRoleWatchHelper{}
				return nil
			}
			defer l.InfoLog("msg", "exiting watcher", "service", "auth.Role")
			for {
				select {
				case ev, ok := <-watcher.EventChan():
					if !ok {
						l.ErrorLog("msg", "Channel closed for Watcher", "WatcherID", id, "bbject", "auth.Role")
						return nil
					}
					evin, ok := ev.Object.(*auth.Role)
					if !ok {
						status, ok := ev.Object.(*api.Status)
						if !ok {
							return errors.New("unknown error")
						}
						return fmt.Errorf("%v:(%s) %s", status.Code, status.Result, status.Message)
					}
					// XXX-TODO(sanjayt): Avoid a copy and update selflink at enqueue.
					cin, err := evin.Clone(nil)
					if err != nil {
						return fmt.Errorf("unable to clone object (%s)", err)
					}
					in := cin.(*auth.Role)
					in.SelfLink = in.MakeURI(globals.ConfigURIPrefix, "v1", "auth")

					strEvent := &auth.AutoMsgRoleWatchHelper_WatchEvent{
						Type:   string(ev.Type),
						Object: in,
					}
					l.DebugLog("msg", "received Role watch event from KV", "type", ev.Type)
					if version != in.APIVersion {
						i, err := txfn(in.APIVersion, version, in)
						if err != nil {
							l.ErrorLog("msg", "Failed to transform message", "type", "Role", "fromver", in.APIVersion, "tover", version, "WatcherID", id, "bbject", "auth.Role")
							break
						}
						strEvent.Object = i.(*auth.Role)
					}
					events.Events = append(events.Events, strEvent)
					if !running {
						running = true
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
					if len(events.Events) >= apiserver.DefaultWatchBatchSize {
						if err = sendToStream(); err != nil {
							return err
						}
						if !timer.Stop() {
							<-timer.C
						}
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
				case <-timer.C:
					running = false
					if err = sendToStream(); err != nil {
						return err
					}
				case <-nctx.Done():
					l.DebugLog("msg", "Context cancelled for Watcher", "WatcherID", id, "bbject", "auth.Role")
					return wstream.Context().Err()
				}
			}
		})

		pkgMessages["auth.RoleBinding"].WithKvWatchFunc(func(l log.Logger, options *api.ListWatchOptions, kvs kvstore.Interface, stream interface{}, txfn func(from, to string, i interface{}) (interface{}, error), version, svcprefix string) error {
			o := auth.RoleBinding{}
			key := o.MakeKey(svcprefix)
			if strings.HasSuffix(key, "//") {
				key = strings.TrimSuffix(key, "/")
			}
			if strings.HasSuffix(key, "//Singleton") {
				key = strings.TrimSuffix(key, "/Singleton")
			}
			wstream := stream.(auth.AuthV1_AutoWatchRoleBindingServer)
			nctx, cancel := context.WithCancel(wstream.Context())
			defer cancel()
			id := fmt.Sprintf("%s-%x", ctxutils.GetPeerID(nctx), &key)

			nctx = ctxutils.SetContextID(nctx, id)
			if kvs == nil {
				return fmt.Errorf("Nil KVS")
			}
			nctx = apiutils.SetVar(nctx, "ObjKind", "auth.RoleBinding")
			l.InfoLog("msg", "KVWatcher starting watch", "WatcherID", id, "object", "auth.RoleBinding")
			watcher, err := kvs.WatchFiltered(nctx, key, *options)
			if err != nil {
				l.ErrorLog("msg", "error starting Watch on KV", "err", err, "WatcherID", id, "bbject", "auth.RoleBinding")
				return err
			}
			timer := time.NewTimer(apiserver.DefaultWatchHoldInterval)
			if !timer.Stop() {
				<-timer.C
			}
			running := false
			events := &auth.AutoMsgRoleBindingWatchHelper{}
			sendToStream := func() error {
				l.DebugLog("msg", "writing to stream", "len", len(events.Events))
				if err := wstream.Send(events); err != nil {
					l.ErrorLog("msg", "Stream send error'ed for Order", "err", err, "WatcherID", id, "bbject", "auth.RoleBinding")
					return err
				}
				events = &auth.AutoMsgRoleBindingWatchHelper{}
				return nil
			}
			defer l.InfoLog("msg", "exiting watcher", "service", "auth.RoleBinding")
			for {
				select {
				case ev, ok := <-watcher.EventChan():
					if !ok {
						l.ErrorLog("msg", "Channel closed for Watcher", "WatcherID", id, "bbject", "auth.RoleBinding")
						return nil
					}
					evin, ok := ev.Object.(*auth.RoleBinding)
					if !ok {
						status, ok := ev.Object.(*api.Status)
						if !ok {
							return errors.New("unknown error")
						}
						return fmt.Errorf("%v:(%s) %s", status.Code, status.Result, status.Message)
					}
					// XXX-TODO(sanjayt): Avoid a copy and update selflink at enqueue.
					cin, err := evin.Clone(nil)
					if err != nil {
						return fmt.Errorf("unable to clone object (%s)", err)
					}
					in := cin.(*auth.RoleBinding)
					in.SelfLink = in.MakeURI(globals.ConfigURIPrefix, "v1", "auth")

					strEvent := &auth.AutoMsgRoleBindingWatchHelper_WatchEvent{
						Type:   string(ev.Type),
						Object: in,
					}
					l.DebugLog("msg", "received RoleBinding watch event from KV", "type", ev.Type)
					if version != in.APIVersion {
						i, err := txfn(in.APIVersion, version, in)
						if err != nil {
							l.ErrorLog("msg", "Failed to transform message", "type", "RoleBinding", "fromver", in.APIVersion, "tover", version, "WatcherID", id, "bbject", "auth.RoleBinding")
							break
						}
						strEvent.Object = i.(*auth.RoleBinding)
					}
					events.Events = append(events.Events, strEvent)
					if !running {
						running = true
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
					if len(events.Events) >= apiserver.DefaultWatchBatchSize {
						if err = sendToStream(); err != nil {
							return err
						}
						if !timer.Stop() {
							<-timer.C
						}
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
				case <-timer.C:
					running = false
					if err = sendToStream(); err != nil {
						return err
					}
				case <-nctx.Done():
					l.DebugLog("msg", "Context cancelled for Watcher", "WatcherID", id, "bbject", "auth.RoleBinding")
					return wstream.Context().Err()
				}
			}
		})

		pkgMessages["auth.UserPreference"].WithKvWatchFunc(func(l log.Logger, options *api.ListWatchOptions, kvs kvstore.Interface, stream interface{}, txfn func(from, to string, i interface{}) (interface{}, error), version, svcprefix string) error {
			o := auth.UserPreference{}
			key := o.MakeKey(svcprefix)
			if strings.HasSuffix(key, "//") {
				key = strings.TrimSuffix(key, "/")
			}
			if strings.HasSuffix(key, "//Singleton") {
				key = strings.TrimSuffix(key, "/Singleton")
			}
			wstream := stream.(auth.AuthV1_AutoWatchUserPreferenceServer)
			nctx, cancel := context.WithCancel(wstream.Context())
			defer cancel()
			id := fmt.Sprintf("%s-%x", ctxutils.GetPeerID(nctx), &key)

			nctx = ctxutils.SetContextID(nctx, id)
			if kvs == nil {
				return fmt.Errorf("Nil KVS")
			}
			nctx = apiutils.SetVar(nctx, "ObjKind", "auth.UserPreference")
			l.InfoLog("msg", "KVWatcher starting watch", "WatcherID", id, "object", "auth.UserPreference")
			watcher, err := kvs.WatchFiltered(nctx, key, *options)
			if err != nil {
				l.ErrorLog("msg", "error starting Watch on KV", "err", err, "WatcherID", id, "bbject", "auth.UserPreference")
				return err
			}
			timer := time.NewTimer(apiserver.DefaultWatchHoldInterval)
			if !timer.Stop() {
				<-timer.C
			}
			running := false
			events := &auth.AutoMsgUserPreferenceWatchHelper{}
			sendToStream := func() error {
				l.DebugLog("msg", "writing to stream", "len", len(events.Events))
				if err := wstream.Send(events); err != nil {
					l.ErrorLog("msg", "Stream send error'ed for Order", "err", err, "WatcherID", id, "bbject", "auth.UserPreference")
					return err
				}
				events = &auth.AutoMsgUserPreferenceWatchHelper{}
				return nil
			}
			defer l.InfoLog("msg", "exiting watcher", "service", "auth.UserPreference")
			for {
				select {
				case ev, ok := <-watcher.EventChan():
					if !ok {
						l.ErrorLog("msg", "Channel closed for Watcher", "WatcherID", id, "bbject", "auth.UserPreference")
						return nil
					}
					evin, ok := ev.Object.(*auth.UserPreference)
					if !ok {
						status, ok := ev.Object.(*api.Status)
						if !ok {
							return errors.New("unknown error")
						}
						return fmt.Errorf("%v:(%s) %s", status.Code, status.Result, status.Message)
					}
					// XXX-TODO(sanjayt): Avoid a copy and update selflink at enqueue.
					cin, err := evin.Clone(nil)
					if err != nil {
						return fmt.Errorf("unable to clone object (%s)", err)
					}
					in := cin.(*auth.UserPreference)
					in.SelfLink = in.MakeURI(globals.ConfigURIPrefix, "v1", "auth")

					strEvent := &auth.AutoMsgUserPreferenceWatchHelper_WatchEvent{
						Type:   string(ev.Type),
						Object: in,
					}
					l.DebugLog("msg", "received UserPreference watch event from KV", "type", ev.Type)
					if version != in.APIVersion {
						i, err := txfn(in.APIVersion, version, in)
						if err != nil {
							l.ErrorLog("msg", "Failed to transform message", "type", "UserPreference", "fromver", in.APIVersion, "tover", version, "WatcherID", id, "bbject", "auth.UserPreference")
							break
						}
						strEvent.Object = i.(*auth.UserPreference)
					}
					events.Events = append(events.Events, strEvent)
					if !running {
						running = true
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
					if len(events.Events) >= apiserver.DefaultWatchBatchSize {
						if err = sendToStream(); err != nil {
							return err
						}
						if !timer.Stop() {
							<-timer.C
						}
						timer.Reset(apiserver.DefaultWatchHoldInterval)
					}
				case <-timer.C:
					running = false
					if err = sendToStream(); err != nil {
						return err
					}
				case <-nctx.Done():
					l.DebugLog("msg", "Context cancelled for Watcher", "WatcherID", id, "bbject", "auth.UserPreference")
					return wstream.Context().Err()
				}
			}
		})

	}

}

func (s *sauthSvc_authBackend) CompleteRegistration(ctx context.Context, logger log.Logger,
	grpcserver *rpckit.RPCServer, scheme *runtime.Scheme) error {
	// register all messages in the package if not done already
	s.logger = logger
	s.scheme = scheme
	registerMessages(logger, scheme)
	registerServices(ctx, logger, grpcserver, scheme)
	registerWatchers(ctx, logger, grpcserver, scheme)
	return nil
}

func (s *sauthSvc_authBackend) Reset() {
	cleanupRegistration()
}

func (e *eAuthV1Endpoints) AutoAddAuthenticationPolicy(ctx context.Context, t auth.AuthenticationPolicy) (auth.AuthenticationPolicy, error) {
	r, err := e.fnAutoAddAuthenticationPolicy(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}
func (e *eAuthV1Endpoints) AutoAddRole(ctx context.Context, t auth.Role) (auth.Role, error) {
	r, err := e.fnAutoAddRole(ctx, t)
	if err == nil {
		return r.(auth.Role), err
	}
	return auth.Role{}, err

}
func (e *eAuthV1Endpoints) AutoAddRoleBinding(ctx context.Context, t auth.RoleBinding) (auth.RoleBinding, error) {
	r, err := e.fnAutoAddRoleBinding(ctx, t)
	if err == nil {
		return r.(auth.RoleBinding), err
	}
	return auth.RoleBinding{}, err

}
func (e *eAuthV1Endpoints) AutoAddUser(ctx context.Context, t auth.User) (auth.User, error) {
	r, err := e.fnAutoAddUser(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) AutoAddUserPreference(ctx context.Context, t auth.UserPreference) (auth.UserPreference, error) {
	r, err := e.fnAutoAddUserPreference(ctx, t)
	if err == nil {
		return r.(auth.UserPreference), err
	}
	return auth.UserPreference{}, err

}
func (e *eAuthV1Endpoints) AutoDeleteAuthenticationPolicy(ctx context.Context, t auth.AuthenticationPolicy) (auth.AuthenticationPolicy, error) {
	r, err := e.fnAutoDeleteAuthenticationPolicy(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}
func (e *eAuthV1Endpoints) AutoDeleteRole(ctx context.Context, t auth.Role) (auth.Role, error) {
	r, err := e.fnAutoDeleteRole(ctx, t)
	if err == nil {
		return r.(auth.Role), err
	}
	return auth.Role{}, err

}
func (e *eAuthV1Endpoints) AutoDeleteRoleBinding(ctx context.Context, t auth.RoleBinding) (auth.RoleBinding, error) {
	r, err := e.fnAutoDeleteRoleBinding(ctx, t)
	if err == nil {
		return r.(auth.RoleBinding), err
	}
	return auth.RoleBinding{}, err

}
func (e *eAuthV1Endpoints) AutoDeleteUser(ctx context.Context, t auth.User) (auth.User, error) {
	r, err := e.fnAutoDeleteUser(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) AutoDeleteUserPreference(ctx context.Context, t auth.UserPreference) (auth.UserPreference, error) {
	r, err := e.fnAutoDeleteUserPreference(ctx, t)
	if err == nil {
		return r.(auth.UserPreference), err
	}
	return auth.UserPreference{}, err

}
func (e *eAuthV1Endpoints) AutoGetAuthenticationPolicy(ctx context.Context, t auth.AuthenticationPolicy) (auth.AuthenticationPolicy, error) {
	r, err := e.fnAutoGetAuthenticationPolicy(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}
func (e *eAuthV1Endpoints) AutoGetRole(ctx context.Context, t auth.Role) (auth.Role, error) {
	r, err := e.fnAutoGetRole(ctx, t)
	if err == nil {
		return r.(auth.Role), err
	}
	return auth.Role{}, err

}
func (e *eAuthV1Endpoints) AutoGetRoleBinding(ctx context.Context, t auth.RoleBinding) (auth.RoleBinding, error) {
	r, err := e.fnAutoGetRoleBinding(ctx, t)
	if err == nil {
		return r.(auth.RoleBinding), err
	}
	return auth.RoleBinding{}, err

}
func (e *eAuthV1Endpoints) AutoGetUser(ctx context.Context, t auth.User) (auth.User, error) {
	r, err := e.fnAutoGetUser(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) AutoGetUserPreference(ctx context.Context, t auth.UserPreference) (auth.UserPreference, error) {
	r, err := e.fnAutoGetUserPreference(ctx, t)
	if err == nil {
		return r.(auth.UserPreference), err
	}
	return auth.UserPreference{}, err

}
func (e *eAuthV1Endpoints) AutoLabelAuthenticationPolicy(ctx context.Context, t api.Label) (auth.AuthenticationPolicy, error) {
	r, err := e.fnAutoLabelAuthenticationPolicy(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}
func (e *eAuthV1Endpoints) AutoLabelRole(ctx context.Context, t api.Label) (auth.Role, error) {
	r, err := e.fnAutoLabelRole(ctx, t)
	if err == nil {
		return r.(auth.Role), err
	}
	return auth.Role{}, err

}
func (e *eAuthV1Endpoints) AutoLabelRoleBinding(ctx context.Context, t api.Label) (auth.RoleBinding, error) {
	r, err := e.fnAutoLabelRoleBinding(ctx, t)
	if err == nil {
		return r.(auth.RoleBinding), err
	}
	return auth.RoleBinding{}, err

}
func (e *eAuthV1Endpoints) AutoLabelUser(ctx context.Context, t api.Label) (auth.User, error) {
	r, err := e.fnAutoLabelUser(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) AutoLabelUserPreference(ctx context.Context, t api.Label) (auth.UserPreference, error) {
	r, err := e.fnAutoLabelUserPreference(ctx, t)
	if err == nil {
		return r.(auth.UserPreference), err
	}
	return auth.UserPreference{}, err

}
func (e *eAuthV1Endpoints) AutoListAuthenticationPolicy(ctx context.Context, t api.ListWatchOptions) (auth.AuthenticationPolicyList, error) {
	r, err := e.fnAutoListAuthenticationPolicy(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicyList), err
	}
	return auth.AuthenticationPolicyList{}, err

}
func (e *eAuthV1Endpoints) AutoListRole(ctx context.Context, t api.ListWatchOptions) (auth.RoleList, error) {
	r, err := e.fnAutoListRole(ctx, t)
	if err == nil {
		return r.(auth.RoleList), err
	}
	return auth.RoleList{}, err

}
func (e *eAuthV1Endpoints) AutoListRoleBinding(ctx context.Context, t api.ListWatchOptions) (auth.RoleBindingList, error) {
	r, err := e.fnAutoListRoleBinding(ctx, t)
	if err == nil {
		return r.(auth.RoleBindingList), err
	}
	return auth.RoleBindingList{}, err

}
func (e *eAuthV1Endpoints) AutoListUser(ctx context.Context, t api.ListWatchOptions) (auth.UserList, error) {
	r, err := e.fnAutoListUser(ctx, t)
	if err == nil {
		return r.(auth.UserList), err
	}
	return auth.UserList{}, err

}
func (e *eAuthV1Endpoints) AutoListUserPreference(ctx context.Context, t api.ListWatchOptions) (auth.UserPreferenceList, error) {
	r, err := e.fnAutoListUserPreference(ctx, t)
	if err == nil {
		return r.(auth.UserPreferenceList), err
	}
	return auth.UserPreferenceList{}, err

}
func (e *eAuthV1Endpoints) AutoUpdateAuthenticationPolicy(ctx context.Context, t auth.AuthenticationPolicy) (auth.AuthenticationPolicy, error) {
	r, err := e.fnAutoUpdateAuthenticationPolicy(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}
func (e *eAuthV1Endpoints) AutoUpdateRole(ctx context.Context, t auth.Role) (auth.Role, error) {
	r, err := e.fnAutoUpdateRole(ctx, t)
	if err == nil {
		return r.(auth.Role), err
	}
	return auth.Role{}, err

}
func (e *eAuthV1Endpoints) AutoUpdateRoleBinding(ctx context.Context, t auth.RoleBinding) (auth.RoleBinding, error) {
	r, err := e.fnAutoUpdateRoleBinding(ctx, t)
	if err == nil {
		return r.(auth.RoleBinding), err
	}
	return auth.RoleBinding{}, err

}
func (e *eAuthV1Endpoints) AutoUpdateUser(ctx context.Context, t auth.User) (auth.User, error) {
	r, err := e.fnAutoUpdateUser(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) AutoUpdateUserPreference(ctx context.Context, t auth.UserPreference) (auth.UserPreference, error) {
	r, err := e.fnAutoUpdateUserPreference(ctx, t)
	if err == nil {
		return r.(auth.UserPreference), err
	}
	return auth.UserPreference{}, err

}
func (e *eAuthV1Endpoints) IsAuthorized(ctx context.Context, t auth.SubjectAccessReviewRequest) (auth.User, error) {
	r, err := e.fnIsAuthorized(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) LdapBindCheck(ctx context.Context, t auth.AuthenticationPolicy) (auth.AuthenticationPolicy, error) {
	r, err := e.fnLdapBindCheck(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}
func (e *eAuthV1Endpoints) LdapConnectionCheck(ctx context.Context, t auth.AuthenticationPolicy) (auth.AuthenticationPolicy, error) {
	r, err := e.fnLdapConnectionCheck(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}
func (e *eAuthV1Endpoints) PasswordChange(ctx context.Context, t auth.PasswordChangeRequest) (auth.User, error) {
	r, err := e.fnPasswordChange(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) PasswordReset(ctx context.Context, t auth.PasswordResetRequest) (auth.User, error) {
	r, err := e.fnPasswordReset(ctx, t)
	if err == nil {
		return r.(auth.User), err
	}
	return auth.User{}, err

}
func (e *eAuthV1Endpoints) TokenSecretGenerate(ctx context.Context, t auth.TokenSecretRequest) (auth.AuthenticationPolicy, error) {
	r, err := e.fnTokenSecretGenerate(ctx, t)
	if err == nil {
		return r.(auth.AuthenticationPolicy), err
	}
	return auth.AuthenticationPolicy{}, err

}

func (e *eAuthV1Endpoints) AutoWatchUser(in *api.ListWatchOptions, stream auth.AuthV1_AutoWatchUserServer) error {
	return e.fnAutoWatchUser(in, stream, "auth")
}
func (e *eAuthV1Endpoints) AutoWatchAuthenticationPolicy(in *api.ListWatchOptions, stream auth.AuthV1_AutoWatchAuthenticationPolicyServer) error {
	return e.fnAutoWatchAuthenticationPolicy(in, stream, "auth")
}
func (e *eAuthV1Endpoints) AutoWatchRole(in *api.ListWatchOptions, stream auth.AuthV1_AutoWatchRoleServer) error {
	return e.fnAutoWatchRole(in, stream, "auth")
}
func (e *eAuthV1Endpoints) AutoWatchRoleBinding(in *api.ListWatchOptions, stream auth.AuthV1_AutoWatchRoleBindingServer) error {
	return e.fnAutoWatchRoleBinding(in, stream, "auth")
}
func (e *eAuthV1Endpoints) AutoWatchUserPreference(in *api.ListWatchOptions, stream auth.AuthV1_AutoWatchUserPreferenceServer) error {
	return e.fnAutoWatchUserPreference(in, stream, "auth")
}
func (e *eAuthV1Endpoints) AutoWatchSvcAuthV1(in *api.ListWatchOptions, stream auth.AuthV1_AutoWatchSvcAuthV1Server) error {
	return e.fnAutoWatchSvcAuthV1(in, stream, "")
}

func init() {
	apisrv = apisrvpkg.MustGetAPIServer()

	svc := sauthSvc_authBackend{}
	addMsgRegFunc(svc.regMsgsFunc)
	addSvcRegFunc(svc.regSvcsFunc)
	addWatcherRegFunc(svc.regWatchersFunc)

	{
		e := eAuthV1Endpoints{Svc: svc}
		svc.endpointsAuthV1 = &e
	}
	apisrv.Register("auth.svc_auth.proto", &svc)
}
