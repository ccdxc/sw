// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: svc_security.proto

package security

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import _ "github.com/pensando/sw/api/labels"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AppList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*App `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AppList) Reset()                    { *m = AppList{} }
func (m *AppList) String() string            { return proto.CompactTextString(m) }
func (*AppList) ProtoMessage()               {}
func (*AppList) Descriptor() ([]byte, []int) { return fileDescriptorSvcSecurity, []int{0} }

func (m *AppList) GetItems() []*App {
	if m != nil {
		return m.Items
	}
	return nil
}

type AppUserGrpList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*AppUserGrp `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AppUserGrpList) Reset()                    { *m = AppUserGrpList{} }
func (m *AppUserGrpList) String() string            { return proto.CompactTextString(m) }
func (*AppUserGrpList) ProtoMessage()               {}
func (*AppUserGrpList) Descriptor() ([]byte, []int) { return fileDescriptorSvcSecurity, []int{1} }

func (m *AppUserGrpList) GetItems() []*AppUserGrp {
	if m != nil {
		return m.Items
	}
	return nil
}

type AppUserList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*AppUser `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *AppUserList) Reset()                    { *m = AppUserList{} }
func (m *AppUserList) String() string            { return proto.CompactTextString(m) }
func (*AppUserList) ProtoMessage()               {}
func (*AppUserList) Descriptor() ([]byte, []int) { return fileDescriptorSvcSecurity, []int{2} }

func (m *AppUserList) GetItems() []*AppUser {
	if m != nil {
		return m.Items
	}
	return nil
}

type AutoMsgAppUserGrpWatchHelper struct {
	Type   string      `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *AppUserGrp `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAppUserGrpWatchHelper) Reset()         { *m = AutoMsgAppUserGrpWatchHelper{} }
func (m *AutoMsgAppUserGrpWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgAppUserGrpWatchHelper) ProtoMessage()    {}
func (*AutoMsgAppUserGrpWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcSecurity, []int{3}
}

func (m *AutoMsgAppUserGrpWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAppUserGrpWatchHelper) GetObject() *AppUserGrp {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgAppUserWatchHelper struct {
	Type   string   `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *AppUser `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAppUserWatchHelper) Reset()         { *m = AutoMsgAppUserWatchHelper{} }
func (m *AutoMsgAppUserWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgAppUserWatchHelper) ProtoMessage()    {}
func (*AutoMsgAppUserWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcSecurity, []int{4}
}

func (m *AutoMsgAppUserWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAppUserWatchHelper) GetObject() *AppUser {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgAppWatchHelper struct {
	Type   string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *App   `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgAppWatchHelper) Reset()                    { *m = AutoMsgAppWatchHelper{} }
func (m *AutoMsgAppWatchHelper) String() string            { return proto.CompactTextString(m) }
func (*AutoMsgAppWatchHelper) ProtoMessage()               {}
func (*AutoMsgAppWatchHelper) Descriptor() ([]byte, []int) { return fileDescriptorSvcSecurity, []int{5} }

func (m *AutoMsgAppWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgAppWatchHelper) GetObject() *App {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgCertificateWatchHelper struct {
	Type   string       `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *Certificate `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgCertificateWatchHelper) Reset()         { *m = AutoMsgCertificateWatchHelper{} }
func (m *AutoMsgCertificateWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgCertificateWatchHelper) ProtoMessage()    {}
func (*AutoMsgCertificateWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcSecurity, []int{6}
}

func (m *AutoMsgCertificateWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgCertificateWatchHelper) GetObject() *Certificate {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgSecurityGroupWatchHelper struct {
	Type   string         `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *SecurityGroup `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgSecurityGroupWatchHelper) Reset()         { *m = AutoMsgSecurityGroupWatchHelper{} }
func (m *AutoMsgSecurityGroupWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgSecurityGroupWatchHelper) ProtoMessage()    {}
func (*AutoMsgSecurityGroupWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcSecurity, []int{7}
}

func (m *AutoMsgSecurityGroupWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgSecurityGroupWatchHelper) GetObject() *SecurityGroup {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgSgpolicyWatchHelper struct {
	Type   string    `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *Sgpolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgSgpolicyWatchHelper) Reset()         { *m = AutoMsgSgpolicyWatchHelper{} }
func (m *AutoMsgSgpolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgSgpolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgSgpolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcSecurity, []int{8}
}

func (m *AutoMsgSgpolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgSgpolicyWatchHelper) GetObject() *Sgpolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

type AutoMsgTrafficEncryptionPolicyWatchHelper struct {
	Type   string                   `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	Object *TrafficEncryptionPolicy `protobuf:"bytes,2,opt,name=Object" json:"Object,omitempty"`
}

func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) Reset() {
	*m = AutoMsgTrafficEncryptionPolicyWatchHelper{}
}
func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) String() string { return proto.CompactTextString(m) }
func (*AutoMsgTrafficEncryptionPolicyWatchHelper) ProtoMessage()    {}
func (*AutoMsgTrafficEncryptionPolicyWatchHelper) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcSecurity, []int{9}
}

func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) GetObject() *TrafficEncryptionPolicy {
	if m != nil {
		return m.Object
	}
	return nil
}

type CertificateList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*Certificate `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *CertificateList) Reset()                    { *m = CertificateList{} }
func (m *CertificateList) String() string            { return proto.CompactTextString(m) }
func (*CertificateList) ProtoMessage()               {}
func (*CertificateList) Descriptor() ([]byte, []int) { return fileDescriptorSvcSecurity, []int{10} }

func (m *CertificateList) GetItems() []*Certificate {
	if m != nil {
		return m.Items
	}
	return nil
}

type SecurityGroupList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*SecurityGroup `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *SecurityGroupList) Reset()                    { *m = SecurityGroupList{} }
func (m *SecurityGroupList) String() string            { return proto.CompactTextString(m) }
func (*SecurityGroupList) ProtoMessage()               {}
func (*SecurityGroupList) Descriptor() ([]byte, []int) { return fileDescriptorSvcSecurity, []int{11} }

func (m *SecurityGroupList) GetItems() []*SecurityGroup {
	if m != nil {
		return m.Items
	}
	return nil
}

type SgpolicyList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*Sgpolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *SgpolicyList) Reset()                    { *m = SgpolicyList{} }
func (m *SgpolicyList) String() string            { return proto.CompactTextString(m) }
func (*SgpolicyList) ProtoMessage()               {}
func (*SgpolicyList) Descriptor() ([]byte, []int) { return fileDescriptorSvcSecurity, []int{12} }

func (m *SgpolicyList) GetItems() []*Sgpolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

type TrafficEncryptionPolicyList struct {
	api.TypeMeta `protobuf:"bytes,2,opt,name=T,embedded=T" json:"T"`
	api.ListMeta `protobuf:"bytes,3,opt,name=ListMeta,embedded=ListMeta" json:"ListMeta"`
	Items        []*TrafficEncryptionPolicy `protobuf:"bytes,4,rep,name=Items" json:"Items,omitempty"`
}

func (m *TrafficEncryptionPolicyList) Reset()         { *m = TrafficEncryptionPolicyList{} }
func (m *TrafficEncryptionPolicyList) String() string { return proto.CompactTextString(m) }
func (*TrafficEncryptionPolicyList) ProtoMessage()    {}
func (*TrafficEncryptionPolicyList) Descriptor() ([]byte, []int) {
	return fileDescriptorSvcSecurity, []int{13}
}

func (m *TrafficEncryptionPolicyList) GetItems() []*TrafficEncryptionPolicy {
	if m != nil {
		return m.Items
	}
	return nil
}

func init() {
	proto.RegisterType((*AppList)(nil), "security.AppList")
	proto.RegisterType((*AppUserGrpList)(nil), "security.AppUserGrpList")
	proto.RegisterType((*AppUserList)(nil), "security.AppUserList")
	proto.RegisterType((*AutoMsgAppUserGrpWatchHelper)(nil), "security.AutoMsgAppUserGrpWatchHelper")
	proto.RegisterType((*AutoMsgAppUserWatchHelper)(nil), "security.AutoMsgAppUserWatchHelper")
	proto.RegisterType((*AutoMsgAppWatchHelper)(nil), "security.AutoMsgAppWatchHelper")
	proto.RegisterType((*AutoMsgCertificateWatchHelper)(nil), "security.AutoMsgCertificateWatchHelper")
	proto.RegisterType((*AutoMsgSecurityGroupWatchHelper)(nil), "security.AutoMsgSecurityGroupWatchHelper")
	proto.RegisterType((*AutoMsgSgpolicyWatchHelper)(nil), "security.AutoMsgSgpolicyWatchHelper")
	proto.RegisterType((*AutoMsgTrafficEncryptionPolicyWatchHelper)(nil), "security.AutoMsgTrafficEncryptionPolicyWatchHelper")
	proto.RegisterType((*CertificateList)(nil), "security.CertificateList")
	proto.RegisterType((*SecurityGroupList)(nil), "security.SecurityGroupList")
	proto.RegisterType((*SgpolicyList)(nil), "security.SgpolicyList")
	proto.RegisterType((*TrafficEncryptionPolicyList)(nil), "security.TrafficEncryptionPolicyList")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SecurityV1 service

type SecurityV1Client interface {
	AutoAddApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error)
	AutoAddAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error)
	AutoAddAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error)
	AutoAddCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error)
	AutoAddSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error)
	AutoAddSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error)
	AutoAddTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error)
	AutoDeleteApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error)
	AutoDeleteAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error)
	AutoDeleteAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error)
	AutoDeleteCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error)
	AutoDeleteSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error)
	AutoDeleteSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error)
	AutoDeleteTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error)
	AutoGetApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error)
	AutoGetAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error)
	AutoGetAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error)
	AutoGetCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error)
	AutoGetSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error)
	AutoGetSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error)
	AutoGetTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error)
	AutoListApp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AppList, error)
	AutoListAppUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AppUserList, error)
	AutoListAppUserGrp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AppUserGrpList, error)
	AutoListCertificate(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*CertificateList, error)
	AutoListSecurityGroup(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SecurityGroupList, error)
	AutoListSgpolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SgpolicyList, error)
	AutoListTrafficEncryptionPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*TrafficEncryptionPolicyList, error)
	AutoUpdateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error)
	AutoUpdateAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error)
	AutoUpdateAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error)
	AutoUpdateCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error)
	AutoUpdateSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error)
	AutoUpdateSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error)
	AutoUpdateTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error)
	AutoWatchApp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchAppClient, error)
	AutoWatchAppUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchAppUserClient, error)
	AutoWatchAppUserGrp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchAppUserGrpClient, error)
	AutoWatchCertificate(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchCertificateClient, error)
	AutoWatchSecurityGroup(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchSecurityGroupClient, error)
	AutoWatchSgpolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchSgpolicyClient, error)
	AutoWatchTrafficEncryptionPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchTrafficEncryptionPolicyClient, error)
}

type securityV1Client struct {
	cc *grpc.ClientConn
}

func NewSecurityV1Client(cc *grpc.ClientConn) SecurityV1Client {
	return &securityV1Client{cc}
}

func (c *securityV1Client) AutoAddApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error) {
	out := new(App)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoAddApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoAddAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error) {
	out := new(AppUser)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoAddAppUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoAddAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error) {
	out := new(AppUserGrp)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoAddAppUserGrp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoAddCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoAddCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoAddSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error) {
	out := new(SecurityGroup)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoAddSecurityGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoAddSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error) {
	out := new(Sgpolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoAddSgpolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoAddTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error) {
	out := new(TrafficEncryptionPolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoAddTrafficEncryptionPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoDeleteApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error) {
	out := new(App)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoDeleteApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoDeleteAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error) {
	out := new(AppUser)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoDeleteAppUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoDeleteAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error) {
	out := new(AppUserGrp)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoDeleteAppUserGrp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoDeleteCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoDeleteCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoDeleteSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error) {
	out := new(SecurityGroup)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoDeleteSecurityGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoDeleteSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error) {
	out := new(Sgpolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoDeleteSgpolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoDeleteTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error) {
	out := new(TrafficEncryptionPolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoDeleteTrafficEncryptionPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoGetApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error) {
	out := new(App)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoGetApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoGetAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error) {
	out := new(AppUser)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoGetAppUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoGetAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error) {
	out := new(AppUserGrp)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoGetAppUserGrp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoGetCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoGetCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoGetSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error) {
	out := new(SecurityGroup)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoGetSecurityGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoGetSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error) {
	out := new(Sgpolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoGetSgpolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoGetTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error) {
	out := new(TrafficEncryptionPolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoGetTrafficEncryptionPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoListApp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AppList, error) {
	out := new(AppList)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoListApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoListAppUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AppUserList, error) {
	out := new(AppUserList)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoListAppUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoListAppUserGrp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*AppUserGrpList, error) {
	out := new(AppUserGrpList)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoListAppUserGrp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoListCertificate(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*CertificateList, error) {
	out := new(CertificateList)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoListCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoListSecurityGroup(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SecurityGroupList, error) {
	out := new(SecurityGroupList)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoListSecurityGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoListSgpolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*SgpolicyList, error) {
	out := new(SgpolicyList)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoListSgpolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoListTrafficEncryptionPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (*TrafficEncryptionPolicyList, error) {
	out := new(TrafficEncryptionPolicyList)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoListTrafficEncryptionPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoUpdateApp(ctx context.Context, in *App, opts ...grpc.CallOption) (*App, error) {
	out := new(App)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoUpdateApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoUpdateAppUser(ctx context.Context, in *AppUser, opts ...grpc.CallOption) (*AppUser, error) {
	out := new(AppUser)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoUpdateAppUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoUpdateAppUserGrp(ctx context.Context, in *AppUserGrp, opts ...grpc.CallOption) (*AppUserGrp, error) {
	out := new(AppUserGrp)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoUpdateAppUserGrp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoUpdateCertificate(ctx context.Context, in *Certificate, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoUpdateCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoUpdateSecurityGroup(ctx context.Context, in *SecurityGroup, opts ...grpc.CallOption) (*SecurityGroup, error) {
	out := new(SecurityGroup)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoUpdateSecurityGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoUpdateSgpolicy(ctx context.Context, in *Sgpolicy, opts ...grpc.CallOption) (*Sgpolicy, error) {
	out := new(Sgpolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoUpdateSgpolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoUpdateTrafficEncryptionPolicy(ctx context.Context, in *TrafficEncryptionPolicy, opts ...grpc.CallOption) (*TrafficEncryptionPolicy, error) {
	out := new(TrafficEncryptionPolicy)
	err := grpc.Invoke(ctx, "/security.SecurityV1/AutoUpdateTrafficEncryptionPolicy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityV1Client) AutoWatchApp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchAppClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityV1_serviceDesc.Streams[0], c.cc, "/security.SecurityV1/AutoWatchApp", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityV1AutoWatchAppClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityV1_AutoWatchAppClient interface {
	Recv() (*AutoMsgAppWatchHelper, error)
	grpc.ClientStream
}

type securityV1AutoWatchAppClient struct {
	grpc.ClientStream
}

func (x *securityV1AutoWatchAppClient) Recv() (*AutoMsgAppWatchHelper, error) {
	m := new(AutoMsgAppWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityV1Client) AutoWatchAppUser(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchAppUserClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityV1_serviceDesc.Streams[1], c.cc, "/security.SecurityV1/AutoWatchAppUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityV1AutoWatchAppUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityV1_AutoWatchAppUserClient interface {
	Recv() (*AutoMsgAppUserWatchHelper, error)
	grpc.ClientStream
}

type securityV1AutoWatchAppUserClient struct {
	grpc.ClientStream
}

func (x *securityV1AutoWatchAppUserClient) Recv() (*AutoMsgAppUserWatchHelper, error) {
	m := new(AutoMsgAppUserWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityV1Client) AutoWatchAppUserGrp(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchAppUserGrpClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityV1_serviceDesc.Streams[2], c.cc, "/security.SecurityV1/AutoWatchAppUserGrp", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityV1AutoWatchAppUserGrpClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityV1_AutoWatchAppUserGrpClient interface {
	Recv() (*AutoMsgAppUserGrpWatchHelper, error)
	grpc.ClientStream
}

type securityV1AutoWatchAppUserGrpClient struct {
	grpc.ClientStream
}

func (x *securityV1AutoWatchAppUserGrpClient) Recv() (*AutoMsgAppUserGrpWatchHelper, error) {
	m := new(AutoMsgAppUserGrpWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityV1Client) AutoWatchCertificate(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchCertificateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityV1_serviceDesc.Streams[3], c.cc, "/security.SecurityV1/AutoWatchCertificate", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityV1AutoWatchCertificateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityV1_AutoWatchCertificateClient interface {
	Recv() (*AutoMsgCertificateWatchHelper, error)
	grpc.ClientStream
}

type securityV1AutoWatchCertificateClient struct {
	grpc.ClientStream
}

func (x *securityV1AutoWatchCertificateClient) Recv() (*AutoMsgCertificateWatchHelper, error) {
	m := new(AutoMsgCertificateWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityV1Client) AutoWatchSecurityGroup(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchSecurityGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityV1_serviceDesc.Streams[4], c.cc, "/security.SecurityV1/AutoWatchSecurityGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityV1AutoWatchSecurityGroupClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityV1_AutoWatchSecurityGroupClient interface {
	Recv() (*AutoMsgSecurityGroupWatchHelper, error)
	grpc.ClientStream
}

type securityV1AutoWatchSecurityGroupClient struct {
	grpc.ClientStream
}

func (x *securityV1AutoWatchSecurityGroupClient) Recv() (*AutoMsgSecurityGroupWatchHelper, error) {
	m := new(AutoMsgSecurityGroupWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityV1Client) AutoWatchSgpolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchSgpolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityV1_serviceDesc.Streams[5], c.cc, "/security.SecurityV1/AutoWatchSgpolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityV1AutoWatchSgpolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityV1_AutoWatchSgpolicyClient interface {
	Recv() (*AutoMsgSgpolicyWatchHelper, error)
	grpc.ClientStream
}

type securityV1AutoWatchSgpolicyClient struct {
	grpc.ClientStream
}

func (x *securityV1AutoWatchSgpolicyClient) Recv() (*AutoMsgSgpolicyWatchHelper, error) {
	m := new(AutoMsgSgpolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *securityV1Client) AutoWatchTrafficEncryptionPolicy(ctx context.Context, in *api.ListWatchOptions, opts ...grpc.CallOption) (SecurityV1_AutoWatchTrafficEncryptionPolicyClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SecurityV1_serviceDesc.Streams[6], c.cc, "/security.SecurityV1/AutoWatchTrafficEncryptionPolicy", opts...)
	if err != nil {
		return nil, err
	}
	x := &securityV1AutoWatchTrafficEncryptionPolicyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SecurityV1_AutoWatchTrafficEncryptionPolicyClient interface {
	Recv() (*AutoMsgTrafficEncryptionPolicyWatchHelper, error)
	grpc.ClientStream
}

type securityV1AutoWatchTrafficEncryptionPolicyClient struct {
	grpc.ClientStream
}

func (x *securityV1AutoWatchTrafficEncryptionPolicyClient) Recv() (*AutoMsgTrafficEncryptionPolicyWatchHelper, error) {
	m := new(AutoMsgTrafficEncryptionPolicyWatchHelper)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SecurityV1 service

type SecurityV1Server interface {
	AutoAddApp(context.Context, *App) (*App, error)
	AutoAddAppUser(context.Context, *AppUser) (*AppUser, error)
	AutoAddAppUserGrp(context.Context, *AppUserGrp) (*AppUserGrp, error)
	AutoAddCertificate(context.Context, *Certificate) (*Certificate, error)
	AutoAddSecurityGroup(context.Context, *SecurityGroup) (*SecurityGroup, error)
	AutoAddSgpolicy(context.Context, *Sgpolicy) (*Sgpolicy, error)
	AutoAddTrafficEncryptionPolicy(context.Context, *TrafficEncryptionPolicy) (*TrafficEncryptionPolicy, error)
	AutoDeleteApp(context.Context, *App) (*App, error)
	AutoDeleteAppUser(context.Context, *AppUser) (*AppUser, error)
	AutoDeleteAppUserGrp(context.Context, *AppUserGrp) (*AppUserGrp, error)
	AutoDeleteCertificate(context.Context, *Certificate) (*Certificate, error)
	AutoDeleteSecurityGroup(context.Context, *SecurityGroup) (*SecurityGroup, error)
	AutoDeleteSgpolicy(context.Context, *Sgpolicy) (*Sgpolicy, error)
	AutoDeleteTrafficEncryptionPolicy(context.Context, *TrafficEncryptionPolicy) (*TrafficEncryptionPolicy, error)
	AutoGetApp(context.Context, *App) (*App, error)
	AutoGetAppUser(context.Context, *AppUser) (*AppUser, error)
	AutoGetAppUserGrp(context.Context, *AppUserGrp) (*AppUserGrp, error)
	AutoGetCertificate(context.Context, *Certificate) (*Certificate, error)
	AutoGetSecurityGroup(context.Context, *SecurityGroup) (*SecurityGroup, error)
	AutoGetSgpolicy(context.Context, *Sgpolicy) (*Sgpolicy, error)
	AutoGetTrafficEncryptionPolicy(context.Context, *TrafficEncryptionPolicy) (*TrafficEncryptionPolicy, error)
	AutoListApp(context.Context, *api.ListWatchOptions) (*AppList, error)
	AutoListAppUser(context.Context, *api.ListWatchOptions) (*AppUserList, error)
	AutoListAppUserGrp(context.Context, *api.ListWatchOptions) (*AppUserGrpList, error)
	AutoListCertificate(context.Context, *api.ListWatchOptions) (*CertificateList, error)
	AutoListSecurityGroup(context.Context, *api.ListWatchOptions) (*SecurityGroupList, error)
	AutoListSgpolicy(context.Context, *api.ListWatchOptions) (*SgpolicyList, error)
	AutoListTrafficEncryptionPolicy(context.Context, *api.ListWatchOptions) (*TrafficEncryptionPolicyList, error)
	AutoUpdateApp(context.Context, *App) (*App, error)
	AutoUpdateAppUser(context.Context, *AppUser) (*AppUser, error)
	AutoUpdateAppUserGrp(context.Context, *AppUserGrp) (*AppUserGrp, error)
	AutoUpdateCertificate(context.Context, *Certificate) (*Certificate, error)
	AutoUpdateSecurityGroup(context.Context, *SecurityGroup) (*SecurityGroup, error)
	AutoUpdateSgpolicy(context.Context, *Sgpolicy) (*Sgpolicy, error)
	AutoUpdateTrafficEncryptionPolicy(context.Context, *TrafficEncryptionPolicy) (*TrafficEncryptionPolicy, error)
	AutoWatchApp(*api.ListWatchOptions, SecurityV1_AutoWatchAppServer) error
	AutoWatchAppUser(*api.ListWatchOptions, SecurityV1_AutoWatchAppUserServer) error
	AutoWatchAppUserGrp(*api.ListWatchOptions, SecurityV1_AutoWatchAppUserGrpServer) error
	AutoWatchCertificate(*api.ListWatchOptions, SecurityV1_AutoWatchCertificateServer) error
	AutoWatchSecurityGroup(*api.ListWatchOptions, SecurityV1_AutoWatchSecurityGroupServer) error
	AutoWatchSgpolicy(*api.ListWatchOptions, SecurityV1_AutoWatchSgpolicyServer) error
	AutoWatchTrafficEncryptionPolicy(*api.ListWatchOptions, SecurityV1_AutoWatchTrafficEncryptionPolicyServer) error
}

func RegisterSecurityV1Server(s *grpc.Server, srv SecurityV1Server) {
	s.RegisterService(&_SecurityV1_serviceDesc, srv)
}

func _SecurityV1_AutoAddApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoAddApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoAddApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoAddApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoAddAppUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoAddAppUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoAddAppUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoAddAppUser(ctx, req.(*AppUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoAddAppUserGrp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUserGrp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoAddAppUserGrp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoAddAppUserGrp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoAddAppUserGrp(ctx, req.(*AppUserGrp))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoAddCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Certificate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoAddCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoAddCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoAddCertificate(ctx, req.(*Certificate))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoAddSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoAddSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoAddSecurityGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoAddSecurityGroup(ctx, req.(*SecurityGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoAddSgpolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Sgpolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoAddSgpolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoAddSgpolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoAddSgpolicy(ctx, req.(*Sgpolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoAddTrafficEncryptionPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficEncryptionPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoAddTrafficEncryptionPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoAddTrafficEncryptionPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoAddTrafficEncryptionPolicy(ctx, req.(*TrafficEncryptionPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoDeleteApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoDeleteApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoDeleteApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoDeleteApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoDeleteAppUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoDeleteAppUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoDeleteAppUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoDeleteAppUser(ctx, req.(*AppUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoDeleteAppUserGrp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUserGrp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoDeleteAppUserGrp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoDeleteAppUserGrp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoDeleteAppUserGrp(ctx, req.(*AppUserGrp))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoDeleteCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Certificate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoDeleteCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoDeleteCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoDeleteCertificate(ctx, req.(*Certificate))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoDeleteSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoDeleteSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoDeleteSecurityGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoDeleteSecurityGroup(ctx, req.(*SecurityGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoDeleteSgpolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Sgpolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoDeleteSgpolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoDeleteSgpolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoDeleteSgpolicy(ctx, req.(*Sgpolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoDeleteTrafficEncryptionPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficEncryptionPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoDeleteTrafficEncryptionPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoDeleteTrafficEncryptionPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoDeleteTrafficEncryptionPolicy(ctx, req.(*TrafficEncryptionPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoGetApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoGetApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoGetApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoGetApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoGetAppUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoGetAppUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoGetAppUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoGetAppUser(ctx, req.(*AppUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoGetAppUserGrp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUserGrp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoGetAppUserGrp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoGetAppUserGrp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoGetAppUserGrp(ctx, req.(*AppUserGrp))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoGetCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Certificate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoGetCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoGetCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoGetCertificate(ctx, req.(*Certificate))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoGetSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoGetSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoGetSecurityGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoGetSecurityGroup(ctx, req.(*SecurityGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoGetSgpolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Sgpolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoGetSgpolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoGetSgpolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoGetSgpolicy(ctx, req.(*Sgpolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoGetTrafficEncryptionPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficEncryptionPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoGetTrafficEncryptionPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoGetTrafficEncryptionPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoGetTrafficEncryptionPolicy(ctx, req.(*TrafficEncryptionPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoListApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoListApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoListApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoListApp(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoListAppUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoListAppUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoListAppUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoListAppUser(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoListAppUserGrp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoListAppUserGrp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoListAppUserGrp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoListAppUserGrp(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoListCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoListCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoListCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoListCertificate(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoListSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoListSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoListSecurityGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoListSecurityGroup(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoListSgpolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoListSgpolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoListSgpolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoListSgpolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoListTrafficEncryptionPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(api.ListWatchOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoListTrafficEncryptionPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoListTrafficEncryptionPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoListTrafficEncryptionPolicy(ctx, req.(*api.ListWatchOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoUpdateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(App)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoUpdateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoUpdateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoUpdateApp(ctx, req.(*App))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoUpdateAppUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoUpdateAppUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoUpdateAppUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoUpdateAppUser(ctx, req.(*AppUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoUpdateAppUserGrp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppUserGrp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoUpdateAppUserGrp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoUpdateAppUserGrp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoUpdateAppUserGrp(ctx, req.(*AppUserGrp))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoUpdateCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Certificate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoUpdateCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoUpdateCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoUpdateCertificate(ctx, req.(*Certificate))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoUpdateSecurityGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoUpdateSecurityGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoUpdateSecurityGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoUpdateSecurityGroup(ctx, req.(*SecurityGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoUpdateSgpolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Sgpolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoUpdateSgpolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoUpdateSgpolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoUpdateSgpolicy(ctx, req.(*Sgpolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoUpdateTrafficEncryptionPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficEncryptionPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityV1Server).AutoUpdateTrafficEncryptionPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/security.SecurityV1/AutoUpdateTrafficEncryptionPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityV1Server).AutoUpdateTrafficEncryptionPolicy(ctx, req.(*TrafficEncryptionPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityV1_AutoWatchApp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityV1Server).AutoWatchApp(m, &securityV1AutoWatchAppServer{stream})
}

type SecurityV1_AutoWatchAppServer interface {
	Send(*AutoMsgAppWatchHelper) error
	grpc.ServerStream
}

type securityV1AutoWatchAppServer struct {
	grpc.ServerStream
}

func (x *securityV1AutoWatchAppServer) Send(m *AutoMsgAppWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityV1_AutoWatchAppUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityV1Server).AutoWatchAppUser(m, &securityV1AutoWatchAppUserServer{stream})
}

type SecurityV1_AutoWatchAppUserServer interface {
	Send(*AutoMsgAppUserWatchHelper) error
	grpc.ServerStream
}

type securityV1AutoWatchAppUserServer struct {
	grpc.ServerStream
}

func (x *securityV1AutoWatchAppUserServer) Send(m *AutoMsgAppUserWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityV1_AutoWatchAppUserGrp_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityV1Server).AutoWatchAppUserGrp(m, &securityV1AutoWatchAppUserGrpServer{stream})
}

type SecurityV1_AutoWatchAppUserGrpServer interface {
	Send(*AutoMsgAppUserGrpWatchHelper) error
	grpc.ServerStream
}

type securityV1AutoWatchAppUserGrpServer struct {
	grpc.ServerStream
}

func (x *securityV1AutoWatchAppUserGrpServer) Send(m *AutoMsgAppUserGrpWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityV1_AutoWatchCertificate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityV1Server).AutoWatchCertificate(m, &securityV1AutoWatchCertificateServer{stream})
}

type SecurityV1_AutoWatchCertificateServer interface {
	Send(*AutoMsgCertificateWatchHelper) error
	grpc.ServerStream
}

type securityV1AutoWatchCertificateServer struct {
	grpc.ServerStream
}

func (x *securityV1AutoWatchCertificateServer) Send(m *AutoMsgCertificateWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityV1_AutoWatchSecurityGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityV1Server).AutoWatchSecurityGroup(m, &securityV1AutoWatchSecurityGroupServer{stream})
}

type SecurityV1_AutoWatchSecurityGroupServer interface {
	Send(*AutoMsgSecurityGroupWatchHelper) error
	grpc.ServerStream
}

type securityV1AutoWatchSecurityGroupServer struct {
	grpc.ServerStream
}

func (x *securityV1AutoWatchSecurityGroupServer) Send(m *AutoMsgSecurityGroupWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityV1_AutoWatchSgpolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityV1Server).AutoWatchSgpolicy(m, &securityV1AutoWatchSgpolicyServer{stream})
}

type SecurityV1_AutoWatchSgpolicyServer interface {
	Send(*AutoMsgSgpolicyWatchHelper) error
	grpc.ServerStream
}

type securityV1AutoWatchSgpolicyServer struct {
	grpc.ServerStream
}

func (x *securityV1AutoWatchSgpolicyServer) Send(m *AutoMsgSgpolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

func _SecurityV1_AutoWatchTrafficEncryptionPolicy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(api.ListWatchOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SecurityV1Server).AutoWatchTrafficEncryptionPolicy(m, &securityV1AutoWatchTrafficEncryptionPolicyServer{stream})
}

type SecurityV1_AutoWatchTrafficEncryptionPolicyServer interface {
	Send(*AutoMsgTrafficEncryptionPolicyWatchHelper) error
	grpc.ServerStream
}

type securityV1AutoWatchTrafficEncryptionPolicyServer struct {
	grpc.ServerStream
}

func (x *securityV1AutoWatchTrafficEncryptionPolicyServer) Send(m *AutoMsgTrafficEncryptionPolicyWatchHelper) error {
	return x.ServerStream.SendMsg(m)
}

var _SecurityV1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "security.SecurityV1",
	HandlerType: (*SecurityV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AutoAddApp",
			Handler:    _SecurityV1_AutoAddApp_Handler,
		},
		{
			MethodName: "AutoAddAppUser",
			Handler:    _SecurityV1_AutoAddAppUser_Handler,
		},
		{
			MethodName: "AutoAddAppUserGrp",
			Handler:    _SecurityV1_AutoAddAppUserGrp_Handler,
		},
		{
			MethodName: "AutoAddCertificate",
			Handler:    _SecurityV1_AutoAddCertificate_Handler,
		},
		{
			MethodName: "AutoAddSecurityGroup",
			Handler:    _SecurityV1_AutoAddSecurityGroup_Handler,
		},
		{
			MethodName: "AutoAddSgpolicy",
			Handler:    _SecurityV1_AutoAddSgpolicy_Handler,
		},
		{
			MethodName: "AutoAddTrafficEncryptionPolicy",
			Handler:    _SecurityV1_AutoAddTrafficEncryptionPolicy_Handler,
		},
		{
			MethodName: "AutoDeleteApp",
			Handler:    _SecurityV1_AutoDeleteApp_Handler,
		},
		{
			MethodName: "AutoDeleteAppUser",
			Handler:    _SecurityV1_AutoDeleteAppUser_Handler,
		},
		{
			MethodName: "AutoDeleteAppUserGrp",
			Handler:    _SecurityV1_AutoDeleteAppUserGrp_Handler,
		},
		{
			MethodName: "AutoDeleteCertificate",
			Handler:    _SecurityV1_AutoDeleteCertificate_Handler,
		},
		{
			MethodName: "AutoDeleteSecurityGroup",
			Handler:    _SecurityV1_AutoDeleteSecurityGroup_Handler,
		},
		{
			MethodName: "AutoDeleteSgpolicy",
			Handler:    _SecurityV1_AutoDeleteSgpolicy_Handler,
		},
		{
			MethodName: "AutoDeleteTrafficEncryptionPolicy",
			Handler:    _SecurityV1_AutoDeleteTrafficEncryptionPolicy_Handler,
		},
		{
			MethodName: "AutoGetApp",
			Handler:    _SecurityV1_AutoGetApp_Handler,
		},
		{
			MethodName: "AutoGetAppUser",
			Handler:    _SecurityV1_AutoGetAppUser_Handler,
		},
		{
			MethodName: "AutoGetAppUserGrp",
			Handler:    _SecurityV1_AutoGetAppUserGrp_Handler,
		},
		{
			MethodName: "AutoGetCertificate",
			Handler:    _SecurityV1_AutoGetCertificate_Handler,
		},
		{
			MethodName: "AutoGetSecurityGroup",
			Handler:    _SecurityV1_AutoGetSecurityGroup_Handler,
		},
		{
			MethodName: "AutoGetSgpolicy",
			Handler:    _SecurityV1_AutoGetSgpolicy_Handler,
		},
		{
			MethodName: "AutoGetTrafficEncryptionPolicy",
			Handler:    _SecurityV1_AutoGetTrafficEncryptionPolicy_Handler,
		},
		{
			MethodName: "AutoListApp",
			Handler:    _SecurityV1_AutoListApp_Handler,
		},
		{
			MethodName: "AutoListAppUser",
			Handler:    _SecurityV1_AutoListAppUser_Handler,
		},
		{
			MethodName: "AutoListAppUserGrp",
			Handler:    _SecurityV1_AutoListAppUserGrp_Handler,
		},
		{
			MethodName: "AutoListCertificate",
			Handler:    _SecurityV1_AutoListCertificate_Handler,
		},
		{
			MethodName: "AutoListSecurityGroup",
			Handler:    _SecurityV1_AutoListSecurityGroup_Handler,
		},
		{
			MethodName: "AutoListSgpolicy",
			Handler:    _SecurityV1_AutoListSgpolicy_Handler,
		},
		{
			MethodName: "AutoListTrafficEncryptionPolicy",
			Handler:    _SecurityV1_AutoListTrafficEncryptionPolicy_Handler,
		},
		{
			MethodName: "AutoUpdateApp",
			Handler:    _SecurityV1_AutoUpdateApp_Handler,
		},
		{
			MethodName: "AutoUpdateAppUser",
			Handler:    _SecurityV1_AutoUpdateAppUser_Handler,
		},
		{
			MethodName: "AutoUpdateAppUserGrp",
			Handler:    _SecurityV1_AutoUpdateAppUserGrp_Handler,
		},
		{
			MethodName: "AutoUpdateCertificate",
			Handler:    _SecurityV1_AutoUpdateCertificate_Handler,
		},
		{
			MethodName: "AutoUpdateSecurityGroup",
			Handler:    _SecurityV1_AutoUpdateSecurityGroup_Handler,
		},
		{
			MethodName: "AutoUpdateSgpolicy",
			Handler:    _SecurityV1_AutoUpdateSgpolicy_Handler,
		},
		{
			MethodName: "AutoUpdateTrafficEncryptionPolicy",
			Handler:    _SecurityV1_AutoUpdateTrafficEncryptionPolicy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AutoWatchApp",
			Handler:       _SecurityV1_AutoWatchApp_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchAppUser",
			Handler:       _SecurityV1_AutoWatchAppUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchAppUserGrp",
			Handler:       _SecurityV1_AutoWatchAppUserGrp_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchCertificate",
			Handler:       _SecurityV1_AutoWatchCertificate_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchSecurityGroup",
			Handler:       _SecurityV1_AutoWatchSecurityGroup_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchSgpolicy",
			Handler:       _SecurityV1_AutoWatchSgpolicy_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AutoWatchTrafficEncryptionPolicy",
			Handler:       _SecurityV1_AutoWatchTrafficEncryptionPolicy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "svc_security.proto",
}

func (m *AppList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.ListMeta.Size()))
	n2, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcSecurity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppUserGrpList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppUserGrpList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.TypeMeta.Size()))
	n3, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.ListMeta.Size()))
	n4, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcSecurity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AppUserList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppUserList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.ListMeta.Size()))
	n6, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcSecurity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AutoMsgAppUserGrpWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAppUserGrpWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(m.Object.Size()))
		n7, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *AutoMsgAppUserWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAppUserWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(m.Object.Size()))
		n8, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *AutoMsgAppWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgAppWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(m.Object.Size()))
		n9, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *AutoMsgCertificateWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgCertificateWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(m.Object.Size()))
		n10, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *AutoMsgSecurityGroupWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgSecurityGroupWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(m.Object.Size()))
		n11, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *AutoMsgSgpolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgSgpolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(m.Object.Size()))
		n12, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Object != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSvcSecurity(dAtA, i, uint64(m.Object.Size()))
		n13, err := m.Object.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *CertificateList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertificateList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.TypeMeta.Size()))
	n14, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.ListMeta.Size()))
	n15, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcSecurity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SecurityGroupList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityGroupList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.TypeMeta.Size()))
	n16, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.ListMeta.Size()))
	n17, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcSecurity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SgpolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SgpolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.TypeMeta.Size()))
	n18, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.ListMeta.Size()))
	n19, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcSecurity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TrafficEncryptionPolicyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficEncryptionPolicyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.TypeMeta.Size()))
	n20, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x1a
	i++
	i = encodeVarintSvcSecurity(dAtA, i, uint64(m.ListMeta.Size()))
	n21, err := m.ListMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintSvcSecurity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintSvcSecurity(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AppList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcSecurity(uint64(l))
		}
	}
	return n
}

func (m *AppUserGrpList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcSecurity(uint64(l))
		}
	}
	return n
}

func (m *AppUserList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcSecurity(uint64(l))
		}
	}
	return n
}

func (m *AutoMsgAppUserGrpWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	return n
}

func (m *AutoMsgAppUserWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	return n
}

func (m *AutoMsgAppWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	return n
}

func (m *AutoMsgCertificateWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	return n
}

func (m *AutoMsgSecurityGroupWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	return n
}

func (m *AutoMsgSgpolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	return n
}

func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovSvcSecurity(uint64(l))
	}
	return n
}

func (m *CertificateList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcSecurity(uint64(l))
		}
	}
	return n
}

func (m *SecurityGroupList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcSecurity(uint64(l))
		}
	}
	return n
}

func (m *SgpolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcSecurity(uint64(l))
		}
	}
	return n
}

func (m *TrafficEncryptionPolicyList) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	l = m.ListMeta.Size()
	n += 1 + l + sovSvcSecurity(uint64(l))
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovSvcSecurity(uint64(l))
		}
	}
	return n
}

func sovSvcSecurity(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSvcSecurity(x uint64) (n int) {
	return sovSvcSecurity(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &App{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppUserGrpList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppUserGrpList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppUserGrpList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AppUserGrp{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppUserList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppUserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppUserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AppUser{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAppUserGrpWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAppUserGrpWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAppUserGrpWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &AppUserGrp{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAppUserWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAppUserWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAppUserWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &AppUser{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgAppWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgAppWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgAppWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &App{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgCertificateWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgCertificateWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgCertificateWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Certificate{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgSecurityGroupWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgSecurityGroupWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgSecurityGroupWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &SecurityGroup{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgSgpolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgSgpolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgSgpolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &Sgpolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AutoMsgTrafficEncryptionPolicyWatchHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AutoMsgTrafficEncryptionPolicyWatchHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AutoMsgTrafficEncryptionPolicyWatchHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &TrafficEncryptionPolicy{}
			}
			if err := m.Object.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertificateList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Certificate{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityGroupList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityGroupList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityGroupList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SecurityGroup{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SgpolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SgpolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SgpolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Sgpolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficEncryptionPolicyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficEncryptionPolicyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficEncryptionPolicyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &TrafficEncryptionPolicy{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSvcSecurity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSvcSecurity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSvcSecurity(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSvcSecurity
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSvcSecurity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSvcSecurity
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSvcSecurity
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSvcSecurity(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSvcSecurity = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSvcSecurity   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("svc_security.proto", fileDescriptorSvcSecurity) }

var fileDescriptorSvcSecurity = []byte{
	// 1667 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x99, 0xcd, 0x6f, 0x13, 0xc7,
	0x1b, 0xc7, 0xb3, 0x24, 0x40, 0x98, 0xbc, 0x00, 0x43, 0x42, 0xb2, 0xce, 0xfb, 0x26, 0x21, 0x21,
	0x90, 0x38, 0x21, 0xf0, 0x03, 0x02, 0x3f, 0x68, 0xa0, 0xd4, 0xad, 0x54, 0x0a, 0x55, 0x03, 0x9c,
	0x2a, 0xb4, 0xd9, 0x4c, 0x9c, 0x05, 0xc7, 0xbb, 0xda, 0x1d, 0x27, 0x44, 0x34, 0x6a, 0x85, 0x43,
	0x2f, 0xad, 0xaa, 0xaa, 0xad, 0x7a, 0xe0, 0x98, 0x43, 0x2b, 0x51, 0xa9, 0x52, 0x73, 0xea, 0xb5,
	0x37, 0x8e, 0x48, 0xbd, 0x71, 0x40, 0x15, 0xea, 0x1f, 0x52, 0xcd, 0xcb, 0x7a, 0x5f, 0x66, 0xc6,
	0x6b, 0x83, 0x7c, 0xb3, 0xc7, 0xcf, 0x3c, 0x9f, 0xef, 0xce, 0x3e, 0xdf, 0x79, 0x26, 0x13, 0x00,
	0xfd, 0x0d, 0xeb, 0xbe, 0x8f, 0xac, 0x92, 0x67, 0xe3, 0xad, 0x19, 0xd7, 0x73, 0xb0, 0x03, 0x5b,
	0x83, 0xef, 0x99, 0xfe, 0xbc, 0xe3, 0xe4, 0x0b, 0x28, 0x6b, 0xba, 0x76, 0xd6, 0x2c, 0x16, 0x1d,
	0x6c, 0x62, 0xdb, 0x29, 0xfa, 0x2c, 0x2e, 0x73, 0x23, 0x6f, 0xe3, 0xb5, 0xd2, 0xf2, 0x8c, 0xe5,
	0xac, 0x67, 0x5d, 0x54, 0xf4, 0xcd, 0xe2, 0x8a, 0x93, 0xf5, 0x37, 0xb3, 0x1b, 0xa8, 0x68, 0x5b,
	0x28, 0x5b, 0xc2, 0x76, 0xc1, 0x27, 0x53, 0xf3, 0xa8, 0x18, 0x9d, 0x9d, 0xb5, 0x8b, 0x56, 0xa1,
	0xb4, 0x82, 0x82, 0x34, 0xd3, 0x91, 0x34, 0x79, 0x27, 0xef, 0x64, 0xe9, 0xf0, 0x72, 0x69, 0x95,
	0x7e, 0xa3, 0x5f, 0xe8, 0x27, 0x1e, 0x3e, 0xae, 0xa0, 0x12, 0x8d, 0xeb, 0x08, 0x9b, 0x3c, 0x6c,
	0xb6, 0x4a, 0x58, 0xc1, 0x5c, 0x46, 0x05, 0x3f, 0xeb, 0xa3, 0x02, 0xb2, 0xb0, 0xe3, 0xf1, 0x19,
	0x9d, 0x7e, 0xde, 0x75, 0x0a, 0xb6, 0xc5, 0x97, 0x21, 0x73, 0x2c, 0x58, 0x86, 0xbc, 0xe7, 0x94,
	0x5c, 0x3e, 0x78, 0xc8, 0x74, 0x83, 0x8f, 0xe0, 0xd1, 0xb9, 0xd9, 0x8b, 0xfc, 0x73, 0x4f, 0x11,
	0xe1, 0x4d, 0xc7, 0x7b, 0x88, 0x8a, 0x96, 0xb7, 0xe5, 0x92, 0xc7, 0x64, 0x3f, 0x18, 0x5f, 0x6b,
	0xe0, 0xe0, 0xa2, 0xeb, 0x7e, 0x6c, 0xfb, 0x18, 0x1a, 0x40, 0x5b, 0xea, 0xdd, 0x37, 0xac, 0x4d,
	0xb6, 0x9d, 0xe9, 0x98, 0x31, 0x5d, 0x7b, 0x66, 0x69, 0xcb, 0x45, 0x37, 0x11, 0x36, 0xaf, 0xb5,
	0xbe, 0x78, 0x3d, 0xd4, 0xf4, 0xf2, 0xf5, 0x90, 0x06, 0x4f, 0x82, 0x56, 0x12, 0x4b, 0x46, 0x7b,
	0x9b, 0x23, 0xa1, 0xc1, 0x60, 0x24, 0xb4, 0x1f, 0xec, 0xff, 0x08, 0xa3, 0x75, 0xbf, 0xb7, 0x65,
	0xb8, 0x99, 0xc6, 0x55, 0x5e, 0xe3, 0xa2, 0xeb, 0x2e, 0x74, 0xbe, 0x7a, 0xaa, 0x83, 0x82, 0xed,
	0xe3, 0x35, 0x54, 0x70, 0x91, 0x67, 0xfc, 0xa4, 0x81, 0xce, 0x45, 0xd7, 0xbd, 0xe3, 0x23, 0x2f,
	0xe7, 0x35, 0x44, 0xcf, 0x68, 0x5c, 0x4f, 0x57, 0x4c, 0x0f, 0xe7, 0x0a, 0xb2, 0xbe, 0xd3, 0x40,
	0x1b, 0xff, 0xb9, 0x11, 0x9a, 0x86, 0xe3, 0x9a, 0x8e, 0x0a, 0x9a, 0x04, 0x41, 0x16, 0xe8, 0x5f,
	0x2c, 0x61, 0xe7, 0xa6, 0x9f, 0x0f, 0x55, 0xdf, 0x33, 0xb1, 0xb5, 0xf6, 0x21, 0xfd, 0x1d, 0xb6,
	0x83, 0x16, 0x22, 0xa9, 0x57, 0x1b, 0xd6, 0x26, 0x0f, 0xc1, 0x31, 0x70, 0xe0, 0xd6, 0xf2, 0x03,
	0x64, 0x61, 0xae, 0x59, 0xfe, 0xd0, 0x87, 0x5f, 0x3d, 0xd5, 0xdb, 0x36, 0x49, 0x12, 0x0e, 0xf9,
	0x1c, 0xe8, 0x71, 0x88, 0x9a, 0x30, 0x92, 0x20, 0x48, 0x1e, 0x41, 0x48, 0x7f, 0x07, 0x74, 0x87,
	0xe9, 0xd5, 0xa9, 0x07, 0x12, 0xa9, 0x13, 0x15, 0x24, 0xa4, 0x45, 0x60, 0x80, 0xa7, 0xbd, 0x8e,
	0x3c, 0x6c, 0xaf, 0xda, 0x96, 0x89, 0x91, 0x3a, 0xfd, 0x78, 0x22, 0x7d, 0x77, 0x98, 0x3e, 0x32,
	0x5f, 0xc4, 0xd8, 0x60, 0x88, 0x63, 0x3e, 0xe3, 0xf1, 0x39, 0x62, 0x40, 0x35, 0x68, 0x22, 0x01,
	0xea, 0x09, 0x41, 0xb1, 0x0c, 0x22, 0xea, 0x3e, 0xc8, 0x04, 0x28, 0xee, 0x7d, 0x35, 0xc5, 0x48,
	0x50, 0x60, 0x84, 0xc2, 0x27, 0x8b, 0x80, 0x6d, 0x70, 0x92, 0x03, 0x96, 0x3c, 0x73, 0x75, 0xd5,
	0xb6, 0x6e, 0x54, 0x36, 0x88, 0xdb, 0x29, 0xbc, 0xb9, 0x04, 0x6f, 0x24, 0xe4, 0x29, 0x72, 0x89,
	0xf8, 0x9f, 0x35, 0x70, 0x38, 0xb2, 0xd6, 0x8d, 0x70, 0xd8, 0x58, 0xdc, 0x61, 0x8a, 0x97, 0x9c,
	0x74, 0xd9, 0x33, 0x0d, 0x1c, 0x8d, 0xbd, 0x9b, 0x46, 0x48, 0x3b, 0x11, 0x97, 0xa6, 0x2c, 0x8b,
	0xa4, 0xb8, 0xef, 0x35, 0xd0, 0x1e, 0xbc, 0xd2, 0x46, 0xe8, 0x1a, 0x89, 0xeb, 0x92, 0x15, 0x52,
	0x52, 0xd2, 0xef, 0x1a, 0xe8, 0x53, 0xbc, 0xf5, 0x46, 0x28, 0x9c, 0x8d, 0x2b, 0xac, 0xa1, 0xf4,
	0x12, 0x82, 0xcf, 0xfc, 0x35, 0x05, 0x40, 0xb0, 0xca, 0x77, 0xe7, 0xe0, 0x02, 0x00, 0xc4, 0x07,
	0x8b, 0x2b, 0x2b, 0x8b, 0xae, 0x0b, 0xe3, 0x1b, 0x4d, 0x26, 0xfe, 0xd5, 0xe8, 0xdc, 0xdb, 0xd1,
	0x0f, 0x58, 0x1e, 0x32, 0x31, 0xfa, 0x73, 0x47, 0xd7, 0xe0, 0x1a, 0xe8, 0x0c, 0xe7, 0x92, 0x0d,
	0x0f, 0x8a, 0x7b, 0x60, 0x46, 0x1c, 0x32, 0x66, 0xe3, 0x79, 0x9e, 0xfc, 0xfd, 0xef, 0x8f, 0xfb,
	0xfa, 0x41, 0xd3, 0x82, 0x36, 0x65, 0x74, 0x67, 0x1f, 0xdf, 0x9a, 0x59, 0x42, 0x45, 0xb3, 0x88,
	0xb7, 0xb3, 0xa6, 0xeb, 0x4e, 0x97, 0x7c, 0xe4, 0xf9, 0xf0, 0x11, 0x38, 0x1a, 0x27, 0xe5, 0x3c,
	0x17, 0x4a, 0xb7, 0xf4, 0x8c, 0x74, 0xd4, 0x38, 0x2f, 0x41, 0x8e, 0x32, 0x64, 0xbf, 0x14, 0x39,
	0x4d, 0xcf, 0x16, 0x3e, 0xdc, 0x04, 0x90, 0x93, 0x23, 0xae, 0x81, 0x72, 0x33, 0x65, 0xe4, 0xc3,
	0xc6, 0xbc, 0x04, 0x3e, 0xc4, 0xe0, 0xbd, 0x51, 0xb8, 0x15, 0xce, 0xf1, 0xe1, 0x57, 0x1a, 0xe8,
	0xe2, 0xe4, 0x98, 0x29, 0xa0, 0xca, 0x2d, 0x19, 0xd5, 0x0f, 0xc6, 0xff, 0x24, 0x7c, 0x83, 0xf1,
	0xfb, 0xa2, 0xfc, 0x60, 0x7a, 0xf0, 0xec, 0x0f, 0xc0, 0xe1, 0x40, 0x01, 0x2f, 0x7f, 0x28, 0xb1,
	0x44, 0x46, 0x32, 0x66, 0x64, 0x25, 0xc8, 0x3e, 0x86, 0xec, 0x8a, 0x21, 0x83, 0xc4, 0xbf, 0x68,
	0x60, 0x90, 0xc3, 0x14, 0x95, 0x0c, 0xd3, 0x8b, 0x3d, 0x93, 0x1e, 0x62, 0x5c, 0x91, 0x28, 0x9b,
	0x62, 0xca, 0x46, 0xa3, 0xca, 0xb0, 0x42, 0xc5, 0xff, 0x41, 0x07, 0xd1, 0xf9, 0x3e, 0x2a, 0x20,
	0x8c, 0x6a, 0xf4, 0xcc, 0x0a, 0x0d, 0xa6, 0x9e, 0xf1, 0x59, 0x25, 0x57, 0xa6, 0xd7, 0x61, 0x9b,
	0x0b, 0xf1, 0x54, 0x54, 0xf9, 0x18, 0x68, 0x5a, 0x68, 0x9a, 0x1a, 0x94, 0x96, 0x30, 0x19, 0xfc,
	0xc4, 0x5c, 0x47, 0xdb, 0xb0, 0xcc, 0x6b, 0x29, 0x46, 0xad, 0xd7, 0x42, 0x57, 0x25, 0xf8, 0x53,
	0x14, 0x3f, 0x5e, 0xcd, 0x41, 0xa1, 0x8a, 0x27, 0x1a, 0x3b, 0xfd, 0x30, 0x15, 0x6f, 0x6f, 0xa7,
	0x4b, 0x12, 0x21, 0x13, 0x54, 0xc8, 0x88, 0xca, 0x4d, 0xa1, 0x88, 0x6f, 0x34, 0xd0, 0x13, 0x8a,
	0x78, 0x57, 0x67, 0x5d, 0x91, 0x48, 0x99, 0xa2, 0x52, 0xc6, 0xaa, 0x18, 0x2b, 0x54, 0x53, 0x62,
	0xbb, 0x0b, 0x17, 0x53, 0xaf, 0xc9, 0xce, 0x4b, 0xe8, 0xa3, 0x94, 0x3e, 0x20, 0xf3, 0x58, 0x88,
	0xfd, 0x43, 0x03, 0x23, 0x21, 0xb7, 0xb1, 0x7e, 0xfb, 0x40, 0x22, 0xf2, 0x0c, 0x15, 0x79, 0xba,
	0x06, 0xbb, 0x85, 0x9a, 0x3f, 0x65, 0x8d, 0x2a, 0x87, 0x70, 0xba, 0xe9, 0xc6, 0xf7, 0x76, 0xf4,
	0xe6, 0x3c, 0xc2, 0x15, 0x60, 0x17, 0x01, 0xc2, 0x4e, 0x52, 0x9c, 0x91, 0xd5, 0x5f, 0x67, 0xfd,
	0x8b, 0xa5, 0xac, 0xc3, 0x88, 0xe7, 0x92, 0xe9, 0xa9, 0x0b, 0x61, 0x9a, 0x0b, 0xb7, 0x99, 0xf5,
	0x43, 0x5c, 0xbd, 0x0e, 0xbc, 0x9c, 0xe4, 0x52, 0xfb, 0xc1, 0x1a, 0xed, 0xf7, 0x05, 0xab, 0xb5,
	0x1c, 0xc2, 0x6f, 0x6f, 0xbd, 0x0b, 0x49, 0x05, 0xd4, 0x77, 0xb0, 0x06, 0xdf, 0x3d, 0xe5, 0x5b,
	0x50, 0x0e, 0xe1, 0x77, 0x35, 0xdd, 0xa5, 0xa4, 0x08, 0xea, 0x38, 0x58, 0x9b, 0xe3, 0x1c, 0xd6,
	0xd3, 0x88, 0x8c, 0x7a, 0xed, 0x76, 0x36, 0xc9, 0xa5, 0x5e, 0x83, 0x29, 0x5e, 0xfb, 0x8d, 0x37,
	0xb6, 0x1c, 0xc2, 0x8d, 0x35, 0xda, 0xf5, 0xa4, 0x3c, 0xea, 0x32, 0x58, 0x9f, 0xcb, 0xee, 0x82,
	0x36, 0x22, 0x96, 0x9c, 0x3c, 0x89, 0xcd, 0xba, 0x2b, 0xe7, 0x50, 0xfa, 0xe7, 0xd0, 0x2d, 0x3a,
	0xc7, 0x4f, 0x78, 0x82, 0xfc, 0x6c, 0x0c, 0xec, 0xed, 0xe8, 0x2d, 0xe4, 0x98, 0x59, 0xc1, 0xb7,
	0x51, 0xfc, 0x7e, 0xea, 0x39, 0x58, 0x64, 0xcb, 0xce, 0xf3, 0x52, 0xaf, 0x29, 0x72, 0x77, 0x0b,
	0xa5, 0x4f, 0xf3, 0x4f, 0x0b, 0xf9, 0xfb, 0x68, 0x7e, 0xc5, 0x81, 0xf1, 0x31, 0x2b, 0xf6, 0x08,
	0x8f, 0x98, 0x4d, 0x81, 0xec, 0x95, 0xb9, 0x8d, 0x52, 0xcf, 0x0a, 0x54, 0x83, 0x52, 0xab, 0x9f,
	0x19, 0xb7, 0xc0, 0xb1, 0x00, 0x1e, 0xb7, 0x9a, 0x94, 0xae, 0x4b, 0xad, 0x46, 0xf1, 0xb3, 0x02,
	0x7e, 0x90, 0xe2, 0xab, 0x9e, 0x1a, 0xbb, 0x03, 0x76, 0xdc, 0x67, 0x0a, 0x7a, 0x9f, 0xc2, 0x65,
	0x94, 0x3f, 0x2f, 0xf0, 0x47, 0x28, 0xbf, 0xea, 0xa9, 0xd1, 0x01, 0x47, 0x2a, 0x0a, 0x02, 0x8b,
	0x29, 0xe0, 0xc7, 0x45, 0x97, 0x51, 0xee, 0x69, 0x81, 0x9b, 0xa1, 0x5c, 0xf9, 0xd1, 0x71, 0x9d,
	0x5d, 0x4b, 0x90, 0x99, 0x2a, 0x87, 0x29, 0xf8, 0xe3, 0xa9, 0xae, 0xa2, 0x72, 0xda, 0xa3, 0x72,
	0x82, 0x03, 0xe0, 0x1d, 0x77, 0xc5, 0xac, 0xf9, 0x00, 0x58, 0xa2, 0xc1, 0x74, 0x3a, 0x66, 0x5d,
	0xa0, 0x32, 0xbd, 0x8e, 0xbe, 0x73, 0x31, 0x9e, 0x8a, 0x2e, 0xcc, 0x38, 0x3d, 0xba, 0x66, 0xd2,
	0x7a, 0xcf, 0x0e, 0xdf, 0x7e, 0x63, 0xd8, 0x7a, 0xfb, 0xcf, 0x7b, 0x12, 0xfe, 0x69, 0xc6, 0xaf,
	0xb1, 0x07, 0x95, 0x79, 0x79, 0x32, 0x19, 0x6f, 0xdf, 0x87, 0x2e, 0x4b, 0x94, 0x4c, 0x32, 0x25,
	0x35, 0xf4, 0xa2, 0x6f, 0xf9, 0x19, 0x90, 0xa9, 0x78, 0xd7, 0x76, 0x74, 0x55, 0xa2, 0xe5, 0x14,
	0xd3, 0x52, 0x5b, 0x4b, 0xda, 0x60, 0x7b, 0x15, 0x57, 0x53, 0x6f, 0x57, 0xba, 0x20, 0xc1, 0x8f,
	0x31, 0x7c, 0x4a, 0x67, 0xda, 0xe3, 0xa7, 0x40, 0x06, 0x6e, 0x6c, 0x73, 0xca, 0x49, 0x54, 0xce,
	0x33, 0x95, 0xf5, 0x35, 0xa8, 0x7b, 0xa0, 0x9d, 0x68, 0xa6, 0x36, 0xae, 0xd2, 0xa1, 0x86, 0x22,
	0x05, 0x2c, 0xbb, 0x70, 0x35, 0x3a, 0xf6, 0x76, 0xf4, 0xfd, 0xf4, 0x46, 0x8e, 0xe8, 0x99, 0xd5,
	0xe0, 0x7d, 0xb6, 0x6d, 0x05, 0x89, 0xab, 0xb5, 0xa8, 0x51, 0x59, 0xf2, 0xc4, 0x65, 0xb1, 0x08,
	0x40, 0xac, 0x2b, 0x44, 0x01, 0x55, 0x7a, 0xd2, 0x09, 0x15, 0x23, 0x7e, 0xeb, 0x2d, 0x62, 0xf2,
	0xcc, 0xe8, 0x34, 0xa6, 0x86, 0xee, 0x33, 0x21, 0x70, 0xe4, 0x57, 0xc8, 0x22, 0xe8, 0x21, 0x38,
	0x5e, 0x01, 0xd5, 0xd4, 0x6a, 0x4e, 0x0a, 0x28, 0xd5, 0x35, 0xb2, 0x08, 0x33, 0xd9, 0xae, 0xc9,
	0x60, 0x29, 0x5d, 0x65, 0x4c, 0xe4, 0x88, 0x77, 0xc8, 0x22, 0xe2, 0x4b, 0x30, 0x5c, 0x41, 0xd4,
	0xd9, 0x47, 0xe6, 0x05, 0x62, 0xfa, 0xa5, 0xb2, 0x20, 0x20, 0xf3, 0x6b, 0xf3, 0x0f, 0x65, 0x7d,
	0xdf, 0xc6, 0xdc, 0xb3, 0xb2, 0x5e, 0xf9, 0x47, 0xdf, 0x6e, 0x59, 0xef, 0x88, 0xad, 0xd2, 0x6e,
	0x59, 0x6f, 0x0d, 0x1e, 0x67, 0xb7, 0xac, 0x37, 0x2f, 0xba, 0x64, 0xe8, 0x20, 0x2f, 0x8e, 0xdd,
	0xb2, 0x0e, 0xc2, 0x3a, 0xd9, 0x2d, 0xeb, 0x6d, 0x91, 0xb7, 0xb9, 0x5b, 0xd6, 0x7b, 0x14, 0xba,
	0x9e, 0x97, 0xf5, 0x69, 0x10, 0x07, 0x41, 0x72, 0x96, 0x84, 0xcd, 0x6e, 0x09, 0x43, 0xfe, 0xe7,
	0x1b, 0x6c, 0x71, 0x1d, 0x1f, 0x43, 0xda, 0x09, 0x9f, 0x97, 0xf5, 0x49, 0x50, 0x11, 0x92, 0x1a,
	0x7b, 0x04, 0x10, 0xa1, 0x2c, 0x2c, 0x18, 0x9b, 0x00, 0x81, 0xea, 0xd4, 0xe9, 0x53, 0x20, 0xf2,
	0x54, 0xa9, 0xd1, 0xa7, 0x40, 0xf4, 0xa9, 0x53, 0xc3, 0xe7, 0x80, 0x6a, 0x55, 0x54, 0x53, 0xaf,
	0xb5, 0xbf, 0x78, 0x33, 0xa8, 0xbd, 0x7c, 0x33, 0xa8, 0xfd, 0xf3, 0x66, 0x50, 0xbb, 0xad, 0x2d,
	0x1f, 0xa0, 0xff, 0x52, 0x9c, 0xff, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x7c, 0xff, 0x72, 0x57, 0xb4,
	0x1d, 0x00, 0x00,
}
