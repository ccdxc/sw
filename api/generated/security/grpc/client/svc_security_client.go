// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"
	"net/http"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	security "github.com/pensando/sw/api/generated/security"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewSecurityV1 sets up a new client for SecurityV1
func NewSecurityV1(conn *grpc.ClientConn, logger log.Logger) security.ServiceSecurityV1Client {

	var lAutoAddAppEndpoint endpoint.Endpoint
	{
		lAutoAddAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddApp")(lAutoAddAppEndpoint)
	}
	var lAutoAddCertificateEndpoint endpoint.Endpoint
	{
		lAutoAddCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddCertificate")(lAutoAddCertificateEndpoint)
	}
	var lAutoAddFirewallProfileEndpoint endpoint.Endpoint
	{
		lAutoAddFirewallProfileEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddFirewallProfile",
			security.EncodeGrpcReqFirewallProfile,
			security.DecodeGrpcRespFirewallProfile,
			&security.FirewallProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddFirewallProfileEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddFirewallProfile")(lAutoAddFirewallProfileEndpoint)
	}
	var lAutoAddSGPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddSGPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddSGPolicy",
			security.EncodeGrpcReqSGPolicy,
			security.DecodeGrpcRespSGPolicy,
			&security.SGPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSGPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddSGPolicy")(lAutoAddSGPolicyEndpoint)
	}
	var lAutoAddSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoAddSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddSecurityGroup")(lAutoAddSecurityGroupEndpoint)
	}
	var lAutoAddTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoAddTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoAddTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoAddTrafficEncryptionPolicy")(lAutoAddTrafficEncryptionPolicyEndpoint)
	}
	var lAutoDeleteAppEndpoint endpoint.Endpoint
	{
		lAutoDeleteAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteApp")(lAutoDeleteAppEndpoint)
	}
	var lAutoDeleteCertificateEndpoint endpoint.Endpoint
	{
		lAutoDeleteCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteCertificate")(lAutoDeleteCertificateEndpoint)
	}
	var lAutoDeleteFirewallProfileEndpoint endpoint.Endpoint
	{
		lAutoDeleteFirewallProfileEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteFirewallProfile",
			security.EncodeGrpcReqFirewallProfile,
			security.DecodeGrpcRespFirewallProfile,
			&security.FirewallProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteFirewallProfileEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteFirewallProfile")(lAutoDeleteFirewallProfileEndpoint)
	}
	var lAutoDeleteSGPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteSGPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteSGPolicy",
			security.EncodeGrpcReqSGPolicy,
			security.DecodeGrpcRespSGPolicy,
			&security.SGPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSGPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteSGPolicy")(lAutoDeleteSGPolicyEndpoint)
	}
	var lAutoDeleteSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoDeleteSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteSecurityGroup")(lAutoDeleteSecurityGroupEndpoint)
	}
	var lAutoDeleteTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoDeleteTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoDeleteTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoDeleteTrafficEncryptionPolicy")(lAutoDeleteTrafficEncryptionPolicyEndpoint)
	}
	var lAutoGetAppEndpoint endpoint.Endpoint
	{
		lAutoGetAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetApp")(lAutoGetAppEndpoint)
	}
	var lAutoGetCertificateEndpoint endpoint.Endpoint
	{
		lAutoGetCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetCertificate")(lAutoGetCertificateEndpoint)
	}
	var lAutoGetFirewallProfileEndpoint endpoint.Endpoint
	{
		lAutoGetFirewallProfileEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetFirewallProfile",
			security.EncodeGrpcReqFirewallProfile,
			security.DecodeGrpcRespFirewallProfile,
			&security.FirewallProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetFirewallProfileEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetFirewallProfile")(lAutoGetFirewallProfileEndpoint)
	}
	var lAutoGetSGPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetSGPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetSGPolicy",
			security.EncodeGrpcReqSGPolicy,
			security.DecodeGrpcRespSGPolicy,
			&security.SGPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSGPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetSGPolicy")(lAutoGetSGPolicyEndpoint)
	}
	var lAutoGetSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoGetSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetSecurityGroup")(lAutoGetSecurityGroupEndpoint)
	}
	var lAutoGetTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoGetTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoGetTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoGetTrafficEncryptionPolicy")(lAutoGetTrafficEncryptionPolicyEndpoint)
	}
	var lAutoListAppEndpoint endpoint.Endpoint
	{
		lAutoListAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListApp",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespAppList,
			&security.AppList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoListApp")(lAutoListAppEndpoint)
	}
	var lAutoListCertificateEndpoint endpoint.Endpoint
	{
		lAutoListCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListCertificate",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespCertificateList,
			&security.CertificateList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoListCertificate")(lAutoListCertificateEndpoint)
	}
	var lAutoListFirewallProfileEndpoint endpoint.Endpoint
	{
		lAutoListFirewallProfileEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListFirewallProfile",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespFirewallProfileList,
			&security.FirewallProfileList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListFirewallProfileEndpoint = trace.ClientEndPoint("SecurityV1:AutoListFirewallProfile")(lAutoListFirewallProfileEndpoint)
	}
	var lAutoListSGPolicyEndpoint endpoint.Endpoint
	{
		lAutoListSGPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListSGPolicy",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespSGPolicyList,
			&security.SGPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSGPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoListSGPolicy")(lAutoListSGPolicyEndpoint)
	}
	var lAutoListSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoListSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListSecurityGroup",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespSecurityGroupList,
			&security.SecurityGroupList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoListSecurityGroup")(lAutoListSecurityGroupEndpoint)
	}
	var lAutoListTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoListTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoListTrafficEncryptionPolicy",
			security.EncodeGrpcReqListWatchOptions,
			security.DecodeGrpcRespTrafficEncryptionPolicyList,
			&security.TrafficEncryptionPolicyList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoListTrafficEncryptionPolicy")(lAutoListTrafficEncryptionPolicyEndpoint)
	}
	var lAutoUpdateAppEndpoint endpoint.Endpoint
	{
		lAutoUpdateAppEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateApp",
			security.EncodeGrpcReqApp,
			security.DecodeGrpcRespApp,
			&security.App{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateAppEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateApp")(lAutoUpdateAppEndpoint)
	}
	var lAutoUpdateCertificateEndpoint endpoint.Endpoint
	{
		lAutoUpdateCertificateEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateCertificate",
			security.EncodeGrpcReqCertificate,
			security.DecodeGrpcRespCertificate,
			&security.Certificate{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateCertificateEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateCertificate")(lAutoUpdateCertificateEndpoint)
	}
	var lAutoUpdateFirewallProfileEndpoint endpoint.Endpoint
	{
		lAutoUpdateFirewallProfileEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateFirewallProfile",
			security.EncodeGrpcReqFirewallProfile,
			security.DecodeGrpcRespFirewallProfile,
			&security.FirewallProfile{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateFirewallProfileEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateFirewallProfile")(lAutoUpdateFirewallProfileEndpoint)
	}
	var lAutoUpdateSGPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateSGPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateSGPolicy",
			security.EncodeGrpcReqSGPolicy,
			security.DecodeGrpcRespSGPolicy,
			&security.SGPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSGPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateSGPolicy")(lAutoUpdateSGPolicyEndpoint)
	}
	var lAutoUpdateSecurityGroupEndpoint endpoint.Endpoint
	{
		lAutoUpdateSecurityGroupEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateSecurityGroup",
			security.EncodeGrpcReqSecurityGroup,
			security.DecodeGrpcRespSecurityGroup,
			&security.SecurityGroup{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateSecurityGroupEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateSecurityGroup")(lAutoUpdateSecurityGroupEndpoint)
	}
	var lAutoUpdateTrafficEncryptionPolicyEndpoint endpoint.Endpoint
	{
		lAutoUpdateTrafficEncryptionPolicyEndpoint = grpctransport.NewClient(
			conn,
			"security.SecurityV1",
			"AutoUpdateTrafficEncryptionPolicy",
			security.EncodeGrpcReqTrafficEncryptionPolicy,
			security.DecodeGrpcRespTrafficEncryptionPolicy,
			&security.TrafficEncryptionPolicy{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateTrafficEncryptionPolicyEndpoint = trace.ClientEndPoint("SecurityV1:AutoUpdateTrafficEncryptionPolicy")(lAutoUpdateTrafficEncryptionPolicyEndpoint)
	}
	return security.EndpointsSecurityV1Client{
		Client: security.NewSecurityV1Client(conn),

		AutoAddAppEndpoint:                        lAutoAddAppEndpoint,
		AutoAddCertificateEndpoint:                lAutoAddCertificateEndpoint,
		AutoAddFirewallProfileEndpoint:            lAutoAddFirewallProfileEndpoint,
		AutoAddSGPolicyEndpoint:                   lAutoAddSGPolicyEndpoint,
		AutoAddSecurityGroupEndpoint:              lAutoAddSecurityGroupEndpoint,
		AutoAddTrafficEncryptionPolicyEndpoint:    lAutoAddTrafficEncryptionPolicyEndpoint,
		AutoDeleteAppEndpoint:                     lAutoDeleteAppEndpoint,
		AutoDeleteCertificateEndpoint:             lAutoDeleteCertificateEndpoint,
		AutoDeleteFirewallProfileEndpoint:         lAutoDeleteFirewallProfileEndpoint,
		AutoDeleteSGPolicyEndpoint:                lAutoDeleteSGPolicyEndpoint,
		AutoDeleteSecurityGroupEndpoint:           lAutoDeleteSecurityGroupEndpoint,
		AutoDeleteTrafficEncryptionPolicyEndpoint: lAutoDeleteTrafficEncryptionPolicyEndpoint,
		AutoGetAppEndpoint:                        lAutoGetAppEndpoint,
		AutoGetCertificateEndpoint:                lAutoGetCertificateEndpoint,
		AutoGetFirewallProfileEndpoint:            lAutoGetFirewallProfileEndpoint,
		AutoGetSGPolicyEndpoint:                   lAutoGetSGPolicyEndpoint,
		AutoGetSecurityGroupEndpoint:              lAutoGetSecurityGroupEndpoint,
		AutoGetTrafficEncryptionPolicyEndpoint:    lAutoGetTrafficEncryptionPolicyEndpoint,
		AutoListAppEndpoint:                       lAutoListAppEndpoint,
		AutoListCertificateEndpoint:               lAutoListCertificateEndpoint,
		AutoListFirewallProfileEndpoint:           lAutoListFirewallProfileEndpoint,
		AutoListSGPolicyEndpoint:                  lAutoListSGPolicyEndpoint,
		AutoListSecurityGroupEndpoint:             lAutoListSecurityGroupEndpoint,
		AutoListTrafficEncryptionPolicyEndpoint:   lAutoListTrafficEncryptionPolicyEndpoint,
		AutoUpdateAppEndpoint:                     lAutoUpdateAppEndpoint,
		AutoUpdateCertificateEndpoint:             lAutoUpdateCertificateEndpoint,
		AutoUpdateFirewallProfileEndpoint:         lAutoUpdateFirewallProfileEndpoint,
		AutoUpdateSGPolicyEndpoint:                lAutoUpdateSGPolicyEndpoint,
		AutoUpdateSecurityGroupEndpoint:           lAutoUpdateSecurityGroupEndpoint,
		AutoUpdateTrafficEncryptionPolicyEndpoint: lAutoUpdateTrafficEncryptionPolicyEndpoint,
	}
}

// NewSecurityV1Backend creates an instrumented client with middleware
func NewSecurityV1Backend(conn *grpc.ClientConn, logger log.Logger) security.ServiceSecurityV1Client {
	cl := NewSecurityV1(conn, logger)
	cl = security.LoggingSecurityV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjSecurityV1SecurityGroup struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1SecurityGroup) Create(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSecurityGroup(nctx, in)
}

func (a *grpcObjSecurityV1SecurityGroup) Update(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSecurityGroup(nctx, in)
}

func (a *grpcObjSecurityV1SecurityGroup) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSecurityGroup(nctx, &in)
}

func (a *grpcObjSecurityV1SecurityGroup) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSecurityGroup(nctx, &in)
}

func (a *grpcObjSecurityV1SecurityGroup) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.SecurityGroup, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSecurityGroup(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1SecurityGroup) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityGroup", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSecurityGroup(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchSecurityGroupClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1SecurityGroup) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1SecurityGroup struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1SecurityGroup) Create(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSecurityGroup(ctx, in)
}

func (a *restObjSecurityV1SecurityGroup) Update(ctx context.Context, in *security.SecurityGroup) (*security.SecurityGroup, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSecurityGroup(ctx, in)
}

func (a *restObjSecurityV1SecurityGroup) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSecurityGroup(ctx, &in)
}

func (a *restObjSecurityV1SecurityGroup) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.SecurityGroup, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SecurityGroup{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSecurityGroup(ctx, &in)
}

func (a *restObjSecurityV1SecurityGroup) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.SecurityGroup, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListSecurityGroup(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1SecurityGroup) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchSecurityGroup(ctx, options)
}

func (a *restObjSecurityV1SecurityGroup) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1SGPolicy struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1SGPolicy) Create(ctx context.Context, in *security.SGPolicy) (*security.SGPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "SGPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddSGPolicy(nctx, in)
}

func (a *grpcObjSecurityV1SGPolicy) Update(ctx context.Context, in *security.SGPolicy) (*security.SGPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "SGPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateSGPolicy(nctx, in)
}

func (a *grpcObjSecurityV1SGPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.SGPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "SGPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SGPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetSGPolicy(nctx, &in)
}

func (a *grpcObjSecurityV1SGPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.SGPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "SGPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SGPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteSGPolicy(nctx, &in)
}

func (a *grpcObjSecurityV1SGPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.SGPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "SGPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListSGPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1SGPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SGPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSGPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchSGPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1SGPolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1SGPolicy struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1SGPolicy) Create(ctx context.Context, in *security.SGPolicy) (*security.SGPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddSGPolicy(ctx, in)
}

func (a *restObjSecurityV1SGPolicy) Update(ctx context.Context, in *security.SGPolicy) (*security.SGPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateSGPolicy(ctx, in)
}

func (a *restObjSecurityV1SGPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.SGPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SGPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetSGPolicy(ctx, &in)
}

func (a *restObjSecurityV1SGPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.SGPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.SGPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteSGPolicy(ctx, &in)
}

func (a *restObjSecurityV1SGPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.SGPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListSGPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1SGPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchSGPolicy(ctx, options)
}

func (a *restObjSecurityV1SGPolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1App struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1App) Create(ctx context.Context, in *security.App) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddApp(nctx, in)
}

func (a *grpcObjSecurityV1App) Update(ctx context.Context, in *security.App) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateApp(nctx, in)
}

func (a *grpcObjSecurityV1App) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetApp(nctx, &in)
}

func (a *grpcObjSecurityV1App) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteApp(nctx, &in)
}

func (a *grpcObjSecurityV1App) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.App, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListApp(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1App) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "App", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchApp(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchAppClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1App) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1App struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1App) Create(ctx context.Context, in *security.App) (*security.App, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddApp(ctx, in)
}

func (a *restObjSecurityV1App) Update(ctx context.Context, in *security.App) (*security.App, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateApp(ctx, in)
}

func (a *restObjSecurityV1App) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetApp(ctx, &in)
}

func (a *restObjSecurityV1App) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.App, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.App{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteApp(ctx, &in)
}

func (a *restObjSecurityV1App) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.App, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListApp(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1App) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchApp(ctx, options)
}

func (a *restObjSecurityV1App) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1FirewallProfile struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1FirewallProfile) Create(ctx context.Context, in *security.FirewallProfile) (*security.FirewallProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "FirewallProfile", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddFirewallProfile(nctx, in)
}

func (a *grpcObjSecurityV1FirewallProfile) Update(ctx context.Context, in *security.FirewallProfile) (*security.FirewallProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "FirewallProfile", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateFirewallProfile(nctx, in)
}

func (a *grpcObjSecurityV1FirewallProfile) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.FirewallProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "FirewallProfile", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.FirewallProfile{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetFirewallProfile(nctx, &in)
}

func (a *grpcObjSecurityV1FirewallProfile) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.FirewallProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "FirewallProfile", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.FirewallProfile{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteFirewallProfile(nctx, &in)
}

func (a *grpcObjSecurityV1FirewallProfile) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.FirewallProfile, error) {
	a.logger.DebugLog("msg", "received call", "object", "FirewallProfile", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListFirewallProfile(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1FirewallProfile) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "FirewallProfile", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchFirewallProfile(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchFirewallProfileClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1FirewallProfile) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1FirewallProfile struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1FirewallProfile) Create(ctx context.Context, in *security.FirewallProfile) (*security.FirewallProfile, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddFirewallProfile(ctx, in)
}

func (a *restObjSecurityV1FirewallProfile) Update(ctx context.Context, in *security.FirewallProfile) (*security.FirewallProfile, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateFirewallProfile(ctx, in)
}

func (a *restObjSecurityV1FirewallProfile) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.FirewallProfile, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.FirewallProfile{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetFirewallProfile(ctx, &in)
}

func (a *restObjSecurityV1FirewallProfile) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.FirewallProfile, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.FirewallProfile{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteFirewallProfile(ctx, &in)
}

func (a *restObjSecurityV1FirewallProfile) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.FirewallProfile, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListFirewallProfile(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1FirewallProfile) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchFirewallProfile(ctx, options)
}

func (a *restObjSecurityV1FirewallProfile) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1Certificate struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1Certificate) Create(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddCertificate(nctx, in)
}

func (a *grpcObjSecurityV1Certificate) Update(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateCertificate(nctx, in)
}

func (a *grpcObjSecurityV1Certificate) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetCertificate(nctx, &in)
}

func (a *grpcObjSecurityV1Certificate) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteCertificate(nctx, &in)
}

func (a *grpcObjSecurityV1Certificate) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.Certificate, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListCertificate(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1Certificate) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Certificate", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchCertificate(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchCertificateClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1Certificate) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1Certificate struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1Certificate) Create(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddCertificate(ctx, in)
}

func (a *restObjSecurityV1Certificate) Update(ctx context.Context, in *security.Certificate) (*security.Certificate, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateCertificate(ctx, in)
}

func (a *restObjSecurityV1Certificate) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetCertificate(ctx, &in)
}

func (a *restObjSecurityV1Certificate) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.Certificate, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.Certificate{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteCertificate(ctx, &in)
}

func (a *restObjSecurityV1Certificate) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.Certificate, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListCertificate(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1Certificate) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchCertificate(ctx, options)
}

func (a *restObjSecurityV1Certificate) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type grpcObjSecurityV1TrafficEncryptionPolicy struct {
	logger log.Logger
	client security.ServiceSecurityV1Client
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Create(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddTrafficEncryptionPolicy(nctx, in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Update(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateTrafficEncryptionPolicy(nctx, in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetTrafficEncryptionPolicy(nctx, &in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteTrafficEncryptionPolicy(nctx, &in)
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.TrafficEncryptionPolicy, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListTrafficEncryptionPolicy(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "TrafficEncryptionPolicy", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchTrafficEncryptionPolicy(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchTrafficEncryptionPolicyClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjSecurityV1TrafficEncryptionPolicy) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjSecurityV1TrafficEncryptionPolicy struct {
	endpoints security.EndpointsSecurityV1RestClient
	instance  string
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Create(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddTrafficEncryptionPolicy(ctx, in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Update(ctx context.Context, in *security.TrafficEncryptionPolicy) (*security.TrafficEncryptionPolicy, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateTrafficEncryptionPolicy(ctx, in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Get(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetTrafficEncryptionPolicy(ctx, &in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*security.TrafficEncryptionPolicy, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := security.TrafficEncryptionPolicy{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteTrafficEncryptionPolicy(ctx, &in)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) List(ctx context.Context, options *api.ListWatchOptions) ([]*security.TrafficEncryptionPolicy, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}

	if options.Tenant == "" {
		options.Tenant = globals.DefaultTenant
	}
	r, err := a.endpoints.AutoListTrafficEncryptionPolicy(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoWatchTrafficEncryptionPolicy(ctx, options)
}

func (a *restObjSecurityV1TrafficEncryptionPolicy) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return false
	case apiserver.WatchOper:
		return true
	default:
		return false
	}
}

type crudClientSecurityV1 struct {
	logger log.Logger
	client security.ServiceSecurityV1Client

	grpcSecurityGroup           security.SecurityV1SecurityGroupInterface
	grpcSGPolicy                security.SecurityV1SGPolicyInterface
	grpcApp                     security.SecurityV1AppInterface
	grpcFirewallProfile         security.SecurityV1FirewallProfileInterface
	grpcCertificate             security.SecurityV1CertificateInterface
	grpcTrafficEncryptionPolicy security.SecurityV1TrafficEncryptionPolicyInterface
}

// NewGrpcCrudClientSecurityV1 creates a GRPC client for the service
func NewGrpcCrudClientSecurityV1(conn *grpc.ClientConn, logger log.Logger) security.SecurityV1Interface {
	client := NewSecurityV1Backend(conn, logger)
	return &crudClientSecurityV1{
		logger: logger,
		client: client,

		grpcSecurityGroup:           &grpcObjSecurityV1SecurityGroup{client: client, logger: logger},
		grpcSGPolicy:                &grpcObjSecurityV1SGPolicy{client: client, logger: logger},
		grpcApp:                     &grpcObjSecurityV1App{client: client, logger: logger},
		grpcFirewallProfile:         &grpcObjSecurityV1FirewallProfile{client: client, logger: logger},
		grpcCertificate:             &grpcObjSecurityV1Certificate{client: client, logger: logger},
		grpcTrafficEncryptionPolicy: &grpcObjSecurityV1TrafficEncryptionPolicy{client: client, logger: logger},
	}
}

func (a *crudClientSecurityV1) SecurityGroup() security.SecurityV1SecurityGroupInterface {
	return a.grpcSecurityGroup
}

func (a *crudClientSecurityV1) SGPolicy() security.SecurityV1SGPolicyInterface {
	return a.grpcSGPolicy
}

func (a *crudClientSecurityV1) App() security.SecurityV1AppInterface {
	return a.grpcApp
}

func (a *crudClientSecurityV1) FirewallProfile() security.SecurityV1FirewallProfileInterface {
	return a.grpcFirewallProfile
}

func (a *crudClientSecurityV1) Certificate() security.SecurityV1CertificateInterface {
	return a.grpcCertificate
}

func (a *crudClientSecurityV1) TrafficEncryptionPolicy() security.SecurityV1TrafficEncryptionPolicyInterface {
	return a.grpcTrafficEncryptionPolicy
}

func (a *crudClientSecurityV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "SecurityV1", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchSvcSecurityV1(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(security.SecurityV1_AutoWatchSvcSecurityV1Client)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{Type: kvstore.WatchEventType(e.Type)}
				robj, err := listerwatcher.GetObject(e)
				if err != nil {
					a.logger.ErrorLog("msg", "error on receive unmarshall", "error", err)
					close(lw.OutCh)
					return
				}
				ev.Object = robj
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

type crudRestClientSecurityV1 struct {
	restSecurityGroup           security.SecurityV1SecurityGroupInterface
	restSGPolicy                security.SecurityV1SGPolicyInterface
	restApp                     security.SecurityV1AppInterface
	restFirewallProfile         security.SecurityV1FirewallProfileInterface
	restCertificate             security.SecurityV1CertificateInterface
	restTrafficEncryptionPolicy security.SecurityV1TrafficEncryptionPolicyInterface
}

// NewRestCrudClientSecurityV1 creates a REST client for the service.
func NewRestCrudClientSecurityV1(url string, httpClient *http.Client) security.SecurityV1Interface {
	endpoints, err := security.MakeSecurityV1RestClientEndpoints(url, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientSecurityV1{

		restSecurityGroup:           &restObjSecurityV1SecurityGroup{endpoints: endpoints, instance: url},
		restSGPolicy:                &restObjSecurityV1SGPolicy{endpoints: endpoints, instance: url},
		restApp:                     &restObjSecurityV1App{endpoints: endpoints, instance: url},
		restFirewallProfile:         &restObjSecurityV1FirewallProfile{endpoints: endpoints, instance: url},
		restCertificate:             &restObjSecurityV1Certificate{endpoints: endpoints, instance: url},
		restTrafficEncryptionPolicy: &restObjSecurityV1TrafficEncryptionPolicy{endpoints: endpoints, instance: url},
	}
}

// NewStagedRestCrudClientSecurityV1 creates a REST client for the service.
func NewStagedRestCrudClientSecurityV1(url string, id string, httpClient *http.Client) security.SecurityV1Interface {
	endpoints, err := security.MakeSecurityV1StagedRestClientEndpoints(url, id, httpClient)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientSecurityV1{

		restSecurityGroup:           &restObjSecurityV1SecurityGroup{endpoints: endpoints, instance: url},
		restSGPolicy:                &restObjSecurityV1SGPolicy{endpoints: endpoints, instance: url},
		restApp:                     &restObjSecurityV1App{endpoints: endpoints, instance: url},
		restFirewallProfile:         &restObjSecurityV1FirewallProfile{endpoints: endpoints, instance: url},
		restCertificate:             &restObjSecurityV1Certificate{endpoints: endpoints, instance: url},
		restTrafficEncryptionPolicy: &restObjSecurityV1TrafficEncryptionPolicy{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientSecurityV1) SecurityGroup() security.SecurityV1SecurityGroupInterface {
	return a.restSecurityGroup
}

func (a *crudRestClientSecurityV1) SGPolicy() security.SecurityV1SGPolicyInterface {
	return a.restSGPolicy
}

func (a *crudRestClientSecurityV1) App() security.SecurityV1AppInterface {
	return a.restApp
}

func (a *crudRestClientSecurityV1) FirewallProfile() security.SecurityV1FirewallProfileInterface {
	return a.restFirewallProfile
}

func (a *crudRestClientSecurityV1) Certificate() security.SecurityV1CertificateInterface {
	return a.restCertificate
}

func (a *crudRestClientSecurityV1) TrafficEncryptionPolicy() security.SecurityV1TrafficEncryptionPolicyInterface {
	return a.restTrafficEncryptionPolicy
}

func (a *crudRestClientSecurityV1) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("method unimplemented")
}
