{
  "swagger": "2.0",
  "info": {
    "title": "Search API reference",
    "description": "Search API to search configuration policies, events etc.\n\n",
    "version": "v1"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/search/v1/policy-query": {
      "get": {
        "summary": "Security Policy Query",
        "operationId": "GetPolicyQuery_1",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchPolicySearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "tenant",
            "description": "Tenant Name, to perform query within a Tenant's scope. The default tenant is \"default\". In the backend this field gets auto-filled \u0026 validated by apigw-hook based on user login context.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace is optional. If provided policy-search will be limited to the specified namespace.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sg-policy",
            "description": "NetworkSecurityPolicy name is optional. If provided policy-search will be limited to the specified SGpolicy object name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "app",
            "description": "App specification,  predefined apps and alg config.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "protocol",
            "description": "Protocol eg: tcp, udp, icmp.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "port",
            "description": "TCP or UDP Port number.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "from-ip-address",
            "description": "Inbound ip-address, use any to refer to all ipaddresses eg: 10.1.1.1, any.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "to-ip-address",
            "description": "Outbound ip-address, use any to refer to all ipaddresses eg: 20.1.1.1, any.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "from-security-group",
            "description": "Inbound security group.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "to-security-group",
            "description": "Outbound security group.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "search/v1"
        ]
      },
      "post": {
        "summary": "Security Policy Query",
        "operationId": "PostPolicyQuery",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchPolicySearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/searchPolicySearchRequest"
            }
          }
        ],
        "tags": [
          "search/v1"
        ]
      }
    },
    "/search/v1/query": {
      "get": {
        "summary": "Structured or free-form search",
        "operationId": "GetQuery_1",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchSearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "query-string",
            "description": "Simple query string This can be specified as URI parameter. For advanced query cases, Users should use specify SearchQuery and pass the SearchRequest in a GET/POST Body The max query-string length is 256 bytes. Length of string should be between 0 and 256.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "from",
            "description": "From represents the start offset (zero based), used in paginated search requests The results returned would be in the range [From ... From+MaxResults-1] This can be specified as URI parameter. Default value is 0 and valid range is 0..1023. Value should be between 0 and 1023.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "max-results",
            "description": "MaxResults is the max-count of search results This can be specified as URI parameter. Default value is 50 and valid range is 0..8192. Value should be between 0 and 8192.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sort-by",
            "description": "SortyBy is an optional parameter and contains the field name to be sorted by, For eg: \"meta.name\" This can be specified as URI parameter. Length of string should be between 0 and 256.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sort-order",
            "description": "SortOrder is an optional parameter and contains whether to sort ascending or descending This can be specified as URI parameter.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "mode",
            "description": "Query Mode.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "query.categories",
            "description": "OR of Categories to be matched, AND and Exclude are not supported for this type The max category string length is 64 bytes. Length of string should be between 0 and 64.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "query.kinds",
            "description": "OR of Kinds to be matched, AND and Exclude are not supported for this type. Should be a valid object Kind.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "tenants",
            "description": "OR of tenants within the scope of which search needs to be performed. If not specified, it will be set to tenant of the logged in user.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "aggregate",
            "description": "Indicates whether to perform aggregation on the search results or not.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "search/v1"
        ]
      },
      "post": {
        "summary": "Structured or free-form search",
        "operationId": "PostQuery",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchSearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/searchSearchRequest"
            }
          }
        ],
        "tags": [
          "search/v1"
        ]
      }
    }
  },
  "definitions": {
    "apiAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Any is wrapper around the proto Any object."
    },
    "apiListWatchOptions": {
      "type": "object",
      "required": [
        "sort-order"
      ],
      "properties": {
        "name": {
          "type": "string",
          "minLength": 2,
          "maxLength": 64,
          "pattern": "^[a-zA-Z0-9][\\w\\-\\.]*[a-zA-Z0-9]$",
          "description": "Must start and end with alpha numeric and can have alphanumeric, -, _, . Length of string should be between 2 and 64."
        },
        "tenant": {
          "type": "string",
          "minLength": 1,
          "maxLength": 48,
          "pattern": "^[a-zA-Z0-9]+$",
          "description": "Must be alpha-numerics. Length of string should be between 1 and 48."
        },
        "namespace": {
          "type": "string",
          "minLength": 2,
          "maxLength": 64,
          "pattern": "^[a-zA-Z0-9][\\w\\-\\.]*[a-zA-Z0-9]$",
          "description": "Must start and end with alpha numeric and can have alphanumeric, -, _, . Length of string should be between 2 and 64."
        },
        "generation-id": {
          "type": "string"
        },
        "resource-version": {
          "type": "string"
        },
        "uuid": {
          "type": "string"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "creation-time": {
          "type": "string",
          "format": "date-time"
        },
        "mod-time": {
          "type": "string",
          "format": "date-time"
        },
        "self-link": {
          "type": "string"
        },
        "label-selector": {
          "type": "string",
          "description": "LabelSelector to select on labels in list or watch results."
        },
        "field-selector": {
          "type": "string",
          "description": "FieldSelector to select on field values in list or watch results."
        },
        "field-change-selector": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "FieldChangeSelector specifies to generate a watch notification on change in field(s) specified."
        },
        "from": {
          "type": "integer",
          "format": "int32",
          "description": "from represents the start offset (zero based), used for pagination. results returned would be in the range [from ... from+max-results-1]."
        },
        "max-results": {
          "type": "integer",
          "format": "int32",
          "description": "max. number of events to be fetched for the request."
        },
        "sort-order": {
          "type": "string",
          "enum": [
            "none",
            "by-name",
            "by-name-reverse",
            "by-version",
            "by-version-reverse",
            "by-creation-time",
            "by-creation-time-reverse",
            "by-mod-time",
            "by-mod-time-reverse"
          ],
          "default": "none",
          "x-ui-hints": {
            "by-creation-time": "By Creation Time",
            "by-creation-time-reverse": "By Creation Time Reverse",
            "by-mod-time": "By Modification Time",
            "by-mod-time-reverse": "By Modification Time Reverse",
            "by-name": "By Name",
            "by-name-reverse": "By Name Reverse",
            "by-version": "By Version",
            "by-version-reverse": "By Version Reverse",
            "none": "None"
          },
          "description": "order to sort List results in."
        }
      }
    },
    "apiObjectMeta": {
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "type": "string",
          "minLength": 2,
          "maxLength": 64,
          "pattern": "^[a-zA-Z0-9][\\w\\-\\.]*[a-zA-Z0-9]$",
          "description": "Must start and end with alpha numeric and can have alphanumeric, -, _, . Length of string should be between 2 and 64.",
          "title": "Name of the object, unique within a Namespace for scoped objects"
        },
        "tenant": {
          "type": "string",
          "minLength": 1,
          "maxLength": 48,
          "pattern": "^[a-zA-Z0-9]+$",
          "description": "This can be automatically filled in many cases based on the tenant the user, who created the object, belongs to. Must be alpha-numerics. Length of string should be between 1 and 48.",
          "title": "Tenant to which the object belongs to"
        },
        "namespace": {
          "type": "string",
          "minLength": 2,
          "maxLength": 64,
          "pattern": "^[a-zA-Z0-9][\\w\\-\\.]*[a-zA-Z0-9]$",
          "description": "Namespace of the object, for scoped objects. Must start and end with alpha numeric and can have alphanumeric, -, _, . Length of string should be between 2 and 64."
        },
        "generation-id": {
          "type": "string",
          "description": "This is incremented anytime there is an update to the user intent, including Spec update and any update to ObjectMeta. System generated and updated, not updatable by user.",
          "title": "GenerationID is the generation Id for the object"
        },
        "resource-version": {
          "type": "string",
          "description": "This is updated anytime there is any change to the object. System generated and updated, not updatable by user.",
          "title": "Resource version in the object store"
        },
        "uuid": {
          "type": "string",
          "description": "This is generated on creation of the object. System generated, not updatable by user.",
          "title": "UUID is the unique identifier for the object"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Labels are arbitrary (key,value) pairs associated with any object"
        },
        "creation-time": {
          "type": "string",
          "format": "date-time",
          "description": "System generated and updated, not updatable by user.",
          "title": "CreationTime is the creation time of the object"
        },
        "mod-time": {
          "type": "string",
          "format": "date-time",
          "description": "System generated and updated, not updatable by user.",
          "title": "ModTime is the Last Modification time of the object"
        },
        "self-link": {
          "type": "string",
          "description": "When the object is served from the API-GW it is the URI path. Example: - \"/v1/tenants/tenants/tenant2\" System generated and updated, not updatable by user.",
          "title": "SelfLink is a link for accessing this object"
        }
      },
      "description": "ObjectMeta contains metadata that all objects stored in kvstore must have."
    },
    "apiObjectRef": {
      "type": "object",
      "properties": {
        "tenant": {
          "type": "string",
          "description": "Tenant of the object."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the object, for scoped objects."
        },
        "kind": {
          "type": "string",
          "description": "Kind represents the type of the API object."
        },
        "name": {
          "type": "string",
          "description": "Name of the object, unique within a Namespace for scoped objects."
        },
        "uri": {
          "type": "string",
          "description": "URI is a link to accessing the referenced object."
        }
      },
      "description": "ObjectRef contains identifying information about an object."
    },
    "apiStatus": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string"
        },
        "api-version": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/apiStatusResult",
          "description": "Result contains the status of the operation, success or failure."
        },
        "message": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Message contains human readable form of the error."
        },
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "Code is the HTTP status code."
        },
        "object-ref": {
          "$ref": "#/definitions/apiObjectRef",
          "description": "Reference to the object (optional) for which this status is being sent."
        }
      },
      "description": "Status is returned for calls that dont return objects."
    },
    "apiStatusResult": {
      "type": "object",
      "properties": {
        "Str": {
          "type": "string"
        }
      },
      "description": "StatusResult contains possible statuses for a NIC."
    },
    "apiTimestamp": {
      "type": "object",
      "properties": {
        "seconds": {
          "type": "string",
          "format": "int64"
        },
        "nanos": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "apiWatchEvent": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "object": {
          "$ref": "#/definitions/googleprotobufAny"
        }
      }
    },
    "apiWatchEventList": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/apiWatchEvent"
          }
        }
      }
    },
    "fieldsRequirement": {
      "type": "object",
      "required": [
        "operator"
      ],
      "properties": {
        "key": {
          "type": "string",
          "description": "The label key that the condition applies to."
        },
        "operator": {
          "type": "string",
          "enum": [
            "equals",
            "notequals",
            "in",
            "notin",
            "gt",
            "gte",
            "lt",
            "lte"
          ],
          "default": "equals",
          "x-ui-hints": {
            "gt": "greater than",
            "gte": "greater than or equals",
            "lt": "less than",
            "lte": "less than or equals",
            "notequals": "not equals",
            "notin": "not in"
          },
          "description": "Condition checked for the key."
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Values contains one or more values corresponding to the label key. \"equals\" and \"notEquals\" operators need a single Value. \"in\" and \"notIn\" operators can have one or more values."
        }
      },
      "description": "Requirement defines a single matching condition for a selector."
    },
    "fieldsSelector": {
      "type": "object",
      "properties": {
        "requirements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/fieldsRequirement"
          },
          "description": "Requirements are ANDed."
        }
      },
      "description": "Selector is used to select objects by fields. Requirements in the selector are ANDed. A selector with no Requirements does not select anything."
    },
    "googleprotobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name whose content describes the type of the serialized protocol buffer message. For URLs which use the scheme `http`, `https`, or no scheme, the following restrictions and interpretations apply: * If no scheme is provided, `https` is assumed. * The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). * An HTTP GET on the URL must yield a [google.protobuf.Type][] value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message. Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type. Example 1: Pack and unpack a message in C++. Foo foo = ...; Any any; any.PackFrom(foo); ... if (any.UnpackTo(\u0026foo)) { ... } Example 2: Pack and unpack a message in Java. Foo foo = ...; Any any = Any.pack(foo); ... if (any.is(Foo.class)) { foo = any.unpack(Foo.class); } Example 3: Pack and unpack a message in Python. foo = Foo(...) any = Any() any.Pack(foo) ... if any.Is(Foo.DESCRIPTOR): any.Unpack(foo) ... Example 4: Pack and unpack a message in Go foo := \u0026pb.Foo{...} any, err := ptypes.MarshalAny(foo) ... foo := \u0026pb.Foo{} if err := ptypes.UnmarshalAny(any, foo); err != nil { ... } The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\". JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example: package google.profile; message Person { string first_name = 1; string last_name = 2; } { \"@type\": \"type.googleapis.com/google.profile.Person\", \"firstName\": \u003cstring\u003e, \"lastName\": \u003cstring\u003e } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]): { \"@type\": \"type.googleapis.com/google.protobuf.Duration\", \"value\": \"1.212s\" }."
    },
    "labelsRequirement": {
      "type": "object",
      "required": [
        "operator"
      ],
      "properties": {
        "key": {
          "type": "string",
          "description": "The label key that the condition applies to."
        },
        "operator": {
          "type": "string",
          "enum": [
            "equals",
            "notequals",
            "in",
            "notin"
          ],
          "default": "equals",
          "x-ui-hints": {
            "notequals": "not equals",
            "notin": "not in"
          },
          "description": "Condition checked for the key."
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Values contains one or more values corresponding to the label key. \"equals\" and \"notEquals\" operators need a single Value. \"in\" and \"notIn\" operators can have one or more values."
        }
      },
      "description": "Requirement defines a single matching condition for a selector."
    },
    "labelsSelector": {
      "type": "object",
      "properties": {
        "requirements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/labelsRequirement"
          },
          "description": "Requirements are ANDed."
        }
      },
      "description": "Selector is used to select objects by labels. Requirements in the selector are ANDed. A selector with no Requirements does not select anything."
    },
    "searchCategoryAggregation": {
      "type": "object",
      "properties": {
        "categories": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchKindAggregation"
          }
        }
      },
      "description": "CategoryAggregation contains map of search result entries grouped by two levels: first by Category and then by Kind."
    },
    "searchCategoryPreview": {
      "type": "object",
      "properties": {
        "categories": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchKindPreview"
          }
        }
      },
      "description": "CategoryPreview contains map of search summary (#hits) grouped by two levels: first by Category and then by Kind."
    },
    "searchEntry": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/apiAny",
          "description": "TODO: Right now our api codegen does not support nested inline and hence this attribute cannot be be made embedded/inline. api.Any is already had embededed attribute Any. Once infra supports nested inline or an alternative, this attribute should be embedded and made inline to make json response user friendly for search."
        }
      },
      "description": "Entry represent a single search result entry and contents of this entity vary based on Kind. For Events and Alerts Kind, the result will be entire object respectively. For rest of the configs objects, the result will be ConfigEntry with only the type \u0026 object meta data fields."
    },
    "searchEntryList": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/searchEntry"
          }
        }
      },
      "description": "EntryList is list of search result entries."
    },
    "searchError": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Type of error."
        },
        "reason": {
          "type": "string",
          "description": "Reason or description of the failure."
        }
      },
      "description": "Error contains the error code, description and associated details."
    },
    "searchKindAggregation": {
      "type": "object",
      "properties": {
        "kinds": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchEntryList"
          }
        }
      },
      "description": "KindAggregation contains map of search result entries grouped by Kind."
    },
    "searchKindPreview": {
      "type": "object",
      "properties": {
        "kinds": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        }
      },
      "description": "KindPreview contains map of search summary (#hits) grouped by Kind."
    },
    "searchPolicyMatchEntries": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/searchPolicyMatchEntry"
          }
        }
      },
      "description": "PolicyMatchEntries multiple PolicyMatchEntry in entries."
    },
    "searchPolicyMatchEntry": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/securitySGRule",
          "description": "Matching SGRule."
        },
        "index": {
          "type": "integer",
          "format": "int64",
          "description": "Index of the matching SG rule."
        }
      },
      "description": "PolicyMatchEntry contains the matching SGrule and Index within the NetworkSecurityPolicy ruleset."
    },
    "searchPolicySearchRequest": {
      "type": "object",
      "properties": {
        "tenant": {
          "type": "string",
          "default": "default",
          "description": "Tenant Name, to perform query within a Tenant's scope. The default tenant is \"default\". In the backend this field gets auto-filled \u0026 validated by apigw-hook based on user login context."
        },
        "namespace": {
          "type": "string",
          "default": "default",
          "description": "Namespace is optional. If provided policy-search will be limited to the specified namespace."
        },
        "sg-policy": {
          "type": "string",
          "description": "NetworkSecurityPolicy name is optional. If provided policy-search will be limited to the specified SGpolicy object name."
        },
        "app": {
          "type": "string",
          "description": "App specification,  predefined apps and alg config."
        },
        "protocol": {
          "type": "string",
          "description": "Protocol eg: tcp, udp, icmp."
        },
        "port": {
          "type": "string",
          "description": "TCP or UDP Port number."
        },
        "from-ip-address": {
          "type": "string",
          "description": "Inbound ip-address, use any to refer to all ipaddresses eg: 10.1.1.1, any."
        },
        "to-ip-address": {
          "type": "string",
          "description": "Outbound ip-address, use any to refer to all ipaddresses eg: 20.1.1.1, any."
        },
        "from-security-group": {
          "type": "string",
          "description": "Inbound security group."
        },
        "to-security-group": {
          "type": "string",
          "description": "Outbound security group."
        }
      },
      "description": "PolicySearchRequest is input to the security/firewall policy search request."
    },
    "searchPolicySearchResponse": {
      "type": "object",
      "required": [
        "status"
      ],
      "properties": {
        "status": {
          "type": "string",
          "enum": [
            "match",
            "miss"
          ],
          "default": "match",
          "description": "Status of firewall policy search."
        },
        "results": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchPolicyMatchEntries"
          },
          "description": "Result is Map of \u003cNetworkSecurityPolicy object name, PolicyMatch Entry\u003e."
        }
      },
      "description": "PolicySearchResponse is response to the security/firewall policy search request."
    },
    "searchSearchQuery": {
      "type": "object",
      "properties": {
        "texts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/searchTextRequirement"
          },
          "description": "OR of Text-requirements to be matched, Exclude is not supported for Text search."
        },
        "categories": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "maxLength": 64,
          "description": "OR of Categories to be matched, AND and Exclude are not supported for this type The max category string length is 64 bytes. Length of string should be between 0 and 64."
        },
        "kinds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "example": "Network",
          "description": "OR of Kinds to be matched, AND and Exclude are not supported for this type. Should be a valid object Kind."
        },
        "fields": {
          "$ref": "#/definitions/fieldsSelector",
          "description": "Field Selector is AND of field.Requirements."
        },
        "labels": {
          "$ref": "#/definitions/labelsSelector",
          "description": "Label Selector is AND of label.Requirememts."
        }
      }
    },
    "searchSearchRequest": {
      "type": "object",
      "required": [
        "from",
        "max-results",
        "sort-order",
        "mode"
      ],
      "properties": {
        "query-string": {
          "type": "string",
          "maxLength": 256,
          "description": "Simple query string This can be specified as URI parameter. For advanced query cases, Users should use specify SearchQuery and pass the SearchRequest in a GET/POST Body The max query-string length is 256 bytes. Length of string should be between 0 and 256."
        },
        "from": {
          "type": "integer",
          "format": "int32",
          "maximum": 1023,
          "description": "From represents the start offset (zero based), used in paginated search requests The results returned would be in the range [From ... From+MaxResults-1] This can be specified as URI parameter. Default value is 0 and valid range is 0..1023. Value should be between 0 and 1023."
        },
        "max-results": {
          "type": "integer",
          "format": "int32",
          "default": "50",
          "maximum": 8192,
          "description": "MaxResults is the max-count of search results This can be specified as URI parameter. Default value is 50 and valid range is 0..8192. Value should be between 0 and 8192."
        },
        "sort-by": {
          "type": "string",
          "maxLength": 256,
          "description": "SortyBy is an optional parameter and contains the field name to be sorted by, For eg: \"meta.name\" This can be specified as URI parameter. Length of string should be between 0 and 256."
        },
        "sort-order": {
          "type": "string",
          "enum": [
            "ascending",
            "descending"
          ],
          "default": "ascending",
          "description": "SortOrder is an optional parameter and contains whether to sort ascending or descending This can be specified as URI parameter."
        },
        "mode": {
          "type": "string",
          "enum": [
            "full",
            "preview"
          ],
          "default": "full",
          "description": "Query Mode."
        },
        "query": {
          "$ref": "#/definitions/searchSearchQuery",
          "description": "Search query contains the search requirements This is intended for advanced query use cases involving boolean query, structured term query and supports various combinations of text, phrase strings and search modifiers for specific categories, kinds, fields and labels. This cannot be specified as URI parameter."
        },
        "tenants": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "OR of tenants within the scope of which search needs to be performed. If not specified, it will be set to tenant of the logged in user."
        },
        "aggregate": {
          "type": "boolean",
          "format": "boolean",
          "default": "true",
          "description": "Indicates whether to perform aggregation on the search results or not."
        }
      },
      "description": "SearchRequest is the input to the search API Simple queries can be specified as URI param using \"QueryString\". For advanced queries, it is recommended to use the \"SearchQuery\" structure and specify them in BODY of the GET/POST method. Examples of search query in query-string format: 1. Find all occurrences matching text “Network” Network 2. Find all occurrences matching phrase “link down” “link down” 3. Find all occurrences matching text production OR \"staging\" production staging 4. Find all occurrences matching text “Network” AND \"link down\" Network,\"link down\" Network AND \"link down\" 5. Find all config objects with label1=foo category:config label:label1=foo 6. Find all objects created on or after certain date+time category:config field:meta.created-time\u003e=”date-time-string” 7. Find all Network objects with type=vlan kind:Network field:spec.type=vlan 8. Find all Naples nodes with admission-phase = pending or rejected kind:DistributedServiceCard field:spec.phase in (pending, rejected) 9. Find all events with text matching “disconnected” category:events disconnected 10. Find all Critical events for Network objects category:events kind:Network field:severity=CRITICAL 11. Find all Alerts generated from Naples MAC1 category:alerts field:status.source.node=MAC1 category:alerts MAC1 12. Find all Naples nodes with metric filter : mem\u003e90 \u0026\u0026 cpu\u003e90 category:metrics kind:DistributedServiceCard field:metric.mem\u003e90,metric.cpu\u003e90 13. Find all Endpoints with label Tier=Web with counter1\u003e=100 category:metrics kind:Endpoint label:Tier=Web field:metric.counter1 \u003e 100 14. Find all Endpoints objects with label target=prod with crc-error-count != 0 category:metrics kind:Endpoint label:target=prod field:status.crc-error-count!=0 15. Find all occurences matching the words and phrase in a certain category \u0026 kinds with certain field and label match production \"status down\" category:Network kind:Network,Service field:spec.service-type=external label:tier=web."
    },
    "searchSearchResponse": {
      "type": "object",
      "properties": {
        "total-hits": {
          "type": "string",
          "format": "int64",
          "description": "TotalHits indicates total number of hits matched."
        },
        "actual-hits": {
          "type": "string",
          "format": "int64",
          "description": "ActualHits indicates the actual hits returned in this response."
        },
        "time-taken-msecs": {
          "type": "string",
          "format": "int64",
          "description": "TimeTakenMsecs is the time taken for search response in millisecs."
        },
        "error": {
          "$ref": "#/definitions/searchError",
          "description": "Error status for failures."
        },
        "entries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/searchEntry"
          },
          "description": "EntryList is list of all search results with no grouping. This attribute is populated and valid only in Full request-mode."
        },
        "preview-entries": {
          "$ref": "#/definitions/searchTenantPreview",
          "description": "PreviewEntries is a three level grouping of search summary (#hits), grouped by tenant, category and kind in that order. This attribute is populated and valid only in Preview request-mode."
        },
        "aggregated-entries": {
          "$ref": "#/definitions/searchTenantAggregation",
          "description": "AggregatedEntries is a three level grouping of full search results, Grouped by tenant, category and kind in that order. This attribute is populated and valid only in Full request-mode."
        }
      },
      "description": "SearchResponse is the output provided by the search API Based on the search request, search results would be part of one of the entities : Entries or NestedAggregation. In case of failures, Error would indicate the error status and description."
    },
    "searchTenantAggregation": {
      "type": "object",
      "properties": {
        "tenants": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchCategoryAggregation"
          }
        }
      },
      "description": "TenantAggregation contains map of search result entries grouped by three levels: first by Tenant, second by Category and finally by Kind."
    },
    "searchTenantPreview": {
      "type": "object",
      "properties": {
        "tenants": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchCategoryPreview"
          }
        }
      },
      "description": "TenantPreview contains map of search summary (#hits) grouped by three levels: first by Tenant, second by Category and finally by Kind."
    },
    "searchTextRequirement": {
      "type": "object",
      "properties": {
        "text": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "maxLength": 256,
          "description": "AND of words or phrases to be matched The max text-string length is 256 bytes. Length of string should be between 0 and 256."
        }
      },
      "description": "TextRequirement is AND of text-strings in the list It is comprised of words or phrases for text search support. If a text-string has space separated multi-word, it will be interpreted as a phrase. In the example below : - \"link down\" will be a phrase query - network, production, staging will be a word query For eg: network                      (match network) link down                    (match \"link down\" phrase) network,production           (match network AND production) network,link down,staging    (match network AND \"link down\" AND staging)."
    },
    "securityProtoPort": {
      "type": "object",
      "properties": {
        "protocol": {
          "type": "string",
          "description": "protocol is ip (v4/v6) protocol name/number; names can be: tcp, udp, igmp, icmp, gre, esp, etc."
        },
        "ports": {
          "type": "string",
          "description": "TCP or UDP port number(s): comma separate port numbers, or dash separate port range."
        }
      }
    },
    "securitySGRule": {
      "type": "object",
      "required": [
        "action"
      ],
      "properties": {
        "apps": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "list of apps objects to which the rule applies to."
        },
        "proto-ports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/securityProtoPort"
          },
          "description": "list of (protocol, ports) pairs to which the rule applies to, in addition to apps."
        },
        "action": {
          "type": "string",
          "enum": [
            "permit",
            "deny",
            "reject"
          ],
          "default": "permit",
          "x-ui-hints": {
            "deny": "Deny",
            "permit": "Permit",
            "reject": "Reject"
          },
          "description": "SGRule action, either PERMIT, DENY or REJECT."
        },
        "from-ip-addresses": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "inbound rule from a given ip-address/ip-mask/ip-range. Use any to refer to all ipaddresses cli-tags: id=from-ip."
        },
        "to-ip-addresses": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "outbound rule from a given ip-address/ip-mask/ip-range. Use any to refer to all ipaddresses cli-tags: id=to-ip."
        },
        "from-security-groups": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "inbound rule from a given security group."
        },
        "to-security-groups": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "outbound rule from a given security group."
        }
      }
    }
  }
}
