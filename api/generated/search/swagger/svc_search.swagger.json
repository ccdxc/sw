{
  "swagger": "2.0",
  "info": {
    "title": "Search API reference",
    "description": "Search API to search configuration policies, events etc.\n\n",
    "version": "v1"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/search/v1/policy-query": {
      "get": {
        "summary": "Security Policy Query",
        "operationId": "GetPolicyQuery_1",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchPolicySearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "tenant",
            "description": "Tenant Name, to perform query within a Tenant's scope.\nThe default tenant is \"default\". In the backend\nthis field gets auto-filled \u0026 validated by apigw-hook\nbased on user login context.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace is optional. If provided policy-search will\nbe limited to the specified namespace.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sg-policy",
            "description": "SGPolicy name is optional. If provided policy-search will\nbe limited to the specified SGpolicy object name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "app",
            "description": "App specification, proto/port format, or predefined apps and alg config\neg: tcp/443, udp/53.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "from-ip-address",
            "description": "Inbound ip-address, use any to refer to all ipaddresses\neg: 10.1.1.1, any.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "to-ip-address",
            "description": "Outbound ip-address, use any to refer to all ipaddresses\neg: 20.1.1.1, any.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "from-security-group",
            "description": "Inbound security group.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "to-security-group",
            "description": "Outbound security group.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "search/v1"
        ]
      },
      "post": {
        "summary": "Security Policy Query",
        "operationId": "PostPolicyQuery",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchPolicySearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/searchPolicySearchRequest"
            }
          }
        ],
        "tags": [
          "search/v1"
        ]
      }
    },
    "/search/v1/query": {
      "get": {
        "summary": "In the example below a query like\n   http://\u003c...\u003e/venice/v1/search/query?QueryString=XXXXX\u0026MaxResults=100\n generates a RPC call Query with the parameter as\n SearchRequest{ QueryString: \"XXXXX\", MaxResults:100}",
        "operationId": "GetQuery_1",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchSearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "query-string",
            "description": "Simple query string\nThis can be specified as URI parameter.\nFor advanced query cases, Users should use specify SearchQuery\nand pass the SearchRequest in a GET/POST Body\nThe max query-string length is 256 bytes. length of string should be between 0 and 256",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "from",
            "description": "From represents the start offset (zero based), used in paginated search requests\nThe results returned would be in the range [From ... From+MaxResults-1]\nThis can be specified as URI parameter. \nDefault value is 0 and valid range is 0..1023. value should be between 0 and 1023",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "max-results",
            "description": "MaxResults is the max-count of search results\nThis can be specified as URI parameter.\nDefault value is 50 and valid range is 0..8192. value should be between 0 and 8192",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sort-by",
            "description": "SortyBy is an optional parameter and contains the field name \nto be sorted by, For eg: \"meta.name\"\nThis can be specified as URI parameter.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "mode",
            "description": "Query Mode.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "query.categories",
            "description": "OR of Categories to be matched, AND and Exclude are not supported for this type\nThe max category string length is 64 bytes. length of string should be between 0 and 64",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "query.kinds",
            "description": "OR of Kinds to be matched, AND and Exclude are not supported for this type\nThe max kind string length is 64 bytes. length of string should be between 0 and 64",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "tenants",
            "description": "OR of tenants within the scope of which search needs to be performed. If not specified, it will be set to tenant\nof the logged in user.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "search/v1"
        ]
      },
      "post": {
        "summary": "In the example below a query like\n   http://\u003c...\u003e/venice/v1/search/query?QueryString=XXXXX\u0026MaxResults=100\n generates a RPC call Query with the parameter as\n SearchRequest{ QueryString: \"XXXXX\", MaxResults:100}",
        "operationId": "PostQuery",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/searchSearchResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/searchSearchRequest"
            }
          }
        ],
        "tags": [
          "search/v1"
        ]
      }
    }
  },
  "definitions": {
    "apiAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Any is wrapper around the proto Any object."
    },
    "apiListWatchOptions": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "tenant": {
          "type": "string"
        },
        "namespace": {
          "type": "string"
        },
        "generation-id": {
          "type": "string"
        },
        "resource-version": {
          "type": "string"
        },
        "uuid": {
          "type": "string"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "creation-time": {
          "type": "string",
          "format": "date-time"
        },
        "mod-time": {
          "type": "string",
          "format": "date-time"
        },
        "self-link": {
          "type": "string"
        },
        "label-selector": {
          "type": "string",
          "description": "LabelSelector to select on labels in list or watch results."
        },
        "field-selector": {
          "type": "string",
          "title": "FieldSelector to select on field values in list or watch results"
        },
        "field-change-selector": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "FieldChangeSelector specifies to generate a watch notification on change in field(s) specified."
        },
        "from": {
          "type": "integer",
          "format": "int32",
          "title": "from represents the start offset (zero based), used for pagination.\nresults returned would be in the range [from ... from+max-results-1]"
        },
        "max-results": {
          "type": "integer",
          "format": "int32",
          "description": "max. number of events to be fetched for the request."
        }
      }
    },
    "apiObjectMeta": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name of the object, unique within a Namespace for scoped objects.\nShould start and end in an alphanumeric character and can contain alphanumner or ._-: characters\nminimum length is 2 and maximum length is 64 characters"
        },
        "tenant": {
          "type": "string",
          "title": "Tenant is global namespace isolation for various objects. This can be automatically\nfilled in many cases based on the tenant a user, who created the object, belongs go.\nShould start and end in an alphanumeric character and can contain alphanumner or ._-: characters\nmaximum length is 64 characters"
        },
        "namespace": {
          "type": "string",
          "title": "Namespace of the object, for scoped objects.\nShould start and end in an alphanumeric character and can contain alphanumner or ._-: characters\nmaximum length is 64 characters"
        },
        "generation-id": {
          "type": "string",
          "description": "GenerationID is the generation Id for the object. This is incremented anytime there\n is an update to the user intent, including Spec update and any update to ObjectMeta.\n System generated and updated, not updatable by user."
        },
        "resource-version": {
          "type": "string",
          "description": "Resource version in the object store. This is updated anytime there is any change to the object.\n System generated and updated, not updatable by user."
        },
        "uuid": {
          "type": "string",
          "description": "UUID is the unique identifier for the object. This is generated on creation of the object.\nSystem generated, not updatable by user."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are arbitrary (key,value) pairs associated with any object."
        },
        "creation-time": {
          "type": "string",
          "format": "date-time",
          "description": "CreationTime is the creation time of the object\n System generated and updated, not updatable by user."
        },
        "mod-time": {
          "type": "string",
          "format": "date-time",
          "description": "ModTime is the Last Modification time of the object\n System generated and updated, not updatable by user."
        },
        "self-link": {
          "type": "string",
          "description": "SelfLink is a link for accessing this object. When the object is served from the API-GW it is the\n URI path. Example:\n   - \"/v1/tenants/tenants/tenant2\" \n System generated and updated, not updatable by user."
        }
      },
      "description": "ObjectMeta contains metadata that all objects stored in kvstore must have."
    },
    "apiObjectRef": {
      "type": "object",
      "properties": {
        "tenant": {
          "type": "string",
          "description": "Tenant of the object."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the object, for scoped objects."
        },
        "kind": {
          "type": "string",
          "description": "Kind represents the type of the API object."
        },
        "name": {
          "type": "string",
          "description": "Name of the object, unique within a Namespace for scoped objects."
        },
        "uri": {
          "type": "string",
          "description": "URI is a link to accessing the referenced object."
        }
      },
      "description": "ObjectRef contains identifying information about an object."
    },
    "apiStatus": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string"
        },
        "api-version": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/apiStatusResult",
          "description": "Result contains the status of the operation, success or failure."
        },
        "message": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Message contains human readable form of the error."
        },
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "Code is the HTTP status code."
        },
        "object-ref": {
          "$ref": "#/definitions/apiObjectRef",
          "description": "Reference to the object (optional) for which this status is being sent."
        }
      },
      "description": "Status is returned for calls that dont return objects."
    },
    "apiStatusResult": {
      "type": "object",
      "properties": {
        "Str": {
          "type": "string"
        }
      },
      "description": "StatusResult contains possible statuses for a NIC."
    },
    "apiTimestamp": {
      "type": "object",
      "properties": {
        "seconds": {
          "type": "string",
          "format": "int64"
        },
        "nanos": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "apiWatchEvent": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "object": {
          "$ref": "#/definitions/googleprotobufAny"
        }
      }
    },
    "apiWatchEventList": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/apiWatchEvent"
          }
        }
      }
    },
    "fieldsRequirement": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "The label key that the condition applies to."
        },
        "operator": {
          "type": "string",
          "enum": [
            "equals",
            "notEquals",
            "in",
            "notIn",
            "gt",
            "gte",
            "lt",
            "lte"
          ],
          "default": "equals",
          "x-ui-hints": {
            "gt": "greater than",
            "gte": "greater than or equals",
            "lt": "less than",
            "lte": "less than or equals",
            "notEquals": "not equals",
            "notIn": "not in"
          },
          "description": "Condition checked for the key."
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Values contains one or more values corresponding to the label key. \"equals\" and\n\"notEquals\" operators need a single Value. \"in\" and \"notIn\" operators can have\none or more values."
        }
      },
      "description": "Requirement defines a single matching condition for a selector."
    },
    "fieldsSelector": {
      "type": "object",
      "properties": {
        "requirements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/fieldsRequirement"
          },
          "description": "Requirements are ANDed."
        }
      },
      "description": "Selector is used to select objects by fields. Requirements in the selector are ANDed.\nA selector with no Requirements does not select anything."
    },
    "googleprotobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name whose content describes the type of the\nserialized protocol buffer message.\n\nFor URLs which use the scheme `http`, `https`, or no scheme, the\nfollowing restrictions and interpretations apply:\n\n* If no scheme is provided, `https` is assumed.\n* The last segment of the URL's path must represent the fully\n  qualified name of the type (as in `path/google.protobuf.Duration`).\n  The name should be in a canonical form (e.g., leading \".\" is\n  not accepted).\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "labelsRequirement": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "The label key that the condition applies to."
        },
        "operator": {
          "type": "string",
          "enum": [
            "equals",
            "notEquals",
            "in",
            "notIn"
          ],
          "default": "equals",
          "x-ui-hints": {
            "notEquals": "not equals",
            "notIn": "not in"
          },
          "description": "Condition checked for the key."
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Values contains one or more values corresponding to the label key. \"equals\" and\n\"notEquals\" operators need a single Value. \"in\" and \"notIn\" operators can have\none or more values."
        }
      },
      "description": "Requirement defines a single matching condition for a selector."
    },
    "labelsSelector": {
      "type": "object",
      "properties": {
        "requirements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/labelsRequirement"
          },
          "description": "Requirements are ANDed."
        }
      },
      "description": "Selector is used to select objects by labels. Requirements in the selector are ANDed.\nA selector with no Requirements does not select anything."
    },
    "searchCategoryAggregation": {
      "type": "object",
      "properties": {
        "categories": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchKindAggregation"
          }
        }
      },
      "description": "CategoryAggregation contains map of search result entries\ngrouped by two levels: first by Category and then by Kind."
    },
    "searchCategoryPreview": {
      "type": "object",
      "properties": {
        "categories": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchKindPreview"
          }
        }
      },
      "description": "CategoryPreview contains map of search summary (#hits)\ngrouped by two levels: first by Category and then by Kind."
    },
    "searchEntry": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/apiAny",
          "description": "TODO: Right now our api codegen does not support\nnested inline and hence this attribute cannot be \nbe made embedded/inline. api.Any is already had\nembededed attribute Any. Once infra supports nested\ninline or an alternative, this attribute should be \nembedded and made inline to make json response user\nfriendly for search."
        }
      },
      "description": "Entry represent a single search result entry and contents\nof this entity vary based on Kind.\nFor Events and Alerts Kind, the result will be entire\nobject respectively.\nFor rest of the configs objects, the result will be ConfigEntry\nwith only the type \u0026 object meta data fields."
    },
    "searchEntryList": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/searchEntry"
          }
        }
      },
      "title": "EntryList is list of search result entries"
    },
    "searchError": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "title": "Type of error"
        },
        "reason": {
          "type": "string",
          "title": "Reason or description of the failure"
        }
      },
      "title": "Error contains the error code, description and\nassociated details"
    },
    "searchKindAggregation": {
      "type": "object",
      "properties": {
        "kinds": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchEntryList"
          }
        }
      },
      "description": "KindAggregation contains map of search result\nentries grouped by Kind."
    },
    "searchKindPreview": {
      "type": "object",
      "properties": {
        "kinds": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "int64"
          }
        }
      },
      "description": "KindPreview contains map of search summary (#hits) grouped by Kind."
    },
    "searchPolicyMatchEntry": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/securitySGRule",
          "title": "Matching SGRule"
        },
        "index": {
          "type": "integer",
          "format": "int64",
          "title": "Index of the matching SG rule"
        }
      },
      "description": "PolicyMatchEntry contains the matching SGrule and Index\nwithin the SGPolicy ruleset."
    },
    "searchPolicySearchRequest": {
      "type": "object",
      "properties": {
        "tenant": {
          "type": "string",
          "default": "default",
          "description": "Tenant Name, to perform query within a Tenant's scope.\nThe default tenant is \"default\". In the backend\nthis field gets auto-filled \u0026 validated by apigw-hook\nbased on user login context."
        },
        "namespace": {
          "type": "string",
          "default": "default",
          "description": "Namespace is optional. If provided policy-search will\nbe limited to the specified namespace."
        },
        "sg-policy": {
          "type": "string",
          "description": "SGPolicy name is optional. If provided policy-search will\nbe limited to the specified SGpolicy object name."
        },
        "app": {
          "type": "string",
          "title": "App specification, proto/port format, or predefined apps and alg config\neg: tcp/443, udp/53"
        },
        "from-ip-address": {
          "type": "string",
          "title": "Inbound ip-address, use any to refer to all ipaddresses\neg: 10.1.1.1, any"
        },
        "to-ip-address": {
          "type": "string",
          "title": "Outbound ip-address, use any to refer to all ipaddresses\neg: 20.1.1.1, any"
        },
        "from-security-group": {
          "type": "string",
          "title": "Inbound security group"
        },
        "to-security-group": {
          "type": "string",
          "title": "Outbound security group"
        }
      },
      "title": "PolicySearchRequest is input to the security/firewall policy search request"
    },
    "searchPolicySearchResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string",
          "enum": [
            "MATCH",
            "MISS"
          ],
          "default": "MATCH",
          "title": "Status of firewall policy search"
        },
        "results": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchPolicyMatchEntry"
          },
          "description": "Result is Map of \u003cSGPolicy object name, PolicyMatch Entry\u003e."
        }
      },
      "title": "PolicySearchResponse is response to the security/firewall policy search request"
    },
    "searchSearchQuery": {
      "type": "object",
      "properties": {
        "texts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/searchTextRequirement"
          },
          "title": "OR of Text-requirements to be matched, Exclude is not supported for Text search"
        },
        "categories": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "enum": [
            "Cluster",
            "Workload",
            "Security",
            "Auth",
            "Network",
            "Monitoring",
            "Telemetry",
            "Events",
            "Alerts",
            "AuditTrail"
          ],
          "default": "Cluster",
          "maxLength": 64,
          "description": "length of string should be between 0 and 64\n",
          "title": "OR of Categories to be matched, AND and Exclude are not supported for this type\nThe max category string length is 64 bytes"
        },
        "kinds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "enum": [
            "Cluster",
            "Node",
            "SmartNIC",
            "Rollout",
            "Tenant",
            "Endpoint",
            "SecurityGroup",
            "SGPolicy",
            "App",
            "AppUser",
            "AppUserGrp",
            "Certificate",
            "TrafficEncryptionPolicy",
            "User",
            "AuthenticationPolicy",
            "Role",
            "RoleBinding",
            "Network",
            "Service",
            "LbPolicy",
            "Alert",
            "AlertDestination",
            "AlertPolicy",
            "Event",
            "EventPolicy",
            "StatsPolicy",
            "FlowExportPolicy",
            "FwlogPolicy",
            "MirrorSession",
            "Workload",
            "Host",
            "AuditEvent"
          ],
          "default": "Cluster",
          "maxLength": 64,
          "description": "length of string should be between 0 and 64\n",
          "title": "OR of Kinds to be matched, AND and Exclude are not supported for this type\nThe max kind string length is 64 bytes"
        },
        "fields": {
          "$ref": "#/definitions/fieldsSelector",
          "title": "Field Selector is AND of field.Requirements"
        },
        "labels": {
          "$ref": "#/definitions/labelsSelector",
          "title": "Label Selector is AND of label.Requirememts"
        }
      }
    },
    "searchSearchRequest": {
      "type": "object",
      "properties": {
        "query-string": {
          "type": "string",
          "maxLength": 256,
          "description": "length of string should be between 0 and 256\n",
          "title": "Simple query string\nThis can be specified as URI parameter.\nFor advanced query cases, Users should use specify SearchQuery\nand pass the SearchRequest in a GET/POST Body\nThe max query-string length is 256 bytes"
        },
        "from": {
          "type": "integer",
          "format": "int32",
          "maximum": 1023,
          "description": "value should be between 0 and 1023\n",
          "title": "From represents the start offset (zero based), used in paginated search requests\nThe results returned would be in the range [From ... From+MaxResults-1]\nThis can be specified as URI parameter. \nDefault value is 0 and valid range is 0..1023"
        },
        "max-results": {
          "type": "integer",
          "format": "int32",
          "default": "50",
          "maximum": 8192,
          "description": "value should be between 0 and 8192\n",
          "title": "MaxResults is the max-count of search results\nThis can be specified as URI parameter.\nDefault value is 50 and valid range is 0..8192"
        },
        "sort-by": {
          "type": "string",
          "maxLength": 256,
          "description": "SortyBy is an optional parameter and contains the field name \nto be sorted by, For eg: \"meta.name\"\nThis can be specified as URI parameter."
        },
        "mode": {
          "type": "string",
          "enum": [
            "Full",
            "Preview"
          ],
          "default": "Full",
          "title": "Query Mode"
        },
        "query": {
          "$ref": "#/definitions/searchSearchQuery",
          "description": "Search query contains the search requirements\nThis is intended for advanced query use cases involving\nboolean query, structured term query and supports various\ncombinations of text, phrase strings and search modifiers\nfor specific categories, kinds, fields and labels.\nThis cannot be specified as URI parameter."
        },
        "tenants": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "OR of tenants within the scope of which search needs to be performed. If not specified, it will be set to tenant\nof the logged in user"
        }
      },
      "description": "Simple queries can be specified as URI param using \"QueryString\".\nFor advanced queries, it is recommended to use the \"SearchQuery\" structure\nand specify them in BODY of the GET/POST method.\n\nExamples of search query in query-string format:\n\n 1. Find all occurrences matching text “Network”\n    Network\n 2. Find all occurrences matching phrase “link down”\n    “link down”\n 3. Find all occurrences matching text production OR \"staging\"\n    production staging\n 4. Find all occurrences matching text “Network” AND \"link down\"\n    Network,\"link down\"\n    Network AND \"link down\"\n 5. Find all config objects with label1=foo\n    category:config label:label1=foo\n 6. Find all objects created on or after certain date+time\n    category:config field:meta.created-time\u003e=”date-time-string”\n 7. Find all Network objects with type=vlan\n    kind:Network field:spec.type=vlan\n 8. Find all Naples nodes with admission-phase = pending or rejected\n    kind:SmartNIC field:spec.phase in (pending, rejected)\n 9. Find all events with text matching “disconnected”\n    category:events disconnected\n10. Find all Critical events for Network objects\n    category:events kind:Network field:severity=CRITICAL\n11. Find all Alerts generated from Naples MAC1\n    category:alerts field:status.source.node=MAC1\n    category:alerts MAC1\n12. Find all Naples nodes with metric filter : mem\u003e90 \u0026\u0026 cpu\u003e90\n    category:metrics kind:SmartNIC field:metric.mem\u003e90,metric.cpu\u003e90\n13. Find all Endpoints with label Tier=Web with counter1\u003e=100\n    category:metrics kind:Endpoint label:Tier=Web field:metric.counter1 \u003e 100\n14. Find all Endpoints objects with label target=prod with crc-error-count != 0\n    category:metrics kind:Endpoint label:target=prod field:status.crc-error-count!=0\n15. Find all occurences matching the words and phrase in a certain category \u0026 kinds with certain field and label match\n    production \"status down\" category:Network kind:Network,Service field:spec.service-type=external label:tier=web",
      "title": "SearchRequest is the input to the search API"
    },
    "searchSearchResponse": {
      "type": "object",
      "properties": {
        "total-hits": {
          "type": "string",
          "format": "int64",
          "title": "TotalHits indicates total number of hits matched"
        },
        "actual-hits": {
          "type": "string",
          "format": "int64",
          "title": "ActualHits indicates the actual hits returned in this response"
        },
        "time-taken-msecs": {
          "type": "string",
          "format": "int64",
          "title": "TimeTakenMsecs is the time taken for search response in millisecs"
        },
        "error": {
          "$ref": "#/definitions/searchError",
          "title": "Error status for failures"
        },
        "entries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/searchEntry"
          },
          "title": "EntryList is list of all search results with no grouping.\nThis attribute is populated and valid only in Full request-mode"
        },
        "preview-entries": {
          "$ref": "#/definitions/searchTenantPreview",
          "title": "PreviewEntries is a three level grouping of search summary (#hits),\ngrouped by tenant, category and kind in that order. This attribute\nis populated and valid only in Preview request-mode"
        },
        "aggregated-entries": {
          "$ref": "#/definitions/searchTenantAggregation",
          "title": "AggregatedEntries is a three level grouping of full search results,\nGrouped by tenant, category and kind in that order. This attribute\nis populated and valid only in Full request-mode"
        }
      },
      "description": "SearchResponse is the output provided by the search API\nBased on the search request, search results would be part\nof one of the entities : Entries or NestedAggregation.\nIn case of failures, Error would indicate the error status and\ndescription."
    },
    "searchTenantAggregation": {
      "type": "object",
      "properties": {
        "tenants": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchCategoryAggregation"
          }
        }
      },
      "description": "TenantAggregation contains map of search result entries\ngrouped by three levels: first by Tenant, second by Category \nand finally by Kind."
    },
    "searchTenantPreview": {
      "type": "object",
      "properties": {
        "tenants": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/searchCategoryPreview"
          }
        }
      },
      "description": "TenantPreview contains map of search summary (#hits)\ngrouped by three levels: first by Tenant, second by Category \nand finally by Kind."
    },
    "searchTextRequirement": {
      "type": "object",
      "properties": {
        "text": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "maxLength": 256,
          "description": "length of string should be between 0 and 256\n",
          "title": "AND of words or phrases to be matched\nThe max text-string length is 256 bytes"
        }
      },
      "description": "TextRequirement is AND of text-strings in the list\nIt is comprised of words or phrases for text search support.\nIf a text-string has space separated multi-word, it will be\ninterpreted as a phrase.\n\nIn the example below :\n- \"link down\" will be a phrase query\n- network, production, staging will be a word query\n\nFor eg:\n   network                      (match network)\n   link down                    (match \"link down\" phrase)\n   network,production           (match network AND production)\n   network,link down,staging    (match network AND \"link down\" AND staging)"
    },
    "securityProtoPort": {
      "type": "object",
      "properties": {
        "protocol": {
          "type": "string",
          "description": "protocol is ip (v4/v6) protocol name/number; names can be: tcp, udp, igmp, icmp, gre, esp, etc."
        },
        "ports": {
          "type": "string",
          "title": "TCP or UDP port number(s): comma separate port numbers, or dash separate port range"
        }
      }
    },
    "securitySGRule": {
      "type": "object",
      "properties": {
        "apps": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "list of apps objects to which the rule applies to"
        },
        "proto-ports": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/securityProtoPort"
          },
          "title": "list of (protocol, ports) pairs to which the rule applies to, in addition to apps"
        },
        "action": {
          "type": "string",
          "enum": [
            "PERMIT",
            "DENY",
            "REJECT"
          ],
          "default": "PERMIT",
          "title": "SGRule action, either PERMIT, DENY or REJECT"
        },
        "from-ip-addresses": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "inbound rule from a given ip-address/ip-mask/ip-range. Use any to refer to all ipaddresses\ncli-tags: id=from-ip"
        },
        "to-ip-addresses": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "outbound rule from a given ip-address/ip-mask/ip-range. Use any to refer to all ipaddresses\ncli-tags: id=to-ip"
        },
        "from-security-groups": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "inbound rule from a given security group"
        },
        "to-security-groups": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "outbound rule from a given security group"
        }
      }
    }
  }
}
