// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: search.proto

/*
	Package search is a generated protocol buffer package.

	Service name

	It is generated from these files:
		search.proto
		svc_search.proto

	It has these top-level messages:
		Category
		CategoryAggregation
		Entry
		EntryList
		Error
		Kind
		KindAggregation
		SearchQuery
		SearchRequest
		SearchResponse
		TenantAggregation
		TextRequirement
*/
package search

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import fields "github.com/pensando/sw/api/fields"
import labels "github.com/pensando/sw/api/labels"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Category_Type int32

const (
	// api-groups
	Category_Cluster    Category_Type = 0
	Category_Workload   Category_Type = 1
	Category_Security   Category_Type = 2
	Category_Auth       Category_Type = 3
	Category_Network    Category_Type = 4
	Category_Monitoring Category_Type = 5
	// Additional categories
	// granular categories
	Category_Telemetry Category_Type = 6
	Category_Events    Category_Type = 7
	Category_Alerts    Category_Type = 8
	// special categories
	Category_AuditTrail Category_Type = 9
)

var Category_Type_name = map[int32]string{
	0: "Cluster",
	1: "Workload",
	2: "Security",
	3: "Auth",
	4: "Network",
	5: "Monitoring",
	6: "Telemetry",
	7: "Events",
	8: "Alerts",
	9: "AuditTrail",
}
var Category_Type_value = map[string]int32{
	"Cluster":    0,
	"Workload":   1,
	"Security":   2,
	"Auth":       3,
	"Network":    4,
	"Monitoring": 5,
	"Telemetry":  6,
	"Events":     7,
	"Alerts":     8,
	"AuditTrail": 9,
}

func (x Category_Type) String() string {
	return proto.EnumName(Category_Type_name, int32(x))
}
func (Category_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorSearch, []int{0, 0} }

type Kind_Type int32

const (
	Kind_Cluster                 Kind_Type = 0
	Kind_Node                    Kind_Type = 1
	Kind_SmartNIC                Kind_Type = 2
	Kind_Rollout                 Kind_Type = 3
	Kind_Tenant                  Kind_Type = 4
	Kind_Endpoint                Kind_Type = 5
	Kind_SecurityGroup           Kind_Type = 6
	Kind_Sgpolicy                Kind_Type = 7
	Kind_App                     Kind_Type = 8
	Kind_AppUser                 Kind_Type = 9
	Kind_AppUserGrp              Kind_Type = 10
	Kind_Certificate             Kind_Type = 11
	Kind_TrafficEncryptionPolicy Kind_Type = 12
	Kind_User                    Kind_Type = 13
	Kind_AuthenticationPolicy    Kind_Type = 14
	Kind_Role                    Kind_Type = 15
	Kind_RoleBinding             Kind_Type = 16
	Kind_Network                 Kind_Type = 17
	Kind_Service                 Kind_Type = 18
	Kind_LbPolicy                Kind_Type = 19
	Kind_Alert                   Kind_Type = 20
	Kind_AlertDestination        Kind_Type = 21
	Kind_AlertPolicy             Kind_Type = 22
	Kind_Event                   Kind_Type = 23
	Kind_EventPolicy             Kind_Type = 24
	Kind_StatsPolicy             Kind_Type = 25
	Kind_FlowExportPolicy        Kind_Type = 26
	Kind_FwlogPolicy             Kind_Type = 27
	Kind_MirrorSession           Kind_Type = 28
)

var Kind_Type_name = map[int32]string{
	0:  "Cluster",
	1:  "Node",
	2:  "SmartNIC",
	3:  "Rollout",
	4:  "Tenant",
	5:  "Endpoint",
	6:  "SecurityGroup",
	7:  "Sgpolicy",
	8:  "App",
	9:  "AppUser",
	10: "AppUserGrp",
	11: "Certificate",
	12: "TrafficEncryptionPolicy",
	13: "User",
	14: "AuthenticationPolicy",
	15: "Role",
	16: "RoleBinding",
	17: "Network",
	18: "Service",
	19: "LbPolicy",
	20: "Alert",
	21: "AlertDestination",
	22: "AlertPolicy",
	23: "Event",
	24: "EventPolicy",
	25: "StatsPolicy",
	26: "FlowExportPolicy",
	27: "FwlogPolicy",
	28: "MirrorSession",
}
var Kind_Type_value = map[string]int32{
	"Cluster":                 0,
	"Node":                    1,
	"SmartNIC":                2,
	"Rollout":                 3,
	"Tenant":                  4,
	"Endpoint":                5,
	"SecurityGroup":           6,
	"Sgpolicy":                7,
	"App":                     8,
	"AppUser":                 9,
	"AppUserGrp":              10,
	"Certificate":             11,
	"TrafficEncryptionPolicy": 12,
	"User":                 13,
	"AuthenticationPolicy": 14,
	"Role":                 15,
	"RoleBinding":          16,
	"Network":              17,
	"Service":              18,
	"LbPolicy":             19,
	"Alert":                20,
	"AlertDestination":     21,
	"AlertPolicy":          22,
	"Event":                23,
	"EventPolicy":          24,
	"StatsPolicy":          25,
	"FlowExportPolicy":     26,
	"FwlogPolicy":          27,
	"MirrorSession":        28,
}

func (x Kind_Type) String() string {
	return proto.EnumName(Kind_Type_name, int32(x))
}
func (Kind_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptorSearch, []int{5, 0} }

// List of search categories, specified via "category" modifier
// TODO: generate these enums if possible and use it for validation
type Category struct {
}

func (m *Category) Reset()                    { *m = Category{} }
func (m *Category) String() string            { return proto.CompactTextString(m) }
func (*Category) ProtoMessage()               {}
func (*Category) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{0} }

// List of all allowed Kinds in search, specified via "kind" modifier
// TODO: Define a list/map of Kinds per Category
// TODO: generate these enums if possible and use it for validation per Category
//       This is a placeholder enum until we have a way to auto-generate list
//       of all kinds
type CategoryAggregation struct {
	Categories map[string]*KindAggregation `protobuf:"bytes,1,rep,name=Categories,json=categories,omitempty" json:"categories,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CategoryAggregation) Reset()                    { *m = CategoryAggregation{} }
func (m *CategoryAggregation) String() string            { return proto.CompactTextString(m) }
func (*CategoryAggregation) ProtoMessage()               {}
func (*CategoryAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{1} }

func (m *CategoryAggregation) GetCategories() map[string]*KindAggregation {
	if m != nil {
		return m.Categories
	}
	return nil
}

// TextRequirement is AND of text-strings in the list
// It is comprised of words or phrases for text search support.
// If a text-string has space separated multi-word, it will be
// interpreted as a phrase.
//
// In the example below :
// - "link down" will be a phrase query
// - network, production, staging will be a word query
//
// For eg:
//    network                      (match network)
//    link down                    (match "link down" phrase)
//    network,production           (match network AND production)
//    network,link down,staging    (match network AND "link down" AND staging)
//
type Entry struct {
	// AND of words or phrases to be matched
	// The max text-string length is 256 bytes
	api.TypeMeta   `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta,omitempty,embedded=O" json:"meta,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{2} }

type EntryList struct {
	// OR of Text-requirements to be matched, Exclude is not supported for Text search
	Entries []*Entry `protobuf:"bytes,1,rep,name=Entries,json=entries,omitempty" json:"entries,omitempty"`
}

func (m *EntryList) Reset()                    { *m = EntryList{} }
func (m *EntryList) String() string            { return proto.CompactTextString(m) }
func (*EntryList) ProtoMessage()               {}
func (*EntryList) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{3} }

func (m *EntryList) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Error contains the error code, description and
// associated details
type Error struct {
	// Type of error
	Type string `protobuf:"bytes,1,opt,name=Type,json=type,omitempty,proto3" json:"type,omitempty"`
	// Reason or description of the failure
	Reason string `protobuf:"bytes,2,opt,name=Reason,json=reason,omitempty,proto3" json:"reason,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{4} }

func (m *Error) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Error) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Entry represent a single search result entry
type Kind struct {
}

func (m *Kind) Reset()                    { *m = Kind{} }
func (m *Kind) String() string            { return proto.CompactTextString(m) }
func (*Kind) ProtoMessage()               {}
func (*Kind) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{5} }

// EntryList is list of search result entries
type KindAggregation struct {
	Kinds map[string]*EntryList `protobuf:"bytes,1,rep,name=Kinds,json=kinds,omitempty" json:"kinds,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *KindAggregation) Reset()                    { *m = KindAggregation{} }
func (m *KindAggregation) String() string            { return proto.CompactTextString(m) }
func (*KindAggregation) ProtoMessage()               {}
func (*KindAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{6} }

func (m *KindAggregation) GetKinds() map[string]*EntryList {
	if m != nil {
		return m.Kinds
	}
	return nil
}

// KindAggregation contains map of search result
// entries grouped by Kind.
type SearchQuery struct {
	Texts      []*TextRequirement `protobuf:"bytes,1,rep,name=Texts,json=texts,omitempty" json:"texts,omitempty"`
	Categories []string           `protobuf:"bytes,2,rep,name=Categories,json=categories,omitempty" json:"categories,omitempty"`
	Kinds      []string           `protobuf:"bytes,3,rep,name=Kinds,json=kinds,omitempty" json:"kinds,omitempty"`
	Fields     *fields.Selector   `protobuf:"bytes,4,opt,name=Fields,json=fields,omitempty" json:"fields,omitempty"`
	Labels     *labels.Selector   `protobuf:"bytes,5,opt,name=Labels,json=labels,omitempty" json:"labels,omitempty"`
}

func (m *SearchQuery) Reset()                    { *m = SearchQuery{} }
func (m *SearchQuery) String() string            { return proto.CompactTextString(m) }
func (*SearchQuery) ProtoMessage()               {}
func (*SearchQuery) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{7} }

func (m *SearchQuery) GetTexts() []*TextRequirement {
	if m != nil {
		return m.Texts
	}
	return nil
}

func (m *SearchQuery) GetCategories() []string {
	if m != nil {
		return m.Categories
	}
	return nil
}

func (m *SearchQuery) GetKinds() []string {
	if m != nil {
		return m.Kinds
	}
	return nil
}

func (m *SearchQuery) GetFields() *fields.Selector {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SearchQuery) GetLabels() *labels.Selector {
	if m != nil {
		return m.Labels
	}
	return nil
}

// CategoryAggregation contains map of search result entries
// grouped by two levels: first by Category and then by Kind.
type SearchRequest struct {
	QueryString string       `protobuf:"bytes,1,opt,name=QueryString,json=query-string,omitempty,proto3" json:"query-string,omitempty"`
	From        int32        `protobuf:"varint,2,opt,name=From,json=from,omitempty,proto3" json:"from,omitempty"`
	MaxResults  int32        `protobuf:"varint,3,opt,name=MaxResults,json=max-results,omitempty,proto3" json:"max-results,omitempty"`
	SortBy      string       `protobuf:"bytes,4,opt,name=SortBy,json=sort-by,omitempty,proto3" json:"sort-by,omitempty"`
	Query       *SearchQuery `protobuf:"bytes,5,opt,name=Query,json=query,omitempty" json:"query,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{8} }

func (m *SearchRequest) GetQueryString() string {
	if m != nil {
		return m.QueryString
	}
	return ""
}

func (m *SearchRequest) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SearchRequest) GetMaxResults() int32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

func (m *SearchRequest) GetSortBy() string {
	if m != nil {
		return m.SortBy
	}
	return ""
}

func (m *SearchRequest) GetQuery() *SearchQuery {
	if m != nil {
		return m.Query
	}
	return nil
}

// TenantAggregation contains map of search result entries
// grouped by three levels: first by Tenant, second by Category
// and finally by Kind.
type SearchResponse struct {
	TotalHits         int64              `protobuf:"varint,3,opt,name=TotalHits,json=total-hits,omitempty,proto3" json:"total-hits,omitempty"`
	ActualHits        int64              `protobuf:"varint,4,opt,name=ActualHits,json=actual-hits,omitempty,proto3" json:"actual-hits,omitempty"`
	TimeTakenMsecs    int64              `protobuf:"varint,5,opt,name=TimeTakenMsecs,json=time-taken-msecs,omitempty,proto3" json:"time-taken-msecs,omitempty"`
	Error             *Error             `protobuf:"bytes,6,opt,name=Error,json=error,omitempty" json:"error,omitempty"`
	Entries           []*Entry           `protobuf:"bytes,7,rep,name=Entries,json=entries,omitempty" json:"entries,omitempty"`
	AggregatedEntries *TenantAggregation `protobuf:"bytes,8,opt,name=AggregatedEntries,json=aggregated-entries,omitempty" json:"aggregated-entries,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{9} }

func (m *SearchResponse) GetTotalHits() int64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SearchResponse) GetActualHits() int64 {
	if m != nil {
		return m.ActualHits
	}
	return 0
}

func (m *SearchResponse) GetTimeTakenMsecs() int64 {
	if m != nil {
		return m.TimeTakenMsecs
	}
	return 0
}

func (m *SearchResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SearchResponse) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *SearchResponse) GetAggregatedEntries() *TenantAggregation {
	if m != nil {
		return m.AggregatedEntries
	}
	return nil
}

// SearchRequest is the input to the search API
//
// Simple queries can be specified as URI param using "QueryString".
// For advanced queries, it is recommended to use the "SearchQuery" structure
// and specify them in BODY of the GET/POST method.
//
// Examples of search query in query-string format:
//
//  1. Find all occurrences matching text “Network”
//     Network
//  2. Find all occurrences matching phrase “link down”
//     “link down”
//  3. Find all occurrences matching text production OR "staging"
//     production staging
//  4. Find all occurrences matching text “Network” AND "link down"
//     Network,"link down"
//     Network AND "link down"
//  5. Find all config objects with label1=foo
//     category:config label:label1=foo
//  6. Find all objects created on or after certain date+time
//     category:config field:meta.created-time>=”date-time-string”
//  7. Find all Network objects with type=vlan
//     kind:Network field:spec.type=vlan
//  8. Find all Naples nodes with admission-phase = pending or rejected
//     kind:SmartNIC field:spec.phase in (pending, rejected)
//  9. Find all events with text matching “disconnected”
//     category:events disconnected
// 10. Find all Critical events for Network objects
//     category:events kind:Network field:severity=CRITICAL
// 11. Find all Alerts generated from Naples MAC1
//     category:alerts field:status.source.node=MAC1
//     category:alerts MAC1
// 12. Find all Naples nodes with metric filter : mem>90 && cpu>90
//     category:metrics kind:SmartNIC field:metric.mem>90,metric.cpu>90
// 13. Find all Endpoints with label Tier=Web with counter1>=100
//     category:metrics kind:Endpoint label:Tier=Web field:metric.counter1 > 100
// 14. Find all Endpoints objects with label target=prod with crc-error-count != 0
//     category:metrics kind:Endpoint label:target=prod field:status.crc-error-count!=0
// 15. Find all occurences matching the words and phrase in a certain category & kinds with certain field and label match
//     production "status down" category:Network kind:Network,Service field:spec.service-type=external label:tier=web
//
type TenantAggregation struct {
	// Simple query string
	// This can be specified as URI parameter.
	// For advanced query cases, Users should use specify SearchQuery
	// and pass the SearchRequest in a GET/POST Body
	// The max query-string length is 256 bytes
	Tenants map[string]*CategoryAggregation `protobuf:"bytes,1,rep,name=Tenants,json=tenants,omitempty" json:"tenants,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *TenantAggregation) Reset()                    { *m = TenantAggregation{} }
func (m *TenantAggregation) String() string            { return proto.CompactTextString(m) }
func (*TenantAggregation) ProtoMessage()               {}
func (*TenantAggregation) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{10} }

func (m *TenantAggregation) GetTenants() map[string]*CategoryAggregation {
	if m != nil {
		return m.Tenants
	}
	return nil
}

// SearchResponse is the output provided by the search API
// Based on the search request, search results would be part
// of one of the entities : Entries or NestedAggregation.
// In case of failures, Error would indicate the error status and
// description.
type TextRequirement struct {
	// TotalHits indicates total number of hits matched
	Text []string `protobuf:"bytes,1,rep,name=Text,json=text,omitempty" json:"text,omitempty"`
}

func (m *TextRequirement) Reset()                    { *m = TextRequirement{} }
func (m *TextRequirement) String() string            { return proto.CompactTextString(m) }
func (*TextRequirement) ProtoMessage()               {}
func (*TextRequirement) Descriptor() ([]byte, []int) { return fileDescriptorSearch, []int{11} }

func (m *TextRequirement) GetText() []string {
	if m != nil {
		return m.Text
	}
	return nil
}

func init() {
	proto.RegisterType((*Category)(nil), "search.Category")
	proto.RegisterType((*CategoryAggregation)(nil), "search.CategoryAggregation")
	proto.RegisterType((*Entry)(nil), "search.Entry")
	proto.RegisterType((*EntryList)(nil), "search.EntryList")
	proto.RegisterType((*Error)(nil), "search.Error")
	proto.RegisterType((*Kind)(nil), "search.Kind")
	proto.RegisterType((*KindAggregation)(nil), "search.KindAggregation")
	proto.RegisterType((*SearchQuery)(nil), "search.SearchQuery")
	proto.RegisterType((*SearchRequest)(nil), "search.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "search.SearchResponse")
	proto.RegisterType((*TenantAggregation)(nil), "search.TenantAggregation")
	proto.RegisterType((*TextRequirement)(nil), "search.TextRequirement")
	proto.RegisterEnum("search.Category_Type", Category_Type_name, Category_Type_value)
	proto.RegisterEnum("search.Kind_Type", Kind_Type_name, Kind_Type_value)
}
func (m *Category) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Category) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CategoryAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CategoryAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, _ := range m.Categories {
			dAtA[i] = 0xa
			i++
			v := m.Categories[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.TypeMeta.Size()))
	n2, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x12
	i++
	i = encodeVarintSearch(dAtA, i, uint64(m.ObjectMeta.Size()))
	n3, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *EntryList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *Kind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *KindAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KindAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for k, _ := range m.Kinds {
			dAtA[i] = 0xa
			i++
			v := m.Kinds[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n4, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n4
			}
		}
	}
	return i, nil
}

func (m *SearchQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchQuery) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Texts) > 0 {
		for _, msg := range m.Texts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Fields != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Fields.Size()))
		n5, err := m.Fields.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Labels != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Labels.Size()))
		n6, err := m.Labels.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.QueryString) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.QueryString)))
		i += copy(dAtA[i:], m.QueryString)
	}
	if m.From != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.From))
	}
	if m.MaxResults != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.MaxResults))
	}
	if len(m.SortBy) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSearch(dAtA, i, uint64(len(m.SortBy)))
		i += copy(dAtA[i:], m.SortBy)
	}
	if m.Query != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Query.Size()))
		n7, err := m.Query.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.Error.Size()))
		n8, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintSearch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AggregatedEntries != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSearch(dAtA, i, uint64(m.AggregatedEntries.Size()))
		n9, err := m.AggregatedEntries.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *TenantAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantAggregation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for k, _ := range m.Tenants {
			dAtA[i] = 0xa
			i++
			v := m.Tenants[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovSearch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovSearch(uint64(len(k))) + msgSize
			i = encodeVarintSearch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSearch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintSearch(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *TextRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		for _, s := range m.Text {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintSearch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Category) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CategoryAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Categories) > 0 {
		for k, v := range m.Categories {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovSearch(uint64(l))
	return n
}

func (m *EntryList) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *Kind) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *KindAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Kinds) > 0 {
		for k, v := range m.Kinds {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SearchQuery) Size() (n int) {
	var l int
	_ = l
	if len(m.Texts) > 0 {
		for _, e := range m.Texts {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if len(m.Categories) > 0 {
		for _, s := range m.Categories {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.Labels != nil {
		l = m.Labels.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.QueryString)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.From != 0 {
		n += 1 + sovSearch(uint64(m.From))
	}
	if m.MaxResults != 0 {
		n += 1 + sovSearch(uint64(m.MaxResults))
	}
	l = len(m.SortBy)
	if l > 0 {
		n += 1 + l + sovSearch(uint64(l))
	}
	if m.Query != nil {
		l = m.Query.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovSearch(uint64(m.TotalHits))
	}
	if m.ActualHits != 0 {
		n += 1 + sovSearch(uint64(m.ActualHits))
	}
	if m.TimeTakenMsecs != 0 {
		n += 1 + sovSearch(uint64(m.TimeTakenMsecs))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	if m.AggregatedEntries != nil {
		l = m.AggregatedEntries.Size()
		n += 1 + l + sovSearch(uint64(l))
	}
	return n
}

func (m *TenantAggregation) Size() (n int) {
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for k, v := range m.Tenants {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSearch(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSearch(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSearch(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TextRequirement) Size() (n int) {
	var l int
	_ = l
	if len(m.Text) > 0 {
		for _, s := range m.Text {
			l = len(s)
			n += 1 + l + sovSearch(uint64(l))
		}
	}
	return n
}

func sovSearch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSearch(x uint64) (n int) {
	return sovSearch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Category) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Category: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Category: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CategoryAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CategoryAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CategoryAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Categories == nil {
				m.Categories = make(map[string]*KindAggregation)
			}
			var mapkey string
			var mapvalue *KindAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KindAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Categories[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntryList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KindAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KindAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KindAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kinds == nil {
				m.Kinds = make(map[string]*EntryList)
			}
			var mapkey string
			var mapvalue *EntryList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntryList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Kinds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Texts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Texts = append(m.Texts, &TextRequirement{})
			if err := m.Texts[len(m.Texts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Categories", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Categories = append(m.Categories, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &fields.Selector{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = &labels.Selector{}
			}
			if err := m.Labels.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxResults", wireType)
			}
			m.MaxResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxResults |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Query == nil {
				m.Query = &SearchQuery{}
			}
			if err := m.Query.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualHits", wireType)
			}
			m.ActualHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualHits |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeTakenMsecs", wireType)
			}
			m.TimeTakenMsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeTakenMsecs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatedEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AggregatedEntries == nil {
				m.AggregatedEntries = &TenantAggregation{}
			}
			if err := m.AggregatedEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tenants == nil {
				m.Tenants = make(map[string]*CategoryAggregation)
			}
			var mapkey string
			var mapvalue *CategoryAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSearch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSearch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthSearch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &CategoryAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSearch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSearch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tenants[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSearch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = append(m.Text, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSearch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSearch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSearch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSearch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSearch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSearch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSearch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSearch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSearch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSearch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("search.proto", fileDescriptorSearch) }

var fileDescriptorSearch = []byte{
	// 1460 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xdd, 0x4e, 0x1b, 0x47,
	0x14, 0xce, 0xe2, 0x3f, 0x3c, 0xe6, 0x67, 0x18, 0x48, 0xb0, 0x1d, 0x04, 0xc8, 0x6d, 0x53, 0xa2,
	0x60, 0x1b, 0x48, 0x8b, 0x92, 0xde, 0x79, 0x89, 0x49, 0xa2, 0x40, 0x92, 0xda, 0x6e, 0xd3, 0xa8,
	0x52, 0xa5, 0xc5, 0x1e, 0xcc, 0x94, 0xf5, 0xcc, 0x66, 0x76, 0x16, 0xf0, 0x0b, 0xd0, 0xab, 0xbe,
	0x40, 0x9f, 0xa0, 0xe2, 0xb2, 0x57, 0x95, 0xfa, 0x00, 0xcd, 0x65, 0xa4, 0xde, 0xa3, 0x8a, 0x4b,
	0xde, 0xa1, 0x52, 0x75, 0x66, 0x77, 0x61, 0xbd, 0x18, 0xda, 0xaa, 0x77, 0x73, 0xbe, 0x39, 0xe7,
	0x9b, 0x33, 0x67, 0xce, 0xcf, 0x2e, 0x1a, 0x73, 0xa9, 0x25, 0xdb, 0x7b, 0x15, 0x47, 0x0a, 0x25,
	0x48, 0xda, 0x97, 0x8a, 0x73, 0x5d, 0x21, 0xba, 0x36, 0xad, 0x5a, 0x0e, 0xab, 0x5a, 0x9c, 0x0b,
	0x65, 0x29, 0x26, 0xb8, 0xeb, 0x6b, 0x15, 0xeb, 0x5d, 0xa6, 0xf6, 0xbc, 0x9d, 0x4a, 0x5b, 0xf4,
	0xaa, 0x0e, 0xe5, 0xae, 0xc5, 0x3b, 0xa2, 0xea, 0x1e, 0x56, 0x0f, 0x28, 0x67, 0x6d, 0x5a, 0xf5,
	0x14, 0xb3, 0x5d, 0x30, 0xed, 0x52, 0x1e, 0xb5, 0xae, 0x32, 0xde, 0xb6, 0xbd, 0x0e, 0x0d, 0x69,
	0xca, 0x11, 0x9a, 0xae, 0xe8, 0x8a, 0xaa, 0x86, 0x77, 0xbc, 0x5d, 0x2d, 0x69, 0x41, 0xaf, 0x02,
	0xf5, 0x4f, 0xae, 0x39, 0x15, 0x7c, 0xec, 0x51, 0x65, 0x05, 0x6a, 0x2b, 0x37, 0xa8, 0xed, 0x32,
	0x6a, 0x77, 0xdc, 0xaa, 0x4b, 0x6d, 0xda, 0x56, 0x42, 0xfe, 0x0b, 0x0b, 0xdb, 0xda, 0xa1, 0x76,
	0xdc, 0xa2, 0xf4, 0x93, 0x81, 0x46, 0x37, 0x2c, 0x45, 0xbb, 0x42, 0xf6, 0x4b, 0x3f, 0x1a, 0x28,
	0xd9, 0xea, 0x3b, 0x94, 0xe4, 0x50, 0x66, 0xc3, 0xf6, 0x5c, 0x45, 0x25, 0xbe, 0x45, 0xc6, 0xd0,
	0xe8, 0x1b, 0x21, 0xf7, 0x6d, 0x61, 0x75, 0xb0, 0x01, 0x52, 0x93, 0xb6, 0x3d, 0xc9, 0x54, 0x1f,
	0x8f, 0x90, 0x51, 0x94, 0xac, 0x79, 0x6a, 0x0f, 0x27, 0xc0, 0xe4, 0x25, 0x55, 0x87, 0x42, 0xee,
	0xe3, 0x24, 0x99, 0x40, 0x68, 0x5b, 0x70, 0xa6, 0x84, 0x64, 0xbc, 0x8b, 0x53, 0x64, 0x1c, 0x65,
	0x5b, 0xd4, 0xa6, 0x3d, 0xaa, 0x64, 0x1f, 0xa7, 0x09, 0x42, 0xe9, 0xfa, 0x01, 0xe5, 0xca, 0xc5,
	0x19, 0x58, 0xd7, 0x6c, 0x2a, 0x95, 0x8b, 0x47, 0xc1, 0xac, 0xe6, 0x75, 0x98, 0x6a, 0x49, 0x8b,
	0xd9, 0x38, 0x5b, 0x3a, 0x33, 0xd0, 0x74, 0xe8, 0x5c, 0xad, 0xdb, 0x95, 0xb4, 0xab, 0xc3, 0x4f,
	0x5c, 0x84, 0x02, 0x98, 0x51, 0x37, 0x6f, 0x2c, 0x26, 0x96, 0x72, 0x6b, 0x0f, 0x2a, 0xc1, 0xf3,
	0x0f, 0x31, 0xa8, 0x5c, 0x6a, 0xd7, 0xb9, 0x92, 0x7d, 0x73, 0xee, 0xfd, 0xe9, 0x82, 0x71, 0x7e,
	0xba, 0x30, 0xd3, 0xbe, 0xd8, 0x58, 0x16, 0x3d, 0xa6, 0x68, 0xcf, 0x51, 0xfd, 0xc6, 0x50, 0xb4,
	0xf8, 0x35, 0x9a, 0x8c, 0xd1, 0x10, 0x8c, 0x12, 0xfb, 0xb4, 0x9f, 0x37, 0x16, 0x8d, 0xa5, 0x6c,
	0x03, 0x96, 0xa4, 0x8c, 0x52, 0x07, 0x96, 0xed, 0xd1, 0xfc, 0xc8, 0xa2, 0xb1, 0x94, 0x5b, 0x9b,
	0x0d, 0x9d, 0x7a, 0xc1, 0x78, 0x27, 0xe2, 0x50, 0xc3, 0xd7, 0xfa, 0x62, 0xe4, 0x91, 0x51, 0xfa,
	0xc1, 0x40, 0x29, 0x9f, 0x6e, 0x1d, 0x19, 0x2d, 0x4d, 0x96, 0x5b, 0x1b, 0xaf, 0x58, 0x0e, 0xab,
	0xc0, 0x5b, 0x6c, 0x53, 0x65, 0x99, 0xd3, 0xef, 0x4f, 0x17, 0x6e, 0x7d, 0xf0, 0x7d, 0xce, 0x2c,
	0x33, 0x6e, 0x33, 0x4e, 0x1b, 0xe1, 0x82, 0x6c, 0x22, 0xe3, 0x55, 0x70, 0xe0, 0xa4, 0xb6, 0x7b,
	0xb5, 0xf3, 0x3d, 0x6d, 0x2b, 0x6d, 0x59, 0x8c, 0x58, 0x4e, 0x40, 0x6e, 0x45, 0xee, 0x19, 0x93,
	0x4b, 0x6f, 0x51, 0x56, 0x3b, 0xb2, 0xc5, 0x5c, 0x45, 0xb6, 0x50, 0x06, 0x84, 0xcb, 0x00, 0x8f,
	0x87, 0x77, 0xf1, 0x43, 0x58, 0x08, 0x42, 0x38, 0x45, 0x7d, 0xad, 0x08, 0xef, 0x55, 0xa8, 0xf4,
	0x0e, 0xa5, 0xea, 0x52, 0x0a, 0x49, 0x56, 0xfc, 0x0c, 0xf3, 0x63, 0x66, 0x12, 0xf0, 0x4a, 0xf5,
	0x1d, 0x1a, 0xf5, 0x6a, 0x50, 0x26, 0xeb, 0x28, 0xdd, 0xa0, 0x96, 0x2b, 0xb8, 0xbe, 0x62, 0xd6,
	0x9c, 0x39, 0x3f, 0x5d, 0xc0, 0x52, 0x23, 0x11, 0xab, 0x2b, 0x48, 0xe9, 0x43, 0x02, 0x25, 0x21,
	0xec, 0xa5, 0xdf, 0x13, 0xc3, 0xb2, 0x7a, 0x14, 0x25, 0x5f, 0x8a, 0x0e, 0x0d, 0x32, 0xba, 0x67,
	0x49, 0xf5, 0xf2, 0xf9, 0x06, 0x1e, 0x01, 0xa5, 0x86, 0xb0, 0x6d, 0xe1, 0x29, 0x9c, 0x80, 0xe4,
	0x6c, 0x51, 0x6e, 0x71, 0x85, 0x93, 0xa0, 0x56, 0xe7, 0x1d, 0x47, 0x30, 0xae, 0x70, 0x8a, 0x4c,
	0xa1, 0xf1, 0xb0, 0x0c, 0x9e, 0x4a, 0xe1, 0x39, 0x38, 0xad, 0x79, 0xba, 0x8e, 0xb0, 0x59, 0xbb,
	0x8f, 0x33, 0x24, 0x83, 0x12, 0x35, 0xc7, 0xc1, 0xa3, 0x40, 0x58, 0x73, 0x9c, 0xaf, 0x5c, 0x2a,
	0x71, 0x56, 0x67, 0xb8, 0x2f, 0x3c, 0x95, 0x0e, 0x46, 0x64, 0x12, 0xe5, 0x36, 0xa8, 0x54, 0x6c,
	0x97, 0x41, 0xce, 0xe1, 0x1c, 0xb9, 0x8b, 0x66, 0x5b, 0xd2, 0xda, 0xdd, 0x65, 0xed, 0x3a, 0x6f,
	0xcb, 0xbe, 0x03, 0xd9, 0xf2, 0xda, 0xe7, 0x1c, 0x03, 0x9f, 0x35, 0xcf, 0x38, 0xc9, 0xa3, 0x19,
	0xa8, 0x3b, 0xca, 0x15, 0x18, 0x5e, 0xea, 0x4c, 0x80, 0x4e, 0x43, 0xd8, 0x14, 0x4f, 0x02, 0x37,
	0xac, 0x4c, 0xc6, 0x3b, 0x50, 0x85, 0x38, 0x5a, 0xa2, 0x53, 0x20, 0x34, 0xa9, 0x3c, 0x60, 0x6d,
	0x8a, 0x09, 0xb8, 0xbe, 0xb5, 0x13, 0x50, 0x4c, 0x93, 0x2c, 0x4a, 0xe9, 0x92, 0xc4, 0x33, 0x64,
	0x06, 0x61, 0xbd, 0x7c, 0x42, 0x5d, 0xc5, 0xb8, 0x3e, 0x09, 0xdf, 0x06, 0x66, 0x8d, 0x06, 0x16,
	0x77, 0xc0, 0x42, 0x17, 0x34, 0x9e, 0x85, 0x3d, 0xbd, 0x0c, 0xf6, 0xf2, 0x00, 0x34, 0x95, 0xa5,
	0xdc, 0x00, 0x28, 0x00, 0xe7, 0xa6, 0x2d, 0x0e, 0xeb, 0x47, 0x8e, 0xb8, 0xa0, 0x28, 0x82, 0xda,
	0xe6, 0xa1, 0x2d, 0xba, 0x01, 0x70, 0x17, 0x22, 0xbc, 0xcd, 0x20, 0x67, 0x9a, 0xd4, 0x75, 0xe1,
	0xdc, 0xb9, 0xd2, 0x6f, 0x06, 0x9a, 0x8c, 0x55, 0x12, 0xf9, 0x16, 0xa5, 0x00, 0x0a, 0xb3, 0xb4,
	0x74, 0x4d, 0xc5, 0x69, 0x39, 0xa8, 0xfe, 0xd9, 0x20, 0x75, 0x27, 0xf7, 0x01, 0x8b, 0x24, 0x51,
	0x1c, 0x28, 0xbe, 0x40, 0xe8, 0xd2, 0x6e, 0x48, 0xb9, 0x7f, 0x3a, 0x58, 0xee, 0x53, 0x03, 0x25,
	0x02, 0x65, 0x14, 0x2d, 0xf4, 0x5f, 0x13, 0x28, 0xd7, 0xd4, 0xfb, 0x5f, 0x7a, 0x54, 0xf6, 0xc9,
	0x16, 0x4a, 0xb5, 0xe8, 0x91, 0x0a, 0x3d, 0xbf, 0xe8, 0x15, 0x00, 0x36, 0xe8, 0x3b, 0x8f, 0x49,
	0xda, 0xa3, 0x5c, 0x99, 0xd3, 0xe0, 0xaa, 0x02, 0xcd, 0xa8, 0xab, 0x31, 0x80, 0xd8, 0x03, 0x3d,
	0x71, 0x64, 0x31, 0xb1, 0x94, 0x35, 0xcd, 0x93, 0xe3, 0xc2, 0x9d, 0xa6, 0x92, 0x75, 0xee, 0xf5,
	0x96, 0xc2, 0xbe, 0xa8, 0xbb, 0xca, 0xfd, 0x93, 0xe3, 0xc2, 0x58, 0x53, 0xc9, 0x2d, 0xca, 0x97,
	0x56, 0x96, 0xd7, 0x3f, 0xbb, 0xff, 0xdf, 0x9a, 0x21, 0x79, 0x1b, 0x46, 0x3d, 0xa1, 0x0f, 0x7a,
	0x7c, 0x72, 0x5c, 0x20, 0xe1, 0x41, 0xb0, 0x71, 0xed, 0x21, 0xff, 0x18, 0x73, 0xf2, 0x0c, 0xa5,
	0x37, 0xf5, 0x70, 0xcb, 0x27, 0x75, 0x50, 0x71, 0xc5, 0x9f, 0x75, 0x95, 0x66, 0x30, 0xb9, 0xfc,
	0x0e, 0xe0, 0x83, 0xd1, 0x0e, 0x10, 0x47, 0x80, 0x69, 0x4b, 0x0f, 0xbd, 0x7c, 0x2a, 0x60, 0xf2,
	0x67, 0x60, 0x8c, 0xc9, 0x07, 0xa3, 0x4c, 0x71, 0xa4, 0xf4, 0x73, 0x02, 0xca, 0x1d, 0x5e, 0x07,
	0x1e, 0x86, 0xba, 0x8a, 0x7c, 0x83, 0x72, 0xfa, 0x15, 0x9b, 0x0a, 0x46, 0x5c, 0xd0, 0xce, 0x1e,
	0x9c, 0x1c, 0x17, 0xc6, 0x2f, 0x2e, 0xbc, 0xf6, 0xf9, 0x3a, 0xdc, 0xf8, 0xce, 0x3b, 0xd0, 0x2b,
	0xbb, 0x5a, 0x31, 0x72, 0xca, 0x35, 0x38, 0x79, 0x82, 0x92, 0x9b, 0x52, 0xf4, 0x74, 0x4a, 0xa5,
	0xcc, 0x7b, 0x27, 0xc7, 0x05, 0xfc, 0x9c, 0xab, 0x86, 0xc5, 0xbb, 0x74, 0x69, 0x65, 0x79, 0x75,
	0x65, 0xed, 0x21, 0xb0, 0x4e, 0xec, 0x4a, 0xd1, 0x8b, 0x76, 0xcd, 0x41, 0x99, 0x7c, 0x87, 0xd0,
	0xb6, 0x75, 0xd4, 0xa0, 0xae, 0x67, 0x2b, 0x78, 0x25, 0xe0, 0x7a, 0x18, 0xe3, 0x7a, 0xb4, 0xfa,
	0x78, 0xed, 0xfe, 0x2f, 0xc7, 0x85, 0x91, 0xd5, 0x95, 0xf3, 0xd3, 0x85, 0xdb, 0x3d, 0xeb, 0xa8,
	0x2c, 0x7d, 0x83, 0x08, 0xf1, 0x70, 0x98, 0x3c, 0x47, 0xe9, 0xa6, 0x90, 0xca, 0xec, 0xeb, 0x57,
	0xca, 0x6a, 0x3f, 0xaf, 0x5c, 0x7d, 0xca, 0x15, 0x52, 0x95, 0x77, 0xfa, 0xd1, 0xd9, 0x70, 0x05,
	0x82, 0x3a, 0xd0, 0xa1, 0x0c, 0x5e, 0x69, 0x3a, 0xac, 0x83, 0x48, 0xad, 0x5c, 0x96, 0xac, 0x0e,
	0x5a, 0x34, 0x7d, 0x62, 0x40, 0xe9, 0xaf, 0x04, 0x9a, 0x08, 0x9f, 0xca, 0x75, 0x04, 0x77, 0x29,
	0xa9, 0xa1, 0x6c, 0x4b, 0x28, 0xcb, 0x7e, 0xc6, 0x82, 0x50, 0x24, 0xcc, 0x3c, 0xe4, 0xbb, 0x02,
	0xb0, 0xbc, 0xc7, 0x06, 0xee, 0x3b, 0x14, 0x25, 0x4f, 0x10, 0xaa, 0xb5, 0x95, 0x17, 0x70, 0x24,
	0x35, 0x47, 0x01, 0x82, 0x66, 0x69, 0x34, 0x4e, 0x32, 0x1c, 0x26, 0x0d, 0x34, 0xd1, 0x62, 0x3d,
	0xda, 0xb2, 0xf6, 0x29, 0xdf, 0x76, 0x69, 0xdb, 0x4f, 0xcc, 0x84, 0x39, 0x7f, 0x7e, 0xba, 0x50,
	0x54, 0xac, 0x47, 0xcb, 0x0a, 0xb6, 0xca, 0x3d, 0xd8, 0x8b, 0xd0, 0xdd, 0xb0, 0x47, 0x36, 0x83,
	0xc9, 0x9a, 0x4f, 0x07, 0x1f, 0x0e, 0x61, 0x0b, 0x02, 0xf0, 0x32, 0x6e, 0x14, 0xc4, 0x68, 0xdc,
	0x62, 0x40, 0x74, 0xde, 0x67, 0xfe, 0xf7, 0xbc, 0x27, 0x47, 0x68, 0x2a, 0x6c, 0xbe, 0xb4, 0x13,
	0xf2, 0x8e, 0x6a, 0x0f, 0x0b, 0x97, 0x7d, 0x0e, 0x26, 0x6b, 0xa4, 0x47, 0x9b, 0x1f, 0x07, 0x67,
	0xcc, 0x59, 0x17, 0xb6, 0xe5, 0xab, 0xc7, 0xdd, 0xb8, 0x5b, 0xfa, 0xc3, 0x40, 0x53, 0x57, 0x98,
	0x09, 0x45, 0x19, 0x1f, 0x0c, 0xbb, 0xed, 0xbd, 0x6b, 0xbd, 0x08, 0x10, 0x37, 0x76, 0x6d, 0xe5,
	0xa3, 0xd1, 0x6b, 0x5f, 0x81, 0x8a, 0x6f, 0xd0, 0x58, 0xd4, 0x7a, 0xc8, 0xc4, 0x58, 0x1d, 0x9c,
	0x18, 0x77, 0x6f, 0xf8, 0x6a, 0x8d, 0xce, 0x8e, 0x16, 0x9a, 0x8c, 0x8d, 0x05, 0x52, 0x43, 0x49,
	0x80, 0xf4, 0x7d, 0xb2, 0xe6, 0x47, 0xc3, 0xea, 0x6f, 0x02, 0x86, 0xc4, 0xc0, 0xa7, 0xd5, 0x80,
	0x6c, 0x8e, 0xbd, 0x3f, 0x9b, 0x37, 0x3e, 0x9c, 0xcd, 0x1b, 0x7f, 0x9e, 0xcd, 0x1b, 0xaf, 0x8d,
	0x9d, 0xb4, 0xfe, 0x27, 0x78, 0xf8, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4a, 0xbb, 0xfc, 0x9c,
	0x4a, 0x0d, 0x00, 0x00,
}
