// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

package grpcclient

import (
	"context"
	"errors"
	oldlog "log"

	"github.com/go-kit/kit/endpoint"
	grpctransport "github.com/go-kit/kit/transport/grpc"
	"google.golang.org/grpc"

	api "github.com/pensando/sw/api"
	workload "github.com/pensando/sw/api/generated/workload"
	listerwatcher "github.com/pensando/sw/api/listerwatcher"
	apiserver "github.com/pensando/sw/venice/apiserver"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/trace"
)

// Dummy vars to suppress import errors
var _ api.TypeMeta
var _ listerwatcher.WatcherClient
var _ kvstore.Interface

// NewWorkloadV1 sets up a new client for WorkloadV1
func NewWorkloadV1(conn *grpc.ClientConn, logger log.Logger) workload.ServiceWorkloadV1Client {

	var lAutoAddEndpointEndpoint endpoint.Endpoint
	{
		lAutoAddEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoAddEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoAddEndpoint")(lAutoAddEndpointEndpoint)
	}
	var lAutoAddWorkloadEndpoint endpoint.Endpoint
	{
		lAutoAddWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoAddWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoAddWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoAddWorkload")(lAutoAddWorkloadEndpoint)
	}
	var lAutoDeleteEndpointEndpoint endpoint.Endpoint
	{
		lAutoDeleteEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoDeleteEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoDeleteEndpoint")(lAutoDeleteEndpointEndpoint)
	}
	var lAutoDeleteWorkloadEndpoint endpoint.Endpoint
	{
		lAutoDeleteWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoDeleteWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoDeleteWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoDeleteWorkload")(lAutoDeleteWorkloadEndpoint)
	}
	var lAutoGetEndpointEndpoint endpoint.Endpoint
	{
		lAutoGetEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoGetEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoGetEndpoint")(lAutoGetEndpointEndpoint)
	}
	var lAutoGetWorkloadEndpoint endpoint.Endpoint
	{
		lAutoGetWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoGetWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoGetWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoGetWorkload")(lAutoGetWorkloadEndpoint)
	}
	var lAutoListEndpointEndpoint endpoint.Endpoint
	{
		lAutoListEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoListEndpoint",
			workload.EncodeGrpcReqListWatchOptions,
			workload.DecodeGrpcRespEndpointList,
			&workload.EndpointList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoListEndpoint")(lAutoListEndpointEndpoint)
	}
	var lAutoListWorkloadEndpoint endpoint.Endpoint
	{
		lAutoListWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoListWorkload",
			workload.EncodeGrpcReqListWatchOptions,
			workload.DecodeGrpcRespWorkloadList,
			&workload.WorkloadList{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoListWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoListWorkload")(lAutoListWorkloadEndpoint)
	}
	var lAutoUpdateEndpointEndpoint endpoint.Endpoint
	{
		lAutoUpdateEndpointEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoUpdateEndpoint",
			workload.EncodeGrpcReqEndpoint,
			workload.DecodeGrpcRespEndpoint,
			&workload.Endpoint{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateEndpointEndpoint = trace.ClientEndPoint("WorkloadV1:AutoUpdateEndpoint")(lAutoUpdateEndpointEndpoint)
	}
	var lAutoUpdateWorkloadEndpoint endpoint.Endpoint
	{
		lAutoUpdateWorkloadEndpoint = grpctransport.NewClient(
			conn,
			"workload.WorkloadV1",
			"AutoUpdateWorkload",
			workload.EncodeGrpcReqWorkload,
			workload.DecodeGrpcRespWorkload,
			&workload.Workload{},
			grpctransport.ClientBefore(trace.ToGRPCRequest(logger)),
			grpctransport.ClientBefore(dummyBefore),
		).Endpoint()
		lAutoUpdateWorkloadEndpoint = trace.ClientEndPoint("WorkloadV1:AutoUpdateWorkload")(lAutoUpdateWorkloadEndpoint)
	}
	return workload.EndpointsWorkloadV1Client{
		Client: workload.NewWorkloadV1Client(conn),

		AutoAddEndpointEndpoint:    lAutoAddEndpointEndpoint,
		AutoAddWorkloadEndpoint:    lAutoAddWorkloadEndpoint,
		AutoDeleteEndpointEndpoint: lAutoDeleteEndpointEndpoint,
		AutoDeleteWorkloadEndpoint: lAutoDeleteWorkloadEndpoint,
		AutoGetEndpointEndpoint:    lAutoGetEndpointEndpoint,
		AutoGetWorkloadEndpoint:    lAutoGetWorkloadEndpoint,
		AutoListEndpointEndpoint:   lAutoListEndpointEndpoint,
		AutoListWorkloadEndpoint:   lAutoListWorkloadEndpoint,
		AutoUpdateEndpointEndpoint: lAutoUpdateEndpointEndpoint,
		AutoUpdateWorkloadEndpoint: lAutoUpdateWorkloadEndpoint,
	}
}

// NewWorkloadV1Backend creates an instrumented client with middleware
func NewWorkloadV1Backend(conn *grpc.ClientConn, logger log.Logger) workload.ServiceWorkloadV1Client {
	cl := NewWorkloadV1(conn, logger)
	cl = workload.LoggingWorkloadV1MiddlewareClient(logger)(cl)
	return cl
}

type grpcObjWorkloadV1Endpoint struct {
	logger log.Logger
	client workload.ServiceWorkloadV1Client
}

func (a *grpcObjWorkloadV1Endpoint) Create(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddEndpoint(nctx, in)
}

func (a *grpcObjWorkloadV1Endpoint) Update(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateEndpoint(nctx, in)
}

func (a *grpcObjWorkloadV1Endpoint) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetEndpoint(nctx, &in)
}

func (a *grpcObjWorkloadV1Endpoint) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteEndpoint(nctx, &in)
}

func (a *grpcObjWorkloadV1Endpoint) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Endpoint, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListEndpoint(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjWorkloadV1Endpoint) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Endpoint", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchEndpoint(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(workload.WorkloadV1_AutoWatchEndpointClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjWorkloadV1Endpoint) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjWorkloadV1Endpoint struct {
	endpoints workload.EndpointsWorkloadV1RestClient
	instance  string
}

func (a *restObjWorkloadV1Endpoint) Create(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddEndpoint(ctx, in)
}

func (a *restObjWorkloadV1Endpoint) Update(ctx context.Context, in *workload.Endpoint) (*workload.Endpoint, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateEndpoint(ctx, in)
}

func (a *restObjWorkloadV1Endpoint) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetEndpoint(ctx, &in)
}

func (a *restObjWorkloadV1Endpoint) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Endpoint, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Endpoint{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteEndpoint(ctx, &in)
}

func (a *restObjWorkloadV1Endpoint) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Endpoint, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListEndpoint(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjWorkloadV1Endpoint) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjWorkloadV1Endpoint) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type grpcObjWorkloadV1Workload struct {
	logger log.Logger
	client workload.ServiceWorkloadV1Client
}

func (a *grpcObjWorkloadV1Workload) Create(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "create")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoAddWorkload(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) Update(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "update")
	if in == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	return a.client.AutoUpdateWorkload(nctx, in)
}

func (a *grpcObjWorkloadV1Workload) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "get")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoGetWorkload(nctx, &in)
}

func (a *grpcObjWorkloadV1Workload) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "delete")
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	nctx := addVersion(ctx, "v1")
	return a.client.AutoDeleteWorkload(nctx, &in)
}

func (a *grpcObjWorkloadV1Workload) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Workload, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "list")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	nctx := addVersion(ctx, "v1")
	r, err := a.client.AutoListWorkload(nctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *grpcObjWorkloadV1Workload) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	a.logger.DebugLog("msg", "received call", "object", "Workload", "oper", "WatchOper")
	nctx := addVersion(ctx, "v1")
	if options == nil {
		return nil, errors.New("invalid input")
	}
	stream, err := a.client.AutoWatchWorkload(nctx, options)
	if err != nil {
		return nil, err
	}
	wstream := stream.(workload.WorkloadV1_AutoWatchWorkloadClient)
	bridgefn := func(lw *listerwatcher.WatcherClient) {
		for {
			r, err := wstream.Recv()
			if err != nil {
				a.logger.ErrorLog("msg", "error on receive", "error", err)
				close(lw.OutCh)
				return
			}
			for _, e := range r.Events {
				ev := kvstore.WatchEvent{
					Type:   kvstore.WatchEventType(e.Type),
					Object: e.Object,
				}
				select {
				case lw.OutCh <- &ev:
				case <-wstream.Context().Done():
					close(lw.OutCh)
					return
				}
			}
		}
	}
	lw := listerwatcher.NewWatcherClient(wstream, bridgefn)
	lw.Run()
	return lw, nil
}

func (a *grpcObjWorkloadV1Workload) Allowed(oper apiserver.APIOperType) bool {
	return true
}

type restObjWorkloadV1Workload struct {
	endpoints workload.EndpointsWorkloadV1RestClient
	instance  string
}

func (a *restObjWorkloadV1Workload) Create(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoAddWorkload(ctx, in)
}

func (a *restObjWorkloadV1Workload) Update(ctx context.Context, in *workload.Workload) (*workload.Workload, error) {
	if in == nil {
		return nil, errors.New("invalid input")
	}
	return a.endpoints.AutoUpdateWorkload(ctx, in)
}

func (a *restObjWorkloadV1Workload) Get(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoGetWorkload(ctx, &in)
}

func (a *restObjWorkloadV1Workload) Delete(ctx context.Context, objMeta *api.ObjectMeta) (*workload.Workload, error) {
	if objMeta == nil {
		return nil, errors.New("invalid input")
	}
	in := workload.Workload{}
	in.ObjectMeta = *objMeta
	return a.endpoints.AutoDeleteWorkload(ctx, &in)
}

func (a *restObjWorkloadV1Workload) List(ctx context.Context, options *api.ListWatchOptions) ([]*workload.Workload, error) {
	if options == nil {
		return nil, errors.New("invalid input")
	}
	r, err := a.endpoints.AutoListWorkload(ctx, options)
	if err == nil {
		return r.Items, nil
	}
	return nil, err
}

func (a *restObjWorkloadV1Workload) Watch(ctx context.Context, options *api.ListWatchOptions) (kvstore.Watcher, error) {
	return nil, errors.New("not allowed")
}

func (a *restObjWorkloadV1Workload) Allowed(oper apiserver.APIOperType) bool {
	switch oper {
	case apiserver.CreateOper:
		return true
	case apiserver.UpdateOper:
		return true
	case apiserver.GetOper:
		return true
	case apiserver.DeleteOper:
		return true
	case apiserver.ListOper:
		return true
	case apiserver.WatchOper:
		return false
	default:
		return false
	}
}

type crudClientWorkloadV1 struct {
	grpcEndpoint workload.WorkloadV1EndpointInterface
	grpcWorkload workload.WorkloadV1WorkloadInterface
}

// NewGrpcCrudClientWorkloadV1 creates a GRPC client for the service
func NewGrpcCrudClientWorkloadV1(conn *grpc.ClientConn, logger log.Logger) workload.WorkloadV1Interface {
	client := NewWorkloadV1Backend(conn, logger)
	return &crudClientWorkloadV1{

		grpcEndpoint: &grpcObjWorkloadV1Endpoint{client: client, logger: logger},
		grpcWorkload: &grpcObjWorkloadV1Workload{client: client, logger: logger},
	}
}

func (a *crudClientWorkloadV1) Endpoint() workload.WorkloadV1EndpointInterface {
	return a.grpcEndpoint
}

func (a *crudClientWorkloadV1) Workload() workload.WorkloadV1WorkloadInterface {
	return a.grpcWorkload
}

type crudRestClientWorkloadV1 struct {
	restEndpoint workload.WorkloadV1EndpointInterface
	restWorkload workload.WorkloadV1WorkloadInterface
}

// NewRestCrudClientWorkloadV1 creates a REST client for the service.
func NewRestCrudClientWorkloadV1(url string) workload.WorkloadV1Interface {
	endpoints, err := workload.MakeWorkloadV1RestClientEndpoints(url)
	if err != nil {
		oldlog.Fatal("failed to create client")
	}
	return &crudRestClientWorkloadV1{

		restEndpoint: &restObjWorkloadV1Endpoint{endpoints: endpoints, instance: url},
		restWorkload: &restObjWorkloadV1Workload{endpoints: endpoints, instance: url},
	}
}

func (a *crudRestClientWorkloadV1) Endpoint() workload.WorkloadV1EndpointInterface {
	return a.restEndpoint
}

func (a *crudRestClientWorkloadV1) Workload() workload.WorkloadV1WorkloadInterface {
	return a.restWorkload
}
