// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_cluster.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/cluster"
	apiintf "github.com/pensando/sw/api/interfaces"
	"github.com/pensando/sw/venice/globals"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/runtime"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// Cluster is a wrapper object that implements additional functionality
type Cluster struct {
	sync.Mutex
	cluster.Cluster
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Cluster) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Cluster_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Cluster().UpdateStatus(context.Background(), &obj.Cluster)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Cluster().Create(context.Background(), &obj.Cluster)
	}

	return nil
}

// ClusterHandler is the event handler for Cluster object
type ClusterHandler interface {
	OnClusterCreate(obj *Cluster) error
	OnClusterUpdate(oldObj *Cluster, newObj *cluster.Cluster) error
	OnClusterDelete(obj *Cluster) error
	GetClusterWatchOptions() *api.ListWatchOptions
}

// OnClusterCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnClusterCreate(obj *Cluster) error {
	log.Info("OnClusterCreate is not implemented")
	return nil
}

// OnClusterUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnClusterUpdate(oldObj *Cluster, newObj *cluster.Cluster) error {
	log.Info("OnClusterUpdate is not implemented")
	return nil
}

// OnClusterDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnClusterDelete(obj *Cluster) error {
	log.Info("OnClusterDelete is not implemented")
	return nil
}

// GetClusterWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetClusterWatchOptions() *api.ListWatchOptions {
	log.Info("GetClusterWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleClusterEvent handles Cluster events from watcher
func (ct *ctrlerCtx) handleClusterEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleClusterEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Cluster:
		eobj := evt.Object.(*cluster.Cluster)
		kind := "Cluster"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &clusterCtx{event: evt.Type,
			obj: &Cluster{Cluster: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Cluster watch channel", tp)
	}

	return nil
}

// handleClusterEventNoResolver handles Cluster events from watcher
func (ct *ctrlerCtx) handleClusterEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Cluster:
		eobj := evt.Object.(*cluster.Cluster)
		kind := "Cluster"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		clusterHandler := handler.(ClusterHandler)
		// handle based on event type
		ctrlCtx := &clusterCtx{event: evt.Type, obj: &Cluster{Cluster: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Cluster_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = clusterHandler.OnClusterCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*clusterCtx)
				ct.stats.Counter("Cluster_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.Cluster{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = clusterHandler.OnClusterUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Cluster = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &clusterCtx{event: evt.Type, obj: &Cluster{Cluster: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Cluster)
			ct.stats.Counter("Cluster_Deleted_Events").Inc()
			obj.Lock()
			err = clusterHandler.OnClusterDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Cluster watch channel", tp)
	}

	return nil
}

type clusterCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Cluster //
	//   newObj     *cluster.Cluster //update
	newObj *clusterCtx //update
}

func (ctx *clusterCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *clusterCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *clusterCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *clusterCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *clusterCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *clusterCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*clusterCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *clusterCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *clusterCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Cluster = obj.(*clusterCtx).obj.Cluster
}

func (ctx *clusterCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *clusterCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *clusterCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *clusterCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *clusterCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Cluster"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	clusterHandler := handler.(ClusterHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = clusterHandler.OnClusterCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Cluster_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.Cluster{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = clusterHandler.OnClusterUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = clusterHandler.OnClusterDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleClusterEventParallel handles Cluster events from watcher
func (ct *ctrlerCtx) handleClusterEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleClusterEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Cluster:
		eobj := evt.Object.(*cluster.Cluster)
		kind := "Cluster"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &clusterCtx{event: evt.Type, obj: &Cluster{Cluster: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Cluster watch channel", tp)
	}

	return nil
}

// handleClusterEventParallel handles Cluster events from watcher
func (ct *ctrlerCtx) handleClusterEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Cluster:
		eobj := evt.Object.(*cluster.Cluster)
		kind := "Cluster"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		clusterHandler := handler.(ClusterHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*clusterCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Cluster_Created_Events").Inc()
					eobj.Lock()
					err = clusterHandler.OnClusterCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*clusterCtx)
					obj := workCtx.obj
					ct.stats.Counter("Cluster_Updated_Events").Inc()
					obj.Lock()
					p := cluster.Cluster{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = clusterHandler.OnClusterUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Cluster = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &clusterCtx{event: evt.Type, obj: &Cluster{Cluster: *eobj, ctrler: ct}}
			ct.runFunction("Cluster", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*clusterCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Cluster)
				ct.stats.Counter("Cluster_Deleted_Events").Inc()
				obj.Lock()
				err = clusterHandler.OnClusterDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &clusterCtx{event: evt.Type, obj: &Cluster{Cluster: *eobj, ctrler: ct}}
			ct.runFunction("Cluster", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Cluster watch channel", tp)
	}

	return nil
}

// diffCluster does a diff of Cluster objects between local cache and API server
func (ct *ctrlerCtx) diffCluster(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Cluster().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffCluster(): ClusterList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Cluster)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Cluster().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffCluster(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Cluster,
			}
			ct.handleClusterEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffCluster(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleClusterEvent(&evt)
	}
}

func (ct *ctrlerCtx) runClusterWatcher() {
	kind := "Cluster"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	clusterHandler := handler.(ClusterHandler)

	opts := clusterHandler.GetClusterWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "ClusterWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffCluster(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Cluster_Watch").Inc()
		defer ct.stats.Counter("Cluster_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Cluster_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Cluster object watcher
				wt, werr := apicl.ClusterV1().Cluster().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffCluster(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Cluster_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleClusterEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchCluster starts watch on Cluster object
func (ct *ctrlerCtx) WatchCluster(handler ClusterHandler) error {
	kind := "Cluster"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Cluster watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Cluster watcher in a go routine
	ct.runClusterWatcher()

	return nil
}

// StopWatchCluster stops watch on Cluster object
func (ct *ctrlerCtx) StopWatchCluster(handler ClusterHandler) error {
	kind := "Cluster"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Cluster watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// ClusterAPI returns
type ClusterAPI interface {
	Create(obj *cluster.Cluster) error
	SyncCreate(obj *cluster.Cluster) error
	Update(obj *cluster.Cluster) error
	SyncUpdate(obj *cluster.Cluster) error
	Delete(obj *cluster.Cluster) error
	Find(meta *api.ObjectMeta) (*Cluster, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Cluster, error)
	Watch(handler ClusterHandler) error
	StopWatch(handler ClusterHandler) error
	AuthBootstrapComplete(obj *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error)
	RegisterLocalAuthBootstrapCompleteHandler(fn func(*cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error))
	SyncAuthBootstrapComplete(obj *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error)
	RegisterLocalSyncAuthBootstrapCompleteHandler(fn func(*cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error))
	UpdateTLSConfig(obj *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error)
	RegisterLocalUpdateTLSConfigHandler(fn func(*cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error))
	SyncUpdateTLSConfig(obj *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error)
	RegisterLocalSyncUpdateTLSConfigHandler(fn func(*cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error))
}

// dummy struct that implements ClusterAPI
type clusterAPI struct {
	ct *ctrlerCtx

	localAuthBootstrapCompleteHandler     func(obj *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error)
	localSyncAuthBootstrapCompleteHandler func(obj *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error)
	localUpdateTLSConfigHandler           func(obj *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error)
	localSyncUpdateTLSConfigHandler       func(obj *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error)
}

// Create creates Cluster object
func (api *clusterAPI) Create(obj *cluster.Cluster) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Cluster().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Cluster().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Cluster object and updates the cache
func (api *clusterAPI) SyncCreate(obj *cluster.Cluster) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Cluster().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().Cluster().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Cluster object
func (api *clusterAPI) Update(obj *cluster.Cluster) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Cluster().Update(context.Background(), obj)
		return err
	}

	api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Cluster object and updates the cache
func (api *clusterAPI) SyncUpdate(obj *cluster.Cluster) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Cluster().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Cluster object
func (api *clusterAPI) Delete(obj *cluster.Cluster) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Cluster().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *clusterAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "cluster", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "cluster", "/", name)
}

// Find returns an object by meta
func (api *clusterAPI) Find(meta *api.ObjectMeta) (*Cluster, error) {
	// find the object
	obj, err := api.ct.FindObject("Cluster", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Cluster:
		hobj := obj.(*Cluster)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Cluster objects
func (api *clusterAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Cluster, error) {
	var objlist []*Cluster
	objs, err := api.ct.List("Cluster", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Cluster:
			eobj := obj.(*Cluster)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Cluster", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Cluster object
func (api *clusterAPI) Watch(handler ClusterHandler) error {
	api.ct.startWorkerPool("Cluster")
	return api.ct.WatchCluster(handler)
}

// StopWatch stop watch for Tenant Cluster object
func (api *clusterAPI) StopWatch(handler ClusterHandler) error {
	api.ct.Lock()
	api.ct.workPools["Cluster"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchCluster(handler)
}

// AuthBootstrapComplete is an API action
func (api *clusterAPI) AuthBootstrapComplete(obj *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.ClusterV1().Cluster().AuthBootstrapComplete(context.Background(), obj)
	}
	if api.localAuthBootstrapCompleteHandler != nil {
		return api.localAuthBootstrapCompleteHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncAuthBootstrapComplete is an API action. Cache will be updated
func (api *clusterAPI) SyncAuthBootstrapComplete(obj *cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.ClusterV1().Cluster().AuthBootstrapComplete(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.ClusterV1().Cluster().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncAuthBootstrapCompleteHandler != nil {
		return api.localSyncAuthBootstrapCompleteHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *clusterAPI) RegisterLocalAuthBootstrapCompleteHandler(fn func(*cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error)) {
	api.localAuthBootstrapCompleteHandler = fn
}

func (api *clusterAPI) RegisterLocalSyncAuthBootstrapCompleteHandler(fn func(*cluster.ClusterAuthBootstrapRequest) (*cluster.Cluster, error)) {
	api.localSyncAuthBootstrapCompleteHandler = fn
}

// UpdateTLSConfig is an API action
func (api *clusterAPI) UpdateTLSConfig(obj *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.ClusterV1().Cluster().UpdateTLSConfig(context.Background(), obj)
	}
	if api.localUpdateTLSConfigHandler != nil {
		return api.localUpdateTLSConfigHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncUpdateTLSConfig is an API action. Cache will be updated
func (api *clusterAPI) SyncUpdateTLSConfig(obj *cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.ClusterV1().Cluster().UpdateTLSConfig(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.ClusterV1().Cluster().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleClusterEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncUpdateTLSConfigHandler != nil {
		return api.localSyncUpdateTLSConfigHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *clusterAPI) RegisterLocalUpdateTLSConfigHandler(fn func(*cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error)) {
	api.localUpdateTLSConfigHandler = fn
}

func (api *clusterAPI) RegisterLocalSyncUpdateTLSConfigHandler(fn func(*cluster.UpdateTLSConfigRequest) (*cluster.Cluster, error)) {
	api.localSyncUpdateTLSConfigHandler = fn
}

// Cluster returns ClusterAPI
func (ct *ctrlerCtx) Cluster() ClusterAPI {
	kind := "Cluster"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &clusterAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*clusterAPI)
}

// Node is a wrapper object that implements additional functionality
type Node struct {
	sync.Mutex
	cluster.Node
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Node) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Node_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Node().UpdateStatus(context.Background(), &obj.Node)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Node().Create(context.Background(), &obj.Node)
	}

	return nil
}

// NodeHandler is the event handler for Node object
type NodeHandler interface {
	OnNodeCreate(obj *Node) error
	OnNodeUpdate(oldObj *Node, newObj *cluster.Node) error
	OnNodeDelete(obj *Node) error
	GetNodeWatchOptions() *api.ListWatchOptions
}

// OnNodeCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNodeCreate(obj *Node) error {
	log.Info("OnNodeCreate is not implemented")
	return nil
}

// OnNodeUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNodeUpdate(oldObj *Node, newObj *cluster.Node) error {
	log.Info("OnNodeUpdate is not implemented")
	return nil
}

// OnNodeDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnNodeDelete(obj *Node) error {
	log.Info("OnNodeDelete is not implemented")
	return nil
}

// GetNodeWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetNodeWatchOptions() *api.ListWatchOptions {
	log.Info("GetNodeWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleNodeEvent handles Node events from watcher
func (ct *ctrlerCtx) handleNodeEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNodeEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Node:
		eobj := evt.Object.(*cluster.Node)
		kind := "Node"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &nodeCtx{event: evt.Type,
			obj: &Node{Node: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Node watch channel", tp)
	}

	return nil
}

// handleNodeEventNoResolver handles Node events from watcher
func (ct *ctrlerCtx) handleNodeEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Node:
		eobj := evt.Object.(*cluster.Node)
		kind := "Node"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		nodeHandler := handler.(NodeHandler)
		// handle based on event type
		ctrlCtx := &nodeCtx{event: evt.Type, obj: &Node{Node: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Node_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = nodeHandler.OnNodeCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*nodeCtx)
				ct.stats.Counter("Node_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.Node{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = nodeHandler.OnNodeUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Node = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &nodeCtx{event: evt.Type, obj: &Node{Node: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Node)
			ct.stats.Counter("Node_Deleted_Events").Inc()
			obj.Lock()
			err = nodeHandler.OnNodeDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Node watch channel", tp)
	}

	return nil
}

type nodeCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Node //
	//   newObj     *cluster.Node //update
	newObj *nodeCtx //update
}

func (ctx *nodeCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *nodeCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *nodeCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *nodeCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *nodeCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *nodeCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*nodeCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *nodeCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *nodeCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Node = obj.(*nodeCtx).obj.Node
}

func (ctx *nodeCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *nodeCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *nodeCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *nodeCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *nodeCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Node"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	nodeHandler := handler.(NodeHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = nodeHandler.OnNodeCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Node_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.Node{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = nodeHandler.OnNodeUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = nodeHandler.OnNodeDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleNodeEventParallel handles Node events from watcher
func (ct *ctrlerCtx) handleNodeEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleNodeEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Node:
		eobj := evt.Object.(*cluster.Node)
		kind := "Node"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &nodeCtx{event: evt.Type, obj: &Node{Node: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Node watch channel", tp)
	}

	return nil
}

// handleNodeEventParallel handles Node events from watcher
func (ct *ctrlerCtx) handleNodeEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Node:
		eobj := evt.Object.(*cluster.Node)
		kind := "Node"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		nodeHandler := handler.(NodeHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*nodeCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Node_Created_Events").Inc()
					eobj.Lock()
					err = nodeHandler.OnNodeCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*nodeCtx)
					obj := workCtx.obj
					ct.stats.Counter("Node_Updated_Events").Inc()
					obj.Lock()
					p := cluster.Node{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = nodeHandler.OnNodeUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Node = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &nodeCtx{event: evt.Type, obj: &Node{Node: *eobj, ctrler: ct}}
			ct.runFunction("Node", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*nodeCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Node)
				ct.stats.Counter("Node_Deleted_Events").Inc()
				obj.Lock()
				err = nodeHandler.OnNodeDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &nodeCtx{event: evt.Type, obj: &Node{Node: *eobj, ctrler: ct}}
			ct.runFunction("Node", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Node watch channel", tp)
	}

	return nil
}

// diffNode does a diff of Node objects between local cache and API server
func (ct *ctrlerCtx) diffNode(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Node().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffNode(): NodeList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Node)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Node().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffNode(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Node,
			}
			ct.handleNodeEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffNode(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleNodeEvent(&evt)
	}
}

func (ct *ctrlerCtx) runNodeWatcher() {
	kind := "Node"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	nodeHandler := handler.(NodeHandler)

	opts := nodeHandler.GetNodeWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "NodeWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffNode(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Node_Watch").Inc()
		defer ct.stats.Counter("Node_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Node_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Node object watcher
				wt, werr := apicl.ClusterV1().Node().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffNode(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Node_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleNodeEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchNode starts watch on Node object
func (ct *ctrlerCtx) WatchNode(handler NodeHandler) error {
	kind := "Node"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Node watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Node watcher in a go routine
	ct.runNodeWatcher()

	return nil
}

// StopWatchNode stops watch on Node object
func (ct *ctrlerCtx) StopWatchNode(handler NodeHandler) error {
	kind := "Node"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Node watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// NodeAPI returns
type NodeAPI interface {
	Create(obj *cluster.Node) error
	SyncCreate(obj *cluster.Node) error
	Update(obj *cluster.Node) error
	SyncUpdate(obj *cluster.Node) error
	Delete(obj *cluster.Node) error
	Find(meta *api.ObjectMeta) (*Node, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Node, error)
	Watch(handler NodeHandler) error
	StopWatch(handler NodeHandler) error
}

// dummy struct that implements NodeAPI
type nodeAPI struct {
	ct *ctrlerCtx
}

// Create creates Node object
func (api *nodeAPI) Create(obj *cluster.Node) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Node().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Node().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Node object and updates the cache
func (api *nodeAPI) SyncCreate(obj *cluster.Node) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Node().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().Node().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Node object
func (api *nodeAPI) Update(obj *cluster.Node) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Node().Update(context.Background(), obj)
		return err
	}

	api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Node object and updates the cache
func (api *nodeAPI) SyncUpdate(obj *cluster.Node) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Node().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Node object
func (api *nodeAPI) Delete(obj *cluster.Node) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Node().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleNodeEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *nodeAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "nodes", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "nodes", "/", name)
}

// Find returns an object by meta
func (api *nodeAPI) Find(meta *api.ObjectMeta) (*Node, error) {
	// find the object
	obj, err := api.ct.FindObject("Node", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Node:
		hobj := obj.(*Node)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Node objects
func (api *nodeAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Node, error) {
	var objlist []*Node
	objs, err := api.ct.List("Node", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Node:
			eobj := obj.(*Node)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Node", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Node object
func (api *nodeAPI) Watch(handler NodeHandler) error {
	api.ct.startWorkerPool("Node")
	return api.ct.WatchNode(handler)
}

// StopWatch stop watch for Tenant Node object
func (api *nodeAPI) StopWatch(handler NodeHandler) error {
	api.ct.Lock()
	api.ct.workPools["Node"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchNode(handler)
}

// Node returns NodeAPI
func (ct *ctrlerCtx) Node() NodeAPI {
	kind := "Node"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &nodeAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*nodeAPI)
}

// Host is a wrapper object that implements additional functionality
type Host struct {
	sync.Mutex
	cluster.Host
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Host) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Host_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Host().UpdateStatus(context.Background(), &obj.Host)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Host().Create(context.Background(), &obj.Host)
	}

	return nil
}

// HostHandler is the event handler for Host object
type HostHandler interface {
	OnHostCreate(obj *Host) error
	OnHostUpdate(oldObj *Host, newObj *cluster.Host) error
	OnHostDelete(obj *Host) error
	GetHostWatchOptions() *api.ListWatchOptions
}

// OnHostCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnHostCreate(obj *Host) error {
	log.Info("OnHostCreate is not implemented")
	return nil
}

// OnHostUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnHostUpdate(oldObj *Host, newObj *cluster.Host) error {
	log.Info("OnHostUpdate is not implemented")
	return nil
}

// OnHostDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnHostDelete(obj *Host) error {
	log.Info("OnHostDelete is not implemented")
	return nil
}

// GetHostWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetHostWatchOptions() *api.ListWatchOptions {
	log.Info("GetHostWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleHostEvent handles Host events from watcher
func (ct *ctrlerCtx) handleHostEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleHostEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Host:
		eobj := evt.Object.(*cluster.Host)
		kind := "Host"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &hostCtx{event: evt.Type,
			obj: &Host{Host: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Host watch channel", tp)
	}

	return nil
}

// handleHostEventNoResolver handles Host events from watcher
func (ct *ctrlerCtx) handleHostEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Host:
		eobj := evt.Object.(*cluster.Host)
		kind := "Host"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		hostHandler := handler.(HostHandler)
		// handle based on event type
		ctrlCtx := &hostCtx{event: evt.Type, obj: &Host{Host: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Host_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = hostHandler.OnHostCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*hostCtx)
				ct.stats.Counter("Host_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.Host{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = hostHandler.OnHostUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Host = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &hostCtx{event: evt.Type, obj: &Host{Host: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Host)
			ct.stats.Counter("Host_Deleted_Events").Inc()
			obj.Lock()
			err = hostHandler.OnHostDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Host watch channel", tp)
	}

	return nil
}

type hostCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Host //
	//   newObj     *cluster.Host //update
	newObj *hostCtx //update
}

func (ctx *hostCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *hostCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *hostCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *hostCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *hostCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *hostCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*hostCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *hostCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *hostCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Host = obj.(*hostCtx).obj.Host
}

func (ctx *hostCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *hostCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *hostCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *hostCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *hostCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Host"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	hostHandler := handler.(HostHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = hostHandler.OnHostCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Host_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.Host{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = hostHandler.OnHostUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = hostHandler.OnHostDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleHostEventParallel handles Host events from watcher
func (ct *ctrlerCtx) handleHostEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleHostEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Host:
		eobj := evt.Object.(*cluster.Host)
		kind := "Host"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &hostCtx{event: evt.Type, obj: &Host{Host: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Host watch channel", tp)
	}

	return nil
}

// handleHostEventParallel handles Host events from watcher
func (ct *ctrlerCtx) handleHostEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Host:
		eobj := evt.Object.(*cluster.Host)
		kind := "Host"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		hostHandler := handler.(HostHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*hostCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Host_Created_Events").Inc()
					eobj.Lock()
					err = hostHandler.OnHostCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*hostCtx)
					obj := workCtx.obj
					ct.stats.Counter("Host_Updated_Events").Inc()
					obj.Lock()
					p := cluster.Host{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = hostHandler.OnHostUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Host = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &hostCtx{event: evt.Type, obj: &Host{Host: *eobj, ctrler: ct}}
			ct.runFunction("Host", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*hostCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Host)
				ct.stats.Counter("Host_Deleted_Events").Inc()
				obj.Lock()
				err = hostHandler.OnHostDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &hostCtx{event: evt.Type, obj: &Host{Host: *eobj, ctrler: ct}}
			ct.runFunction("Host", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Host watch channel", tp)
	}

	return nil
}

// diffHost does a diff of Host objects between local cache and API server
func (ct *ctrlerCtx) diffHost(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Host().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffHost(): HostList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Host)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Host().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffHost(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Host,
			}
			ct.handleHostEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffHost(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleHostEvent(&evt)
	}
}

func (ct *ctrlerCtx) runHostWatcher() {
	kind := "Host"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	hostHandler := handler.(HostHandler)

	opts := hostHandler.GetHostWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "HostWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffHost(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Host_Watch").Inc()
		defer ct.stats.Counter("Host_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Host_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Host object watcher
				wt, werr := apicl.ClusterV1().Host().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffHost(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Host_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleHostEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchHost starts watch on Host object
func (ct *ctrlerCtx) WatchHost(handler HostHandler) error {
	kind := "Host"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Host watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Host watcher in a go routine
	ct.runHostWatcher()

	return nil
}

// StopWatchHost stops watch on Host object
func (ct *ctrlerCtx) StopWatchHost(handler HostHandler) error {
	kind := "Host"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Host watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// HostAPI returns
type HostAPI interface {
	Create(obj *cluster.Host) error
	SyncCreate(obj *cluster.Host) error
	Update(obj *cluster.Host) error
	SyncUpdate(obj *cluster.Host) error
	Delete(obj *cluster.Host) error
	Find(meta *api.ObjectMeta) (*Host, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Host, error)
	Watch(handler HostHandler) error
	StopWatch(handler HostHandler) error
}

// dummy struct that implements HostAPI
type hostAPI struct {
	ct *ctrlerCtx
}

// Create creates Host object
func (api *hostAPI) Create(obj *cluster.Host) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Host().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Host().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleHostEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Host object and updates the cache
func (api *hostAPI) SyncCreate(obj *cluster.Host) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Host().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().Host().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleHostEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Host object
func (api *hostAPI) Update(obj *cluster.Host) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Host().Update(context.Background(), obj)
		return err
	}

	api.ct.handleHostEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Host object and updates the cache
func (api *hostAPI) SyncUpdate(obj *cluster.Host) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Host().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleHostEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Host object
func (api *hostAPI) Delete(obj *cluster.Host) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Host().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleHostEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *hostAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "hosts", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "hosts", "/", name)
}

// Find returns an object by meta
func (api *hostAPI) Find(meta *api.ObjectMeta) (*Host, error) {
	// find the object
	obj, err := api.ct.FindObject("Host", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Host:
		hobj := obj.(*Host)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Host objects
func (api *hostAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Host, error) {
	var objlist []*Host
	objs, err := api.ct.List("Host", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Host:
			eobj := obj.(*Host)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Host", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Host object
func (api *hostAPI) Watch(handler HostHandler) error {
	api.ct.startWorkerPool("Host")
	return api.ct.WatchHost(handler)
}

// StopWatch stop watch for Tenant Host object
func (api *hostAPI) StopWatch(handler HostHandler) error {
	api.ct.Lock()
	api.ct.workPools["Host"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchHost(handler)
}

// Host returns HostAPI
func (ct *ctrlerCtx) Host() HostAPI {
	kind := "Host"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &hostAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*hostAPI)
}

// DistributedServiceCard is a wrapper object that implements additional functionality
type DistributedServiceCard struct {
	sync.Mutex
	cluster.DistributedServiceCard
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *DistributedServiceCard) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("DistributedServiceCard_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().DistributedServiceCard().UpdateStatus(context.Background(), &obj.DistributedServiceCard)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().DistributedServiceCard().Create(context.Background(), &obj.DistributedServiceCard)
	}

	return nil
}

// DistributedServiceCardHandler is the event handler for DistributedServiceCard object
type DistributedServiceCardHandler interface {
	OnDistributedServiceCardCreate(obj *DistributedServiceCard) error
	OnDistributedServiceCardUpdate(oldObj *DistributedServiceCard, newObj *cluster.DistributedServiceCard) error
	OnDistributedServiceCardDelete(obj *DistributedServiceCard) error
	GetDistributedServiceCardWatchOptions() *api.ListWatchOptions
}

// OnDistributedServiceCardCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnDistributedServiceCardCreate(obj *DistributedServiceCard) error {
	log.Info("OnDistributedServiceCardCreate is not implemented")
	return nil
}

// OnDistributedServiceCardUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnDistributedServiceCardUpdate(oldObj *DistributedServiceCard, newObj *cluster.DistributedServiceCard) error {
	log.Info("OnDistributedServiceCardUpdate is not implemented")
	return nil
}

// OnDistributedServiceCardDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnDistributedServiceCardDelete(obj *DistributedServiceCard) error {
	log.Info("OnDistributedServiceCardDelete is not implemented")
	return nil
}

// GetDistributedServiceCardWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetDistributedServiceCardWatchOptions() *api.ListWatchOptions {
	log.Info("GetDistributedServiceCardWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleDistributedServiceCardEvent handles DistributedServiceCard events from watcher
func (ct *ctrlerCtx) handleDistributedServiceCardEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleDistributedServiceCardEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.DistributedServiceCard:
		eobj := evt.Object.(*cluster.DistributedServiceCard)
		kind := "DistributedServiceCard"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &distributedservicecardCtx{event: evt.Type,
			obj: &DistributedServiceCard{DistributedServiceCard: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DistributedServiceCard watch channel", tp)
	}

	return nil
}

// handleDistributedServiceCardEventNoResolver handles DistributedServiceCard events from watcher
func (ct *ctrlerCtx) handleDistributedServiceCardEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.DistributedServiceCard:
		eobj := evt.Object.(*cluster.DistributedServiceCard)
		kind := "DistributedServiceCard"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		distributedservicecardHandler := handler.(DistributedServiceCardHandler)
		// handle based on event type
		ctrlCtx := &distributedservicecardCtx{event: evt.Type, obj: &DistributedServiceCard{DistributedServiceCard: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("DistributedServiceCard_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = distributedservicecardHandler.OnDistributedServiceCardCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*distributedservicecardCtx)
				ct.stats.Counter("DistributedServiceCard_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.DistributedServiceCard{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = distributedservicecardHandler.OnDistributedServiceCardUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.DistributedServiceCard = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &distributedservicecardCtx{event: evt.Type, obj: &DistributedServiceCard{DistributedServiceCard: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*DistributedServiceCard)
			ct.stats.Counter("DistributedServiceCard_Deleted_Events").Inc()
			obj.Lock()
			err = distributedservicecardHandler.OnDistributedServiceCardDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DistributedServiceCard watch channel", tp)
	}

	return nil
}

type distributedservicecardCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *DistributedServiceCard //
	//   newObj     *cluster.DistributedServiceCard //update
	newObj *distributedservicecardCtx //update
}

func (ctx *distributedservicecardCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *distributedservicecardCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *distributedservicecardCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *distributedservicecardCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *distributedservicecardCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *distributedservicecardCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*distributedservicecardCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *distributedservicecardCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *distributedservicecardCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.DistributedServiceCard = obj.(*distributedservicecardCtx).obj.DistributedServiceCard
}

func (ctx *distributedservicecardCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *distributedservicecardCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *distributedservicecardCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *distributedservicecardCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *distributedservicecardCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "DistributedServiceCard"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	distributedservicecardHandler := handler.(DistributedServiceCardHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = distributedservicecardHandler.OnDistributedServiceCardCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("DistributedServiceCard_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.DistributedServiceCard{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = distributedservicecardHandler.OnDistributedServiceCardUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = distributedservicecardHandler.OnDistributedServiceCardDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleDistributedServiceCardEventParallel handles DistributedServiceCard events from watcher
func (ct *ctrlerCtx) handleDistributedServiceCardEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleDistributedServiceCardEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.DistributedServiceCard:
		eobj := evt.Object.(*cluster.DistributedServiceCard)
		kind := "DistributedServiceCard"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &distributedservicecardCtx{event: evt.Type, obj: &DistributedServiceCard{DistributedServiceCard: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DistributedServiceCard watch channel", tp)
	}

	return nil
}

// handleDistributedServiceCardEventParallel handles DistributedServiceCard events from watcher
func (ct *ctrlerCtx) handleDistributedServiceCardEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.DistributedServiceCard:
		eobj := evt.Object.(*cluster.DistributedServiceCard)
		kind := "DistributedServiceCard"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		distributedservicecardHandler := handler.(DistributedServiceCardHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*distributedservicecardCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("DistributedServiceCard_Created_Events").Inc()
					eobj.Lock()
					err = distributedservicecardHandler.OnDistributedServiceCardCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*distributedservicecardCtx)
					obj := workCtx.obj
					ct.stats.Counter("DistributedServiceCard_Updated_Events").Inc()
					obj.Lock()
					p := cluster.DistributedServiceCard{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = distributedservicecardHandler.OnDistributedServiceCardUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.DistributedServiceCard = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &distributedservicecardCtx{event: evt.Type, obj: &DistributedServiceCard{DistributedServiceCard: *eobj, ctrler: ct}}
			ct.runFunction("DistributedServiceCard", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*distributedservicecardCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*DistributedServiceCard)
				ct.stats.Counter("DistributedServiceCard_Deleted_Events").Inc()
				obj.Lock()
				err = distributedservicecardHandler.OnDistributedServiceCardDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &distributedservicecardCtx{event: evt.Type, obj: &DistributedServiceCard{DistributedServiceCard: *eobj, ctrler: ct}}
			ct.runFunction("DistributedServiceCard", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DistributedServiceCard watch channel", tp)
	}

	return nil
}

// diffDistributedServiceCard does a diff of DistributedServiceCard objects between local cache and API server
func (ct *ctrlerCtx) diffDistributedServiceCard(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().DistributedServiceCard().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffDistributedServiceCard(): DistributedServiceCardList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.DistributedServiceCard)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.DistributedServiceCard().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffDistributedServiceCard(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.DistributedServiceCard,
			}
			ct.handleDistributedServiceCardEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffDistributedServiceCard(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleDistributedServiceCardEvent(&evt)
	}
}

func (ct *ctrlerCtx) runDistributedServiceCardWatcher() {
	kind := "DistributedServiceCard"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	distributedservicecardHandler := handler.(DistributedServiceCardHandler)

	opts := distributedservicecardHandler.GetDistributedServiceCardWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "DistributedServiceCardWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffDistributedServiceCard(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("DistributedServiceCard_Watch").Inc()
		defer ct.stats.Counter("DistributedServiceCard_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("DistributedServiceCard_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// DistributedServiceCard object watcher
				wt, werr := apicl.ClusterV1().DistributedServiceCard().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffDistributedServiceCard(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("DistributedServiceCard_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleDistributedServiceCardEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchDistributedServiceCard starts watch on DistributedServiceCard object
func (ct *ctrlerCtx) WatchDistributedServiceCard(handler DistributedServiceCardHandler) error {
	kind := "DistributedServiceCard"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("DistributedServiceCard watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run DistributedServiceCard watcher in a go routine
	ct.runDistributedServiceCardWatcher()

	return nil
}

// StopWatchDistributedServiceCard stops watch on DistributedServiceCard object
func (ct *ctrlerCtx) StopWatchDistributedServiceCard(handler DistributedServiceCardHandler) error {
	kind := "DistributedServiceCard"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("DistributedServiceCard watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// DistributedServiceCardAPI returns
type DistributedServiceCardAPI interface {
	Create(obj *cluster.DistributedServiceCard) error
	SyncCreate(obj *cluster.DistributedServiceCard) error
	Update(obj *cluster.DistributedServiceCard) error
	SyncUpdate(obj *cluster.DistributedServiceCard) error
	Delete(obj *cluster.DistributedServiceCard) error
	Find(meta *api.ObjectMeta) (*DistributedServiceCard, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*DistributedServiceCard, error)
	Watch(handler DistributedServiceCardHandler) error
	StopWatch(handler DistributedServiceCardHandler) error
}

// dummy struct that implements DistributedServiceCardAPI
type distributedservicecardAPI struct {
	ct *ctrlerCtx
}

// Create creates DistributedServiceCard object
func (api *distributedservicecardAPI) Create(obj *cluster.DistributedServiceCard) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().DistributedServiceCard().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().DistributedServiceCard().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleDistributedServiceCardEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates DistributedServiceCard object and updates the cache
func (api *distributedservicecardAPI) SyncCreate(obj *cluster.DistributedServiceCard) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().DistributedServiceCard().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().DistributedServiceCard().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleDistributedServiceCardEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on DistributedServiceCard object
func (api *distributedservicecardAPI) Update(obj *cluster.DistributedServiceCard) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().DistributedServiceCard().Update(context.Background(), obj)
		return err
	}

	api.ct.handleDistributedServiceCardEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on DistributedServiceCard object and updates the cache
func (api *distributedservicecardAPI) SyncUpdate(obj *cluster.DistributedServiceCard) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().DistributedServiceCard().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleDistributedServiceCardEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes DistributedServiceCard object
func (api *distributedservicecardAPI) Delete(obj *cluster.DistributedServiceCard) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().DistributedServiceCard().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleDistributedServiceCardEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *distributedservicecardAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "distributedservicecards", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "distributedservicecards", "/", name)
}

// Find returns an object by meta
func (api *distributedservicecardAPI) Find(meta *api.ObjectMeta) (*DistributedServiceCard, error) {
	// find the object
	obj, err := api.ct.FindObject("DistributedServiceCard", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *DistributedServiceCard:
		hobj := obj.(*DistributedServiceCard)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all DistributedServiceCard objects
func (api *distributedservicecardAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*DistributedServiceCard, error) {
	var objlist []*DistributedServiceCard
	objs, err := api.ct.List("DistributedServiceCard", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *DistributedServiceCard:
			eobj := obj.(*DistributedServiceCard)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for DistributedServiceCard", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for DistributedServiceCard object
func (api *distributedservicecardAPI) Watch(handler DistributedServiceCardHandler) error {
	api.ct.startWorkerPool("DistributedServiceCard")
	return api.ct.WatchDistributedServiceCard(handler)
}

// StopWatch stop watch for Tenant DistributedServiceCard object
func (api *distributedservicecardAPI) StopWatch(handler DistributedServiceCardHandler) error {
	api.ct.Lock()
	api.ct.workPools["DistributedServiceCard"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchDistributedServiceCard(handler)
}

// DistributedServiceCard returns DistributedServiceCardAPI
func (ct *ctrlerCtx) DistributedServiceCard() DistributedServiceCardAPI {
	kind := "DistributedServiceCard"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &distributedservicecardAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*distributedservicecardAPI)
}

// Tenant is a wrapper object that implements additional functionality
type Tenant struct {
	sync.Mutex
	cluster.Tenant
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Tenant) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Tenant_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Tenant().UpdateStatus(context.Background(), &obj.Tenant)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Tenant().Create(context.Background(), &obj.Tenant)
	}

	return nil
}

// TenantHandler is the event handler for Tenant object
type TenantHandler interface {
	OnTenantCreate(obj *Tenant) error
	OnTenantUpdate(oldObj *Tenant, newObj *cluster.Tenant) error
	OnTenantDelete(obj *Tenant) error
	GetTenantWatchOptions() *api.ListWatchOptions
}

// OnTenantCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTenantCreate(obj *Tenant) error {
	log.Info("OnTenantCreate is not implemented")
	return nil
}

// OnTenantUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTenantUpdate(oldObj *Tenant, newObj *cluster.Tenant) error {
	log.Info("OnTenantUpdate is not implemented")
	return nil
}

// OnTenantDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnTenantDelete(obj *Tenant) error {
	log.Info("OnTenantDelete is not implemented")
	return nil
}

// GetTenantWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetTenantWatchOptions() *api.ListWatchOptions {
	log.Info("GetTenantWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleTenantEvent handles Tenant events from watcher
func (ct *ctrlerCtx) handleTenantEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTenantEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Tenant:
		eobj := evt.Object.(*cluster.Tenant)
		kind := "Tenant"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &tenantCtx{event: evt.Type,
			obj: &Tenant{Tenant: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Tenant watch channel", tp)
	}

	return nil
}

// handleTenantEventNoResolver handles Tenant events from watcher
func (ct *ctrlerCtx) handleTenantEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Tenant:
		eobj := evt.Object.(*cluster.Tenant)
		kind := "Tenant"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		tenantHandler := handler.(TenantHandler)
		// handle based on event type
		ctrlCtx := &tenantCtx{event: evt.Type, obj: &Tenant{Tenant: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Tenant_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = tenantHandler.OnTenantCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*tenantCtx)
				ct.stats.Counter("Tenant_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.Tenant{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = tenantHandler.OnTenantUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Tenant = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &tenantCtx{event: evt.Type, obj: &Tenant{Tenant: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Tenant)
			ct.stats.Counter("Tenant_Deleted_Events").Inc()
			obj.Lock()
			err = tenantHandler.OnTenantDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Tenant watch channel", tp)
	}

	return nil
}

type tenantCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Tenant //
	//   newObj     *cluster.Tenant //update
	newObj *tenantCtx //update
}

func (ctx *tenantCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *tenantCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *tenantCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *tenantCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *tenantCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *tenantCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*tenantCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *tenantCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *tenantCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Tenant = obj.(*tenantCtx).obj.Tenant
}

func (ctx *tenantCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *tenantCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *tenantCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *tenantCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *tenantCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Tenant"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	tenantHandler := handler.(TenantHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = tenantHandler.OnTenantCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Tenant_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.Tenant{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = tenantHandler.OnTenantUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = tenantHandler.OnTenantDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleTenantEventParallel handles Tenant events from watcher
func (ct *ctrlerCtx) handleTenantEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleTenantEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Tenant:
		eobj := evt.Object.(*cluster.Tenant)
		kind := "Tenant"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &tenantCtx{event: evt.Type, obj: &Tenant{Tenant: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Tenant watch channel", tp)
	}

	return nil
}

// handleTenantEventParallel handles Tenant events from watcher
func (ct *ctrlerCtx) handleTenantEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Tenant:
		eobj := evt.Object.(*cluster.Tenant)
		kind := "Tenant"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		tenantHandler := handler.(TenantHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*tenantCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Tenant_Created_Events").Inc()
					eobj.Lock()
					err = tenantHandler.OnTenantCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*tenantCtx)
					obj := workCtx.obj
					ct.stats.Counter("Tenant_Updated_Events").Inc()
					obj.Lock()
					p := cluster.Tenant{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = tenantHandler.OnTenantUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Tenant = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &tenantCtx{event: evt.Type, obj: &Tenant{Tenant: *eobj, ctrler: ct}}
			ct.runFunction("Tenant", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*tenantCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Tenant)
				ct.stats.Counter("Tenant_Deleted_Events").Inc()
				obj.Lock()
				err = tenantHandler.OnTenantDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &tenantCtx{event: evt.Type, obj: &Tenant{Tenant: *eobj, ctrler: ct}}
			ct.runFunction("Tenant", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Tenant watch channel", tp)
	}

	return nil
}

// diffTenant does a diff of Tenant objects between local cache and API server
func (ct *ctrlerCtx) diffTenant(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Tenant().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTenant(): TenantList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Tenant)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Tenant().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTenant(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Tenant,
			}
			ct.handleTenantEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTenant(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTenantEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTenantWatcher() {
	kind := "Tenant"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	tenantHandler := handler.(TenantHandler)

	opts := tenantHandler.GetTenantWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "TenantWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffTenant(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Tenant_Watch").Inc()
		defer ct.stats.Counter("Tenant_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Tenant_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Tenant object watcher
				wt, werr := apicl.ClusterV1().Tenant().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffTenant(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Tenant_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTenantEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTenant starts watch on Tenant object
func (ct *ctrlerCtx) WatchTenant(handler TenantHandler) error {
	kind := "Tenant"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Tenant watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Tenant watcher in a go routine
	ct.runTenantWatcher()

	return nil
}

// StopWatchTenant stops watch on Tenant object
func (ct *ctrlerCtx) StopWatchTenant(handler TenantHandler) error {
	kind := "Tenant"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Tenant watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TenantAPI returns
type TenantAPI interface {
	Create(obj *cluster.Tenant) error
	SyncCreate(obj *cluster.Tenant) error
	Update(obj *cluster.Tenant) error
	SyncUpdate(obj *cluster.Tenant) error
	Delete(obj *cluster.Tenant) error
	Find(meta *api.ObjectMeta) (*Tenant, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Tenant, error)
	Watch(handler TenantHandler) error
	StopWatch(handler TenantHandler) error
}

// dummy struct that implements TenantAPI
type tenantAPI struct {
	ct *ctrlerCtx
}

// Create creates Tenant object
func (api *tenantAPI) Create(obj *cluster.Tenant) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Tenant().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Tenant().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Tenant object and updates the cache
func (api *tenantAPI) SyncCreate(obj *cluster.Tenant) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Tenant().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().Tenant().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Tenant object
func (api *tenantAPI) Update(obj *cluster.Tenant) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Tenant().Update(context.Background(), obj)
		return err
	}

	api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Tenant object and updates the cache
func (api *tenantAPI) SyncUpdate(obj *cluster.Tenant) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Tenant().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Tenant object
func (api *tenantAPI) Delete(obj *cluster.Tenant) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Tenant().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleTenantEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *tenantAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "tenants", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "tenants", "/", name)
}

// Find returns an object by meta
func (api *tenantAPI) Find(meta *api.ObjectMeta) (*Tenant, error) {
	// find the object
	obj, err := api.ct.FindObject("Tenant", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Tenant:
		hobj := obj.(*Tenant)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Tenant objects
func (api *tenantAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Tenant, error) {
	var objlist []*Tenant
	objs, err := api.ct.List("Tenant", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Tenant:
			eobj := obj.(*Tenant)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Tenant", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Tenant object
func (api *tenantAPI) Watch(handler TenantHandler) error {
	api.ct.startWorkerPool("Tenant")
	return api.ct.WatchTenant(handler)
}

// StopWatch stop watch for Tenant Tenant object
func (api *tenantAPI) StopWatch(handler TenantHandler) error {
	api.ct.Lock()
	api.ct.workPools["Tenant"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTenant(handler)
}

// Tenant returns TenantAPI
func (ct *ctrlerCtx) Tenant() TenantAPI {
	kind := "Tenant"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &tenantAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*tenantAPI)
}

// Version is a wrapper object that implements additional functionality
type Version struct {
	sync.Mutex
	cluster.Version
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Version) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Version_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().Version().UpdateStatus(context.Background(), &obj.Version)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().Version().Create(context.Background(), &obj.Version)
	}

	return nil
}

// VersionHandler is the event handler for Version object
type VersionHandler interface {
	OnVersionCreate(obj *Version) error
	OnVersionUpdate(oldObj *Version, newObj *cluster.Version) error
	OnVersionDelete(obj *Version) error
	GetVersionWatchOptions() *api.ListWatchOptions
}

// OnVersionCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnVersionCreate(obj *Version) error {
	log.Info("OnVersionCreate is not implemented")
	return nil
}

// OnVersionUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnVersionUpdate(oldObj *Version, newObj *cluster.Version) error {
	log.Info("OnVersionUpdate is not implemented")
	return nil
}

// OnVersionDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnVersionDelete(obj *Version) error {
	log.Info("OnVersionDelete is not implemented")
	return nil
}

// GetVersionWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetVersionWatchOptions() *api.ListWatchOptions {
	log.Info("GetVersionWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleVersionEvent handles Version events from watcher
func (ct *ctrlerCtx) handleVersionEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleVersionEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Version:
		eobj := evt.Object.(*cluster.Version)
		kind := "Version"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &versionCtx{event: evt.Type,
			obj: &Version{Version: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Version watch channel", tp)
	}

	return nil
}

// handleVersionEventNoResolver handles Version events from watcher
func (ct *ctrlerCtx) handleVersionEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Version:
		eobj := evt.Object.(*cluster.Version)
		kind := "Version"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		versionHandler := handler.(VersionHandler)
		// handle based on event type
		ctrlCtx := &versionCtx{event: evt.Type, obj: &Version{Version: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("Version_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = versionHandler.OnVersionCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*versionCtx)
				ct.stats.Counter("Version_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.Version{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = versionHandler.OnVersionUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.Version = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &versionCtx{event: evt.Type, obj: &Version{Version: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Version)
			ct.stats.Counter("Version_Deleted_Events").Inc()
			obj.Lock()
			err = versionHandler.OnVersionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Version watch channel", tp)
	}

	return nil
}

type versionCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *Version //
	//   newObj     *cluster.Version //update
	newObj *versionCtx //update
}

func (ctx *versionCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *versionCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *versionCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *versionCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *versionCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *versionCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*versionCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *versionCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *versionCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.Version = obj.(*versionCtx).obj.Version
}

func (ctx *versionCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *versionCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *versionCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *versionCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *versionCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "Version"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	versionHandler := handler.(VersionHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = versionHandler.OnVersionCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("Version_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.Version{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = versionHandler.OnVersionUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = versionHandler.OnVersionDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleVersionEventParallel handles Version events from watcher
func (ct *ctrlerCtx) handleVersionEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleVersionEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.Version:
		eobj := evt.Object.(*cluster.Version)
		kind := "Version"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &versionCtx{event: evt.Type, obj: &Version{Version: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Version watch channel", tp)
	}

	return nil
}

// handleVersionEventParallel handles Version events from watcher
func (ct *ctrlerCtx) handleVersionEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.Version:
		eobj := evt.Object.(*cluster.Version)
		kind := "Version"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		versionHandler := handler.(VersionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*versionCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("Version_Created_Events").Inc()
					eobj.Lock()
					err = versionHandler.OnVersionCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*versionCtx)
					obj := workCtx.obj
					ct.stats.Counter("Version_Updated_Events").Inc()
					obj.Lock()
					p := cluster.Version{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = versionHandler.OnVersionUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.Version = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &versionCtx{event: evt.Type, obj: &Version{Version: *eobj, ctrler: ct}}
			ct.runFunction("Version", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*versionCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Version)
				ct.stats.Counter("Version_Deleted_Events").Inc()
				obj.Lock()
				err = versionHandler.OnVersionDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &versionCtx{event: evt.Type, obj: &Version{Version: *eobj, ctrler: ct}}
			ct.runFunction("Version", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Version watch channel", tp)
	}

	return nil
}

// diffVersion does a diff of Version objects between local cache and API server
func (ct *ctrlerCtx) diffVersion(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().Version().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffVersion(): VersionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.Version)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Version().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffVersion(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Version,
			}
			ct.handleVersionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffVersion(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleVersionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runVersionWatcher() {
	kind := "Version"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	versionHandler := handler.(VersionHandler)

	opts := versionHandler.GetVersionWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "VersionWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffVersion(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Version_Watch").Inc()
		defer ct.stats.Counter("Version_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Version_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Version object watcher
				wt, werr := apicl.ClusterV1().Version().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffVersion(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Version_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleVersionEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchVersion starts watch on Version object
func (ct *ctrlerCtx) WatchVersion(handler VersionHandler) error {
	kind := "Version"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Version watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Version watcher in a go routine
	ct.runVersionWatcher()

	return nil
}

// StopWatchVersion stops watch on Version object
func (ct *ctrlerCtx) StopWatchVersion(handler VersionHandler) error {
	kind := "Version"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Version watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// VersionAPI returns
type VersionAPI interface {
	Create(obj *cluster.Version) error
	SyncCreate(obj *cluster.Version) error
	Update(obj *cluster.Version) error
	SyncUpdate(obj *cluster.Version) error
	Delete(obj *cluster.Version) error
	Find(meta *api.ObjectMeta) (*Version, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Version, error)
	Watch(handler VersionHandler) error
	StopWatch(handler VersionHandler) error
}

// dummy struct that implements VersionAPI
type versionAPI struct {
	ct *ctrlerCtx
}

// Create creates Version object
func (api *versionAPI) Create(obj *cluster.Version) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Version().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().Version().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates Version object and updates the cache
func (api *versionAPI) SyncCreate(obj *cluster.Version) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Version().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().Version().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on Version object
func (api *versionAPI) Update(obj *cluster.Version) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Version().Update(context.Background(), obj)
		return err
	}

	api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on Version object and updates the cache
func (api *versionAPI) SyncUpdate(obj *cluster.Version) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().Version().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes Version object
func (api *versionAPI) Delete(obj *cluster.Version) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().Version().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleVersionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *versionAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "version", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "version", "/", name)
}

// Find returns an object by meta
func (api *versionAPI) Find(meta *api.ObjectMeta) (*Version, error) {
	// find the object
	obj, err := api.ct.FindObject("Version", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Version:
		hobj := obj.(*Version)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Version objects
func (api *versionAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Version, error) {
	var objlist []*Version
	objs, err := api.ct.List("Version", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Version:
			eobj := obj.(*Version)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Version", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Version object
func (api *versionAPI) Watch(handler VersionHandler) error {
	api.ct.startWorkerPool("Version")
	return api.ct.WatchVersion(handler)
}

// StopWatch stop watch for Tenant Version object
func (api *versionAPI) StopWatch(handler VersionHandler) error {
	api.ct.Lock()
	api.ct.workPools["Version"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchVersion(handler)
}

// Version returns VersionAPI
func (ct *ctrlerCtx) Version() VersionAPI {
	kind := "Version"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &versionAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*versionAPI)
}

// ConfigurationSnapshot is a wrapper object that implements additional functionality
type ConfigurationSnapshot struct {
	sync.Mutex
	cluster.ConfigurationSnapshot
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *ConfigurationSnapshot) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("ConfigurationSnapshot_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().ConfigurationSnapshot().UpdateStatus(context.Background(), &obj.ConfigurationSnapshot)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().ConfigurationSnapshot().Create(context.Background(), &obj.ConfigurationSnapshot)
	}

	return nil
}

// ConfigurationSnapshotHandler is the event handler for ConfigurationSnapshot object
type ConfigurationSnapshotHandler interface {
	OnConfigurationSnapshotCreate(obj *ConfigurationSnapshot) error
	OnConfigurationSnapshotUpdate(oldObj *ConfigurationSnapshot, newObj *cluster.ConfigurationSnapshot) error
	OnConfigurationSnapshotDelete(obj *ConfigurationSnapshot) error
	GetConfigurationSnapshotWatchOptions() *api.ListWatchOptions
}

// OnConfigurationSnapshotCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnConfigurationSnapshotCreate(obj *ConfigurationSnapshot) error {
	log.Info("OnConfigurationSnapshotCreate is not implemented")
	return nil
}

// OnConfigurationSnapshotUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnConfigurationSnapshotUpdate(oldObj *ConfigurationSnapshot, newObj *cluster.ConfigurationSnapshot) error {
	log.Info("OnConfigurationSnapshotUpdate is not implemented")
	return nil
}

// OnConfigurationSnapshotDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnConfigurationSnapshotDelete(obj *ConfigurationSnapshot) error {
	log.Info("OnConfigurationSnapshotDelete is not implemented")
	return nil
}

// GetConfigurationSnapshotWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetConfigurationSnapshotWatchOptions() *api.ListWatchOptions {
	log.Info("GetConfigurationSnapshotWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleConfigurationSnapshotEvent handles ConfigurationSnapshot events from watcher
func (ct *ctrlerCtx) handleConfigurationSnapshotEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleConfigurationSnapshotEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.ConfigurationSnapshot:
		eobj := evt.Object.(*cluster.ConfigurationSnapshot)
		kind := "ConfigurationSnapshot"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &configurationsnapshotCtx{event: evt.Type,
			obj: &ConfigurationSnapshot{ConfigurationSnapshot: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ConfigurationSnapshot watch channel", tp)
	}

	return nil
}

// handleConfigurationSnapshotEventNoResolver handles ConfigurationSnapshot events from watcher
func (ct *ctrlerCtx) handleConfigurationSnapshotEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.ConfigurationSnapshot:
		eobj := evt.Object.(*cluster.ConfigurationSnapshot)
		kind := "ConfigurationSnapshot"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		configurationsnapshotHandler := handler.(ConfigurationSnapshotHandler)
		// handle based on event type
		ctrlCtx := &configurationsnapshotCtx{event: evt.Type, obj: &ConfigurationSnapshot{ConfigurationSnapshot: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("ConfigurationSnapshot_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = configurationsnapshotHandler.OnConfigurationSnapshotCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*configurationsnapshotCtx)
				ct.stats.Counter("ConfigurationSnapshot_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.ConfigurationSnapshot{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = configurationsnapshotHandler.OnConfigurationSnapshotUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.ConfigurationSnapshot = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &configurationsnapshotCtx{event: evt.Type, obj: &ConfigurationSnapshot{ConfigurationSnapshot: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*ConfigurationSnapshot)
			ct.stats.Counter("ConfigurationSnapshot_Deleted_Events").Inc()
			obj.Lock()
			err = configurationsnapshotHandler.OnConfigurationSnapshotDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ConfigurationSnapshot watch channel", tp)
	}

	return nil
}

type configurationsnapshotCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *ConfigurationSnapshot //
	//   newObj     *cluster.ConfigurationSnapshot //update
	newObj *configurationsnapshotCtx //update
}

func (ctx *configurationsnapshotCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *configurationsnapshotCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *configurationsnapshotCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *configurationsnapshotCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *configurationsnapshotCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *configurationsnapshotCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*configurationsnapshotCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *configurationsnapshotCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *configurationsnapshotCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.ConfigurationSnapshot = obj.(*configurationsnapshotCtx).obj.ConfigurationSnapshot
}

func (ctx *configurationsnapshotCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *configurationsnapshotCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *configurationsnapshotCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *configurationsnapshotCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *configurationsnapshotCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "ConfigurationSnapshot"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	configurationsnapshotHandler := handler.(ConfigurationSnapshotHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = configurationsnapshotHandler.OnConfigurationSnapshotCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("ConfigurationSnapshot_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.ConfigurationSnapshot{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = configurationsnapshotHandler.OnConfigurationSnapshotUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = configurationsnapshotHandler.OnConfigurationSnapshotDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleConfigurationSnapshotEventParallel handles ConfigurationSnapshot events from watcher
func (ct *ctrlerCtx) handleConfigurationSnapshotEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleConfigurationSnapshotEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.ConfigurationSnapshot:
		eobj := evt.Object.(*cluster.ConfigurationSnapshot)
		kind := "ConfigurationSnapshot"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &configurationsnapshotCtx{event: evt.Type, obj: &ConfigurationSnapshot{ConfigurationSnapshot: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ConfigurationSnapshot watch channel", tp)
	}

	return nil
}

// handleConfigurationSnapshotEventParallel handles ConfigurationSnapshot events from watcher
func (ct *ctrlerCtx) handleConfigurationSnapshotEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.ConfigurationSnapshot:
		eobj := evt.Object.(*cluster.ConfigurationSnapshot)
		kind := "ConfigurationSnapshot"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		configurationsnapshotHandler := handler.(ConfigurationSnapshotHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*configurationsnapshotCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("ConfigurationSnapshot_Created_Events").Inc()
					eobj.Lock()
					err = configurationsnapshotHandler.OnConfigurationSnapshotCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*configurationsnapshotCtx)
					obj := workCtx.obj
					ct.stats.Counter("ConfigurationSnapshot_Updated_Events").Inc()
					obj.Lock()
					p := cluster.ConfigurationSnapshot{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = configurationsnapshotHandler.OnConfigurationSnapshotUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.ConfigurationSnapshot = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &configurationsnapshotCtx{event: evt.Type, obj: &ConfigurationSnapshot{ConfigurationSnapshot: *eobj, ctrler: ct}}
			ct.runFunction("ConfigurationSnapshot", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*configurationsnapshotCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*ConfigurationSnapshot)
				ct.stats.Counter("ConfigurationSnapshot_Deleted_Events").Inc()
				obj.Lock()
				err = configurationsnapshotHandler.OnConfigurationSnapshotDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &configurationsnapshotCtx{event: evt.Type, obj: &ConfigurationSnapshot{ConfigurationSnapshot: *eobj, ctrler: ct}}
			ct.runFunction("ConfigurationSnapshot", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on ConfigurationSnapshot watch channel", tp)
	}

	return nil
}

// diffConfigurationSnapshot does a diff of ConfigurationSnapshot objects between local cache and API server
func (ct *ctrlerCtx) diffConfigurationSnapshot(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().ConfigurationSnapshot().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffConfigurationSnapshot(): ConfigurationSnapshotList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.ConfigurationSnapshot)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.ConfigurationSnapshot().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffConfigurationSnapshot(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.ConfigurationSnapshot,
			}
			ct.handleConfigurationSnapshotEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffConfigurationSnapshot(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleConfigurationSnapshotEvent(&evt)
	}
}

func (ct *ctrlerCtx) runConfigurationSnapshotWatcher() {
	kind := "ConfigurationSnapshot"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	configurationsnapshotHandler := handler.(ConfigurationSnapshotHandler)

	opts := configurationsnapshotHandler.GetConfigurationSnapshotWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "ConfigurationSnapshotWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffConfigurationSnapshot(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("ConfigurationSnapshot_Watch").Inc()
		defer ct.stats.Counter("ConfigurationSnapshot_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("ConfigurationSnapshot_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// ConfigurationSnapshot object watcher
				wt, werr := apicl.ClusterV1().ConfigurationSnapshot().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffConfigurationSnapshot(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("ConfigurationSnapshot_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleConfigurationSnapshotEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchConfigurationSnapshot starts watch on ConfigurationSnapshot object
func (ct *ctrlerCtx) WatchConfigurationSnapshot(handler ConfigurationSnapshotHandler) error {
	kind := "ConfigurationSnapshot"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("ConfigurationSnapshot watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run ConfigurationSnapshot watcher in a go routine
	ct.runConfigurationSnapshotWatcher()

	return nil
}

// StopWatchConfigurationSnapshot stops watch on ConfigurationSnapshot object
func (ct *ctrlerCtx) StopWatchConfigurationSnapshot(handler ConfigurationSnapshotHandler) error {
	kind := "ConfigurationSnapshot"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("ConfigurationSnapshot watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// ConfigurationSnapshotAPI returns
type ConfigurationSnapshotAPI interface {
	Create(obj *cluster.ConfigurationSnapshot) error
	SyncCreate(obj *cluster.ConfigurationSnapshot) error
	Update(obj *cluster.ConfigurationSnapshot) error
	SyncUpdate(obj *cluster.ConfigurationSnapshot) error
	Delete(obj *cluster.ConfigurationSnapshot) error
	Find(meta *api.ObjectMeta) (*ConfigurationSnapshot, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*ConfigurationSnapshot, error)
	Watch(handler ConfigurationSnapshotHandler) error
	StopWatch(handler ConfigurationSnapshotHandler) error
	Save(obj *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error)
	RegisterLocalSaveHandler(fn func(*cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error))
	SyncSave(obj *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error)
	RegisterLocalSyncSaveHandler(fn func(*cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error))
}

// dummy struct that implements ConfigurationSnapshotAPI
type configurationsnapshotAPI struct {
	ct *ctrlerCtx

	localSaveHandler     func(obj *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error)
	localSyncSaveHandler func(obj *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error)
}

// Create creates ConfigurationSnapshot object
func (api *configurationsnapshotAPI) Create(obj *cluster.ConfigurationSnapshot) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().ConfigurationSnapshot().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().ConfigurationSnapshot().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleConfigurationSnapshotEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates ConfigurationSnapshot object and updates the cache
func (api *configurationsnapshotAPI) SyncCreate(obj *cluster.ConfigurationSnapshot) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().ConfigurationSnapshot().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().ConfigurationSnapshot().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleConfigurationSnapshotEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on ConfigurationSnapshot object
func (api *configurationsnapshotAPI) Update(obj *cluster.ConfigurationSnapshot) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().ConfigurationSnapshot().Update(context.Background(), obj)
		return err
	}

	api.ct.handleConfigurationSnapshotEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on ConfigurationSnapshot object and updates the cache
func (api *configurationsnapshotAPI) SyncUpdate(obj *cluster.ConfigurationSnapshot) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().ConfigurationSnapshot().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleConfigurationSnapshotEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes ConfigurationSnapshot object
func (api *configurationsnapshotAPI) Delete(obj *cluster.ConfigurationSnapshot) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().ConfigurationSnapshot().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleConfigurationSnapshotEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *configurationsnapshotAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "config-snapshot", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "config-snapshot", "/", name)
}

// Find returns an object by meta
func (api *configurationsnapshotAPI) Find(meta *api.ObjectMeta) (*ConfigurationSnapshot, error) {
	// find the object
	obj, err := api.ct.FindObject("ConfigurationSnapshot", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *ConfigurationSnapshot:
		hobj := obj.(*ConfigurationSnapshot)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all ConfigurationSnapshot objects
func (api *configurationsnapshotAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*ConfigurationSnapshot, error) {
	var objlist []*ConfigurationSnapshot
	objs, err := api.ct.List("ConfigurationSnapshot", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *ConfigurationSnapshot:
			eobj := obj.(*ConfigurationSnapshot)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for ConfigurationSnapshot", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for ConfigurationSnapshot object
func (api *configurationsnapshotAPI) Watch(handler ConfigurationSnapshotHandler) error {
	api.ct.startWorkerPool("ConfigurationSnapshot")
	return api.ct.WatchConfigurationSnapshot(handler)
}

// StopWatch stop watch for Tenant ConfigurationSnapshot object
func (api *configurationsnapshotAPI) StopWatch(handler ConfigurationSnapshotHandler) error {
	api.ct.Lock()
	api.ct.workPools["ConfigurationSnapshot"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchConfigurationSnapshot(handler)
}

// Save is an API action
func (api *configurationsnapshotAPI) Save(obj *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.ClusterV1().ConfigurationSnapshot().Save(context.Background(), obj)
	}
	if api.localSaveHandler != nil {
		return api.localSaveHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncSave is an API action. Cache will be updated
func (api *configurationsnapshotAPI) SyncSave(obj *cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.ClusterV1().ConfigurationSnapshot().Save(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.ClusterV1().ConfigurationSnapshot().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleConfigurationSnapshotEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncSaveHandler != nil {
		return api.localSyncSaveHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *configurationsnapshotAPI) RegisterLocalSaveHandler(fn func(*cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error)) {
	api.localSaveHandler = fn
}

func (api *configurationsnapshotAPI) RegisterLocalSyncSaveHandler(fn func(*cluster.ConfigurationSnapshotRequest) (*cluster.ConfigurationSnapshot, error)) {
	api.localSyncSaveHandler = fn
}

// ConfigurationSnapshot returns ConfigurationSnapshotAPI
func (ct *ctrlerCtx) ConfigurationSnapshot() ConfigurationSnapshotAPI {
	kind := "ConfigurationSnapshot"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &configurationsnapshotAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*configurationsnapshotAPI)
}

// SnapshotRestore is a wrapper object that implements additional functionality
type SnapshotRestore struct {
	sync.Mutex
	cluster.SnapshotRestore
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *SnapshotRestore) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("SnapshotRestore_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().SnapshotRestore().UpdateStatus(context.Background(), &obj.SnapshotRestore)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().SnapshotRestore().Create(context.Background(), &obj.SnapshotRestore)
	}

	return nil
}

// SnapshotRestoreHandler is the event handler for SnapshotRestore object
type SnapshotRestoreHandler interface {
	OnSnapshotRestoreCreate(obj *SnapshotRestore) error
	OnSnapshotRestoreUpdate(oldObj *SnapshotRestore, newObj *cluster.SnapshotRestore) error
	OnSnapshotRestoreDelete(obj *SnapshotRestore) error
	GetSnapshotRestoreWatchOptions() *api.ListWatchOptions
}

// OnSnapshotRestoreCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnSnapshotRestoreCreate(obj *SnapshotRestore) error {
	log.Info("OnSnapshotRestoreCreate is not implemented")
	return nil
}

// OnSnapshotRestoreUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnSnapshotRestoreUpdate(oldObj *SnapshotRestore, newObj *cluster.SnapshotRestore) error {
	log.Info("OnSnapshotRestoreUpdate is not implemented")
	return nil
}

// OnSnapshotRestoreDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnSnapshotRestoreDelete(obj *SnapshotRestore) error {
	log.Info("OnSnapshotRestoreDelete is not implemented")
	return nil
}

// GetSnapshotRestoreWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetSnapshotRestoreWatchOptions() *api.ListWatchOptions {
	log.Info("GetSnapshotRestoreWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleSnapshotRestoreEvent handles SnapshotRestore events from watcher
func (ct *ctrlerCtx) handleSnapshotRestoreEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleSnapshotRestoreEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.SnapshotRestore:
		eobj := evt.Object.(*cluster.SnapshotRestore)
		kind := "SnapshotRestore"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &snapshotrestoreCtx{event: evt.Type,
			obj: &SnapshotRestore{SnapshotRestore: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SnapshotRestore watch channel", tp)
	}

	return nil
}

// handleSnapshotRestoreEventNoResolver handles SnapshotRestore events from watcher
func (ct *ctrlerCtx) handleSnapshotRestoreEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.SnapshotRestore:
		eobj := evt.Object.(*cluster.SnapshotRestore)
		kind := "SnapshotRestore"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		snapshotrestoreHandler := handler.(SnapshotRestoreHandler)
		// handle based on event type
		ctrlCtx := &snapshotrestoreCtx{event: evt.Type, obj: &SnapshotRestore{SnapshotRestore: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("SnapshotRestore_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = snapshotrestoreHandler.OnSnapshotRestoreCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*snapshotrestoreCtx)
				ct.stats.Counter("SnapshotRestore_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.SnapshotRestore{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = snapshotrestoreHandler.OnSnapshotRestoreUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.SnapshotRestore = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &snapshotrestoreCtx{event: evt.Type, obj: &SnapshotRestore{SnapshotRestore: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*SnapshotRestore)
			ct.stats.Counter("SnapshotRestore_Deleted_Events").Inc()
			obj.Lock()
			err = snapshotrestoreHandler.OnSnapshotRestoreDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SnapshotRestore watch channel", tp)
	}

	return nil
}

type snapshotrestoreCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *SnapshotRestore //
	//   newObj     *cluster.SnapshotRestore //update
	newObj *snapshotrestoreCtx //update
}

func (ctx *snapshotrestoreCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *snapshotrestoreCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *snapshotrestoreCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *snapshotrestoreCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *snapshotrestoreCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *snapshotrestoreCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*snapshotrestoreCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *snapshotrestoreCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *snapshotrestoreCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.SnapshotRestore = obj.(*snapshotrestoreCtx).obj.SnapshotRestore
}

func (ctx *snapshotrestoreCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *snapshotrestoreCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *snapshotrestoreCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *snapshotrestoreCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *snapshotrestoreCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "SnapshotRestore"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	snapshotrestoreHandler := handler.(SnapshotRestoreHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = snapshotrestoreHandler.OnSnapshotRestoreCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("SnapshotRestore_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.SnapshotRestore{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = snapshotrestoreHandler.OnSnapshotRestoreUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = snapshotrestoreHandler.OnSnapshotRestoreDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleSnapshotRestoreEventParallel handles SnapshotRestore events from watcher
func (ct *ctrlerCtx) handleSnapshotRestoreEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleSnapshotRestoreEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.SnapshotRestore:
		eobj := evt.Object.(*cluster.SnapshotRestore)
		kind := "SnapshotRestore"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &snapshotrestoreCtx{event: evt.Type, obj: &SnapshotRestore{SnapshotRestore: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SnapshotRestore watch channel", tp)
	}

	return nil
}

// handleSnapshotRestoreEventParallel handles SnapshotRestore events from watcher
func (ct *ctrlerCtx) handleSnapshotRestoreEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.SnapshotRestore:
		eobj := evt.Object.(*cluster.SnapshotRestore)
		kind := "SnapshotRestore"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		snapshotrestoreHandler := handler.(SnapshotRestoreHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*snapshotrestoreCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("SnapshotRestore_Created_Events").Inc()
					eobj.Lock()
					err = snapshotrestoreHandler.OnSnapshotRestoreCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*snapshotrestoreCtx)
					obj := workCtx.obj
					ct.stats.Counter("SnapshotRestore_Updated_Events").Inc()
					obj.Lock()
					p := cluster.SnapshotRestore{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = snapshotrestoreHandler.OnSnapshotRestoreUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.SnapshotRestore = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &snapshotrestoreCtx{event: evt.Type, obj: &SnapshotRestore{SnapshotRestore: *eobj, ctrler: ct}}
			ct.runFunction("SnapshotRestore", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*snapshotrestoreCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*SnapshotRestore)
				ct.stats.Counter("SnapshotRestore_Deleted_Events").Inc()
				obj.Lock()
				err = snapshotrestoreHandler.OnSnapshotRestoreDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &snapshotrestoreCtx{event: evt.Type, obj: &SnapshotRestore{SnapshotRestore: *eobj, ctrler: ct}}
			ct.runFunction("SnapshotRestore", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on SnapshotRestore watch channel", tp)
	}

	return nil
}

// diffSnapshotRestore does a diff of SnapshotRestore objects between local cache and API server
func (ct *ctrlerCtx) diffSnapshotRestore(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().SnapshotRestore().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffSnapshotRestore(): SnapshotRestoreList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.SnapshotRestore)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.SnapshotRestore().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffSnapshotRestore(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.SnapshotRestore,
			}
			ct.handleSnapshotRestoreEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffSnapshotRestore(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleSnapshotRestoreEvent(&evt)
	}
}

func (ct *ctrlerCtx) runSnapshotRestoreWatcher() {
	kind := "SnapshotRestore"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	snapshotrestoreHandler := handler.(SnapshotRestoreHandler)

	opts := snapshotrestoreHandler.GetSnapshotRestoreWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "SnapshotRestoreWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffSnapshotRestore(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("SnapshotRestore_Watch").Inc()
		defer ct.stats.Counter("SnapshotRestore_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("SnapshotRestore_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// SnapshotRestore object watcher
				wt, werr := apicl.ClusterV1().SnapshotRestore().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffSnapshotRestore(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("SnapshotRestore_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleSnapshotRestoreEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchSnapshotRestore starts watch on SnapshotRestore object
func (ct *ctrlerCtx) WatchSnapshotRestore(handler SnapshotRestoreHandler) error {
	kind := "SnapshotRestore"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("SnapshotRestore watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run SnapshotRestore watcher in a go routine
	ct.runSnapshotRestoreWatcher()

	return nil
}

// StopWatchSnapshotRestore stops watch on SnapshotRestore object
func (ct *ctrlerCtx) StopWatchSnapshotRestore(handler SnapshotRestoreHandler) error {
	kind := "SnapshotRestore"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("SnapshotRestore watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// SnapshotRestoreAPI returns
type SnapshotRestoreAPI interface {
	Create(obj *cluster.SnapshotRestore) error
	SyncCreate(obj *cluster.SnapshotRestore) error
	Update(obj *cluster.SnapshotRestore) error
	SyncUpdate(obj *cluster.SnapshotRestore) error
	Delete(obj *cluster.SnapshotRestore) error
	Find(meta *api.ObjectMeta) (*SnapshotRestore, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*SnapshotRestore, error)
	Watch(handler SnapshotRestoreHandler) error
	StopWatch(handler SnapshotRestoreHandler) error
	Restore(obj *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error)
	RegisterLocalRestoreHandler(fn func(*cluster.SnapshotRestore) (*cluster.SnapshotRestore, error))
	SyncRestore(obj *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error)
	RegisterLocalSyncRestoreHandler(fn func(*cluster.SnapshotRestore) (*cluster.SnapshotRestore, error))
}

// dummy struct that implements SnapshotRestoreAPI
type snapshotrestoreAPI struct {
	ct *ctrlerCtx

	localRestoreHandler     func(obj *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error)
	localSyncRestoreHandler func(obj *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error)
}

// Create creates SnapshotRestore object
func (api *snapshotrestoreAPI) Create(obj *cluster.SnapshotRestore) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().SnapshotRestore().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().SnapshotRestore().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleSnapshotRestoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates SnapshotRestore object and updates the cache
func (api *snapshotrestoreAPI) SyncCreate(obj *cluster.SnapshotRestore) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().SnapshotRestore().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().SnapshotRestore().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleSnapshotRestoreEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on SnapshotRestore object
func (api *snapshotrestoreAPI) Update(obj *cluster.SnapshotRestore) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().SnapshotRestore().Update(context.Background(), obj)
		return err
	}

	api.ct.handleSnapshotRestoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on SnapshotRestore object and updates the cache
func (api *snapshotrestoreAPI) SyncUpdate(obj *cluster.SnapshotRestore) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().SnapshotRestore().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleSnapshotRestoreEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes SnapshotRestore object
func (api *snapshotrestoreAPI) Delete(obj *cluster.SnapshotRestore) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().SnapshotRestore().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleSnapshotRestoreEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *snapshotrestoreAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "config-restore", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "config-restore", "/", name)
}

// Find returns an object by meta
func (api *snapshotrestoreAPI) Find(meta *api.ObjectMeta) (*SnapshotRestore, error) {
	// find the object
	obj, err := api.ct.FindObject("SnapshotRestore", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *SnapshotRestore:
		hobj := obj.(*SnapshotRestore)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all SnapshotRestore objects
func (api *snapshotrestoreAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*SnapshotRestore, error) {
	var objlist []*SnapshotRestore
	objs, err := api.ct.List("SnapshotRestore", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *SnapshotRestore:
			eobj := obj.(*SnapshotRestore)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for SnapshotRestore", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for SnapshotRestore object
func (api *snapshotrestoreAPI) Watch(handler SnapshotRestoreHandler) error {
	api.ct.startWorkerPool("SnapshotRestore")
	return api.ct.WatchSnapshotRestore(handler)
}

// StopWatch stop watch for Tenant SnapshotRestore object
func (api *snapshotrestoreAPI) StopWatch(handler SnapshotRestoreHandler) error {
	api.ct.Lock()
	api.ct.workPools["SnapshotRestore"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchSnapshotRestore(handler)
}

// Restore is an API action
func (api *snapshotrestoreAPI) Restore(obj *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		return apicl.ClusterV1().SnapshotRestore().Restore(context.Background(), obj)
	}
	if api.localRestoreHandler != nil {
		return api.localRestoreHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

// SyncRestore is an API action. Cache will be updated
func (api *snapshotrestoreAPI) SyncRestore(obj *cluster.SnapshotRestore) (*cluster.SnapshotRestore, error) {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return nil, err
		}

		ret, err := apicl.ClusterV1().SnapshotRestore().Restore(context.Background(), obj)
		if err != nil {
			return ret, err
		}
		// Perform Get to update the cache
		newObj, err := apicl.ClusterV1().SnapshotRestore().Get(context.Background(), obj.GetObjectMeta())
		if err == nil {
			api.ct.handleSnapshotRestoreEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
		}
		return ret, err
	}
	if api.localSyncRestoreHandler != nil {
		return api.localSyncRestoreHandler(obj)
	}
	return nil, fmt.Errorf("Action not implemented for local operation")
}

func (api *snapshotrestoreAPI) RegisterLocalRestoreHandler(fn func(*cluster.SnapshotRestore) (*cluster.SnapshotRestore, error)) {
	api.localRestoreHandler = fn
}

func (api *snapshotrestoreAPI) RegisterLocalSyncRestoreHandler(fn func(*cluster.SnapshotRestore) (*cluster.SnapshotRestore, error)) {
	api.localSyncRestoreHandler = fn
}

// SnapshotRestore returns SnapshotRestoreAPI
func (ct *ctrlerCtx) SnapshotRestore() SnapshotRestoreAPI {
	kind := "SnapshotRestore"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &snapshotrestoreAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*snapshotrestoreAPI)
}

// License is a wrapper object that implements additional functionality
type License struct {
	sync.Mutex
	cluster.License
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *License) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("License_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().License().UpdateStatus(context.Background(), &obj.License)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().License().Create(context.Background(), &obj.License)
	}

	return nil
}

// LicenseHandler is the event handler for License object
type LicenseHandler interface {
	OnLicenseCreate(obj *License) error
	OnLicenseUpdate(oldObj *License, newObj *cluster.License) error
	OnLicenseDelete(obj *License) error
	GetLicenseWatchOptions() *api.ListWatchOptions
}

// OnLicenseCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnLicenseCreate(obj *License) error {
	log.Info("OnLicenseCreate is not implemented")
	return nil
}

// OnLicenseUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnLicenseUpdate(oldObj *License, newObj *cluster.License) error {
	log.Info("OnLicenseUpdate is not implemented")
	return nil
}

// OnLicenseDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnLicenseDelete(obj *License) error {
	log.Info("OnLicenseDelete is not implemented")
	return nil
}

// GetLicenseWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetLicenseWatchOptions() *api.ListWatchOptions {
	log.Info("GetLicenseWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleLicenseEvent handles License events from watcher
func (ct *ctrlerCtx) handleLicenseEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleLicenseEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.License:
		eobj := evt.Object.(*cluster.License)
		kind := "License"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &licenseCtx{event: evt.Type,
			obj: &License{License: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on License watch channel", tp)
	}

	return nil
}

// handleLicenseEventNoResolver handles License events from watcher
func (ct *ctrlerCtx) handleLicenseEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.License:
		eobj := evt.Object.(*cluster.License)
		kind := "License"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		licenseHandler := handler.(LicenseHandler)
		// handle based on event type
		ctrlCtx := &licenseCtx{event: evt.Type, obj: &License{License: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("License_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = licenseHandler.OnLicenseCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*licenseCtx)
				ct.stats.Counter("License_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.License{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = licenseHandler.OnLicenseUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.License = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &licenseCtx{event: evt.Type, obj: &License{License: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*License)
			ct.stats.Counter("License_Deleted_Events").Inc()
			obj.Lock()
			err = licenseHandler.OnLicenseDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on License watch channel", tp)
	}

	return nil
}

type licenseCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *License //
	//   newObj     *cluster.License //update
	newObj *licenseCtx //update
}

func (ctx *licenseCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *licenseCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *licenseCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *licenseCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *licenseCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *licenseCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*licenseCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *licenseCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *licenseCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.License = obj.(*licenseCtx).obj.License
}

func (ctx *licenseCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *licenseCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *licenseCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *licenseCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *licenseCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "License"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	licenseHandler := handler.(LicenseHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = licenseHandler.OnLicenseCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("License_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.License{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = licenseHandler.OnLicenseUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = licenseHandler.OnLicenseDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleLicenseEventParallel handles License events from watcher
func (ct *ctrlerCtx) handleLicenseEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleLicenseEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.License:
		eobj := evt.Object.(*cluster.License)
		kind := "License"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &licenseCtx{event: evt.Type, obj: &License{License: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on License watch channel", tp)
	}

	return nil
}

// handleLicenseEventParallel handles License events from watcher
func (ct *ctrlerCtx) handleLicenseEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.License:
		eobj := evt.Object.(*cluster.License)
		kind := "License"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		licenseHandler := handler.(LicenseHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*licenseCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("License_Created_Events").Inc()
					eobj.Lock()
					err = licenseHandler.OnLicenseCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*licenseCtx)
					obj := workCtx.obj
					ct.stats.Counter("License_Updated_Events").Inc()
					obj.Lock()
					p := cluster.License{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = licenseHandler.OnLicenseUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.License = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &licenseCtx{event: evt.Type, obj: &License{License: *eobj, ctrler: ct}}
			ct.runFunction("License", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*licenseCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*License)
				ct.stats.Counter("License_Deleted_Events").Inc()
				obj.Lock()
				err = licenseHandler.OnLicenseDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &licenseCtx{event: evt.Type, obj: &License{License: *eobj, ctrler: ct}}
			ct.runFunction("License", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on License watch channel", tp)
	}

	return nil
}

// diffLicense does a diff of License objects between local cache and API server
func (ct *ctrlerCtx) diffLicense(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().License().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffLicense(): LicenseList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.License)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.License().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffLicense(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.License,
			}
			ct.handleLicenseEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffLicense(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleLicenseEvent(&evt)
	}
}

func (ct *ctrlerCtx) runLicenseWatcher() {
	kind := "License"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	licenseHandler := handler.(LicenseHandler)

	opts := licenseHandler.GetLicenseWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "LicenseWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffLicense(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("License_Watch").Inc()
		defer ct.stats.Counter("License_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("License_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// License object watcher
				wt, werr := apicl.ClusterV1().License().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffLicense(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("License_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleLicenseEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchLicense starts watch on License object
func (ct *ctrlerCtx) WatchLicense(handler LicenseHandler) error {
	kind := "License"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("License watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run License watcher in a go routine
	ct.runLicenseWatcher()

	return nil
}

// StopWatchLicense stops watch on License object
func (ct *ctrlerCtx) StopWatchLicense(handler LicenseHandler) error {
	kind := "License"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("License watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// LicenseAPI returns
type LicenseAPI interface {
	Create(obj *cluster.License) error
	SyncCreate(obj *cluster.License) error
	Update(obj *cluster.License) error
	SyncUpdate(obj *cluster.License) error
	Delete(obj *cluster.License) error
	Find(meta *api.ObjectMeta) (*License, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*License, error)
	Watch(handler LicenseHandler) error
	StopWatch(handler LicenseHandler) error
}

// dummy struct that implements LicenseAPI
type licenseAPI struct {
	ct *ctrlerCtx
}

// Create creates License object
func (api *licenseAPI) Create(obj *cluster.License) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().License().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().License().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleLicenseEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates License object and updates the cache
func (api *licenseAPI) SyncCreate(obj *cluster.License) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().License().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().License().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleLicenseEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on License object
func (api *licenseAPI) Update(obj *cluster.License) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().License().Update(context.Background(), obj)
		return err
	}

	api.ct.handleLicenseEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on License object and updates the cache
func (api *licenseAPI) SyncUpdate(obj *cluster.License) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().License().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleLicenseEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes License object
func (api *licenseAPI) Delete(obj *cluster.License) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().License().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleLicenseEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *licenseAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "licenses", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "licenses", "/", name)
}

// Find returns an object by meta
func (api *licenseAPI) Find(meta *api.ObjectMeta) (*License, error) {
	// find the object
	obj, err := api.ct.FindObject("License", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *License:
		hobj := obj.(*License)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all License objects
func (api *licenseAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*License, error) {
	var objlist []*License
	objs, err := api.ct.List("License", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *License:
			eobj := obj.(*License)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for License", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for License object
func (api *licenseAPI) Watch(handler LicenseHandler) error {
	api.ct.startWorkerPool("License")
	return api.ct.WatchLicense(handler)
}

// StopWatch stop watch for Tenant License object
func (api *licenseAPI) StopWatch(handler LicenseHandler) error {
	api.ct.Lock()
	api.ct.workPools["License"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchLicense(handler)
}

// License returns LicenseAPI
func (ct *ctrlerCtx) License() LicenseAPI {
	kind := "License"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &licenseAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*licenseAPI)
}

// DSCProfile is a wrapper object that implements additional functionality
type DSCProfile struct {
	sync.Mutex
	cluster.DSCProfile
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *DSCProfile) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("DSCProfile_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.ClusterV1().DSCProfile().UpdateStatus(context.Background(), &obj.DSCProfile)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.ClusterV1().DSCProfile().Create(context.Background(), &obj.DSCProfile)
	}

	return nil
}

// DSCProfileHandler is the event handler for DSCProfile object
type DSCProfileHandler interface {
	OnDSCProfileCreate(obj *DSCProfile) error
	OnDSCProfileUpdate(oldObj *DSCProfile, newObj *cluster.DSCProfile) error
	OnDSCProfileDelete(obj *DSCProfile) error
	GetDSCProfileWatchOptions() *api.ListWatchOptions
}

// OnDSCProfileCreate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnDSCProfileCreate(obj *DSCProfile) error {
	log.Info("OnDSCProfileCreate is not implemented")
	return nil
}

// OnDSCProfileUpdate is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnDSCProfileUpdate(oldObj *DSCProfile, newObj *cluster.DSCProfile) error {
	log.Info("OnDSCProfileUpdate is not implemented")
	return nil
}

// OnDSCProfileDelete is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) OnDSCProfileDelete(obj *DSCProfile) error {
	log.Info("OnDSCProfileDelete is not implemented")
	return nil
}

// GetDSCProfileWatchOptions is a dummy handler used in init if no one registers the handler
func (ctrler CtrlDefReactor) GetDSCProfileWatchOptions() *api.ListWatchOptions {
	log.Info("GetDSCProfileWatchOptions is not implemented")
	opts := &api.ListWatchOptions{}
	return opts
}

// handleDSCProfileEvent handles DSCProfile events from watcher
func (ct *ctrlerCtx) handleDSCProfileEvent(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleDSCProfileEventNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.DSCProfile:
		eobj := evt.Object.(*cluster.DSCProfile)
		kind := "DSCProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &dscprofileCtx{event: evt.Type,
			obj: &DSCProfile{DSCProfile: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DSCProfile watch channel", tp)
	}

	return nil
}

// handleDSCProfileEventNoResolver handles DSCProfile events from watcher
func (ct *ctrlerCtx) handleDSCProfileEventNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.DSCProfile:
		eobj := evt.Object.(*cluster.DSCProfile)
		kind := "DSCProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		dscprofileHandler := handler.(DSCProfileHandler)
		// handle based on event type
		ctrlCtx := &dscprofileCtx{event: evt.Type, obj: &DSCProfile{DSCProfile: *eobj, ctrler: ct}}
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.getObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.addObject(ctrlCtx)
				ct.stats.Counter("DSCProfile_Created_Events").Inc()

				// call the event handler
				ctrlCtx.Lock()
				err = dscprofileHandler.OnDSCProfileCreate(ctrlCtx.obj)
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					ct.delObject(kind, ctrlCtx.GetKey())
					return err
				}
			} else {
				fResVer, fErr := strconv.ParseInt(fobj.GetResourceVersion(), 10, 64)
				eResVer, eErr := strconv.ParseInt(eobj.GetResourceVersion(), 10, 64)
				if ct.resolver != nil && fErr == nil && eErr == nil && fResVer >= eResVer {
					// Event already processed.
					ct.logger.Infof("Skipping update due to old resource version")
					return nil
				}
				ctrlCtx := fobj.(*dscprofileCtx)
				ct.stats.Counter("DSCProfile_Updated_Events").Inc()
				ctrlCtx.Lock()
				p := cluster.DSCProfile{Spec: eobj.Spec,
					ObjectMeta: eobj.ObjectMeta,
					TypeMeta:   eobj.TypeMeta,
					Status:     eobj.Status}

				err = dscprofileHandler.OnDSCProfileUpdate(ctrlCtx.obj, &p)
				ctrlCtx.obj.DSCProfile = *eobj
				ctrlCtx.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctrlCtx.obj, err)
					return err
				}

			}
		case kvstore.Deleted:
			ctrlCtx := &dscprofileCtx{event: evt.Type, obj: &DSCProfile{DSCProfile: *eobj, ctrler: ct}}
			fobj, err := ct.findObject(kind, ctrlCtx.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*DSCProfile)
			ct.stats.Counter("DSCProfile_Deleted_Events").Inc()
			obj.Lock()
			err = dscprofileHandler.OnDSCProfileDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}
			ct.delObject(kind, ctrlCtx.GetKey())
			return nil

		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DSCProfile watch channel", tp)
	}

	return nil
}

type dscprofileCtx struct {
	ctkitBaseCtx
	event kvstore.WatchEventType
	obj   *DSCProfile //
	//   newObj     *cluster.DSCProfile //update
	newObj *dscprofileCtx //update
}

func (ctx *dscprofileCtx) References() map[string]apiintf.ReferenceObj {
	resp := make(map[string]apiintf.ReferenceObj)
	ctx.obj.References(ctx.obj.GetObjectMeta().Name, ctx.obj.GetObjectMeta().Namespace, resp)
	return resp
}

func (ctx *dscprofileCtx) GetKey() string {
	return ctx.obj.MakeKey("cluster")
}

func (ctx *dscprofileCtx) GetKind() string {
	return ctx.obj.GetKind()
}

func (ctx *dscprofileCtx) GetResourceVersion() string {
	return ctx.obj.GetResourceVersion()
}

func (ctx *dscprofileCtx) SetEvent(event kvstore.WatchEventType) {
	ctx.event = event
}

func (ctx *dscprofileCtx) SetNewObj(newObj apiintf.CtkitObject) {
	if newObj == nil {
		ctx.newObj = nil
	} else {
		ctx.newObj = newObj.(*dscprofileCtx)
		ctx.newObj.obj.HandlerCtx = ctx.obj.HandlerCtx
	}
}

func (ctx *dscprofileCtx) GetNewObj() apiintf.CtkitObject {
	return ctx.newObj
}

func (ctx *dscprofileCtx) Copy(obj apiintf.CtkitObject) {
	ctx.obj.DSCProfile = obj.(*dscprofileCtx).obj.DSCProfile
}

func (ctx *dscprofileCtx) Lock() {
	ctx.obj.Lock()
}

func (ctx *dscprofileCtx) Unlock() {
	ctx.obj.Unlock()
}

func (ctx *dscprofileCtx) GetObjectMeta() *api.ObjectMeta {
	return ctx.obj.GetObjectMeta()
}

func (ctx *dscprofileCtx) RuntimeObject() runtime.Object {
	var v interface{}
	v = ctx.obj
	return v.(runtime.Object)
}

func (ctx *dscprofileCtx) WorkFunc(context context.Context) error {
	var err error
	evt := ctx.event
	ct := ctx.obj.ctrler
	kind := "DSCProfile"
	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	dscprofileHandler := handler.(DSCProfileHandler)
	switch evt {
	case kvstore.Created:
		ctx.obj.Lock()
		err = dscprofileHandler.OnDSCProfileCreate(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Updated:
		ct.stats.Counter("DSCProfile_Updated_Events").Inc()
		ctx.obj.Lock()
		p := cluster.DSCProfile{Spec: ctx.newObj.obj.Spec,
			ObjectMeta: ctx.newObj.obj.ObjectMeta,
			TypeMeta:   ctx.newObj.obj.TypeMeta,
			Status:     ctx.newObj.obj.Status}
		err = dscprofileHandler.OnDSCProfileUpdate(ctx.obj, &p)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, ctx.obj, err)
			ctx.SetEvent(kvstore.Deleted)
		}
	case kvstore.Deleted:
		ctx.obj.Lock()
		err = dscprofileHandler.OnDSCProfileDelete(ctx.obj)
		ctx.obj.Unlock()
		if err != nil {
			ct.logger.Errorf("Error deleting %s %+v. Err: %v", kind, ctx.obj, err)
		}
	}
	ct.resolveObject(ctx.event, ctx)
	return nil
}

// handleDSCProfileEventParallel handles DSCProfile events from watcher
func (ct *ctrlerCtx) handleDSCProfileEventParallel(evt *kvstore.WatchEvent) error {

	if ct.objResolver == nil {
		return ct.handleDSCProfileEventParallelWithNoResolver(evt)
	}

	switch tp := evt.Object.(type) {
	case *cluster.DSCProfile:
		eobj := evt.Object.(*cluster.DSCProfile)
		kind := "DSCProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ctx := &dscprofileCtx{event: evt.Type, obj: &DSCProfile{DSCProfile: *eobj, ctrler: ct}}

		var err error
		switch evt.Type {
		case kvstore.Created:
			err = ct.processAdd(ctx)
		case kvstore.Updated:
			err = ct.processUpdate(ctx)
		case kvstore.Deleted:
			err = ct.processDelete(ctx)
		}
		return err
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DSCProfile watch channel", tp)
	}

	return nil
}

// handleDSCProfileEventParallel handles DSCProfile events from watcher
func (ct *ctrlerCtx) handleDSCProfileEventParallelWithNoResolver(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *cluster.DSCProfile:
		eobj := evt.Object.(*cluster.DSCProfile)
		kind := "DSCProfile"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		dscprofileHandler := handler.(DSCProfileHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*dscprofileCtx)
				eobj := workCtx.obj
				fobj, err := ct.getObject(kind, workCtx.GetKey())
				if err != nil {
					ct.addObject(workCtx)
					ct.stats.Counter("DSCProfile_Created_Events").Inc()
					eobj.Lock()
					err = dscprofileHandler.OnDSCProfileCreate(eobj)
					eobj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, eobj, err)
						ct.delObject(kind, workCtx.GetKey())
					}
				} else {
					workCtx := fobj.(*dscprofileCtx)
					obj := workCtx.obj
					ct.stats.Counter("DSCProfile_Updated_Events").Inc()
					obj.Lock()
					p := cluster.DSCProfile{Spec: eobj.Spec,
						ObjectMeta: eobj.ObjectMeta,
						TypeMeta:   eobj.TypeMeta,
						Status:     eobj.Status}

					err = dscprofileHandler.OnDSCProfileUpdate(obj, &p)
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					} else {
						workCtx.obj.DSCProfile = p
					}
					obj.Unlock()
				}
				return err
			}
			ctrlCtx := &dscprofileCtx{event: evt.Type, obj: &DSCProfile{DSCProfile: *eobj, ctrler: ct}}
			ct.runFunction("DSCProfile", ctrlCtx, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, ctrlCtx shardworkers.WorkObj) error {
				var err error
				workCtx := ctrlCtx.(*dscprofileCtx)
				eobj := workCtx.obj
				fobj, err := ct.findObject(kind, workCtx.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*DSCProfile)
				ct.stats.Counter("DSCProfile_Deleted_Events").Inc()
				obj.Lock()
				err = dscprofileHandler.OnDSCProfileDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, workCtx.GetKey())
				return nil
			}
			ctrlCtx := &dscprofileCtx{event: evt.Type, obj: &DSCProfile{DSCProfile: *eobj, ctrler: ct}}
			ct.runFunction("DSCProfile", ctrlCtx, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on DSCProfile watch channel", tp)
	}

	return nil
}

// diffDSCProfile does a diff of DSCProfile objects between local cache and API server
func (ct *ctrlerCtx) diffDSCProfile(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.ClusterV1().DSCProfile().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffDSCProfile(): DSCProfileList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*cluster.DSCProfile)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.DSCProfile().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffDSCProfile(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.DSCProfile,
			}
			ct.handleDSCProfileEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffDSCProfile(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleDSCProfileEvent(&evt)
	}
}

func (ct *ctrlerCtx) runDSCProfileWatcher() {
	kind := "DSCProfile"

	ct.Lock()
	handler, ok := ct.handlers[kind]
	ct.Unlock()
	if !ok {
		ct.logger.Fatalf("Cant find the handler for %s", kind)
	}
	dscprofileHandler := handler.(DSCProfileHandler)

	opts := dscprofileHandler.GetDSCProfileWatchOptions()

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	logger := ct.logger.WithContext("submodule", "DSCProfileWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffDSCProfile(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("DSCProfile_Watch").Inc()
		defer ct.stats.Counter("DSCProfile_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("DSCProfile_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// DSCProfile object watcher
				wt, werr := apicl.ClusterV1().DSCProfile().Watch(ctx, opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffDSCProfile(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("DSCProfile_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleDSCProfileEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchDSCProfile starts watch on DSCProfile object
func (ct *ctrlerCtx) WatchDSCProfile(handler DSCProfileHandler) error {
	kind := "DSCProfile"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("DSCProfile watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run DSCProfile watcher in a go routine
	ct.runDSCProfileWatcher()

	return nil
}

// StopWatchDSCProfile stops watch on DSCProfile object
func (ct *ctrlerCtx) StopWatchDSCProfile(handler DSCProfileHandler) error {
	kind := "DSCProfile"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("DSCProfile watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// DSCProfileAPI returns
type DSCProfileAPI interface {
	Create(obj *cluster.DSCProfile) error
	SyncCreate(obj *cluster.DSCProfile) error
	Update(obj *cluster.DSCProfile) error
	SyncUpdate(obj *cluster.DSCProfile) error
	Delete(obj *cluster.DSCProfile) error
	Find(meta *api.ObjectMeta) (*DSCProfile, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*DSCProfile, error)
	Watch(handler DSCProfileHandler) error
	StopWatch(handler DSCProfileHandler) error
}

// dummy struct that implements DSCProfileAPI
type dscprofileAPI struct {
	ct *ctrlerCtx
}

// Create creates DSCProfile object
func (api *dscprofileAPI) Create(obj *cluster.DSCProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().DSCProfile().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.ClusterV1().DSCProfile().Update(context.Background(), obj)

		}
		return err
	}

	api.ct.handleDSCProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
	return nil
}

// SyncCreate creates DSCProfile object and updates the cache
func (api *dscprofileAPI) SyncCreate(obj *cluster.DSCProfile) error {
	newObj := obj
	evtType := kvstore.Created
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().DSCProfile().Create(context.Background(), obj)
		if writeErr != nil && strings.Contains(writeErr.Error(), "AlreadyExists") {
			newObj, writeErr = apicl.ClusterV1().DSCProfile().Update(context.Background(), obj)
			evtType = kvstore.Updated
		}
	}

	if writeErr == nil {
		api.ct.handleDSCProfileEvent(&kvstore.WatchEvent{Object: newObj, Type: evtType})
	}
	return writeErr
}

// Update triggers update on DSCProfile object
func (api *dscprofileAPI) Update(obj *cluster.DSCProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().DSCProfile().Update(context.Background(), obj)
		return err
	}

	api.ct.handleDSCProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
	return nil
}

// SyncUpdate triggers update on DSCProfile object and updates the cache
func (api *dscprofileAPI) SyncUpdate(obj *cluster.DSCProfile) error {
	newObj := obj
	var writeErr error
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		newObj, writeErr = apicl.ClusterV1().DSCProfile().Update(context.Background(), obj)
	}

	if writeErr == nil {
		api.ct.handleDSCProfileEvent(&kvstore.WatchEvent{Object: newObj, Type: kvstore.Updated})
	}

	return writeErr
}

// Delete deletes DSCProfile object
func (api *dscprofileAPI) Delete(obj *cluster.DSCProfile) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.ClusterV1().DSCProfile().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	api.ct.handleDSCProfileEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
	return nil
}

// MakeKey generates a KV store key for the object
func (api *dscprofileAPI) getFullKey(tenant, name string) string {
	if tenant != "" {
		return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "dscprofiles", "/", tenant, "/", name)
	}
	return fmt.Sprint(globals.ConfigRootPrefix, "/", "cluster", "/", "dscprofiles", "/", name)
}

// Find returns an object by meta
func (api *dscprofileAPI) Find(meta *api.ObjectMeta) (*DSCProfile, error) {
	// find the object
	obj, err := api.ct.FindObject("DSCProfile", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *DSCProfile:
		hobj := obj.(*DSCProfile)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all DSCProfile objects
func (api *dscprofileAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*DSCProfile, error) {
	var objlist []*DSCProfile
	objs, err := api.ct.List("DSCProfile", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *DSCProfile:
			eobj := obj.(*DSCProfile)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for DSCProfile", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for DSCProfile object
func (api *dscprofileAPI) Watch(handler DSCProfileHandler) error {
	api.ct.startWorkerPool("DSCProfile")
	return api.ct.WatchDSCProfile(handler)
}

// StopWatch stop watch for Tenant DSCProfile object
func (api *dscprofileAPI) StopWatch(handler DSCProfileHandler) error {
	api.ct.Lock()
	api.ct.workPools["DSCProfile"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchDSCProfile(handler)
}

// DSCProfile returns DSCProfileAPI
func (ct *ctrlerCtx) DSCProfile() DSCProfileAPI {
	kind := "DSCProfile"
	if _, ok := ct.apiInfMap[kind]; !ok {
		s := &dscprofileAPI{ct: ct}
		ct.apiInfMap[kind] = s
	}
	return ct.apiInfMap[kind].(*dscprofileAPI)
}
