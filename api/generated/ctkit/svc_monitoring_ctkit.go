// Code generated by protoc-gen-grpc-pensando DO NOT EDIT.

/*
Package ctkit is a auto generated package.
Input file: svc_monitoring.proto
*/
package ctkit

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/pensando/sw/api"
	"github.com/pensando/sw/api/generated/apiclient"
	"github.com/pensando/sw/api/generated/monitoring"
	"github.com/pensando/sw/venice/utils/balancer"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/rpckit"
	"github.com/pensando/sw/venice/utils/shardworkers"
)

// EventPolicy is a wrapper object that implements additional functionality
type EventPolicy struct {
	sync.Mutex
	monitoring.EventPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *EventPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("EventPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().EventPolicy().UpdateStatus(context.Background(), &obj.EventPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), &obj.EventPolicy)
	}

	return nil
}

// EventPolicyHandler is the event handler for EventPolicy object
type EventPolicyHandler interface {
	OnEventPolicyCreate(obj *EventPolicy) error
	OnEventPolicyUpdate(oldObj *EventPolicy, newObj *monitoring.EventPolicy) error
	OnEventPolicyDelete(obj *EventPolicy) error
}

// handleEventPolicyEvent handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		eventpolicyHandler := handler.(EventPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &EventPolicy{
					EventPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("EventPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = eventpolicyHandler.OnEventPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*EventPolicy)

				ct.stats.Counter("EventPolicy_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = eventpolicyHandler.OnEventPolicyUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*EventPolicy)

			ct.stats.Counter("EventPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = eventpolicyHandler.OnEventPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// handleEventPolicyEventParallel handles EventPolicy events from watcher
func (ct *ctrlerCtx) handleEventPolicyEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.EventPolicy:
		eobj := evt.Object.(*monitoring.EventPolicy)
		kind := "EventPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		eventpolicyHandler := handler.(EventPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.EventPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &EventPolicy{
						EventPolicy: *eobj,
						HandlerCtx:  nil,
						ctrler:      ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("EventPolicy_Created_Events").Inc()
					obj.Lock()
					err = eventpolicyHandler.OnEventPolicyCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.EventPolicy.GetKey())
					}
				} else {
					obj := fobj.(*EventPolicy)
					ct.stats.Counter("EventPolicy_Updated_Events").Inc()
					obj.Lock()
					err = eventpolicyHandler.OnEventPolicyUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("EventPolicy", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.EventPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*EventPolicy)
				ct.stats.Counter("EventPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = eventpolicyHandler.OnEventPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.EventPolicy.GetKey())
				return nil
			}
			ct.runJob("EventPolicy", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on EventPolicy watch channel", tp)
	}

	return nil
}

// diffEventPolicy does a diff of EventPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffEventPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().EventPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffEventPolicy(): EventPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.EventPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.EventPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffEventPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.EventPolicy,
			}
			ct.handleEventPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffEventPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleEventPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runEventPolicyWatcher() {
	kind := "EventPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "EventPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffEventPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("EventPolicy_Watch").Inc()
		defer ct.stats.Counter("EventPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("EventPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// EventPolicy object watcher
				wt, werr := apicl.MonitoringV1().EventPolicy().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffEventPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("EventPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleEventPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchEventPolicy starts watch on EventPolicy object
func (ct *ctrlerCtx) WatchEventPolicy(handler EventPolicyHandler) error {
	kind := "EventPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("EventPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run EventPolicy watcher in a go routine
	ct.runEventPolicyWatcher()

	return nil
}

// StopWatchEventPolicy stops watch on EventPolicy object
func (ct *ctrlerCtx) StopWatchEventPolicy(handler EventPolicyHandler) error {
	kind := "EventPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("EventPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// EventPolicyAPI returns
type EventPolicyAPI interface {
	Create(obj *monitoring.EventPolicy) error
	CreateEvent(obj *monitoring.EventPolicy) error
	Update(obj *monitoring.EventPolicy) error
	Delete(obj *monitoring.EventPolicy) error
	Find(meta *api.ObjectMeta) (*EventPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*EventPolicy, error)
	Watch(handler EventPolicyHandler) error
	StopWatch(handler EventPolicyHandler) error
}

// dummy struct that implements EventPolicyAPI
type eventpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates EventPolicy object
func (api *eventpolicyAPI) Create(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates EventPolicy object and synchronously triggers local event
func (api *eventpolicyAPI) CreateEvent(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on EventPolicy object
func (api *eventpolicyAPI) Update(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes EventPolicy object
func (api *eventpolicyAPI) Delete(obj *monitoring.EventPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().EventPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleEventPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *eventpolicyAPI) Find(meta *api.ObjectMeta) (*EventPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("EventPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *EventPolicy:
		hobj := obj.(*EventPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all EventPolicy objects
func (api *eventpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*EventPolicy, error) {
	var objlist []*EventPolicy
	objs, err := api.ct.List("EventPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *EventPolicy:
			eobj := obj.(*EventPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for EventPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for EventPolicy object
func (api *eventpolicyAPI) Watch(handler EventPolicyHandler) error {
	api.ct.startWorkerPool("EventPolicy")
	return api.ct.WatchEventPolicy(handler)
}

// StopWatch stop watch for Tenant EventPolicy object
func (api *eventpolicyAPI) StopWatch(handler EventPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["EventPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchEventPolicy(handler)
}

// EventPolicy returns EventPolicyAPI
func (ct *ctrlerCtx) EventPolicy() EventPolicyAPI {
	return &eventpolicyAPI{ct: ct}
}

// StatsPolicy is a wrapper object that implements additional functionality
type StatsPolicy struct {
	sync.Mutex
	monitoring.StatsPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *StatsPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("StatsPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().StatsPolicy().UpdateStatus(context.Background(), &obj.StatsPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().StatsPolicy().Create(context.Background(), &obj.StatsPolicy)
	}

	return nil
}

// StatsPolicyHandler is the event handler for StatsPolicy object
type StatsPolicyHandler interface {
	OnStatsPolicyCreate(obj *StatsPolicy) error
	OnStatsPolicyUpdate(oldObj *StatsPolicy, newObj *monitoring.StatsPolicy) error
	OnStatsPolicyDelete(obj *StatsPolicy) error
}

// handleStatsPolicyEvent handles StatsPolicy events from watcher
func (ct *ctrlerCtx) handleStatsPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.StatsPolicy:
		eobj := evt.Object.(*monitoring.StatsPolicy)
		kind := "StatsPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		statspolicyHandler := handler.(StatsPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &StatsPolicy{
					StatsPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("StatsPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = statspolicyHandler.OnStatsPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*StatsPolicy)

				ct.stats.Counter("StatsPolicy_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = statspolicyHandler.OnStatsPolicyUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*StatsPolicy)

			ct.stats.Counter("StatsPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = statspolicyHandler.OnStatsPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on StatsPolicy watch channel", tp)
	}

	return nil
}

// handleStatsPolicyEventParallel handles StatsPolicy events from watcher
func (ct *ctrlerCtx) handleStatsPolicyEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.StatsPolicy:
		eobj := evt.Object.(*monitoring.StatsPolicy)
		kind := "StatsPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		statspolicyHandler := handler.(StatsPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.StatsPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &StatsPolicy{
						StatsPolicy: *eobj,
						HandlerCtx:  nil,
						ctrler:      ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("StatsPolicy_Created_Events").Inc()
					obj.Lock()
					err = statspolicyHandler.OnStatsPolicyCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.StatsPolicy.GetKey())
					}
				} else {
					obj := fobj.(*StatsPolicy)
					ct.stats.Counter("StatsPolicy_Updated_Events").Inc()
					obj.Lock()
					err = statspolicyHandler.OnStatsPolicyUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("StatsPolicy", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.StatsPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*StatsPolicy)
				ct.stats.Counter("StatsPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = statspolicyHandler.OnStatsPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.StatsPolicy.GetKey())
				return nil
			}
			ct.runJob("StatsPolicy", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on StatsPolicy watch channel", tp)
	}

	return nil
}

// diffStatsPolicy does a diff of StatsPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffStatsPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().StatsPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffStatsPolicy(): StatsPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.StatsPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.StatsPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffStatsPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.StatsPolicy,
			}
			ct.handleStatsPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffStatsPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleStatsPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runStatsPolicyWatcher() {
	kind := "StatsPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "StatsPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffStatsPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("StatsPolicy_Watch").Inc()
		defer ct.stats.Counter("StatsPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("StatsPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// StatsPolicy object watcher
				wt, werr := apicl.MonitoringV1().StatsPolicy().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffStatsPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("StatsPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleStatsPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchStatsPolicy starts watch on StatsPolicy object
func (ct *ctrlerCtx) WatchStatsPolicy(handler StatsPolicyHandler) error {
	kind := "StatsPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("StatsPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run StatsPolicy watcher in a go routine
	ct.runStatsPolicyWatcher()

	return nil
}

// StopWatchStatsPolicy stops watch on StatsPolicy object
func (ct *ctrlerCtx) StopWatchStatsPolicy(handler StatsPolicyHandler) error {
	kind := "StatsPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("StatsPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// StatsPolicyAPI returns
type StatsPolicyAPI interface {
	Create(obj *monitoring.StatsPolicy) error
	CreateEvent(obj *monitoring.StatsPolicy) error
	Update(obj *monitoring.StatsPolicy) error
	Delete(obj *monitoring.StatsPolicy) error
	Find(meta *api.ObjectMeta) (*StatsPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*StatsPolicy, error)
	Watch(handler StatsPolicyHandler) error
	StopWatch(handler StatsPolicyHandler) error
}

// dummy struct that implements StatsPolicyAPI
type statspolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates StatsPolicy object
func (api *statspolicyAPI) Create(obj *monitoring.StatsPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().StatsPolicy().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleStatsPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates StatsPolicy object and synchronously triggers local event
func (api *statspolicyAPI) CreateEvent(obj *monitoring.StatsPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().StatsPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleStatsPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on StatsPolicy object
func (api *statspolicyAPI) Update(obj *monitoring.StatsPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsPolicy().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleStatsPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes StatsPolicy object
func (api *statspolicyAPI) Delete(obj *monitoring.StatsPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().StatsPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleStatsPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *statspolicyAPI) Find(meta *api.ObjectMeta) (*StatsPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("StatsPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *StatsPolicy:
		hobj := obj.(*StatsPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all StatsPolicy objects
func (api *statspolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*StatsPolicy, error) {
	var objlist []*StatsPolicy
	objs, err := api.ct.List("StatsPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *StatsPolicy:
			eobj := obj.(*StatsPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for StatsPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for StatsPolicy object
func (api *statspolicyAPI) Watch(handler StatsPolicyHandler) error {
	api.ct.startWorkerPool("StatsPolicy")
	return api.ct.WatchStatsPolicy(handler)
}

// StopWatch stop watch for Tenant StatsPolicy object
func (api *statspolicyAPI) StopWatch(handler StatsPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["StatsPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchStatsPolicy(handler)
}

// StatsPolicy returns StatsPolicyAPI
func (ct *ctrlerCtx) StatsPolicy() StatsPolicyAPI {
	return &statspolicyAPI{ct: ct}
}

// FwlogPolicy is a wrapper object that implements additional functionality
type FwlogPolicy struct {
	sync.Mutex
	monitoring.FwlogPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FwlogPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FwlogPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().FwlogPolicy().UpdateStatus(context.Background(), &obj.FwlogPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), &obj.FwlogPolicy)
	}

	return nil
}

// FwlogPolicyHandler is the event handler for FwlogPolicy object
type FwlogPolicyHandler interface {
	OnFwlogPolicyCreate(obj *FwlogPolicy) error
	OnFwlogPolicyUpdate(oldObj *FwlogPolicy, newObj *monitoring.FwlogPolicy) error
	OnFwlogPolicyDelete(obj *FwlogPolicy) error
}

// handleFwlogPolicyEvent handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		fwlogpolicyHandler := handler.(FwlogPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &FwlogPolicy{
					FwlogPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("FwlogPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*FwlogPolicy)

				ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FwlogPolicy)

			ct.stats.Counter("FwlogPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = fwlogpolicyHandler.OnFwlogPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// handleFwlogPolicyEventParallel handles FwlogPolicy events from watcher
func (ct *ctrlerCtx) handleFwlogPolicyEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FwlogPolicy:
		eobj := evt.Object.(*monitoring.FwlogPolicy)
		kind := "FwlogPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		fwlogpolicyHandler := handler.(FwlogPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.FwlogPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &FwlogPolicy{
						FwlogPolicy: *eobj,
						HandlerCtx:  nil,
						ctrler:      ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("FwlogPolicy_Created_Events").Inc()
					obj.Lock()
					err = fwlogpolicyHandler.OnFwlogPolicyCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.FwlogPolicy.GetKey())
					}
				} else {
					obj := fobj.(*FwlogPolicy)
					ct.stats.Counter("FwlogPolicy_Updated_Events").Inc()
					obj.Lock()
					err = fwlogpolicyHandler.OnFwlogPolicyUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("FwlogPolicy", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.FwlogPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FwlogPolicy)
				ct.stats.Counter("FwlogPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = fwlogpolicyHandler.OnFwlogPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.FwlogPolicy.GetKey())
				return nil
			}
			ct.runJob("FwlogPolicy", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FwlogPolicy watch channel", tp)
	}

	return nil
}

// diffFwlogPolicy does a diff of FwlogPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFwlogPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FwlogPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFwlogPolicy(): FwlogPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.FwlogPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.FwlogPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFwlogPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FwlogPolicy,
			}
			ct.handleFwlogPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFwlogPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFwlogPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFwlogPolicyWatcher() {
	kind := "FwlogPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "FwlogPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffFwlogPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FwlogPolicy_Watch").Inc()
		defer ct.stats.Counter("FwlogPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FwlogPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FwlogPolicy object watcher
				wt, werr := apicl.MonitoringV1().FwlogPolicy().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffFwlogPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FwlogPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFwlogPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFwlogPolicy starts watch on FwlogPolicy object
func (ct *ctrlerCtx) WatchFwlogPolicy(handler FwlogPolicyHandler) error {
	kind := "FwlogPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FwlogPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FwlogPolicy watcher in a go routine
	ct.runFwlogPolicyWatcher()

	return nil
}

// StopWatchFwlogPolicy stops watch on FwlogPolicy object
func (ct *ctrlerCtx) StopWatchFwlogPolicy(handler FwlogPolicyHandler) error {
	kind := "FwlogPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("FwlogPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// FwlogPolicyAPI returns
type FwlogPolicyAPI interface {
	Create(obj *monitoring.FwlogPolicy) error
	CreateEvent(obj *monitoring.FwlogPolicy) error
	Update(obj *monitoring.FwlogPolicy) error
	Delete(obj *monitoring.FwlogPolicy) error
	Find(meta *api.ObjectMeta) (*FwlogPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*FwlogPolicy, error)
	Watch(handler FwlogPolicyHandler) error
	StopWatch(handler FwlogPolicyHandler) error
}

// dummy struct that implements FwlogPolicyAPI
type fwlogpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FwlogPolicy object
func (api *fwlogpolicyAPI) Create(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates FwlogPolicy object and synchronously triggers local event
func (api *fwlogpolicyAPI) CreateEvent(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on FwlogPolicy object
func (api *fwlogpolicyAPI) Update(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes FwlogPolicy object
func (api *fwlogpolicyAPI) Delete(obj *monitoring.FwlogPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FwlogPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleFwlogPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *fwlogpolicyAPI) Find(meta *api.ObjectMeta) (*FwlogPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("FwlogPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FwlogPolicy:
		hobj := obj.(*FwlogPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FwlogPolicy objects
func (api *fwlogpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*FwlogPolicy, error) {
	var objlist []*FwlogPolicy
	objs, err := api.ct.List("FwlogPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FwlogPolicy:
			eobj := obj.(*FwlogPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FwlogPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for FwlogPolicy object
func (api *fwlogpolicyAPI) Watch(handler FwlogPolicyHandler) error {
	api.ct.startWorkerPool("FwlogPolicy")
	return api.ct.WatchFwlogPolicy(handler)
}

// StopWatch stop watch for Tenant FwlogPolicy object
func (api *fwlogpolicyAPI) StopWatch(handler FwlogPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["FwlogPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchFwlogPolicy(handler)
}

// FwlogPolicy returns FwlogPolicyAPI
func (ct *ctrlerCtx) FwlogPolicy() FwlogPolicyAPI {
	return &fwlogpolicyAPI{ct: ct}
}

// FlowExportPolicy is a wrapper object that implements additional functionality
type FlowExportPolicy struct {
	sync.Mutex
	monitoring.FlowExportPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *FlowExportPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("FlowExportPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().FlowExportPolicy().UpdateStatus(context.Background(), &obj.FlowExportPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), &obj.FlowExportPolicy)
	}

	return nil
}

// FlowExportPolicyHandler is the event handler for FlowExportPolicy object
type FlowExportPolicyHandler interface {
	OnFlowExportPolicyCreate(obj *FlowExportPolicy) error
	OnFlowExportPolicyUpdate(oldObj *FlowExportPolicy, newObj *monitoring.FlowExportPolicy) error
	OnFlowExportPolicyDelete(obj *FlowExportPolicy) error
}

// handleFlowExportPolicyEvent handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &FlowExportPolicy{
					FlowExportPolicy: *eobj,
					HandlerCtx:       nil,
					ctrler:           ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("FlowExportPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*FlowExportPolicy)

				ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*FlowExportPolicy)

			ct.stats.Counter("FlowExportPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = flowexportpolicyHandler.OnFlowExportPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// handleFlowExportPolicyEventParallel handles FlowExportPolicy events from watcher
func (ct *ctrlerCtx) handleFlowExportPolicyEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.FlowExportPolicy:
		eobj := evt.Object.(*monitoring.FlowExportPolicy)
		kind := "FlowExportPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		flowexportpolicyHandler := handler.(FlowExportPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.FlowExportPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &FlowExportPolicy{
						FlowExportPolicy: *eobj,
						HandlerCtx:       nil,
						ctrler:           ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("FlowExportPolicy_Created_Events").Inc()
					obj.Lock()
					err = flowexportpolicyHandler.OnFlowExportPolicyCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.FlowExportPolicy.GetKey())
					}
				} else {
					obj := fobj.(*FlowExportPolicy)
					ct.stats.Counter("FlowExportPolicy_Updated_Events").Inc()
					obj.Lock()
					err = flowexportpolicyHandler.OnFlowExportPolicyUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("FlowExportPolicy", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.FlowExportPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*FlowExportPolicy)
				ct.stats.Counter("FlowExportPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = flowexportpolicyHandler.OnFlowExportPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.FlowExportPolicy.GetKey())
				return nil
			}
			ct.runJob("FlowExportPolicy", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on FlowExportPolicy watch channel", tp)
	}

	return nil
}

// diffFlowExportPolicy does a diff of FlowExportPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffFlowExportPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().FlowExportPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffFlowExportPolicy(): FlowExportPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.FlowExportPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.FlowExportPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffFlowExportPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.FlowExportPolicy,
			}
			ct.handleFlowExportPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffFlowExportPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleFlowExportPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runFlowExportPolicyWatcher() {
	kind := "FlowExportPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "FlowExportPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffFlowExportPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("FlowExportPolicy_Watch").Inc()
		defer ct.stats.Counter("FlowExportPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("FlowExportPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// FlowExportPolicy object watcher
				wt, werr := apicl.MonitoringV1().FlowExportPolicy().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffFlowExportPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("FlowExportPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleFlowExportPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchFlowExportPolicy starts watch on FlowExportPolicy object
func (ct *ctrlerCtx) WatchFlowExportPolicy(handler FlowExportPolicyHandler) error {
	kind := "FlowExportPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("FlowExportPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run FlowExportPolicy watcher in a go routine
	ct.runFlowExportPolicyWatcher()

	return nil
}

// StopWatchFlowExportPolicy stops watch on FlowExportPolicy object
func (ct *ctrlerCtx) StopWatchFlowExportPolicy(handler FlowExportPolicyHandler) error {
	kind := "FlowExportPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("FlowExportPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// FlowExportPolicyAPI returns
type FlowExportPolicyAPI interface {
	Create(obj *monitoring.FlowExportPolicy) error
	CreateEvent(obj *monitoring.FlowExportPolicy) error
	Update(obj *monitoring.FlowExportPolicy) error
	Delete(obj *monitoring.FlowExportPolicy) error
	Find(meta *api.ObjectMeta) (*FlowExportPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*FlowExportPolicy, error)
	Watch(handler FlowExportPolicyHandler) error
	StopWatch(handler FlowExportPolicyHandler) error
}

// dummy struct that implements FlowExportPolicyAPI
type flowexportpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates FlowExportPolicy object
func (api *flowexportpolicyAPI) Create(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates FlowExportPolicy object and synchronously triggers local event
func (api *flowexportpolicyAPI) CreateEvent(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on FlowExportPolicy object
func (api *flowexportpolicyAPI) Update(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes FlowExportPolicy object
func (api *flowexportpolicyAPI) Delete(obj *monitoring.FlowExportPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().FlowExportPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleFlowExportPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *flowexportpolicyAPI) Find(meta *api.ObjectMeta) (*FlowExportPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("FlowExportPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *FlowExportPolicy:
		hobj := obj.(*FlowExportPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all FlowExportPolicy objects
func (api *flowexportpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*FlowExportPolicy, error) {
	var objlist []*FlowExportPolicy
	objs, err := api.ct.List("FlowExportPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *FlowExportPolicy:
			eobj := obj.(*FlowExportPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for FlowExportPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for FlowExportPolicy object
func (api *flowexportpolicyAPI) Watch(handler FlowExportPolicyHandler) error {
	api.ct.startWorkerPool("FlowExportPolicy")
	return api.ct.WatchFlowExportPolicy(handler)
}

// StopWatch stop watch for Tenant FlowExportPolicy object
func (api *flowexportpolicyAPI) StopWatch(handler FlowExportPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["FlowExportPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchFlowExportPolicy(handler)
}

// FlowExportPolicy returns FlowExportPolicyAPI
func (ct *ctrlerCtx) FlowExportPolicy() FlowExportPolicyAPI {
	return &flowexportpolicyAPI{ct: ct}
}

// Alert is a wrapper object that implements additional functionality
type Alert struct {
	sync.Mutex
	monitoring.Alert
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *Alert) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("Alert_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().Alert().UpdateStatus(context.Background(), &obj.Alert)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), &obj.Alert)
	}

	return nil
}

// AlertHandler is the event handler for Alert object
type AlertHandler interface {
	OnAlertCreate(obj *Alert) error
	OnAlertUpdate(oldObj *Alert, newObj *monitoring.Alert) error
	OnAlertDelete(obj *Alert) error
}

// handleAlertEvent handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertHandler := handler.(AlertHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &Alert{
					Alert:      *eobj,
					HandlerCtx: nil,
					ctrler:     ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("Alert_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = alertHandler.OnAlertCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*Alert)

				ct.stats.Counter("Alert_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = alertHandler.OnAlertUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*Alert)

			ct.stats.Counter("Alert_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = alertHandler.OnAlertDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// handleAlertEventParallel handles Alert events from watcher
func (ct *ctrlerCtx) handleAlertEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.Alert:
		eobj := evt.Object.(*monitoring.Alert)
		kind := "Alert"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertHandler := handler.(AlertHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.Alert)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &Alert{
						Alert:      *eobj,
						HandlerCtx: nil,
						ctrler:     ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("Alert_Created_Events").Inc()
					obj.Lock()
					err = alertHandler.OnAlertCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.Alert.GetKey())
					}
				} else {
					obj := fobj.(*Alert)
					ct.stats.Counter("Alert_Updated_Events").Inc()
					obj.Lock()
					err = alertHandler.OnAlertUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("Alert", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.Alert)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*Alert)
				ct.stats.Counter("Alert_Deleted_Events").Inc()
				obj.Lock()
				err = alertHandler.OnAlertDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.Alert.GetKey())
				return nil
			}
			ct.runJob("Alert", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on Alert watch channel", tp)
	}

	return nil
}

// diffAlert does a diff of Alert objects between local cache and API server
func (ct *ctrlerCtx) diffAlert(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().Alert().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlert(): AlertList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.Alert)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.Alert().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlert(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.Alert,
			}
			ct.handleAlertEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlert(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertWatcher() {
	kind := "Alert"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "AlertWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffAlert(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("Alert_Watch").Inc()
		defer ct.stats.Counter("Alert_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("Alert_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// Alert object watcher
				wt, werr := apicl.MonitoringV1().Alert().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffAlert(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("Alert_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlert starts watch on Alert object
func (ct *ctrlerCtx) WatchAlert(handler AlertHandler) error {
	kind := "Alert"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("Alert watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run Alert watcher in a go routine
	ct.runAlertWatcher()

	return nil
}

// StopWatchAlert stops watch on Alert object
func (ct *ctrlerCtx) StopWatchAlert(handler AlertHandler) error {
	kind := "Alert"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("Alert watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertAPI returns
type AlertAPI interface {
	Create(obj *monitoring.Alert) error
	CreateEvent(obj *monitoring.Alert) error
	Update(obj *monitoring.Alert) error
	Delete(obj *monitoring.Alert) error
	Find(meta *api.ObjectMeta) (*Alert, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*Alert, error)
	Watch(handler AlertHandler) error
	StopWatch(handler AlertHandler) error
}

// dummy struct that implements AlertAPI
type alertAPI struct {
	ct *ctrlerCtx
}

// Create creates Alert object
func (api *alertAPI) Create(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates Alert object and synchronously triggers local event
func (api *alertAPI) CreateEvent(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on Alert object
func (api *alertAPI) Update(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes Alert object
func (api *alertAPI) Delete(obj *monitoring.Alert) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().Alert().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleAlertEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *alertAPI) Find(meta *api.ObjectMeta) (*Alert, error) {
	// find the object
	obj, err := api.ct.FindObject("Alert", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *Alert:
		hobj := obj.(*Alert)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all Alert objects
func (api *alertAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*Alert, error) {
	var objlist []*Alert
	objs, err := api.ct.List("Alert", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *Alert:
			eobj := obj.(*Alert)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for Alert", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for Alert object
func (api *alertAPI) Watch(handler AlertHandler) error {
	api.ct.startWorkerPool("Alert")
	return api.ct.WatchAlert(handler)
}

// StopWatch stop watch for Tenant Alert object
func (api *alertAPI) StopWatch(handler AlertHandler) error {
	api.ct.Lock()
	api.ct.workPools["Alert"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlert(handler)
}

// Alert returns AlertAPI
func (ct *ctrlerCtx) Alert() AlertAPI {
	return &alertAPI{ct: ct}
}

// AlertPolicy is a wrapper object that implements additional functionality
type AlertPolicy struct {
	sync.Mutex
	monitoring.AlertPolicy
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *AlertPolicy) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AlertPolicy_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().AlertPolicy().UpdateStatus(context.Background(), &obj.AlertPolicy)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), &obj.AlertPolicy)
	}

	return nil
}

// AlertPolicyHandler is the event handler for AlertPolicy object
type AlertPolicyHandler interface {
	OnAlertPolicyCreate(obj *AlertPolicy) error
	OnAlertPolicyUpdate(oldObj *AlertPolicy, newObj *monitoring.AlertPolicy) error
	OnAlertPolicyDelete(obj *AlertPolicy) error
}

// handleAlertPolicyEvent handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertpolicyHandler := handler.(AlertPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &AlertPolicy{
					AlertPolicy: *eobj,
					HandlerCtx:  nil,
					ctrler:      ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("AlertPolicy_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = alertpolicyHandler.OnAlertPolicyCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*AlertPolicy)

				ct.stats.Counter("AlertPolicy_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = alertpolicyHandler.OnAlertPolicyUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertPolicy)

			ct.stats.Counter("AlertPolicy_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = alertpolicyHandler.OnAlertPolicyDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// handleAlertPolicyEventParallel handles AlertPolicy events from watcher
func (ct *ctrlerCtx) handleAlertPolicyEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertPolicy:
		eobj := evt.Object.(*monitoring.AlertPolicy)
		kind := "AlertPolicy"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertpolicyHandler := handler.(AlertPolicyHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.AlertPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &AlertPolicy{
						AlertPolicy: *eobj,
						HandlerCtx:  nil,
						ctrler:      ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("AlertPolicy_Created_Events").Inc()
					obj.Lock()
					err = alertpolicyHandler.OnAlertPolicyCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.AlertPolicy.GetKey())
					}
				} else {
					obj := fobj.(*AlertPolicy)
					ct.stats.Counter("AlertPolicy_Updated_Events").Inc()
					obj.Lock()
					err = alertpolicyHandler.OnAlertPolicyUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("AlertPolicy", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.AlertPolicy)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AlertPolicy)
				ct.stats.Counter("AlertPolicy_Deleted_Events").Inc()
				obj.Lock()
				err = alertpolicyHandler.OnAlertPolicyDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.AlertPolicy.GetKey())
				return nil
			}
			ct.runJob("AlertPolicy", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertPolicy watch channel", tp)
	}

	return nil
}

// diffAlertPolicy does a diff of AlertPolicy objects between local cache and API server
func (ct *ctrlerCtx) diffAlertPolicy(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlertPolicy(): AlertPolicyList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.AlertPolicy)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AlertPolicy().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlertPolicy(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertPolicy,
			}
			ct.handleAlertPolicyEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlertPolicy(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertPolicyEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertPolicyWatcher() {
	kind := "AlertPolicy"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "AlertPolicyWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffAlertPolicy(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AlertPolicy_Watch").Inc()
		defer ct.stats.Counter("AlertPolicy_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AlertPolicy_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AlertPolicy object watcher
				wt, werr := apicl.MonitoringV1().AlertPolicy().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffAlertPolicy(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AlertPolicy_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertPolicyEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlertPolicy starts watch on AlertPolicy object
func (ct *ctrlerCtx) WatchAlertPolicy(handler AlertPolicyHandler) error {
	kind := "AlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AlertPolicy watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AlertPolicy watcher in a go routine
	ct.runAlertPolicyWatcher()

	return nil
}

// StopWatchAlertPolicy stops watch on AlertPolicy object
func (ct *ctrlerCtx) StopWatchAlertPolicy(handler AlertPolicyHandler) error {
	kind := "AlertPolicy"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AlertPolicy watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertPolicyAPI returns
type AlertPolicyAPI interface {
	Create(obj *monitoring.AlertPolicy) error
	CreateEvent(obj *monitoring.AlertPolicy) error
	Update(obj *monitoring.AlertPolicy) error
	Delete(obj *monitoring.AlertPolicy) error
	Find(meta *api.ObjectMeta) (*AlertPolicy, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertPolicy, error)
	Watch(handler AlertPolicyHandler) error
	StopWatch(handler AlertPolicyHandler) error
}

// dummy struct that implements AlertPolicyAPI
type alertpolicyAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertPolicy object
func (api *alertpolicyAPI) Create(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates AlertPolicy object and synchronously triggers local event
func (api *alertpolicyAPI) CreateEvent(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on AlertPolicy object
func (api *alertpolicyAPI) Update(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes AlertPolicy object
func (api *alertpolicyAPI) Delete(obj *monitoring.AlertPolicy) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertPolicy().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleAlertPolicyEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *alertpolicyAPI) Find(meta *api.ObjectMeta) (*AlertPolicy, error) {
	// find the object
	obj, err := api.ct.FindObject("AlertPolicy", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AlertPolicy:
		hobj := obj.(*AlertPolicy)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AlertPolicy objects
func (api *alertpolicyAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertPolicy, error) {
	var objlist []*AlertPolicy
	objs, err := api.ct.List("AlertPolicy", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertPolicy:
			eobj := obj.(*AlertPolicy)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertPolicy", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for AlertPolicy object
func (api *alertpolicyAPI) Watch(handler AlertPolicyHandler) error {
	api.ct.startWorkerPool("AlertPolicy")
	return api.ct.WatchAlertPolicy(handler)
}

// StopWatch stop watch for Tenant AlertPolicy object
func (api *alertpolicyAPI) StopWatch(handler AlertPolicyHandler) error {
	api.ct.Lock()
	api.ct.workPools["AlertPolicy"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlertPolicy(handler)
}

// AlertPolicy returns AlertPolicyAPI
func (ct *ctrlerCtx) AlertPolicy() AlertPolicyAPI {
	return &alertpolicyAPI{ct: ct}
}

// AlertDestination is a wrapper object that implements additional functionality
type AlertDestination struct {
	sync.Mutex
	monitoring.AlertDestination
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *AlertDestination) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("AlertDestination_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().AlertDestination().UpdateStatus(context.Background(), &obj.AlertDestination)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), &obj.AlertDestination)
	}

	return nil
}

// AlertDestinationHandler is the event handler for AlertDestination object
type AlertDestinationHandler interface {
	OnAlertDestinationCreate(obj *AlertDestination) error
	OnAlertDestinationUpdate(oldObj *AlertDestination, newObj *monitoring.AlertDestination) error
	OnAlertDestinationDelete(obj *AlertDestination) error
}

// handleAlertDestinationEvent handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertdestinationHandler := handler.(AlertDestinationHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &AlertDestination{
					AlertDestination: *eobj,
					HandlerCtx:       nil,
					ctrler:           ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("AlertDestination_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = alertdestinationHandler.OnAlertDestinationCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*AlertDestination)

				ct.stats.Counter("AlertDestination_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = alertdestinationHandler.OnAlertDestinationUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*AlertDestination)

			ct.stats.Counter("AlertDestination_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = alertdestinationHandler.OnAlertDestinationDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// handleAlertDestinationEventParallel handles AlertDestination events from watcher
func (ct *ctrlerCtx) handleAlertDestinationEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.AlertDestination:
		eobj := evt.Object.(*monitoring.AlertDestination)
		kind := "AlertDestination"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		alertdestinationHandler := handler.(AlertDestinationHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.AlertDestination)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &AlertDestination{
						AlertDestination: *eobj,
						HandlerCtx:       nil,
						ctrler:           ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("AlertDestination_Created_Events").Inc()
					obj.Lock()
					err = alertdestinationHandler.OnAlertDestinationCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.AlertDestination.GetKey())
					}
				} else {
					obj := fobj.(*AlertDestination)
					ct.stats.Counter("AlertDestination_Updated_Events").Inc()
					obj.Lock()
					err = alertdestinationHandler.OnAlertDestinationUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("AlertDestination", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.AlertDestination)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*AlertDestination)
				ct.stats.Counter("AlertDestination_Deleted_Events").Inc()
				obj.Lock()
				err = alertdestinationHandler.OnAlertDestinationDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.AlertDestination.GetKey())
				return nil
			}
			ct.runJob("AlertDestination", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on AlertDestination watch channel", tp)
	}

	return nil
}

// diffAlertDestination does a diff of AlertDestination objects between local cache and API server
func (ct *ctrlerCtx) diffAlertDestination(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().AlertDestination().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffAlertDestination(): AlertDestinationList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.AlertDestination)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.AlertDestination().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffAlertDestination(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.AlertDestination,
			}
			ct.handleAlertDestinationEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffAlertDestination(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleAlertDestinationEvent(&evt)
	}
}

func (ct *ctrlerCtx) runAlertDestinationWatcher() {
	kind := "AlertDestination"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "AlertDestinationWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffAlertDestination(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("AlertDestination_Watch").Inc()
		defer ct.stats.Counter("AlertDestination_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("AlertDestination_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// AlertDestination object watcher
				wt, werr := apicl.MonitoringV1().AlertDestination().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffAlertDestination(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("AlertDestination_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleAlertDestinationEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchAlertDestination starts watch on AlertDestination object
func (ct *ctrlerCtx) WatchAlertDestination(handler AlertDestinationHandler) error {
	kind := "AlertDestination"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("AlertDestination watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run AlertDestination watcher in a go routine
	ct.runAlertDestinationWatcher()

	return nil
}

// StopWatchAlertDestination stops watch on AlertDestination object
func (ct *ctrlerCtx) StopWatchAlertDestination(handler AlertDestinationHandler) error {
	kind := "AlertDestination"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("AlertDestination watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// AlertDestinationAPI returns
type AlertDestinationAPI interface {
	Create(obj *monitoring.AlertDestination) error
	CreateEvent(obj *monitoring.AlertDestination) error
	Update(obj *monitoring.AlertDestination) error
	Delete(obj *monitoring.AlertDestination) error
	Find(meta *api.ObjectMeta) (*AlertDestination, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertDestination, error)
	Watch(handler AlertDestinationHandler) error
	StopWatch(handler AlertDestinationHandler) error
}

// dummy struct that implements AlertDestinationAPI
type alertdestinationAPI struct {
	ct *ctrlerCtx
}

// Create creates AlertDestination object
func (api *alertdestinationAPI) Create(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates AlertDestination object and synchronously triggers local event
func (api *alertdestinationAPI) CreateEvent(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on AlertDestination object
func (api *alertdestinationAPI) Update(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes AlertDestination object
func (api *alertdestinationAPI) Delete(obj *monitoring.AlertDestination) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().AlertDestination().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleAlertDestinationEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *alertdestinationAPI) Find(meta *api.ObjectMeta) (*AlertDestination, error) {
	// find the object
	obj, err := api.ct.FindObject("AlertDestination", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *AlertDestination:
		hobj := obj.(*AlertDestination)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all AlertDestination objects
func (api *alertdestinationAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*AlertDestination, error) {
	var objlist []*AlertDestination
	objs, err := api.ct.List("AlertDestination", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *AlertDestination:
			eobj := obj.(*AlertDestination)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for AlertDestination", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for AlertDestination object
func (api *alertdestinationAPI) Watch(handler AlertDestinationHandler) error {
	api.ct.startWorkerPool("AlertDestination")
	return api.ct.WatchAlertDestination(handler)
}

// StopWatch stop watch for Tenant AlertDestination object
func (api *alertdestinationAPI) StopWatch(handler AlertDestinationHandler) error {
	api.ct.Lock()
	api.ct.workPools["AlertDestination"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchAlertDestination(handler)
}

// AlertDestination returns AlertDestinationAPI
func (ct *ctrlerCtx) AlertDestination() AlertDestinationAPI {
	return &alertdestinationAPI{ct: ct}
}

// MirrorSession is a wrapper object that implements additional functionality
type MirrorSession struct {
	sync.Mutex
	monitoring.MirrorSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *MirrorSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("MirrorSession_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().MirrorSession().UpdateStatus(context.Background(), &obj.MirrorSession)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), &obj.MirrorSession)
	}

	return nil
}

// MirrorSessionHandler is the event handler for MirrorSession object
type MirrorSessionHandler interface {
	OnMirrorSessionCreate(obj *MirrorSession) error
	OnMirrorSessionUpdate(oldObj *MirrorSession, newObj *monitoring.MirrorSession) error
	OnMirrorSessionDelete(obj *MirrorSession) error
}

// handleMirrorSessionEvent handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		mirrorsessionHandler := handler.(MirrorSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &MirrorSession{
					MirrorSession: *eobj,
					HandlerCtx:    nil,
					ctrler:        ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("MirrorSession_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = mirrorsessionHandler.OnMirrorSessionCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*MirrorSession)

				ct.stats.Counter("MirrorSession_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = mirrorsessionHandler.OnMirrorSessionUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*MirrorSession)

			ct.stats.Counter("MirrorSession_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = mirrorsessionHandler.OnMirrorSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// handleMirrorSessionEventParallel handles MirrorSession events from watcher
func (ct *ctrlerCtx) handleMirrorSessionEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.MirrorSession:
		eobj := evt.Object.(*monitoring.MirrorSession)
		kind := "MirrorSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		mirrorsessionHandler := handler.(MirrorSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.MirrorSession)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &MirrorSession{
						MirrorSession: *eobj,
						HandlerCtx:    nil,
						ctrler:        ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("MirrorSession_Created_Events").Inc()
					obj.Lock()
					err = mirrorsessionHandler.OnMirrorSessionCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.MirrorSession.GetKey())
					}
				} else {
					obj := fobj.(*MirrorSession)
					ct.stats.Counter("MirrorSession_Updated_Events").Inc()
					obj.Lock()
					err = mirrorsessionHandler.OnMirrorSessionUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("MirrorSession", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.MirrorSession)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*MirrorSession)
				ct.stats.Counter("MirrorSession_Deleted_Events").Inc()
				obj.Lock()
				err = mirrorsessionHandler.OnMirrorSessionDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.MirrorSession.GetKey())
				return nil
			}
			ct.runJob("MirrorSession", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on MirrorSession watch channel", tp)
	}

	return nil
}

// diffMirrorSession does a diff of MirrorSession objects between local cache and API server
func (ct *ctrlerCtx) diffMirrorSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().MirrorSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffMirrorSession(): MirrorSessionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.MirrorSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.MirrorSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffMirrorSession(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.MirrorSession,
			}
			ct.handleMirrorSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffMirrorSession(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleMirrorSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runMirrorSessionWatcher() {
	kind := "MirrorSession"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "MirrorSessionWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffMirrorSession(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("MirrorSession_Watch").Inc()
		defer ct.stats.Counter("MirrorSession_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("MirrorSession_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// MirrorSession object watcher
				wt, werr := apicl.MonitoringV1().MirrorSession().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffMirrorSession(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("MirrorSession_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleMirrorSessionEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchMirrorSession starts watch on MirrorSession object
func (ct *ctrlerCtx) WatchMirrorSession(handler MirrorSessionHandler) error {
	kind := "MirrorSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("MirrorSession watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run MirrorSession watcher in a go routine
	ct.runMirrorSessionWatcher()

	return nil
}

// StopWatchMirrorSession stops watch on MirrorSession object
func (ct *ctrlerCtx) StopWatchMirrorSession(handler MirrorSessionHandler) error {
	kind := "MirrorSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("MirrorSession watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// MirrorSessionAPI returns
type MirrorSessionAPI interface {
	Create(obj *monitoring.MirrorSession) error
	CreateEvent(obj *monitoring.MirrorSession) error
	Update(obj *monitoring.MirrorSession) error
	Delete(obj *monitoring.MirrorSession) error
	Find(meta *api.ObjectMeta) (*MirrorSession, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*MirrorSession, error)
	Watch(handler MirrorSessionHandler) error
	StopWatch(handler MirrorSessionHandler) error
}

// dummy struct that implements MirrorSessionAPI
type mirrorsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates MirrorSession object
func (api *mirrorsessionAPI) Create(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates MirrorSession object and synchronously triggers local event
func (api *mirrorsessionAPI) CreateEvent(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on MirrorSession object
func (api *mirrorsessionAPI) Update(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes MirrorSession object
func (api *mirrorsessionAPI) Delete(obj *monitoring.MirrorSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().MirrorSession().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleMirrorSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *mirrorsessionAPI) Find(meta *api.ObjectMeta) (*MirrorSession, error) {
	// find the object
	obj, err := api.ct.FindObject("MirrorSession", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *MirrorSession:
		hobj := obj.(*MirrorSession)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all MirrorSession objects
func (api *mirrorsessionAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*MirrorSession, error) {
	var objlist []*MirrorSession
	objs, err := api.ct.List("MirrorSession", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *MirrorSession:
			eobj := obj.(*MirrorSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for MirrorSession", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for MirrorSession object
func (api *mirrorsessionAPI) Watch(handler MirrorSessionHandler) error {
	api.ct.startWorkerPool("MirrorSession")
	return api.ct.WatchMirrorSession(handler)
}

// StopWatch stop watch for Tenant MirrorSession object
func (api *mirrorsessionAPI) StopWatch(handler MirrorSessionHandler) error {
	api.ct.Lock()
	api.ct.workPools["MirrorSession"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchMirrorSession(handler)
}

// MirrorSession returns MirrorSessionAPI
func (ct *ctrlerCtx) MirrorSession() MirrorSessionAPI {
	return &mirrorsessionAPI{ct: ct}
}

// TroubleshootingSession is a wrapper object that implements additional functionality
type TroubleshootingSession struct {
	sync.Mutex
	monitoring.TroubleshootingSession
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TroubleshootingSession) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TroubleshootingSession_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().TroubleshootingSession().UpdateStatus(context.Background(), &obj.TroubleshootingSession)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), &obj.TroubleshootingSession)
	}

	return nil
}

// TroubleshootingSessionHandler is the event handler for TroubleshootingSession object
type TroubleshootingSessionHandler interface {
	OnTroubleshootingSessionCreate(obj *TroubleshootingSession) error
	OnTroubleshootingSessionUpdate(oldObj *TroubleshootingSession, newObj *monitoring.TroubleshootingSession) error
	OnTroubleshootingSessionDelete(obj *TroubleshootingSession) error
}

// handleTroubleshootingSessionEvent handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &TroubleshootingSession{
					TroubleshootingSession: *eobj,
					HandlerCtx:             nil,
					ctrler:                 ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("TroubleshootingSession_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*TroubleshootingSession)

				ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TroubleshootingSession)

			ct.stats.Counter("TroubleshootingSession_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// handleTroubleshootingSessionEventParallel handles TroubleshootingSession events from watcher
func (ct *ctrlerCtx) handleTroubleshootingSessionEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TroubleshootingSession:
		eobj := evt.Object.(*monitoring.TroubleshootingSession)
		kind := "TroubleshootingSession"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		troubleshootingsessionHandler := handler.(TroubleshootingSessionHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.TroubleshootingSession)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &TroubleshootingSession{
						TroubleshootingSession: *eobj,
						HandlerCtx:             nil,
						ctrler:                 ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("TroubleshootingSession_Created_Events").Inc()
					obj.Lock()
					err = troubleshootingsessionHandler.OnTroubleshootingSessionCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.TroubleshootingSession.GetKey())
					}
				} else {
					obj := fobj.(*TroubleshootingSession)
					ct.stats.Counter("TroubleshootingSession_Updated_Events").Inc()
					obj.Lock()
					err = troubleshootingsessionHandler.OnTroubleshootingSessionUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("TroubleshootingSession", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.TroubleshootingSession)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TroubleshootingSession)
				ct.stats.Counter("TroubleshootingSession_Deleted_Events").Inc()
				obj.Lock()
				err = troubleshootingsessionHandler.OnTroubleshootingSessionDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.TroubleshootingSession.GetKey())
				return nil
			}
			ct.runJob("TroubleshootingSession", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TroubleshootingSession watch channel", tp)
	}

	return nil
}

// diffTroubleshootingSession does a diff of TroubleshootingSession objects between local cache and API server
func (ct *ctrlerCtx) diffTroubleshootingSession(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TroubleshootingSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTroubleshootingSession(): TroubleshootingSessionList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.TroubleshootingSession)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.TroubleshootingSession().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTroubleshootingSession(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TroubleshootingSession,
			}
			ct.handleTroubleshootingSessionEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTroubleshootingSession(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTroubleshootingSessionEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTroubleshootingSessionWatcher() {
	kind := "TroubleshootingSession"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "TroubleshootingSessionWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffTroubleshootingSession(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TroubleshootingSession_Watch").Inc()
		defer ct.stats.Counter("TroubleshootingSession_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TroubleshootingSession_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TroubleshootingSession object watcher
				wt, werr := apicl.MonitoringV1().TroubleshootingSession().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffTroubleshootingSession(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TroubleshootingSession_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTroubleshootingSessionEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTroubleshootingSession starts watch on TroubleshootingSession object
func (ct *ctrlerCtx) WatchTroubleshootingSession(handler TroubleshootingSessionHandler) error {
	kind := "TroubleshootingSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TroubleshootingSession watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TroubleshootingSession watcher in a go routine
	ct.runTroubleshootingSessionWatcher()

	return nil
}

// StopWatchTroubleshootingSession stops watch on TroubleshootingSession object
func (ct *ctrlerCtx) StopWatchTroubleshootingSession(handler TroubleshootingSessionHandler) error {
	kind := "TroubleshootingSession"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("TroubleshootingSession watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TroubleshootingSessionAPI returns
type TroubleshootingSessionAPI interface {
	Create(obj *monitoring.TroubleshootingSession) error
	CreateEvent(obj *monitoring.TroubleshootingSession) error
	Update(obj *monitoring.TroubleshootingSession) error
	Delete(obj *monitoring.TroubleshootingSession) error
	Find(meta *api.ObjectMeta) (*TroubleshootingSession, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*TroubleshootingSession, error)
	Watch(handler TroubleshootingSessionHandler) error
	StopWatch(handler TroubleshootingSessionHandler) error
}

// dummy struct that implements TroubleshootingSessionAPI
type troubleshootingsessionAPI struct {
	ct *ctrlerCtx
}

// Create creates TroubleshootingSession object
func (api *troubleshootingsessionAPI) Create(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates TroubleshootingSession object and synchronously triggers local event
func (api *troubleshootingsessionAPI) CreateEvent(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on TroubleshootingSession object
func (api *troubleshootingsessionAPI) Update(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes TroubleshootingSession object
func (api *troubleshootingsessionAPI) Delete(obj *monitoring.TroubleshootingSession) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TroubleshootingSession().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleTroubleshootingSessionEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *troubleshootingsessionAPI) Find(meta *api.ObjectMeta) (*TroubleshootingSession, error) {
	// find the object
	obj, err := api.ct.FindObject("TroubleshootingSession", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TroubleshootingSession:
		hobj := obj.(*TroubleshootingSession)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TroubleshootingSession objects
func (api *troubleshootingsessionAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*TroubleshootingSession, error) {
	var objlist []*TroubleshootingSession
	objs, err := api.ct.List("TroubleshootingSession", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TroubleshootingSession:
			eobj := obj.(*TroubleshootingSession)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TroubleshootingSession", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for TroubleshootingSession object
func (api *troubleshootingsessionAPI) Watch(handler TroubleshootingSessionHandler) error {
	api.ct.startWorkerPool("TroubleshootingSession")
	return api.ct.WatchTroubleshootingSession(handler)
}

// StopWatch stop watch for Tenant TroubleshootingSession object
func (api *troubleshootingsessionAPI) StopWatch(handler TroubleshootingSessionHandler) error {
	api.ct.Lock()
	api.ct.workPools["TroubleshootingSession"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTroubleshootingSession(handler)
}

// TroubleshootingSession returns TroubleshootingSessionAPI
func (ct *ctrlerCtx) TroubleshootingSession() TroubleshootingSessionAPI {
	return &troubleshootingsessionAPI{ct: ct}
}

// TechSupportRequest is a wrapper object that implements additional functionality
type TechSupportRequest struct {
	sync.Mutex
	monitoring.TechSupportRequest
	HandlerCtx interface{} // additional state handlers can store
	ctrler     *ctrlerCtx  // reference back to the controller instance
}

func (obj *TechSupportRequest) Write() error {
	// if there is no API server to connect to, we are done
	if (obj.ctrler == nil) || (obj.ctrler.resolver == nil) || obj.ctrler.apisrvURL == "" {
		return nil
	}

	apicl, err := obj.ctrler.apiClient()
	if err != nil {
		obj.ctrler.logger.Errorf("Error creating API server clent. Err: %v", err)
		return err
	}

	obj.ctrler.stats.Counter("TechSupportRequest_Writes").Inc()

	// write to api server
	if obj.ObjectMeta.ResourceVersion != "" {
		// update it
		for i := 0; i < maxApisrvWriteRetry; i++ {
			_, err = apicl.MonitoringV1().TechSupportRequest().UpdateStatus(context.Background(), &obj.TechSupportRequest)
			if err == nil {
				break
			}
			time.Sleep(time.Millisecond * 100)
		}
	} else {
		//  create
		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), &obj.TechSupportRequest)
	}

	return nil
}

// TechSupportRequestHandler is the event handler for TechSupportRequest object
type TechSupportRequestHandler interface {
	OnTechSupportRequestCreate(obj *TechSupportRequest) error
	OnTechSupportRequestUpdate(oldObj *TechSupportRequest, newObj *monitoring.TechSupportRequest) error
	OnTechSupportRequestDelete(obj *TechSupportRequest) error
}

// handleTechSupportRequestEvent handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEvent(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		techsupportrequestHandler := handler.(TechSupportRequestHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				obj := &TechSupportRequest{
					TechSupportRequest: *eobj,
					HandlerCtx:         nil,
					ctrler:             ct,
				}
				ct.addObject(kind, obj.GetKey(), obj)
				ct.stats.Counter("TechSupportRequest_Created_Events").Inc()

				// call the event handler
				obj.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestCreate(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					ct.delObject(kind, eobj.GetKey())
					return err
				}
			} else {
				obj := fobj.(*TechSupportRequest)

				ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()

				// call the event handler
				obj.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestUpdate(obj, eobj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					return err
				}
			}
		case kvstore.Deleted:
			fobj, err := ct.findObject(kind, eobj.GetKey())
			if err != nil {
				ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
				return err
			}

			obj := fobj.(*TechSupportRequest)

			ct.stats.Counter("TechSupportRequest_Deleted_Events").Inc()

			// Call the event reactor
			obj.Lock()
			err = techsupportrequestHandler.OnTechSupportRequestDelete(obj)
			obj.Unlock()
			if err != nil {
				ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
			}

			ct.delObject(kind, eobj.GetKey())
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// handleTechSupportRequestEventParallel handles TechSupportRequest events from watcher
func (ct *ctrlerCtx) handleTechSupportRequestEventParallel(evt *kvstore.WatchEvent) error {
	switch tp := evt.Object.(type) {
	case *monitoring.TechSupportRequest:
		eobj := evt.Object.(*monitoring.TechSupportRequest)
		kind := "TechSupportRequest"

		//ct.logger.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)
		log.Infof("Watcher: Got %s watch event(%s): {%+v}", kind, evt.Type, eobj)

		ct.Lock()
		handler, ok := ct.handlers[kind]
		ct.Unlock()
		if !ok {
			ct.logger.Fatalf("Cant find the handler for %s", kind)
		}
		techsupportrequestHandler := handler.(TechSupportRequestHandler)
		// handle based on event type
		switch evt.Type {
		case kvstore.Created:
			fallthrough
		case kvstore.Updated:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				var err error
				eobj := userCtx.(*monitoring.TechSupportRequest)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					obj := &TechSupportRequest{
						TechSupportRequest: *eobj,
						HandlerCtx:         nil,
						ctrler:             ct,
					}
					ct.addObject(kind, obj.GetKey(), obj)
					ct.stats.Counter("TechSupportRequest_Created_Events").Inc()
					obj.Lock()
					err = techsupportrequestHandler.OnTechSupportRequestCreate(obj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
						ct.delObject(kind, obj.TechSupportRequest.GetKey())
					}
				} else {
					obj := fobj.(*TechSupportRequest)
					ct.stats.Counter("TechSupportRequest_Updated_Events").Inc()
					obj.Lock()
					err = techsupportrequestHandler.OnTechSupportRequestUpdate(obj, eobj)
					obj.Unlock()
					if err != nil {
						ct.logger.Errorf("Error creating %s %+v. Err: %v", kind, obj, err)
					}
				}
				return err
			}
			ct.runJob("TechSupportRequest", eobj, workFunc)
		case kvstore.Deleted:
			workFunc := func(ctx context.Context, userCtx shardworkers.WorkObj) error {
				eobj := userCtx.(*monitoring.TechSupportRequest)
				fobj, err := ct.findObject(kind, eobj.GetKey())
				if err != nil {
					ct.logger.Errorf("Object %s/%s not found durng delete. Err: %v", kind, eobj.GetKey(), err)
					return err
				}
				obj := fobj.(*TechSupportRequest)
				ct.stats.Counter("TechSupportRequest_Deleted_Events").Inc()
				obj.Lock()
				err = techsupportrequestHandler.OnTechSupportRequestDelete(obj)
				obj.Unlock()
				if err != nil {
					ct.logger.Errorf("Error deleting %s: %+v. Err: %v", kind, obj, err)
				}
				ct.delObject(kind, obj.TechSupportRequest.GetKey())
				return nil
			}
			ct.runJob("TechSupportRequest", eobj, workFunc)
		}
	default:
		ct.logger.Fatalf("API watcher Found object of invalid type: %v on TechSupportRequest watch channel", tp)
	}

	return nil
}

// diffTechSupportRequest does a diff of TechSupportRequest objects between local cache and API server
func (ct *ctrlerCtx) diffTechSupportRequest(apicl apiclient.Services) {
	opts := api.ListWatchOptions{}

	// get a list of all objects from API server
	objlist, err := apicl.MonitoringV1().TechSupportRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Errorf("Error getting a list of objects. Err: %v", err)
		return
	}

	ct.logger.Infof("diffTechSupportRequest(): TechSupportRequestList returned %d objects", len(objlist))

	// build an object map
	objmap := make(map[string]*monitoring.TechSupportRequest)
	for _, obj := range objlist {
		objmap[obj.GetKey()] = obj
	}

	list, err := ct.TechSupportRequest().List(context.Background(), &opts)
	if err != nil {
		ct.logger.Infof("Failed to get a list of objects. Err: %s", err)
		return
	}

	// if an object is in our local cache and not in API server, trigger delete for it
	for _, obj := range list {
		_, ok := objmap[obj.GetKey()]
		if !ok {
			ct.logger.Infof("diffTechSupportRequest(): Deleting existing object %#v since its not in apiserver", obj.GetKey())
			evt := kvstore.WatchEvent{
				Type:   kvstore.Deleted,
				Key:    obj.GetKey(),
				Object: &obj.TechSupportRequest,
			}
			ct.handleTechSupportRequestEvent(&evt)
		}
	}

	// trigger create event for all others
	for _, obj := range objlist {
		ct.logger.Infof("diffTechSupportRequest(): Adding object %#v", obj.GetKey())
		evt := kvstore.WatchEvent{
			Type:   kvstore.Created,
			Key:    obj.GetKey(),
			Object: obj,
		}
		ct.handleTechSupportRequestEvent(&evt)
	}
}

func (ct *ctrlerCtx) runTechSupportRequestWatcher() {
	kind := "TechSupportRequest"

	// if there is no API server to connect to, we are done
	if (ct.resolver == nil) || ct.apisrvURL == "" {
		return
	}

	// create context
	ctx, cancel := context.WithCancel(context.Background())
	ct.Lock()
	ct.watchCancel[kind] = cancel
	ct.Unlock()
	opts := api.ListWatchOptions{}
	logger := ct.logger.WithContext("submodule", "TechSupportRequestWatcher")

	// create a grpc client
	apiclt, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
	if err == nil {
		ct.diffTechSupportRequest(apiclt)
	}

	// setup wait group
	ct.waitGrp.Add(1)

	// start a goroutine
	go func() {
		defer ct.waitGrp.Done()
		ct.stats.Counter("TechSupportRequest_Watch").Inc()
		defer ct.stats.Counter("TechSupportRequest_Watch").Dec()

		// loop forever
		for {
			// create a grpc client
			apicl, err := apiclient.NewGrpcAPIClient(ct.name, ct.apisrvURL, logger, rpckit.WithBalancer(balancer.New(ct.resolver)))
			if err != nil {
				logger.Warnf("Failed to connect to gRPC server [%s]\n", ct.apisrvURL)
				ct.stats.Counter("TechSupportRequest_ApiClientErr").Inc()
			} else {
				logger.Infof("API client connected {%+v}", apicl)

				// TechSupportRequest object watcher
				wt, werr := apicl.MonitoringV1().TechSupportRequest().Watch(ctx, &opts)
				if werr != nil {
					select {
					case <-ctx.Done():
						logger.Infof("watch %s cancelled", kind)
						return
					default:
					}
					logger.Errorf("Failed to start %s watch (%s)\n", kind, werr)
					// wait for a second and retry connecting to api server
					apicl.Close()
					time.Sleep(time.Second)
					continue
				}
				ct.Lock()
				ct.watchers[kind] = wt
				ct.Unlock()

				// perform a diff with API server and local cache
				time.Sleep(time.Millisecond * 100)
				ct.diffTechSupportRequest(apicl)

				// handle api server watch events
			innerLoop:
				for {
					// wait for events
					select {
					case evt, ok := <-wt.EventChan():
						if !ok {
							logger.Error("Error receiving from apisrv watcher")
							ct.stats.Counter("TechSupportRequest_WatchErrors").Inc()
							break innerLoop
						}

						// handle event in parallel
						ct.handleTechSupportRequestEventParallel(evt)
					}
				}
				apicl.Close()
			}

			// if stop flag is set, we are done
			if ct.stoped {
				logger.Infof("Exiting API server watcher")
				return
			}

			// wait for a second and retry connecting to api server
			time.Sleep(time.Second)
		}
	}()
}

// WatchTechSupportRequest starts watch on TechSupportRequest object
func (ct *ctrlerCtx) WatchTechSupportRequest(handler TechSupportRequestHandler) error {
	kind := "TechSupportRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if ok {
		return fmt.Errorf("TechSupportRequest watcher already exists")
	}

	// save handler
	ct.Lock()
	ct.handlers[kind] = handler
	ct.Unlock()

	// run TechSupportRequest watcher in a go routine
	ct.runTechSupportRequestWatcher()

	return nil
}

// StopWatchTechSupportRequest stops watch on TechSupportRequest object
func (ct *ctrlerCtx) StopWatchTechSupportRequest(handler TechSupportRequestHandler) error {
	kind := "TechSupportRequest"

	// see if we already have a watcher
	ct.Lock()
	_, ok := ct.watchers[kind]
	ct.Unlock()
	if !ok {
		return fmt.Errorf("TechSupportRequest watcher does not exist")
	}

	ct.Lock()
	cancel, _ := ct.watchCancel[kind]
	cancel()
	delete(ct.watchers, kind)
	delete(ct.watchCancel, kind)
	ct.Unlock()

	time.Sleep(100 * time.Millisecond)

	return nil
}

// TechSupportRequestAPI returns
type TechSupportRequestAPI interface {
	Create(obj *monitoring.TechSupportRequest) error
	CreateEvent(obj *monitoring.TechSupportRequest) error
	Update(obj *monitoring.TechSupportRequest) error
	Delete(obj *monitoring.TechSupportRequest) error
	Find(meta *api.ObjectMeta) (*TechSupportRequest, error)
	List(ctx context.Context, opts *api.ListWatchOptions) ([]*TechSupportRequest, error)
	Watch(handler TechSupportRequestHandler) error
	StopWatch(handler TechSupportRequestHandler) error
}

// dummy struct that implements TechSupportRequestAPI
type techsupportrequestAPI struct {
	ct *ctrlerCtx
}

// Create creates TechSupportRequest object
func (api *techsupportrequestAPI) Create(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
		}
		return err
	}

	return api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// CreateEvent creates TechSupportRequest object and synchronously triggers local event
func (api *techsupportrequestAPI) CreateEvent(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Create(context.Background(), obj)
		if err != nil && strings.Contains(err.Error(), "AlreadyExists") {
			_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
		}
		if err != nil {
			api.ct.logger.Errorf("Error creating object in api server. Err: %v", err)
			return err
		}
	}

	return api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Created})
}

// Update triggers update on TechSupportRequest object
func (api *techsupportrequestAPI) Update(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Update(context.Background(), obj)
		return err
	}

	return api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Updated})
}

// Delete deletes TechSupportRequest object
func (api *techsupportrequestAPI) Delete(obj *monitoring.TechSupportRequest) error {
	if api.ct.resolver != nil {
		apicl, err := api.ct.apiClient()
		if err != nil {
			api.ct.logger.Errorf("Error creating API server clent. Err: %v", err)
			return err
		}

		_, err = apicl.MonitoringV1().TechSupportRequest().Delete(context.Background(), &obj.ObjectMeta)
		return err
	}

	return api.ct.handleTechSupportRequestEvent(&kvstore.WatchEvent{Object: obj, Type: kvstore.Deleted})
}

// Find returns an object by meta
func (api *techsupportrequestAPI) Find(meta *api.ObjectMeta) (*TechSupportRequest, error) {
	// find the object
	obj, err := api.ct.FindObject("TechSupportRequest", meta)
	if err != nil {
		return nil, err
	}

	// asset type
	switch obj.(type) {
	case *TechSupportRequest:
		hobj := obj.(*TechSupportRequest)
		return hobj, nil
	default:
		return nil, errors.New("incorrect object type")
	}
}

// List returns a list of all TechSupportRequest objects
func (api *techsupportrequestAPI) List(ctx context.Context, opts *api.ListWatchOptions) ([]*TechSupportRequest, error) {
	var objlist []*TechSupportRequest
	objs, err := api.ct.List("TechSupportRequest", ctx, opts)

	if err != nil {
		return nil, err
	}

	for _, obj := range objs {
		switch tp := obj.(type) {
		case *TechSupportRequest:
			eobj := obj.(*TechSupportRequest)
			objlist = append(objlist, eobj)
		default:
			log.Fatalf("Got invalid object type %v while looking for TechSupportRequest", tp)
		}
	}

	return objlist, nil
}

// Watch sets up a event handlers for TechSupportRequest object
func (api *techsupportrequestAPI) Watch(handler TechSupportRequestHandler) error {
	api.ct.startWorkerPool("TechSupportRequest")
	return api.ct.WatchTechSupportRequest(handler)
}

// StopWatch stop watch for Tenant TechSupportRequest object
func (api *techsupportrequestAPI) StopWatch(handler TechSupportRequestHandler) error {
	api.ct.Lock()
	api.ct.workPools["TechSupportRequest"].Stop()
	api.ct.Unlock()
	return api.ct.StopWatchTechSupportRequest(handler)
}

// TechSupportRequest returns TechSupportRequestAPI
func (ct *ctrlerCtx) TechSupportRequest() TechSupportRequestAPI {
	return &techsupportrequestAPI{ct: ct}
}
