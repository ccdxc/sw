// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: alerts.proto

/*
	Package monitoring is a generated protocol buffer package.

	Service name

	It is generated from these files:
		alerts.proto
		archive.proto
		eventpolicy.proto
		export.proto
		mirror.proto
		svc_monitoring.proto
		techsupport.proto
		telemetry.proto
		troubleshooting.proto

	It has these top-level messages:
		Alert
		AlertDestination
		AlertDestinationSpec
		AlertDestinationStatus
		AlertPolicy
		AlertPolicySpec
		AlertPolicyStatus
		AlertReason
		AlertSource
		AlertSpec
		AlertStatus
		AuditInfo
		EmailExport
		MatchedRequirement
		SNMPExport
		SyslogExport
		ArchiveQuery
		ArchiveRequest
		ArchiveRequestSpec
		ArchiveRequestStatus
		CancelArchiveRequest
		EventPolicy
		EventPolicySpec
		EventPolicyStatus
		AuthConfig
		ExportConfig
		ExternalCred
		PrivacyConfig
		SNMPTrapServer
		SyslogExportConfig
		AppProtoSelector
		MatchRule
		MatchSelector
		MirrorCollector
		MirrorExportConfig
		MirrorSession
		MirrorSessionSpec
		MirrorSessionStatus
		MirrorStartConditions
		AlertDestinationList
		AlertList
		AlertPolicyList
		ArchiveRequestList
		AutoMsgAlertDestinationWatchHelper
		AutoMsgAlertPolicyWatchHelper
		AutoMsgAlertWatchHelper
		AutoMsgArchiveRequestWatchHelper
		AutoMsgEventPolicyWatchHelper
		AutoMsgFlowExportPolicyWatchHelper
		AutoMsgFwlogPolicyWatchHelper
		AutoMsgMirrorSessionWatchHelper
		AutoMsgTechSupportRequestWatchHelper
		AutoMsgTroubleshootingSessionWatchHelper
		EventPolicyList
		FlowExportPolicyList
		FwlogPolicyList
		MirrorSessionList
		TechSupportRequestList
		TroubleshootingSessionList
		TechSupportNodeResult
		TechSupportRequest
		TechSupportRequestSpec
		TechSupportRequestStatus
		FlowExportPolicy
		FlowExportPolicySpec
		FlowExportPolicyStatus
		FwlogPolicy
		FwlogPolicySpec
		FwlogPolicyStatus
		PingPktStats
		PingStats
		TimeWindow
		TraceRouteInfo
		TroubleshootingSession
		TroubleshootingSessionSpec
		TroubleshootingSessionStatus
		TsAuditTrail
		TsFlowCounters
		TsFlowLogs
		TsPolicy
		TsReport
		TsResult
		TsStats
*/
package monitoring

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/pensando/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/pensando/sw/venice/utils/apigen/annotations"
import _ "github.com/gogo/protobuf/gogoproto"
import api "github.com/pensando/sw/api"
import fields "github.com/pensando/sw/api/fields"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Possible alert states
type AlertState int32

const (
	// ui-hint: Open
	AlertState_OPEN AlertState = 0
	// ui-hint: Resolved
	AlertState_RESOLVED AlertState = 1
	// ui-hint: Acknowledged
	AlertState_ACKNOWLEDGED AlertState = 2
)

var AlertState_name = map[int32]string{
	0: "OPEN",
	1: "RESOLVED",
	2: "ACKNOWLEDGED",
}
var AlertState_value = map[string]int32{
	"OPEN":         0,
	"RESOLVED":     1,
	"ACKNOWLEDGED": 2,
}

func (AlertState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

// Severity Level of an alert
type AlertSeverity int32

const (
	//
	AlertSeverity_INFO AlertSeverity = 0
	//
	AlertSeverity_WARN AlertSeverity = 1
	//
	AlertSeverity_CRITICAL AlertSeverity = 2
)

var AlertSeverity_name = map[int32]string{
	0: "INFO",
	1: "WARN",
	2: "CRITICAL",
}
var AlertSeverity_value = map[string]int32{
	"INFO":     0,
	"WARN":     1,
	"CRITICAL": 2,
}

func (AlertSeverity) EnumDescriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{1} }

// Alert defines an alert object
type Alert struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta, omitempty,embedded=O" json:"meta, omitempty"`
	//
	Spec AlertSpec `protobuf:"bytes,3,opt,name=Spec,json=spec, omitempty" json:"spec, omitempty"`
	//
	Status AlertStatus `protobuf:"bytes,4,opt,name=Status,json=status, omitempty" json:"status, omitempty"`
}

func (m *Alert) Reset()                    { *m = Alert{} }
func (m *Alert) String() string            { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()               {}
func (*Alert) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{0} }

func (m *Alert) GetSpec() AlertSpec {
	if m != nil {
		return m.Spec
	}
	return AlertSpec{}
}

func (m *Alert) GetStatus() AlertStatus {
	if m != nil {
		return m.Status
	}
	return AlertStatus{}
}

// AlertDestination - tenant scoped
type AlertDestination struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta, omitempty,embedded=O" json:"meta, omitempty"`
	//
	Spec AlertDestinationSpec `protobuf:"bytes,3,opt,name=Spec,json=spec, omitempty" json:"spec, omitempty"`
	//
	Status AlertDestinationStatus `protobuf:"bytes,4,opt,name=Status,json=status, omitempty" json:"status, omitempty"`
}

func (m *AlertDestination) Reset()                    { *m = AlertDestination{} }
func (m *AlertDestination) String() string            { return proto.CompactTextString(m) }
func (*AlertDestination) ProtoMessage()               {}
func (*AlertDestination) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{1} }

func (m *AlertDestination) GetSpec() AlertDestinationSpec {
	if m != nil {
		return m.Spec
	}
	return AlertDestinationSpec{}
}

func (m *AlertDestination) GetStatus() AlertDestinationStatus {
	if m != nil {
		return m.Status
	}
	return AlertDestinationStatus{}
}

//
type AlertDestinationSpec struct {
	// export alerts matched by the selector
	Selector *fields.Selector `protobuf:"bytes,1,opt,name=Selector,json=selector,omitempty" json:"selector,omitempty"`
	// Email notification
	EmailExport *EmailExport `protobuf:"bytes,2,opt,name=EmailExport,json=email-export, omitempty" json:"email-export, omitempty"`
	// SNMP trap destination(s)
	SNMPExport *SNMPExport `protobuf:"bytes,3,opt,name=SNMPExport,json=snmp-export, omitempty" json:"snmp-export, omitempty"`
	//
	SyslogExport *SyslogExport `protobuf:"bytes,4,opt,name=SyslogExport,json=syslog-export, omitempty" json:"syslog-export, omitempty"`
}

func (m *AlertDestinationSpec) Reset()                    { *m = AlertDestinationSpec{} }
func (m *AlertDestinationSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationSpec) ProtoMessage()               {}
func (*AlertDestinationSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{2} }

func (m *AlertDestinationSpec) GetSelector() *fields.Selector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *AlertDestinationSpec) GetEmailExport() *EmailExport {
	if m != nil {
		return m.EmailExport
	}
	return nil
}

func (m *AlertDestinationSpec) GetSNMPExport() *SNMPExport {
	if m != nil {
		return m.SNMPExport
	}
	return nil
}

func (m *AlertDestinationSpec) GetSyslogExport() *SyslogExport {
	if m != nil {
		return m.SyslogExport
	}
	return nil
}

//
type AlertDestinationStatus struct {
	// total number of notifications sent using this notification mechanism
	TotalNotificationsSent int32 `protobuf:"varint,1,opt,name=totalNotificationsSent,json=total-notifications-sent, omitempty,proto3" json:"total-notifications-sent, omitempty"`
}

func (m *AlertDestinationStatus) Reset()                    { *m = AlertDestinationStatus{} }
func (m *AlertDestinationStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertDestinationStatus) ProtoMessage()               {}
func (*AlertDestinationStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{3} }

func (m *AlertDestinationStatus) GetTotalNotificationsSent() int32 {
	if m != nil {
		return m.TotalNotificationsSent
	}
	return 0
}

// AlertPolicy - tenant scoped
type AlertPolicy struct {
	//
	api.TypeMeta `protobuf:"bytes,1,opt,name=T,json=,inline,embedded=T" json:",inline"`
	//
	api.ObjectMeta `protobuf:"bytes,2,opt,name=O,json=meta, omitempty,embedded=O" json:"meta, omitempty"`
	//
	Spec AlertPolicySpec `protobuf:"bytes,3,opt,name=Spec,json=spec, omitempty" json:"spec, omitempty"`
	//
	Status AlertPolicyStatus `protobuf:"bytes,4,opt,name=Status,json=status, omitempty" json:"status, omitempty"`
}

func (m *AlertPolicy) Reset()                    { *m = AlertPolicy{} }
func (m *AlertPolicy) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicy) ProtoMessage()               {}
func (*AlertPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{4} }

func (m *AlertPolicy) GetSpec() AlertPolicySpec {
	if m != nil {
		return m.Spec
	}
	return AlertPolicySpec{}
}

func (m *AlertPolicy) GetStatus() AlertPolicyStatus {
	if m != nil {
		return m.Status
	}
	return AlertPolicyStatus{}
}

//
type AlertPolicySpec struct {
	// Resource type - target resource to run this policy.
	// e.g. Network, Endpoint - object based alert policy
	//      Event - event based alert policy
	//      EndpointMetrics - metric based alert policy
	// based on the resource type, the policy gets interpreted.
	Resource string `protobuf:"bytes,1,opt,name=Resource,json=resource, omitempty,proto3" json:"resource, omitempty"`
	// Severity to be set for an alert that gets triggered from this rule
	Severity string `protobuf:"bytes,2,opt,name=Severity,json=severity, omitempty,proto3" json:"severity, omitempty"`
	// Message to be used while generating the alert
	// XXX: Event based alerts should not carry a message. It will be derived from the event.
	Message string `protobuf:"bytes,3,opt,name=Message,json=message, omitempty,proto3" json:"message, omitempty"`
	// List of requirements that needs to be met to trigger an alert
	Requirements []*fields.Requirement `protobuf:"bytes,4,rep,name=Requirements,json=requirements, omitempty" json:"requirements, omitempty"`
	// Met rule (requirements) needs to sustain for the given duration to qualify to be an alert
	PersistenceDuration string `protobuf:"bytes,5,opt,name=PersistenceDuration,json=persistence-duration, omitempty,proto3" json:"persistence-duration, omitempty"`
	// Met rule (requirements) needs to be cleared for the given duration to resolve an alert
	ClearDuration string `protobuf:"bytes,6,opt,name=ClearDuration,json=clear-duration, omitempty,proto3" json:"clear-duration, omitempty"`
	// User can disable the policy by setting this field.
	// Disabled policies will not generate any more alerts but the outstanding ones will remain as is.
	Enable bool `protobuf:"varint,7,opt,name=Enable,json=enable, omitempty,proto3" json:"enable, omitempty"`
	// If set, the underlying alert will be auto-resolved if the rule that
	// triggered the alert is cleared
	AutoResolve bool `protobuf:"varint,8,opt,name=AutoResolve,json=auto-resolve, omitempty,proto3" json:"auto-resolve, omitempty"`
	// name of the alert destinations to be used to send out notification when an alert
	// gets generated.
	Destinations []string `protobuf:"bytes,9,rep,name=Destinations,json=destinations, omitempty" json:"destinations, omitempty"`
}

func (m *AlertPolicySpec) Reset()                    { *m = AlertPolicySpec{} }
func (m *AlertPolicySpec) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicySpec) ProtoMessage()               {}
func (*AlertPolicySpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{5} }

func (m *AlertPolicySpec) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *AlertPolicySpec) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertPolicySpec) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertPolicySpec) GetRequirements() []*fields.Requirement {
	if m != nil {
		return m.Requirements
	}
	return nil
}

func (m *AlertPolicySpec) GetPersistenceDuration() string {
	if m != nil {
		return m.PersistenceDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetClearDuration() string {
	if m != nil {
		return m.ClearDuration
	}
	return ""
}

func (m *AlertPolicySpec) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *AlertPolicySpec) GetAutoResolve() bool {
	if m != nil {
		return m.AutoResolve
	}
	return false
}

func (m *AlertPolicySpec) GetDestinations() []string {
	if m != nil {
		return m.Destinations
	}
	return nil
}

//
type AlertPolicyStatus struct {
	// Total hits on this policy
	TotalHits int32 `protobuf:"varint,1,opt,name=TotalHits,json=total-hits, omitempty,proto3" json:"total-hits, omitempty"`
	// Open alerts based on this policy
	OpenAlerts int32 `protobuf:"varint,2,opt,name=OpenAlerts,json=open-alerts, omitempty,proto3" json:"open-alerts, omitempty"`
	// Acknowledged alerts based on this policy
	AcknowledgedAlerts int32 `protobuf:"varint,3,opt,name=AcknowledgedAlerts,json=acknowledged-alerts, omitempty,proto3" json:"acknowledged-alerts, omitempty"`
}

func (m *AlertPolicyStatus) Reset()                    { *m = AlertPolicyStatus{} }
func (m *AlertPolicyStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertPolicyStatus) ProtoMessage()               {}
func (*AlertPolicyStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{6} }

func (m *AlertPolicyStatus) GetTotalHits() int32 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *AlertPolicyStatus) GetOpenAlerts() int32 {
	if m != nil {
		return m.OpenAlerts
	}
	return 0
}

func (m *AlertPolicyStatus) GetAcknowledgedAlerts() int32 {
	if m != nil {
		return m.AcknowledgedAlerts
	}
	return 0
}

// AlertReason captures all the requirements with matched value from the alert policy rule
// at the time of creating an alert.
// e.g. "matched-requirements": [{"field": "cpu", "operator": "Gt", "values": [90], "observed-value": 95}]
type AlertReason struct {
	// List of requirements from the alert policy with it's matched value
	MatchedRequirements []*MatchedRequirement `protobuf:"bytes,1,rep,name=MatchedRequirements,json=matched-requirements, omitempty" json:"matched-requirements, omitempty"`
	// Alert Policy ID that matched
	PolicyID string `protobuf:"bytes,2,opt,name=PolicyID,json=alert-policy-id, omitempty,proto3" json:"alert-policy-id, omitempty"`
}

func (m *AlertReason) Reset()                    { *m = AlertReason{} }
func (m *AlertReason) String() string            { return proto.CompactTextString(m) }
func (*AlertReason) ProtoMessage()               {}
func (*AlertReason) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{7} }

func (m *AlertReason) GetMatchedRequirements() []*MatchedRequirement {
	if m != nil {
		return m.MatchedRequirements
	}
	return nil
}

func (m *AlertReason) GetPolicyID() string {
	if m != nil {
		return m.PolicyID
	}
	return ""
}

// Source of an alert; for alerts generated from events, it maps to event.Source
type AlertSource struct {
	//
	Component string `protobuf:"bytes,1,opt,name=Component,json=component, omitempty,proto3" json:"component, omitempty"`
	//
	NodeName string `protobuf:"bytes,2,opt,name=NodeName,json=node-name, omitempty,proto3" json:"node-name, omitempty"`
}

func (m *AlertSource) Reset()                    { *m = AlertSource{} }
func (m *AlertSource) String() string            { return proto.CompactTextString(m) }
func (*AlertSource) ProtoMessage()               {}
func (*AlertSource) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{8} }

func (m *AlertSource) GetComponent() string {
	if m != nil {
		return m.Component
	}
	return ""
}

func (m *AlertSource) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

// User can change the state of the alert by changing the spec
type AlertSpec struct {
	//
	State string `protobuf:"bytes,1,opt,name=State,json=state, omitempty,proto3" json:"state, omitempty"`
}

func (m *AlertSpec) Reset()                    { *m = AlertSpec{} }
func (m *AlertSpec) String() string            { return proto.CompactTextString(m) }
func (*AlertSpec) ProtoMessage()               {}
func (*AlertSpec) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{9} }

func (m *AlertSpec) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

// Status part of the alert object
type AlertStatus struct {
	// Severity of an alert
	Severity string `protobuf:"bytes,1,opt,name=Severity,json=severity, omitempty,proto3" json:"severity, omitempty"`
	// Alert source or origin
	Source *AlertSource `protobuf:"bytes,2,opt,name=Source,json=source, omitempty" json:"source, omitempty"`
	// Event that triggered the alert
	EventURI string `protobuf:"bytes,3,opt,name=EventURI,json=event-uri, omitempty,proto3" json:"event-uri, omitempty"`
	// Affected object
	ObjectRef *api.ObjectRef `protobuf:"bytes,4,opt,name=ObjectRef,json=object-ref, omitempty" json:"object-ref, omitempty"`
	// Message from the alert rule that triggered the alert
	Message string `protobuf:"bytes,5,opt,name=Message,json=message, omitempty,proto3" json:"message, omitempty"`
	// Captures all the requirements from the alert policy rule with matched value.
	// All these requirements must be cleared to auto-resolve an alert.
	Reason AlertReason `protobuf:"bytes,6,opt,name=Reason,json=reason, omitempty" json:"reason, omitempty"`
	// Username and time at which the alert was acknowledged
	Acknowledged *AuditInfo `protobuf:"bytes,7,opt,name=Acknowledged,json=acknowledged, omitempty" json:"acknowledged, omitempty"`
	// Username and time at which the alert was resolved
	Resolved *AuditInfo `protobuf:"bytes,8,opt,name=Resolved,json=resolved, omitempty" json:"resolved, omitempty"`
}

func (m *AlertStatus) Reset()                    { *m = AlertStatus{} }
func (m *AlertStatus) String() string            { return proto.CompactTextString(m) }
func (*AlertStatus) ProtoMessage()               {}
func (*AlertStatus) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{10} }

func (m *AlertStatus) GetSeverity() string {
	if m != nil {
		return m.Severity
	}
	return ""
}

func (m *AlertStatus) GetSource() *AlertSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *AlertStatus) GetEventURI() string {
	if m != nil {
		return m.EventURI
	}
	return ""
}

func (m *AlertStatus) GetObjectRef() *api.ObjectRef {
	if m != nil {
		return m.ObjectRef
	}
	return nil
}

func (m *AlertStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *AlertStatus) GetReason() AlertReason {
	if m != nil {
		return m.Reason
	}
	return AlertReason{}
}

func (m *AlertStatus) GetAcknowledged() *AuditInfo {
	if m != nil {
		return m.Acknowledged
	}
	return nil
}

func (m *AlertStatus) GetResolved() *AuditInfo {
	if m != nil {
		return m.Resolved
	}
	return nil
}

// AuditInfo captures the user performed the action and the time at which the
// action was performed.
type AuditInfo struct {
	// Name of the user performed some action.
	User string `protobuf:"bytes,1,opt,name=User,json=user, omitempty,proto3" json:"user, omitempty"`
	// Time at which the action was performed.
	Time *api.Timestamp `protobuf:"bytes,2,opt,name=Time,json=time, omitempty" json:"time, omitempty"`
}

func (m *AuditInfo) Reset()                    { *m = AuditInfo{} }
func (m *AuditInfo) String() string            { return proto.CompactTextString(m) }
func (*AuditInfo) ProtoMessage()               {}
func (*AuditInfo) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{11} }

func (m *AuditInfo) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *AuditInfo) GetTime() *api.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

//
type EmailExport struct {
	// TODO:  format, config, SMTP config
	EmailList []string `protobuf:"bytes,1,rep,name=EmailList,json=email-list, omitempty" json:"email-list, omitempty"`
}

func (m *EmailExport) Reset()                    { *m = EmailExport{} }
func (m *EmailExport) String() string            { return proto.CompactTextString(m) }
func (*EmailExport) ProtoMessage()               {}
func (*EmailExport) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{12} }

func (m *EmailExport) GetEmailList() []string {
	if m != nil {
		return m.EmailList
	}
	return nil
}

// One of the requirement from the expression that was met
type MatchedRequirement struct {
	// Requirement from the alert rule that was met
	*fields.Requirement `protobuf:"bytes,1,opt,name=Requirement,json=,inline,embedded=Requirement" json:",inline"`
	// The value at which the requirement was met.
	// same as Requirement.value for operator `Equals` but could vary for other operators
	// e.g. requirement - CPU;Gt;90 could have a matching value 96
	ObservedValue string `protobuf:"bytes,2,opt,name=ObservedValue,json=observed-value, omitempty,proto3" json:"observed-value, omitempty"`
}

func (m *MatchedRequirement) Reset()                    { *m = MatchedRequirement{} }
func (m *MatchedRequirement) String() string            { return proto.CompactTextString(m) }
func (*MatchedRequirement) ProtoMessage()               {}
func (*MatchedRequirement) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{13} }

func (m *MatchedRequirement) GetObservedValue() string {
	if m != nil {
		return m.ObservedValue
	}
	return ""
}

//
type SNMPExport struct {
	// TODO:  format, config
	// SNMP trap destination(s)
	SNMPTrapServers []*SNMPTrapServer `protobuf:"bytes,1,rep,name=SNMPTrapServers,json=snmp-trap-servers, omitempty" json:"snmp-trap-servers, omitempty"`
}

func (m *SNMPExport) Reset()                    { *m = SNMPExport{} }
func (m *SNMPExport) String() string            { return proto.CompactTextString(m) }
func (*SNMPExport) ProtoMessage()               {}
func (*SNMPExport) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{14} }

func (m *SNMPExport) GetSNMPTrapServers() []*SNMPTrapServer {
	if m != nil {
		return m.SNMPTrapServers
	}
	return nil
}

// Syslog export configuration
type SyslogExport struct {
	// event export format, SYSLOG_BSD default
	Format string `protobuf:"bytes,1,opt,name=Format,json=format, omitempty,proto3" json:"format, omitempty"`
	// export target ip/port/protocol
	Targets []*ExportConfig `protobuf:"bytes,2,rep,name=Targets,json=targets, omitempty" json:"targets, omitempty"`
	// syslog specific configuration; one of the supported configs
	Config *SyslogExportConfig `protobuf:"bytes,3,opt,name=Config,json=config, omitempty" json:"config, omitempty"`
}

func (m *SyslogExport) Reset()                    { *m = SyslogExport{} }
func (m *SyslogExport) String() string            { return proto.CompactTextString(m) }
func (*SyslogExport) ProtoMessage()               {}
func (*SyslogExport) Descriptor() ([]byte, []int) { return fileDescriptorAlerts, []int{15} }

func (m *SyslogExport) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *SyslogExport) GetTargets() []*ExportConfig {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *SyslogExport) GetConfig() *SyslogExportConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterType((*Alert)(nil), "monitoring.Alert")
	proto.RegisterType((*AlertDestination)(nil), "monitoring.AlertDestination")
	proto.RegisterType((*AlertDestinationSpec)(nil), "monitoring.AlertDestinationSpec")
	proto.RegisterType((*AlertDestinationStatus)(nil), "monitoring.AlertDestinationStatus")
	proto.RegisterType((*AlertPolicy)(nil), "monitoring.AlertPolicy")
	proto.RegisterType((*AlertPolicySpec)(nil), "monitoring.AlertPolicySpec")
	proto.RegisterType((*AlertPolicyStatus)(nil), "monitoring.AlertPolicyStatus")
	proto.RegisterType((*AlertReason)(nil), "monitoring.AlertReason")
	proto.RegisterType((*AlertSource)(nil), "monitoring.AlertSource")
	proto.RegisterType((*AlertSpec)(nil), "monitoring.AlertSpec")
	proto.RegisterType((*AlertStatus)(nil), "monitoring.AlertStatus")
	proto.RegisterType((*AuditInfo)(nil), "monitoring.AuditInfo")
	proto.RegisterType((*EmailExport)(nil), "monitoring.EmailExport")
	proto.RegisterType((*MatchedRequirement)(nil), "monitoring.MatchedRequirement")
	proto.RegisterType((*SNMPExport)(nil), "monitoring.SNMPExport")
	proto.RegisterType((*SyslogExport)(nil), "monitoring.SyslogExport")
	proto.RegisterEnum("monitoring.AlertState", AlertState_name, AlertState_value)
	proto.RegisterEnum("monitoring.AlertSeverity", AlertSeverity_name, AlertSeverity_value)
}
func (m *Alert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Alert) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n1, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n2, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n3, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n4, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AlertDestination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n5, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n6, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n7, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n8, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	return i, nil
}

func (m *AlertDestinationSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Selector != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Selector.Size()))
		n9, err := m.Selector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.EmailExport != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.EmailExport.Size()))
		n10, err := m.EmailExport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.SNMPExport != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.SNMPExport.Size()))
		n11, err := m.SNMPExport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.SyslogExport != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.SyslogExport.Size()))
		n12, err := m.SyslogExport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *AlertDestinationStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertDestinationStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalNotificationsSent))
	}
	return i, nil
}

func (m *AlertPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.TypeMeta.Size()))
	n13, err := m.TypeMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x12
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectMeta.Size()))
	n14, err := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x1a
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Spec.Size()))
	n15, err := m.Spec.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x22
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Status.Size()))
	n16, err := m.Status.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	return i, nil
}

func (m *AlertPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resource) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if len(m.Severity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Requirements) > 0 {
		for _, msg := range m.Requirements {
			dAtA[i] = 0x22
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PersistenceDuration) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PersistenceDuration)))
		i += copy(dAtA[i:], m.PersistenceDuration)
	}
	if len(m.ClearDuration) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ClearDuration)))
		i += copy(dAtA[i:], m.ClearDuration)
	}
	if m.Enable {
		dAtA[i] = 0x38
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AutoResolve {
		dAtA[i] = 0x40
		i++
		if m.AutoResolve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *AlertPolicyStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertPolicyStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalHits != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.AcknowledgedAlerts))
	}
	return i, nil
}

func (m *AlertReason) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertReason) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, msg := range m.MatchedRequirements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PolicyID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.PolicyID)))
		i += copy(dAtA[i:], m.PolicyID)
	}
	return i, nil
}

func (m *AlertSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Component) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Component)))
		i += copy(dAtA[i:], m.Component)
	}
	if len(m.NodeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.NodeName)))
		i += copy(dAtA[i:], m.NodeName)
	}
	return i, nil
}

func (m *AlertSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	return i, nil
}

func (m *AlertStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlertStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Severity) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Severity)))
		i += copy(dAtA[i:], m.Severity)
	}
	if m.Source != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Source.Size()))
		n17, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.EventURI) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.EventURI)))
		i += copy(dAtA[i:], m.EventURI)
	}
	if m.ObjectRef != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.ObjectRef.Size()))
		n18, err := m.ObjectRef.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintAlerts(dAtA, i, uint64(m.Reason.Size()))
	n19, err := m.Reason.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if m.Acknowledged != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Acknowledged.Size()))
		n20, err := m.Acknowledged.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Resolved != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Resolved.Size()))
		n21, err := m.Resolved.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *AuditInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	if m.Time != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Time.Size()))
		n22, err := m.Time.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *EmailExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmailExport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MatchedRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchedRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Requirement != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Requirement.Size()))
		n23, err := m.Requirement.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.ObservedValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.ObservedValue)))
		i += copy(dAtA[i:], m.ObservedValue)
	}
	return i, nil
}

func (m *SNMPExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SNMPExport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SNMPTrapServers) > 0 {
		for _, msg := range m.SNMPTrapServers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SyslogExport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyslogExport) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Format) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if len(m.Targets) > 0 {
		for _, msg := range m.Targets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAlerts(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Config != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAlerts(dAtA, i, uint64(m.Config.Size()))
		n24, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func encodeVarintAlerts(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Alert) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestination) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertDestinationSpec) Size() (n int) {
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.EmailExport != nil {
		l = m.EmailExport.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.SNMPExport != nil {
		l = m.SNMPExport.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.SyslogExport != nil {
		l = m.SyslogExport.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertDestinationStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalNotificationsSent != 0 {
		n += 1 + sovAlerts(uint64(m.TotalNotificationsSent))
	}
	return n
}

func (m *AlertPolicy) Size() (n int) {
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovAlerts(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovAlerts(uint64(l))
	return n
}

func (m *AlertPolicySpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Requirements) > 0 {
		for _, e := range m.Requirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PersistenceDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.ClearDuration)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	if m.AutoResolve {
		n += 2
	}
	if len(m.Destinations) > 0 {
		for _, s := range m.Destinations {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *AlertPolicyStatus) Size() (n int) {
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovAlerts(uint64(m.TotalHits))
	}
	if m.OpenAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.OpenAlerts))
	}
	if m.AcknowledgedAlerts != 0 {
		n += 1 + sovAlerts(uint64(m.AcknowledgedAlerts))
	}
	return n
}

func (m *AlertReason) Size() (n int) {
	var l int
	_ = l
	if len(m.MatchedRequirements) > 0 {
		for _, e := range m.MatchedRequirements {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	l = len(m.PolicyID)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Component)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AlertStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Severity)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.EventURI)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.ObjectRef != nil {
		l = m.ObjectRef.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = m.Reason.Size()
	n += 1 + l + sovAlerts(uint64(l))
	if m.Acknowledged != nil {
		l = m.Acknowledged.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Resolved != nil {
		l = m.Resolved.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *AuditInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *EmailExport) Size() (n int) {
	var l int
	_ = l
	if len(m.EmailList) > 0 {
		for _, s := range m.EmailList {
			l = len(s)
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *MatchedRequirement) Size() (n int) {
	var l int
	_ = l
	if m.Requirement != nil {
		l = m.Requirement.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	l = len(m.ObservedValue)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func (m *SNMPExport) Size() (n int) {
	var l int
	_ = l
	if len(m.SNMPTrapServers) > 0 {
		for _, e := range m.SNMPTrapServers {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	return n
}

func (m *SyslogExport) Size() (n int) {
	var l int
	_ = l
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovAlerts(uint64(l))
	}
	if len(m.Targets) > 0 {
		for _, e := range m.Targets {
			l = e.Size()
			n += 1 + l + sovAlerts(uint64(l))
		}
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovAlerts(uint64(l))
	}
	return n
}

func sovAlerts(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAlerts(x uint64) (n int) {
	return sovAlerts(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Alert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Alert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Alert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &fields.Selector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailExport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmailExport == nil {
				m.EmailExport = &EmailExport{}
			}
			if err := m.EmailExport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNMPExport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SNMPExport == nil {
				m.SNMPExport = &SNMPExport{}
			}
			if err := m.SNMPExport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyslogExport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyslogExport == nil {
				m.SyslogExport = &SyslogExport{}
			}
			if err := m.SyslogExport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertDestinationStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertDestinationStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertDestinationStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNotificationsSent", wireType)
			}
			m.TotalNotificationsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNotificationsSent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requirements = append(m.Requirements, &fields.Requirement{})
			if err := m.Requirements[len(m.Requirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistenceDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistenceDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDuration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClearDuration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoResolve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoResolve = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertPolicyStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertPolicyStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertPolicyStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenAlerts", wireType)
			}
			m.OpenAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcknowledgedAlerts", wireType)
			}
			m.AcknowledgedAlerts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcknowledgedAlerts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertReason) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertReason: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertReason: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchedRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchedRequirements = append(m.MatchedRequirements, &MatchedRequirement{})
			if err := m.MatchedRequirements[len(m.MatchedRequirements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Component = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlertStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlertStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlertStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Severity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &AlertSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectRef == nil {
				m.ObjectRef = &api.ObjectRef{}
			}
			if err := m.ObjectRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reason.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledged == nil {
				m.Acknowledged = &AuditInfo{}
			}
			if err := m.Acknowledged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolved", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resolved == nil {
				m.Resolved = &AuditInfo{}
			}
			if err := m.Resolved.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &api.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailList = append(m.EmailList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchedRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchedRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchedRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Requirement == nil {
				m.Requirement = &fields.Requirement{}
			}
			if err := m.Requirement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObservedValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SNMPExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SNMPExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SNMPExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SNMPTrapServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SNMPTrapServers = append(m.SNMPTrapServers, &SNMPTrapServer{})
			if err := m.SNMPTrapServers[len(m.SNMPTrapServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyslogExport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyslogExport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyslogExport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, &ExportConfig{})
			if err := m.Targets[len(m.Targets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAlerts
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &SyslogExportConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAlerts(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAlerts
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAlerts(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAlerts
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAlerts
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAlerts
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAlerts
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAlerts(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAlerts = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAlerts   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("alerts.proto", fileDescriptorAlerts) }

var fileDescriptorAlerts = []byte{
	// 1713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0xf7, 0x52, 0x7f, 0x4c, 0x8e, 0xa4, 0x8a, 0x1e, 0x45, 0x32, 0x29, 0xd9, 0x24, 0xb1, 0x69,
	0x11, 0x35, 0x31, 0xc9, 0xc6, 0x05, 0x82, 0xa2, 0x05, 0x8a, 0x68, 0x25, 0xaa, 0x11, 0x2a, 0x89,
	0x02, 0x49, 0xc5, 0x0e, 0x0a, 0xb4, 0x5d, 0x2d, 0x87, 0xf4, 0xa4, 0xbb, 0x33, 0xdb, 0x9d, 0x59,
	0xa5, 0x42, 0x51, 0xa0, 0x39, 0x58, 0x05, 0x7a, 0xec, 0xb9, 0xa7, 0xdc, 0xea, 0x4b, 0x81, 0x7e,
	0x0a, 0xa3, 0xa7, 0xc0, 0x1f, 0x80, 0x28, 0x9c, 0x4b, 0xc1, 0x0f, 0xd0, 0x73, 0x31, 0x7f, 0x28,
	0xee, 0x70, 0x97, 0x76, 0x1d, 0xf4, 0xe0, 0x1b, 0xe7, 0xf7, 0x66, 0x7e, 0x33, 0xfb, 0xe6, 0xbd,
	0xdf, 0x7b, 0x43, 0xb0, 0xea, 0xfa, 0x28, 0xe2, 0xac, 0x11, 0x46, 0x94, 0x53, 0x08, 0x02, 0x4a,
	0x30, 0xa7, 0x11, 0x26, 0xc3, 0xed, 0x7b, 0x43, 0x4a, 0x87, 0x3e, 0x6a, 0xba, 0x21, 0x6e, 0xba,
	0x84, 0x50, 0xee, 0x72, 0x4c, 0x89, 0x9e, 0xb9, 0xdd, 0x1a, 0x62, 0xfe, 0x24, 0xbe, 0x68, 0x78,
	0x34, 0x68, 0x86, 0x88, 0x30, 0x97, 0xf4, 0x69, 0x93, 0x7d, 0xd1, 0xbc, 0x44, 0x04, 0x7b, 0xa8,
	0x19, 0x73, 0xec, 0x33, 0xb1, 0x74, 0x88, 0x48, 0x72, 0x75, 0x13, 0x13, 0xcf, 0x8f, 0xfb, 0x68,
	0x42, 0x53, 0x4f, 0xd0, 0x0c, 0xe9, 0x90, 0x36, 0x25, 0x7c, 0x11, 0x0f, 0xe4, 0x48, 0x0e, 0xe4,
	0x2f, 0x3d, 0xfd, 0x7b, 0x73, 0x76, 0x15, 0x67, 0x0c, 0x10, 0x77, 0xf5, 0xb4, 0x1f, 0xbc, 0x62,
	0xda, 0x00, 0x23, 0xbf, 0xcf, 0x9a, 0x0c, 0xf9, 0xc8, 0xe3, 0x34, 0xd2, 0x2b, 0x56, 0xd1, 0xef,
	0x42, 0x1a, 0x71, 0x35, 0xb2, 0xff, 0x99, 0x03, 0x4b, 0x7b, 0xc2, 0x2f, 0xf0, 0x23, 0x60, 0xf5,
	0x4a, 0x56, 0xcd, 0xda, 0x5d, 0x79, 0xb8, 0xd6, 0x70, 0x43, 0xdc, 0xe8, 0x5d, 0x85, 0xe8, 0x04,
	0x71, 0xd7, 0xd9, 0x78, 0x3e, 0xaa, 0xde, 0xfa, 0x7a, 0x54, 0xb5, 0xc6, 0xa3, 0xea, 0xed, 0x07,
	0x98, 0xf8, 0x98, 0xa0, 0xce, 0xe4, 0x07, 0xfc, 0x04, 0x58, 0xed, 0x52, 0x4e, 0xae, 0x5b, 0x97,
	0xeb, 0xda, 0x17, 0x9f, 0x23, 0x8f, 0xcb, 0x95, 0x3b, 0x89, 0x95, 0xeb, 0xe2, 0xd4, 0x0f, 0x6a,
	0x34, 0xc0, 0x1c, 0x05, 0x21, 0xbf, 0xea, 0xcc, 0x02, 0xf0, 0x04, 0x2c, 0x76, 0x43, 0xe4, 0x95,
	0x16, 0x24, 0xd9, 0x66, 0x63, 0x7a, 0x43, 0x0d, 0x79, 0x44, 0x61, 0x74, 0xee, 0x0a, 0x4a, 0x41,
	0xc7, 0x42, 0xe4, 0x19, 0x74, 0x33, 0x00, 0x3c, 0x07, 0xcb, 0x5d, 0xee, 0xf2, 0x98, 0x95, 0x16,
	0x25, 0xe1, 0xdd, 0x34, 0xa1, 0x34, 0x3b, 0x65, 0x4d, 0x79, 0x87, 0xc9, 0x71, 0x92, 0x34, 0x0d,
	0xfd, 0xb8, 0xfc, 0xe2, 0x69, 0x79, 0x13, 0xac, 0x34, 0x7f, 0xdf, 0x6e, 0xf4, 0x10, 0x71, 0x09,
	0xff, 0x03, 0x5c, 0x56, 0x91, 0x65, 0xff, 0x27, 0x07, 0x8a, 0x92, 0xf8, 0x00, 0x31, 0x8e, 0x89,
	0x8c, 0x83, 0xb7, 0xc0, 0xaf, 0x8f, 0x0d, 0xbf, 0xd6, 0x52, 0x6e, 0x48, 0x9c, 0xf6, 0x0d, 0x5d,
	0xfc, 0xeb, 0x19, 0x17, 0xdb, 0xaf, 0xe4, 0xfe, 0x36, 0xde, 0xfe, 0xee, 0x8b, 0xa7, 0xe5, 0x9a,
	0xe9, 0xed, 0x3b, 0xee, 0x0c, 0x31, 0xb3, 0xbf, 0x5a, 0x00, 0xef, 0x64, 0x7d, 0x0a, 0xec, 0x80,
	0x7c, 0x57, 0x87, 0xbf, 0xbe, 0x83, 0x62, 0x43, 0xa5, 0x45, 0x63, 0x82, 0x3b, 0xdb, 0xcf, 0x95,
	0x23, 0xe1, 0x24, 0x51, 0x1e, 0x4c, 0x4f, 0x94, 0x81, 0xc1, 0x01, 0x58, 0x69, 0x05, 0x2e, 0xf6,
	0x5b, 0x32, 0x8f, 0xf4, 0x15, 0x19, 0xc1, 0x95, 0x30, 0x3b, 0x55, 0xcd, 0x7e, 0x17, 0x09, 0xb0,
	0xae, 0x92, 0x2f, 0xf9, 0xd1, 0xf3, 0x0c, 0xf0, 0x02, 0x80, 0xee, 0xe9, 0xc9, 0x99, 0xde, 0x46,
	0x5d, 0xde, 0x56, 0x72, 0x9b, 0xa9, 0xd5, 0xa9, 0xe8, 0x5d, 0xb6, 0x18, 0x09, 0xc2, 0x8c, 0x4d,
	0xe6, 0xe0, 0xf0, 0x73, 0xb0, 0xda, 0xbd, 0x62, 0x3e, 0x1d, 0xea, 0x5d, 0xd4, 0x35, 0x96, 0x8c,
	0x5d, 0x12, 0x76, 0xa7, 0xa6, 0xf7, 0x29, 0x31, 0x89, 0x66, 0xec, 0x34, 0xd7, 0x62, 0xff, 0xd9,
	0x02, 0x5b, 0xd9, 0x31, 0x01, 0x43, 0xb0, 0xc5, 0x29, 0x77, 0xfd, 0x53, 0xca, 0xf1, 0x00, 0x7b,
	0xea, 0x56, 0xbb, 0x88, 0x70, 0x79, 0x69, 0x4b, 0xce, 0x07, 0x7a, 0xdb, 0x77, 0xe5, 0xac, 0x3a,
	0x49, 0x4e, 0xab, 0x33, 0x44, 0x8c, 0x13, 0xfc, 0x2f, 0x93, 0xec, 0x6f, 0x72, 0x60, 0x45, 0x1e,
	0xe6, 0x8c, 0xfa, 0xd8, 0xbb, 0x7a, 0x0b, 0xb2, 0xb4, 0x6b, 0x64, 0xe9, 0x4e, 0x2a, 0x93, 0xd4,
	0x41, 0xdf, 0x30, 0x41, 0x7f, 0x31, 0x93, 0xa0, 0xf7, 0xe7, 0xd1, 0x7e, 0x9b, 0xdc, 0xac, 0xbd,
	0x78, 0x5a, 0xbe, 0x67, 0xe6, 0xe6, 0x9a, 0x7b, 0xc3, 0x89, 0x11, 0xb3, 0xbf, 0x5c, 0x06, 0xeb,
	0x33, 0x87, 0x87, 0x3f, 0x05, 0xf9, 0x0e, 0x62, 0x34, 0x8e, 0x3c, 0x24, 0x1d, 0x5e, 0x70, 0xee,
	0x8e, 0x47, 0xd5, 0x8d, 0x48, 0x63, 0xc9, 0x3d, 0xb3, 0x40, 0xf8, 0x58, 0xa4, 0xf4, 0x25, 0x8a,
	0x30, 0xbf, 0x92, 0x8e, 0x2f, 0x38, 0x1f, 0x3e, 0xbb, 0x2e, 0x6f, 0x75, 0x79, 0xd4, 0x22, 0x71,
	0xb0, 0xab, 0x84, 0x5d, 0x4f, 0xf8, 0xbe, 0x60, 0x66, 0x7a, 0x60, 0x30, 0x67, 0x80, 0xf0, 0x27,
	0xe0, 0xf6, 0x09, 0x62, 0xcc, 0x1d, 0x22, 0x79, 0x09, 0x05, 0x67, 0x4b, 0xa8, 0x42, 0xa0, 0xa0,
	0xe4, 0xea, 0x0c, 0x0c, 0xfe, 0x0a, 0xac, 0x76, 0xd0, 0x6f, 0x63, 0x1c, 0xa1, 0x00, 0x11, 0x2e,
	0xfc, 0xbd, 0xb0, 0xbb, 0xf2, 0x70, 0x63, 0xa2, 0x36, 0x09, 0x9b, 0xb3, 0x23, 0xe4, 0x20, 0x4a,
	0x4c, 0x36, 0xe4, 0x60, 0x8e, 0x01, 0xba, 0x60, 0xe3, 0x0c, 0x45, 0x0c, 0x33, 0x8e, 0x88, 0x87,
	0x0e, 0xe2, 0x48, 0x46, 0x76, 0x69, 0x49, 0x9e, 0xf4, 0xdd, 0xf1, 0xa8, 0x5a, 0x0d, 0xa7, 0xe6,
	0x7a, 0x5f, 0xdb, 0x93, 0xd4, 0xaf, 0x9b, 0x00, 0xdb, 0x60, 0x6d, 0xdf, 0x47, 0x6e, 0x74, 0x43,
	0xbe, 0x2c, 0xc9, 0xef, 0x8f, 0x47, 0xd5, 0xb2, 0x27, 0x0c, 0x99, 0xb4, 0xf3, 0x4d, 0xf0, 0x63,
	0xb0, 0xdc, 0x22, 0xee, 0x85, 0x8f, 0x4a, 0xb7, 0x6b, 0xd6, 0x6e, 0xde, 0xb9, 0xff, 0x8f, 0xeb,
	0xf2, 0x22, 0x8f, 0x62, 0x24, 0x62, 0x0c, 0x49, 0x8b, 0x11, 0x63, 0x29, 0x08, 0x1e, 0x81, 0x95,
	0xbd, 0x98, 0x53, 0x11, 0x31, 0xfe, 0x25, 0x2a, 0xe5, 0x25, 0x8d, 0x74, 0xa0, 0x1b, 0x73, 0x5a,
	0x8f, 0x14, 0x6e, 0x38, 0x70, 0x8e, 0x01, 0xc6, 0x60, 0x35, 0x59, 0x34, 0x4a, 0x85, 0xda, 0xc2,
	0x6e, 0xc1, 0x39, 0xfc, 0xea, 0xba, 0xfc, 0x1e, 0xc8, 0x9f, 0xba, 0x01, 0xea, 0x77, 0xd0, 0x00,
	0xee, 0x4c, 0x13, 0xa4, 0x39, 0xab, 0x56, 0x62, 0xdb, 0x7e, 0x82, 0xc2, 0xd8, 0x76, 0x8e, 0xc1,
	0xfe, 0x63, 0x0e, 0xdc, 0x49, 0x65, 0x1a, 0xdc, 0x07, 0x85, 0x9e, 0x90, 0xa9, 0x4f, 0x30, 0x67,
	0x5a, 0xe4, 0xca, 0xe3, 0x51, 0x75, 0x53, 0x69, 0xd7, 0x13, 0x6c, 0x06, 0x45, 0x36, 0x0c, 0x0f,
	0x01, 0x68, 0x87, 0x88, 0x48, 0x76, 0x26, 0x93, 0x61, 0xc9, 0xd9, 0x16, 0x55, 0x80, 0x86, 0x88,
	0xd4, 0x55, 0x53, 0x62, 0x54, 0x81, 0x6c, 0x1c, 0xfe, 0x12, 0xc0, 0x3d, 0xef, 0x37, 0x84, 0x7e,
	0xe1, 0xa3, 0xfe, 0x10, 0xf5, 0x35, 0xdf, 0x82, 0xe4, 0xb3, 0xc7, 0xa3, 0x6a, 0xc5, 0x4d, 0x58,
	0x33, 0x78, 0x5f, 0x63, 0xb7, 0xbf, 0xb1, 0xb4, 0xd8, 0x76, 0x90, 0xcb, 0x28, 0x81, 0x4f, 0x2d,
	0xb0, 0x71, 0xe2, 0x72, 0xef, 0x89, 0x70, 0x79, 0x22, 0x67, 0x2c, 0x99, 0x33, 0x95, 0xa4, 0x46,
	0xa5, 0xa7, 0x39, 0xef, 0xe9, 0x62, 0x50, 0x0d, 0x94, 0xad, 0x3e, 0x2f, 0x95, 0x5e, 0x37, 0x01,
	0x1e, 0x83, 0xbc, 0xba, 0x94, 0xa3, 0x03, 0x2d, 0x25, 0x95, 0xf1, 0xa8, 0xba, 0x2d, 0x3f, 0xa0,
	0x1e, 0x4a, 0x4b, 0x1d, 0xf7, 0x93, 0x94, 0xaf, 0xb0, 0xd9, 0x7f, 0x99, 0x7c, 0x65, 0x57, 0x6a,
	0x16, 0xdc, 0x03, 0x85, 0x7d, 0x1a, 0x84, 0x94, 0x4c, 0xea, 0x58, 0xc1, 0x29, 0x8d, 0x47, 0xd5,
	0x77, 0xbc, 0x09, 0x98, 0x24, 0xce, 0x44, 0xe1, 0xc7, 0x20, 0x7f, 0x4a, 0xfb, 0x48, 0x04, 0xa7,
	0x3e, 0xa0, 0x64, 0x20, 0xb4, 0x8f, 0xea, 0xc4, 0x0d, 0x8c, 0xb8, 0xcf, 0x44, 0xed, 0xcf, 0x40,
	0xe1, 0xa6, 0x77, 0x86, 0xc7, 0x60, 0x49, 0x84, 0xdf, 0x44, 0x77, 0x3f, 0x78, 0x76, 0x5d, 0xde,
	0x30, 0x75, 0x53, 0x58, 0x85, 0x68, 0x16, 0x85, 0xda, 0x1b, 0xf4, 0x29, 0xc4, 0xfe, 0xfb, 0xd2,
	0xe4, 0x7b, 0x55, 0x48, 0x27, 0x85, 0xd9, 0xfa, 0xbf, 0x0a, 0xb3, 0xe8, 0xe4, 0x55, 0xc1, 0xc8,
	0xcd, 0xeb, 0xe4, 0xa5, 0x59, 0xd6, 0x2f, 0x4b, 0xd6, 0xaf, 0x54, 0x2d, 0x49, 0x43, 0xc2, 0xbb,
	0xad, 0x4b, 0x44, 0xf8, 0x79, 0xe7, 0x48, 0x0b, 0xbe, 0xf4, 0x2e, 0x12, 0x58, 0x3d, 0x8e, 0xb0,
	0xe1, 0xdd, 0x2c, 0x14, 0x3e, 0x02, 0x05, 0x55, 0xef, 0x3b, 0x68, 0xa0, 0x2b, 0xec, 0x77, 0x12,
	0x5d, 0x40, 0x07, 0x0d, 0x9c, 0xfb, 0xfa, 0x48, 0x9b, 0x54, 0x42, 0xf5, 0x08, 0x0d, 0x8c, 0xcc,
	0xce, 0x84, 0x93, 0xa5, 0x68, 0xe9, 0x8d, 0x4b, 0xd1, 0x39, 0x58, 0x56, 0x89, 0x26, 0xf5, 0x3b,
	0xcb, 0x5d, 0xca, 0x3c, 0x2d, 0xf7, 0x91, 0x1c, 0x1b, 0xee, 0x4a, 0x41, 0x10, 0x81, 0xd5, 0xa4,
	0x4a, 0x48, 0x49, 0x9f, 0x7d, 0xa6, 0xc5, 0x7d, 0xcc, 0x8f, 0xc8, 0x80, 0x4e, 0xdb, 0xde, 0xa4,
	0x34, 0x98, 0x32, 0x9d, 0x6d, 0x80, 0x9f, 0xa9, 0xfe, 0xc0, 0xbf, 0x44, 0x7d, 0x29, 0xf7, 0x73,
	0xb7, 0xd8, 0xd1, 0x5b, 0x6c, 0x68, 0xad, 0xef, 0xa7, 0x5a, 0x87, 0x19, 0xd0, 0xfe, 0x93, 0x05,
	0x0a, 0x37, 0xeb, 0xe1, 0x43, 0xb0, 0x78, 0xce, 0x50, 0xa4, 0x63, 0x75, 0x43, 0xf4, 0x53, 0x31,
	0x43, 0x91, 0xd1, 0x4f, 0xcd, 0x00, 0xf0, 0x10, 0x2c, 0xf6, 0x70, 0x30, 0x89, 0x43, 0x75, 0xd7,
	0x02, 0x60, 0xdc, 0x0d, 0x42, 0xd9, 0x97, 0xc9, 0x66, 0x8f, 0x63, 0x33, 0x37, 0x67, 0x01, 0xbb,
	0x63, 0xbc, 0x21, 0x44, 0x35, 0x90, 0xc3, 0x63, 0xcc, 0xb8, 0x54, 0xc1, 0x82, 0xaa, 0x06, 0xea,
	0x69, 0xe0, 0x63, 0x66, 0x68, 0x45, 0x36, 0x6c, 0xff, 0xcd, 0x02, 0x30, 0x2d, 0x97, 0xd0, 0x01,
	0x2b, 0x89, 0xa1, 0xee, 0x71, 0x33, 0xfb, 0x92, 0xf5, 0xb9, 0x5d, 0x6e, 0x1b, 0xac, 0xb5, 0x2f,
	0x18, 0x8a, 0x2e, 0x51, 0xff, 0x53, 0xd7, 0x8f, 0x27, 0x62, 0x24, 0x1b, 0x03, 0xaa, 0x0d, 0xf5,
	0x4b, 0x61, 0x31, 0x1a, 0x83, 0xb9, 0x26, 0xfb, 0x4b, 0x2b, 0xf9, 0xb8, 0x81, 0x0c, 0xac, 0x8b,
	0x51, 0x2f, 0x72, 0xc3, 0xae, 0x58, 0x11, 0x4d, 0x6a, 0xc1, 0xf6, 0xec, 0x7b, 0x67, 0x3a, 0xc5,
	0xa9, 0x8d, 0x47, 0xd5, 0x7b, 0xf2, 0x5d, 0xc3, 0x23, 0x37, 0xac, 0x33, 0xb5, 0x30, 0x79, 0x80,
	0x57, 0x5a, 0xed, 0xbf, 0xe6, 0xcc, 0xc7, 0x8f, 0x68, 0x96, 0x0f, 0x69, 0x14, 0xb8, 0x13, 0xb5,
	0xfe, 0xd1, 0xb3, 0xeb, 0x72, 0x75, 0x22, 0x5f, 0x27, 0x37, 0xe7, 0x50, 0xb3, 0xd5, 0x4c, 0xa1,
	0x63, 0x77, 0x06, 0xf2, 0xa7, 0x91, 0x3d, 0x29, 0x08, 0x9e, 0x83, 0xdb, 0x3d, 0x37, 0x1a, 0x22,
	0x59, 0xa8, 0x17, 0x66, 0x1f, 0x59, 0x8a, 0x73, 0x9f, 0x92, 0x01, 0x1e, 0xaa, 0x5c, 0xe7, 0x6a,
	0xb2, 0x91, 0xeb, 0x69, 0x0c, 0x3e, 0x06, 0xcb, 0x6a, 0x95, 0x7e, 0x37, 0x54, 0xe6, 0x3d, 0xdd,
	0x34, 0xf7, 0xa6, 0x38, 0xb0, 0x27, 0x7f, 0x1b, 0x07, 0x4e, 0x41, 0xef, 0x7f, 0x04, 0xc0, 0xb4,
	0x26, 0xc0, 0x3c, 0x58, 0x6c, 0x9f, 0xb5, 0x4e, 0x8b, 0xb7, 0xe0, 0x2a, 0xc8, 0x77, 0x5a, 0xdd,
	0xf6, 0xf1, 0xa7, 0xad, 0x83, 0xa2, 0x05, 0x8b, 0x60, 0x75, 0x6f, 0xff, 0xe7, 0xa7, 0xed, 0x47,
	0xc7, 0xad, 0x83, 0x9f, 0xb5, 0x0e, 0x8a, 0xb9, 0xf7, 0x3f, 0x04, 0x6b, 0x86, 0xd4, 0x8b, 0xa5,
	0x47, 0xa7, 0x87, 0xed, 0xe2, 0x2d, 0xf1, 0xeb, 0xd1, 0x5e, 0xe7, 0xb4, 0x68, 0x09, 0x92, 0xfd,
	0xce, 0x51, 0xef, 0x68, 0x7f, 0xef, 0xb8, 0x98, 0x73, 0x8a, 0xcf, 0x5f, 0x56, 0xac, 0xaf, 0x5f,
	0x56, 0xac, 0x7f, 0xbd, 0xac, 0x58, 0xff, 0x7e, 0x59, 0xb9, 0x75, 0x66, 0x5d, 0x2c, 0xcb, 0xff,
	0xa7, 0x7e, 0xf8, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x15, 0x2b, 0xba, 0xb6, 0x13, 0x00,
	0x00,
}
