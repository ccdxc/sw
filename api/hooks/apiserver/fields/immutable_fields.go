// {C} Copyright 2019 Pensando Systems Inc. All rights reserved.

package fields

import (
	"context"
	"fmt"
	"reflect"

	"github.com/pensando/sw/api"
	apiintf "github.com/pensando/sw/api/interfaces"
	apisrvpkg "github.com/pensando/sw/venice/apiserver/pkg"
	"github.com/pensando/sw/venice/utils/kvstore"
	"github.com/pensando/sw/venice/utils/log"
	"github.com/pensando/sw/venice/utils/runtime"
)

// Dummy type to avoid unused import complaints in autogenerated code
type Dummy struct{}

func hasImmutableFieldChange(fieldMeta *api.Field, updFieldValue, refFieldValue interface{}, schema *runtime.Scheme) (bool, string) {
	if fieldMeta.Mutable == false {
		diff := !reflect.DeepEqual(updFieldValue, refFieldValue)
		if diff {
			return true, fieldMeta.Name
		}
		return false, ""
	}

	upd := reflect.Indirect(reflect.ValueOf(updFieldValue))
	ref := reflect.Indirect(reflect.ValueOf(refFieldValue))

	if upd.IsValid() != ref.IsValid() {
		// This should not happen. If it does, report an error so that we can debug it.
		return true, fmt.Sprintf("ERROR: field %s validity mismatch", fieldMeta.Name)
	}

	if !upd.IsValid() && !ref.IsValid() {
		return false, ""
	}

	ft := schema.Types[fieldMeta.Type]
	if ft != nil {
		for _, f := range ft.Fields {
			switch ref.Kind() {
			case reflect.Array, reflect.Slice:
				// compare directly by index
				l1 := upd.Len()
				l2 := ref.Len()
				for i := 0; i < l1; i++ {
					if i >= l2 {
						break
					}
					result, fieldName := hasImmutableFieldChange(fieldMeta, upd.Index(i).Interface(), ref.Index(i).Interface(), schema)
					if result {
						return true, fieldName
					}
				}
			case reflect.Map:
				// compare by key
				for _, key := range ref.MapKeys() {
					refVal := ref.MapIndex(key)
					updVal := upd.MapIndex(key)
					if !updVal.IsValid() {
						continue
					}
					result, fieldName := hasImmutableFieldChange(fieldMeta, updVal.Interface(), refVal.Interface(), schema)
					if result {
						return true, fieldName
					}

				}
			default:
				result, fieldName := hasImmutableFieldChange(&f, upd.FieldByName(f.Name).Interface(), ref.FieldByName(f.Name).Interface(), schema)
				if result {
					return true, fieldName
				}
			}
		}
	}
	return false, "" // no immutable field change
}

// checkImmutableFields returns true if at least 1 immutable field differs between updObj and retObj
func checkImmutableFields(kind string, updObj, refObj interface{}) (bool, error) {
	schema := runtime.GetDefaultScheme()
	st := schema.Kind2SchemaType(kind)
	t := schema.Types[st]
	if t == nil {
		return false, fmt.Errorf("Cannot get schema for kind %s", kind)
	}

	// check Spec only. If object doesn't have Spec, constraint is satisfied
	specMeta, ok := t.Fields["Spec"]
	if !ok {
		return true, nil
	}

	updSpec := reflect.Indirect(reflect.ValueOf(updObj)).FieldByName("Spec").Interface()
	refSpec := reflect.Indirect(reflect.ValueOf(refObj)).FieldByName("Spec").Interface()

	invMod, fieldName := hasImmutableFieldChange(&specMeta, updSpec, refSpec, schema)
	if invMod {
		return false, fmt.Errorf("Attempt to modify immutable field %s on object of kind %s", fieldName, kind)
	}

	return true, nil
}

// CheckImmutableFieldChanges is a pre-commit hook to prevent user from modifying the value of immutable fields.
// Immutable fields can only be set when the object is created.
func CheckImmutableFieldChanges(ctx context.Context, kv kvstore.Interface, txn kvstore.Txn, key string, oper apiintf.APIOperType, dryRun bool, i interface{}) (interface{}, bool, error) {

	if oper != apiintf.UpdateOper {
		return i, true, nil
	}

	if i == nil {
		return i, false, fmt.Errorf("CheckImmutableFieldsHook: No object provided")
	}

	if key == "" {
		return i, false, fmt.Errorf("CheckImmutableFieldsHook: No key provided")
	}

	vi := reflect.ValueOf(i)
	if !vi.IsValid() || vi.Kind() != reflect.Struct {
		return i, false, fmt.Errorf("CheckImmutableFieldsHook: Invalid object provided")
	}

	vk := vi.FieldByName("Kind")
	if !vk.IsValid() {
		return i, false, fmt.Errorf("CheckImmutableFieldsHook: Unable to determine kind")
	}

	kind := vk.String()
	refObj, err := runtime.GetDefaultScheme().New(kind)
	if err != nil {
		return i, false, fmt.Errorf("Error creating object: %v", err)
	}

	err = kv.Get(ctx, key, refObj)
	if err != nil {
		return i, false, fmt.Errorf("Error retrieving object with key %s: %v", key, err)
	}

	ok, err := checkImmutableFields(kind, i, refObj)
	if !ok {
		log.Errorf("Error checking mutability constraints: %v", err)
		return i, false, err
	}

	// A comparator here is not needed, because even if some other change makes it to
	// kvstore between now and the time this change is ready to commit, the immmutable
	// fields cannot have changed.

	return i, true, nil
}

func hasImmutableFields(Type string, typeMap map[string]*api.Struct) bool {
	if Type == "" || typeMap == nil || typeMap[Type] == nil {
		return false
	}

	for _, field := range typeMap[Type].Fields {
		if field.Mutable == false || hasImmutableFields(field.Type, typeMap) {
			return true
		}
	}
	return false
}

// RegisterImmutableFieldsServiceHooks registers the CheckImmutableFieldChanges hooks for
// services that affect objects with immutable fields.
// Called from autogenerated service code.
func RegisterImmutableFieldsServiceHooks(pkgName, svcName string, msgs []string) {
	apisrv := apisrvpkg.MustGetAPIServer()
	schema := runtime.GetDefaultScheme()
	fqSvcName := pkgName + "." + svcName

	for _, m := range msgs {
		fqMsgName := pkgName + "." + m
		Type, ok := schema.Types[fqMsgName]
		if !ok {
			log.Fatalf("Unknown Type %s", fqMsgName)
		}
		kind := Type.Kind
		if kind != "" && hasImmutableFields(Type.Fields["Spec"].Type, schema.Types) {
			svc := apisrv.GetService(fqSvcName)
			if svc == nil {
				log.Fatalf("Unable to find service %s", fqSvcName)
			}
			svc.GetCrudService(kind, apiintf.UpdateOper).WithPreCommitHook(CheckImmutableFieldChanges)
			log.Infof("Registering CheckImmutableFieldChanges hook for svc: %s, obj: %s", fqSvcName, fqMsgName)
		}
	}
}
